import {
  __commonJS
} from "./chunk-BUSYA2B4.js";

// node_modules/nertc-web-sdk/NERTC.js
var require_NERTC = __commonJS({
  "node_modules/nertc-web-sdk/NERTC.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.NERTC = t() : e.NERTC = t();
    }(window, function() {
      return function(e) {
        var t = {};
        function i(r) {
          if (t[r]) return t[r].exports;
          var s = t[r] = { i: r, l: false, exports: {} };
          return e[r].call(s.exports, s, s.exports, i), s.l = true, s.exports;
        }
        return i.m = e, i.c = t, i.d = function(e2, t2, r) {
          i.o(e2, t2) || Object.defineProperty(e2, t2, { enumerable: true, get: r });
        }, i.r = function(e2) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
        }, i.t = function(e2, t2) {
          if (1 & t2 && (e2 = i(e2)), 8 & t2) return e2;
          if (4 & t2 && "object" == typeof e2 && e2 && e2.__esModule) return e2;
          var r = /* @__PURE__ */ Object.create(null);
          if (i.r(r), Object.defineProperty(r, "default", { enumerable: true, value: e2 }), 2 & t2 && "string" != typeof e2) for (var s in e2) i.d(r, s, (function(t3) {
            return e2[t3];
          }).bind(null, s));
          return r;
        }, i.n = function(e2) {
          var t2 = e2 && e2.__esModule ? function() {
            return e2.default;
          } : function() {
            return e2;
          };
          return i.d(t2, "a", t2), t2;
        }, i.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, i.p = "", i(i.s = 209);
      }([function(e, t) {
        var i = e.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
        "number" == typeof __g && (__g = i);
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getParameters = void 0;
        const r = i(84);
        let s = { tracks: { audio: [], video: [] }, logUpload: false, reportWS: null, shimVideoOrientation: "never", shimCanvas: "ios151", clients: [], localStreams: [], debugG2: false, passEnvCheck: false, enableAlerter: "never", videoLowMaxWidth: 320, videoLowMaxHeight: 180, videoLowFramerate: 15, videoLowCheckCanvasBlank: "ios", screenLowMaxWidth: 320, screenLowMaxHeight: 180, screenLowFramerate: 15, controlOnPaused: true, hideControlOnResume: true, maxTransportRebuildCnt: Number.MAX_SAFE_INTEGER, logLevel: r.loglevels.INFO, forceLogLevel: -1, forceLogUpload: "default", forceGeofenceArea: "NONE", forceListenDeviceChange: true, codecOptions: { audio: { opusStereo: true, opusDtx: true } }, videoHighStartBitrate: 1e3, videoHighMinBitrate: 0, videoLowStartBitrate: 500, videoLowMinBitrate: 0, screenHighStartBitrate: 2e3, screenHighMinBitrate: 0, screenLowStartBitrate: 500, screenLowMinBitrate: 0, screenFocus: "no-focus-change", screenSurfaceSwitching: "default", screenDisplaySurface: "default", screenPreferCurrentTab: false, screenSelfBrowserSurface: "default", allowEmptyMedia: true, keepLocalstreamOnLeave: false, joinFirstTimeout: 2e3, joinMaxRetry: 3, reconnectionFirstTimeout: 2e3, reconnectionMaxRetry: 3, signalProbeEnabled: true, peerLeaveEventOnReconnect: true, leaveOnUnload: true, trustOnOnline: true, trustOnOffline: false, trustUnhandledrejection: false, h264Wait: 1e3, encoderWatermarkLimit: 1, encoderWatermarkFontFamily: "Verdana", forceEncodedInsertableStreams: false, forceCustomEncryptionOff: false, h264StrictHigh: false, disableH264Send: false, disableVP8Send: false, enableTcpCandidate: true, enableUdpCandidate: true, maxEventLoopLagWarning: 3, enableCompatAudio: false, audioInputcompatMode: "auto", fireBackupDelay: 5e3, audioAslFlag: true, keepAspectRatio: false, disableLBSService: false, lbsUseBuiltinOnly: false, protooMessageTimeout: 3e4, reuseMid: true, playMediaTimeout: 3e3, playMediaTimeoutForAutoplay: 6e3, disableWebAudio: false, disable2dContext: false, disableWebGLContext: false, disableAllReports: false, reportPageBrowserId: true, doHeartbeatInterval: 1e3, deviceChangeInterval: 0, h264ProfileLevel: "42e01f", h264ProfileLevelSignal: "42e01f", enableSdpRrtr: "chrome", forceBWE: "no", forceAGC: "no", forceANS: "no", forceAEC: "no", forceChannelCount: -1, forceLatency: -1, forceSampleRate: -1, revertSubstreamProduceType: false, moreNotAllowedError: false, replaceIdealConstraint: "safari16_screen", shimLocalCanvas: "safari", enableVSkip: true, statsLogMaxCnt: 3, showStatsLog: false, chromeLegacyDefault: "unknown", audioLevelFittingAlgorithm: "log2", audioLevelRatioRemote: 1, statsHistoryInterval: 3e3, signalingMessageDelay: 0, reconnectionMaxTimeout: 0, reconnectionWaitTimeout: 5e3, activeSpeakerMin: 10, audioPlayoutDelayHint: 0, videoPlayoutDelayHint: 0, userType: 3, forceDisplaySurface: "default" };
        try {
          if (location.search && "function" == typeof URLSearchParams) {
            const e2 = new URLSearchParams(location.search);
            let t2;
            for (t2 in s) {
              const i2 = s[t2], r2 = e2.get(t2);
              if (r2) {
                let e3 = null;
                "string" == typeof i2 ? e3 = r2 : "boolean" == typeof i2 ? "true" !== r2 && "false" !== r2 || (e3 = "true" === r2) : "number" == typeof i2 && (e3 = Number(r2), Number(r2) > Number.MIN_SAFE_INTEGER && (e3 = Number(r2))), null !== e3 && i2 !== e3 && (console.warn(`NERTC 通过URL改变了私有化变量：${t2}:`, i2, "=>", e3), s[t2] = e3);
              }
            }
          }
        } catch (e2) {
        }
        t.getParameters = () => s;
      }, function(e, t, i) {
        var r = i(36)("wks"), s = i(24), a = i(0).Symbol, o = "function" == typeof a;
        (e.exports = function(e2) {
          return r[e2] || (r[e2] = o && a[e2] || (o ? a : s)("Symbol." + e2));
        }).store = r;
      }, function(e, t, i) {
        "use strict";
        var r = Object.prototype.hasOwnProperty, s = "~";
        function a() {
        }
        function o(e2, t2, i2) {
          this.fn = e2, this.context = t2, this.once = i2 || false;
        }
        function n() {
          this._events = new a(), this._eventsCount = 0;
        }
        Object.create && (a.prototype = /* @__PURE__ */ Object.create(null), new a().__proto__ || (s = false)), n.prototype.eventNames = function() {
          var e2, t2, i2 = [];
          if (0 === this._eventsCount) return i2;
          for (t2 in e2 = this._events) r.call(e2, t2) && i2.push(s ? t2.slice(1) : t2);
          return Object.getOwnPropertySymbols ? i2.concat(Object.getOwnPropertySymbols(e2)) : i2;
        }, n.prototype.listeners = function(e2, t2) {
          var i2 = s ? s + e2 : e2, r2 = this._events[i2];
          if (t2) return !!r2;
          if (!r2) return [];
          if (r2.fn) return [r2.fn];
          for (var a2 = 0, o2 = r2.length, n2 = new Array(o2); a2 < o2; a2++) n2[a2] = r2[a2].fn;
          return n2;
        }, n.prototype.emit = function(e2, t2, i2, r2, a2, o2) {
          var n2 = s ? s + e2 : e2;
          if (!this._events[n2]) return false;
          var d, c, l = this._events[n2], u = arguments.length;
          if (l.fn) {
            switch (l.once && this.removeListener(e2, l.fn, void 0, true), u) {
              case 1:
                return l.fn.call(l.context), true;
              case 2:
                return l.fn.call(l.context, t2), true;
              case 3:
                return l.fn.call(l.context, t2, i2), true;
              case 4:
                return l.fn.call(l.context, t2, i2, r2), true;
              case 5:
                return l.fn.call(l.context, t2, i2, r2, a2), true;
              case 6:
                return l.fn.call(l.context, t2, i2, r2, a2, o2), true;
            }
            for (c = 1, d = new Array(u - 1); c < u; c++) d[c - 1] = arguments[c];
            l.fn.apply(l.context, d);
          } else {
            var h, p = l.length;
            for (c = 0; c < p; c++) switch (l[c].once && this.removeListener(e2, l[c].fn, void 0, true), u) {
              case 1:
                l[c].fn.call(l[c].context);
                break;
              case 2:
                l[c].fn.call(l[c].context, t2);
                break;
              case 3:
                l[c].fn.call(l[c].context, t2, i2);
                break;
              case 4:
                l[c].fn.call(l[c].context, t2, i2, r2);
                break;
              default:
                if (!d) for (h = 1, d = new Array(u - 1); h < u; h++) d[h - 1] = arguments[h];
                l[c].fn.apply(l[c].context, d);
            }
          }
          return true;
        }, n.prototype.on = function(e2, t2, i2) {
          var r2 = new o(t2, i2 || this), a2 = s ? s + e2 : e2;
          return this._events[a2] ? this._events[a2].fn ? this._events[a2] = [this._events[a2], r2] : this._events[a2].push(r2) : (this._events[a2] = r2, this._eventsCount++), this;
        }, n.prototype.once = function(e2, t2, i2) {
          var r2 = new o(t2, i2 || this, true), a2 = s ? s + e2 : e2;
          return this._events[a2] ? this._events[a2].fn ? this._events[a2] = [this._events[a2], r2] : this._events[a2].push(r2) : (this._events[a2] = r2, this._eventsCount++), this;
        }, n.prototype.removeListener = function(e2, t2, i2, r2) {
          var o2 = s ? s + e2 : e2;
          if (!this._events[o2]) return this;
          if (!t2) return 0 == --this._eventsCount ? this._events = new a() : delete this._events[o2], this;
          var n2 = this._events[o2];
          if (n2.fn) n2.fn !== t2 || r2 && !n2.once || i2 && n2.context !== i2 || (0 == --this._eventsCount ? this._events = new a() : delete this._events[o2]);
          else {
            for (var d = 0, c = [], l = n2.length; d < l; d++) (n2[d].fn !== t2 || r2 && !n2[d].once || i2 && n2[d].context !== i2) && c.push(n2[d]);
            c.length ? this._events[o2] = 1 === c.length ? c[0] : c : 0 == --this._eventsCount ? this._events = new a() : delete this._events[o2];
          }
          return this;
        }, n.prototype.removeAllListeners = function(e2) {
          var t2;
          return e2 ? (t2 = s ? s + e2 : e2, this._events[t2] && (0 == --this._eventsCount ? this._events = new a() : delete this._events[t2])) : (this._events = new a(), this._eventsCount = 0), this;
        }, n.prototype.off = n.prototype.removeListener, n.prototype.addListener = n.prototype.on, n.prototype.setMaxListeners = function() {
          return this;
        }, n.prefixed = s, n.EventEmitter = n, e.exports = n;
      }, function(e, t) {
        var i = e.exports = { version: "2.6.12" };
        "number" == typeof __e && (__e = i);
      }, function(e, t, i) {
        var r = i(11);
        e.exports = function(e2) {
          if (!r(e2)) throw TypeError(e2 + " is not an object!");
          return e2;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        t.default = { PAGE_UNLOAD: 3e4, LOGIN_FAILED: 30001, MEDIA_CONNECTION_DISCONNECTED: 30204, SIGNAL_CONNECTION_DISCONNECTED: 30205, CLIENT_BANNED: 30206, CHANNEL_CLOSED: 30207, UID_DUPLICATE: 30209, PERMKEY_TIMEOUT: 30902, AUTO_PLAY_NOT_ALLOWED: 41030, INVALID_PARAMETER_ERROR: 1e4, NOT_SUPPORT_ERROR: 10001, NETWORK_ERROR: 10002, NETWORK_REQUEST_ERROR: 10003, INVALID_OPERATION_ERROR: 10008, API_CALL_SEQUENCE_BEFORE_ERROR: 10009, API_CALL_SEQUENCE_AFTER_ERROR: 10010, LOCALSTREAM_NOT_FOUND_ERROR: 10011, UNKNOWN_TYPE_ERROR: 10012, LOGIN_REQUEST_ERROR: 10017, RECONNECTING: 10020, SERVER_UNKNOWN_ERROR: 10099, JOIN_FAILED: 10100, REPEAT_JOIN_ERROR: 10101, USER_NOT_IN_CHANNEL_ERROR: 10104, JOIN_PERMKEY_ERROR: 10109, JOIN_WITHOUT_CHANNEL_NAME: 10110, JOIN_RECORD_TYPE_ERROR: 10111, JOIN_UID_TYPE_ERROR: 10112, SERVER_AUTH_ERROR: 10119, SET_CHANNEL_PROFILE_INVALID_PARAMETER_ERROR: 10121, TASKS_ROLE_ERROR: 10131, ADD_TASK_PARAMETER_ERROR: 10132, ADD_TASK_FAILED_ERROR: 10133, DELETE_TASK_PARAMETER_ERROR: 10134, DELETE_TASK_FAILED_ERROR: 10135, UPDATE_TASK_PARAMETER_ERROR: 10136, UPDATE_TASKS_FAILED_ERROR: 10137, STREAM_UID_ERROR: 10210, STREAM_PROFILE_ERROR: 10211, MEDIA_DEVICE_ERROR: 10212, STREAM_PLAY_ARGUMENT_ERROR: 10215, STREAM_RENDER_ARGUMENT_ERROR: 10216, STREAM_ISPLAYING_ARGUMENT_ERROR: 10218, STREAM_OPTN_NO_TYPE_ERROR: 10220, REPEAT_OPEN_MIC_ERROR: 10221, REPEAT_OPEN_AUDIO_SLAVE_ERROR: 10222, REPEAT_OPEN_CAMERA_ERROR: 10223, REPEAT_OPEN_SCREEN_ERROR: 10224, STREAM_CLOSE_ARGUMENT_ERROR: 10228, STREAM_CLOSE_AUDIO_ERROR: 10229, STREAM_CLOSE_AUDIO_SLAVE_ERROR: 10230, STREAM_CLOSE_CAMERA_ERROR: 10231, STREAM_CLOSE_SCREEN_ERROR: 10232, STREAM_NOT_SUBSCRIBE_AUDIO: 10240, STREAM_NOT_SUBSCRIBE_AUDIO_SLAVE: 10241, STREAM_SET_CAPTURE_VOLUME_ARGUMENT_ERROR: 10242, STREAM_TAKE_SNAPSHOT_ERROR: 10247, STREAM_TAKE_SNAPSHOT_NO_CANVAS_ERROR: 10248, SET_AUDIO_VOLUME_ARGUMENTS_ERROR: 10250, SET_AUDIO_VOLUME_ERROR: 10251, SET_CAPTURE_VOLUME_ARGUMENTS_ERROR: 10252, SET_AUDIO_OUTPUT_ERROR: 10253, SWITCH_DEVICE_REPEAT_ARGUMENTS_ERROR: 10254, SWITCH_DEVICE_REPEAT_ERROR: 10255, SWITCH_DEVICE_NO_MIC_ERROR: 10256, SWITCH_DEVICE_NO_SUPPORT_AUDIO: 10257, SWITCH_DEVICE_NO_CAMERA_ERROR: 10258, SWITCH_DEVICE_NO_SUPPORT_VIDEO: 10259, STREAM_MUTE_AUDIO_ERROR: 10265, STREAM_NOT_MUTE_AUDIO_YET: 10266, STREAM_UNMUTE_AUDIO_WITHOUT_STREAM: 10267, STREAM_MUTE_AUDIO_SLAVE_ERROR: 10270, STREAM_NOT_MUTE_AUDIO_SLAVE_YET: 10271, STREAM_UNMUTE_AUDIO_SLAVE_WITHOUT_STREAM: 10272, STREAM_MUTE_VIDEO_ERROR: 10275, STREAM_NOT_MUTE_VIDEO_YET: 10276, STREAM_UNMUTE_VIDEO_WITHOUT_STREAM: 10277, STREAM_MUTE_SCREEN_ERROR: 10280, STREAM_NOT_MUTE_SCREEN_YET: 10281, STREAM_UNMUTE_SCREEN_WITHOUT_STREAM: 10282, STREAM_MUTE_VIDEO_THIRD_ERROR: 10284, STREAM_NOT_MUTE_VIDEO_THIRD_YET: 10285, STREAM_UNMUTE_VIDEO_THIRD_WITHOUT_STREAM: 10286, STREAM_MUTE_VIDEO_FOURTH_ERROR: 10287, STREAM_NOT_MUTE_VIDEO_FOURTH_YET: 10288, STREAM_UNMUTE_VIDEO_FOURTH_WITHOUT_STREAM: 10289, ASR_CAPTIONS_ERROR: 10283, NOT_PUBLISHED: 10340, NOT_SUBSCRIBED: 10341, CONSUME_START: 10342, NOT_OPENED: 10345, ENDED: 10346, PAUSED: 10347, PLAYING: 10348, MUTED: 10347, INVALID_STATE: 10349, PUBLISH_NO_STREAM: 10350, PUBLISH_ROLE_ERROR: 10351, PUBLISH_SERVER_ERROR: 10355, SUBSCRIBE_SERVER_ERROR: 10360, WEBGL_NOT_SUPPORT_ERROR: 10401, WEBGL_LOSE_CONTEXT_ERROR: 10402, WEBGL_RESTORED_FAILD_ERROR: 10403, BASIC_BEAUTY_RES_ERROR: 10404, ADV_BEAUTY_RES_ERROR: 10405, PLUGIN_LOADED_ERROR: 10406, PLUGIN_ERROR: 10407, PLUGIN_REGISTER_ERROR: 10408, PLUGIN_NOT_REGISTER: 10409, PLUGIN_NOT_SUPPORT: 10410, PLUGIN_NOT_SUPPORT_BROWSER: 10411, WEBGL_NOT_INIT: 10412, PLUGIN_VERSION_ERROR: 10413, AUDIO_MIX_NO_AUDIO: 10420, AUDIO_MIX_FILE_ERROR: 10421, AUDIO_MIX_NO_SUPPORT: 10422, AUDIO_MIX_NOT_STATE_ERROR: 10423, AUDIO_MIX_NOT_PAUSE: 10424, AUDIO_MIX_VOLUME_ERROR: 10425, AUDIO_MIX_PLAY_START_TIME_ERROR: 10426, AUDIO_EFFECT_NO_SUPPORT: 10430, AUDIO_EFFECT_FILE_ERROR: 10431, AUDIO_EFFECT_NO_AUDIO: 10432, AUDIO_EFFECT_NOT_STATE_ERROR: 10433, AUDIO_EFFECT_FILE_LOST_ERROR: 10434, AUDIO_EFFECT_NOT_PAUSE: 10435, AUDIO_EFFECT_PLAY_ALREADY: 10436, AUDIO_EFFECT_ERROR: 10437, SET_LOCAL_MEDIA_PRIORITY_ARGUMENT_ERROR: 10445, UPDATE_PERMKEY_ERROR: 10446, RECORDING_NOT_SUPPORT: 10450, REPEAT_RECORDING_ERROR: 10451, RECORDING_CACHE_ERROR: 10452, RECORDING_ERROR: 10453, RECORDING_NOT_START_ERROR: 10454, WATERMARKS_EXCEEDED_ERROR: 10460, LBS_REQUEST_ERROR: 10461, LBS_JSON_ERROR: 10462, CUSTOM_TRANSFOR_NOT_SUPPORT_ERROR: 10471, SET_ENCRYPTION_MODE_ERROR: 10472, SET_ENCRYPTION_SECRET_INVALID_OPERATION_ERROR: 10473, ROLE_TYPE_ERROR: 10477, GET_SYSTEM_STATS_NOT_SUPPORT_ERROR: 10480, SET_CLIENT_ROLE_ERROR: 10490, CLIENT_ALREADY_IN_CHANNEL_ERROR: 10500 };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ELECTRON_VERSION = t.IS_ELECTRON = t.IS_UCBROWSER = t.IS_WX = t.IS_LINUX = t.MACOS_VERSION = t.IS_MAC = t.WIN_VERSION = t.IS_WIN = t.IPADQQB_VERSION = t.IS_IPADQQB = t.MACQQB_VERSION = t.IS_MACQQB = t.WQQB_VERSION = t.IS_WQQB = t.MQQB_VERSION = t.IS_MQQB = t.IS_X5MQQB = t.WECHAT_MAJOR_VERSION = t.WECHAT_VERSION = t.IS_WECHAT = t.IE_VERSION = t.IS_IE = t.IS_IE8 = t.XWEB_VERSION = t.IS_XWEB = t.TBS_VERSION = t.IS_TBS = t.SOGOU_VERSION = t.IS_SOGOU = t.SOGOUM_VERSION = t.IS_SOGOUM = t.EDG_VERSION = t.EDG_MAJOR_VERSION = t.IS_EDG = t.EDGE_VERSION = t.IS_EDGE = t.FIREFOX_MAJOR_VERSION = t.FIREFOX_VERSION = t.IS_FIREFOX = t.ANDROID_VERSION = t.IS_ANDROID = t.IOS_MAJOR_VERSION = t.IOS_VERSION = t.IS_IOS = t.IS_IPOD = t.IS_IPHONE = t.IS_IPAD = t.USER_LANGUAGE = t.USER_AGENT = void 0, t.IS_EN = t.IS_ZH = t.IS_LOCAL = t.IS_IOS_SAFARI = t.IS_MAC_SAFARI = t.SAFARI_VERSION = t.SAFARI_MAJOR_VERSION = t.IS_ANY_SAFARI = t.IS_SAFARI = t.IOS_FIREFOX_MAJOR_VERSION = t.IOS_FIREFOX_VERSION = t.IS_IOS_FIREFOX = t.IOS_EDGE_MAJOR_VERSION = t.IOS_EDGE_VERSION = t.IS_IOS_EDGE = t.IOS_CHROME_MAJOR_VERSION = t.IOS_CHROME_VERSION = t.IS_IOS_CHROME = t.ANY_CHROME_MAJOR_VERSION = t.CHROME_VERSION = t.CHROME_MAJOR_VERSION = t.IS_CHROME = t.IS_CHROME_ONLY = t.VIVO_VERSION = t.IS_VIVOBROWSER = t.OPPO_VERSION = t.IS_OPPOBROWSER = t.SAMSUNG_VERSION = t.IS_SAMSUNGBROWSER = t.HUAWEI_VERSION = t.IS_HUAWEIBROWSER = t.MI_VERSION = t.IS_MIBROWSER = void 0, t.USER_AGENT = window.navigator && window.navigator.userAgent || "", t.USER_LANGUAGE = window.navigator && window.navigator.language, t.IS_IPAD = /iPad/i.test(t.USER_AGENT), t.IS_IPHONE = /iPhone/i.test(t.USER_AGENT) && !t.IS_IPAD, t.IS_IPOD = /iPod/i.test(t.USER_AGENT), t.IS_IOS = t.IS_IPHONE || t.IS_IPAD || t.IS_IPOD, t.IOS_VERSION = t.IS_IOS && function() {
          const e2 = t.USER_AGENT.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [""];
          return e2 && e2[0] ? e2[0].replace(/_/g, ".") : null;
        }(), t.IOS_MAJOR_VERSION = t.IOS_VERSION && function() {
          const e2 = t.IOS_VERSION.match(/\d+.?\d/);
          return e2 && e2[0] ? parseFloat(e2[0]) : null;
        }(), t.IS_ANDROID = /Android/i.test(t.USER_AGENT), t.ANDROID_VERSION = t.IS_ANDROID && function() {
          const e2 = t.USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
          if (!e2) return null;
          const i2 = e2[1], r = e2[2], s = e2[3];
          return i2 && r && s ? i2 + "." + r + "." + s : i2 && r ? i2 + "." + r : i2 || null;
        }(), t.IS_FIREFOX = /Firefox/i.test(t.USER_AGENT), t.FIREFOX_VERSION = t.IS_FIREFOX && function() {
          const e2 = navigator.userAgent.match(/Firefox\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.FIREFOX_MAJOR_VERSION = t.IS_FIREFOX && function() {
          const e2 = t.USER_AGENT.match(/Firefox\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.IS_EDGE = /Edge\//i.test(t.USER_AGENT), t.EDGE_VERSION = t.IS_EDGE && function() {
          var e2 = t.USER_AGENT.match(/Edge\/(\d+)/i);
          if (e2 && e2[1]) return e2[1];
        }(), t.IS_EDG = /Edg\//i.test(t.USER_AGENT), t.EDG_MAJOR_VERSION = t.IS_EDG && function() {
          const e2 = t.USER_AGENT.match(/Edg\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.EDG_VERSION = t.IS_EDG && function() {
          const e2 = t.USER_AGENT.match(/Edg\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_SOGOUM = /SogouMobileBrowser\//i.test(t.USER_AGENT), t.SOGOUM_VERSION = t.IS_SOGOUM && function() {
          const e2 = t.USER_AGENT.match(/SogouMobileBrowser\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.IS_SOGOU = /MetaSr\s/i.test(t.USER_AGENT), t.SOGOU_VERSION = t.IS_SOGOU && function() {
          const e2 = t.USER_AGENT.match(/MetaSr(\s\d+(\.\d+)+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.IS_TBS = /TBS\/\d+/i.test(t.USER_AGENT), t.TBS_VERSION = t.IS_TBS && function() {
          var e2 = t.USER_AGENT.match(/TBS\/(\d+)/i);
          if (e2 && e2[1]) return e2[1];
        }(), t.IS_XWEB = /XWEB\/\d+/i.test(t.USER_AGENT), t.XWEB_VERSION = t.IS_XWEB && function() {
          var e2 = t.USER_AGENT.match(/XWEB\/(\d+)/i);
          if (e2 && e2[1]) return e2[1];
        }(), t.IS_IE8 = /MSIE\s8\.0/.test(t.USER_AGENT), t.IS_IE = /MSIE\/\d+/i.test(t.USER_AGENT), t.IE_VERSION = t.IS_IE && function() {
          const e2 = /MSIE\s(\d+)\.\d/.exec(t.USER_AGENT);
          let i2 = e2 && parseFloat(e2[1]);
          return !i2 && /Trident\/7.0/i.test(t.USER_AGENT) && /rv:11.0/.test(t.USER_AGENT) && (i2 = 11), i2;
        }(), t.IS_WECHAT = /(micromessenger|webbrowser)/i.test(t.USER_AGENT), t.WECHAT_VERSION = t.IS_WECHAT && function() {
          var e2 = navigator.userAgent.match(/MicroMessenger\/([\d.]+)/);
          if (e2 && e2[1]) return e2[1];
        }(), t.WECHAT_MAJOR_VERSION = t.IS_WECHAT && function() {
          var e2 = t.USER_AGENT.match(/MicroMessenger\/(\d+)/i);
          if (e2 && e2[1]) return parseFloat(e2[1]);
        }(), t.IS_X5MQQB = !t.IS_TBS && /MQQBrowser\/\d+/i.test(t.USER_AGENT) && /COVC\/\d+/i.test(t.USER_AGENT), t.IS_MQQB = !t.IS_TBS && /MQQBrowser\/\d+/i.test(t.USER_AGENT) && !/COVC\/\d+/i.test(t.USER_AGENT), t.MQQB_VERSION = (t.IS_MQQB || t.IS_X5MQQB) && function() {
          const e2 = t.USER_AGENT.match(/ MQQBrowser\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_WQQB = !t.IS_TBS && / QQBrowser\/\d+/i.test(t.USER_AGENT), t.WQQB_VERSION = t.IS_WQQB && function() {
          const e2 = t.USER_AGENT.match(/ QQBrowser\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_MACQQB = !t.IS_TBS && /QQBrowserLite\/\d+/i.test(t.USER_AGENT), t.MACQQB_VERSION = t.IS_MACQQB && function() {
          const e2 = t.USER_AGENT.match(/QQBrowserLite\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_IPADQQB = !t.IS_TBS && /MQBHD\/\d+/i.test(t.USER_AGENT), t.IPADQQB_VERSION = t.IS_IPADQQB && function() {
          const e2 = t.USER_AGENT.match(/MQBHD\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_WIN = /Windows/i.test(t.USER_AGENT), t.WIN_VERSION = t.IS_WIN && function() {
          const e2 = t.USER_AGENT.match(/Windows NT (\d+)(?:\.(\d+))?(?:\.(\d+))*/i), i2 = e2 && e2[1], r = e2 && e2[2];
          return i2 && r ? i2 + "." + r : i2 || null;
        }(), t.IS_MAC = !t.IS_IOS && /MAC OS X/i.test(t.USER_AGENT), t.MACOS_VERSION = t.IS_MAC && function() {
          const e2 = t.USER_AGENT.match(/\b[0-9]+_[0-9]+(?:_[0-9]+)?\b/) || [""];
          return e2 && e2[0] ? e2[0].replace(/_/g, ".") : null;
        }(), t.IS_LINUX = !t.IS_ANDROID && /Linux/i.test(t.USER_AGENT), t.IS_WX = /MicroMessenger/i.test(t.USER_AGENT), t.IS_UCBROWSER = /UCBrowser/i.test(t.USER_AGENT), t.IS_ELECTRON = /Electron/i.test(t.USER_AGENT), t.ELECTRON_VERSION = t.IS_ELECTRON && function() {
          const e2 = t.USER_AGENT.match(/Electron\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_MIBROWSER = /MiuiBrowser/i.test(t.USER_AGENT), t.MI_VERSION = t.IS_MIBROWSER && function() {
          const e2 = t.USER_AGENT.match(/MiuiBrowser\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_HUAWEIBROWSER = /HuaweiBrowser/i.test(t.USER_AGENT), t.HUAWEI_VERSION = t.IS_HUAWEIBROWSER && function() {
          const e2 = t.USER_AGENT.match(/HuaweiBrowser\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_SAMSUNGBROWSER = /SamsungBrowser/i.test(t.USER_AGENT), t.SAMSUNG_VERSION = t.IS_SAMSUNGBROWSER && function() {
          const e2 = t.USER_AGENT.match(/SamsungBrowser\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_OPPOBROWSER = /HeyTapBrowser/i.test(t.USER_AGENT), t.OPPO_VERSION = t.IS_OPPOBROWSER && function() {
          const e2 = t.USER_AGENT.match(/HeyTapBrowser\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_VIVOBROWSER = /VivoBrowser/i.test(t.USER_AGENT), t.VIVO_VERSION = t.IS_VIVOBROWSER && function() {
          const e2 = t.USER_AGENT.match(/VivoBrowser\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_CHROME_ONLY = /Chrome/i.test(t.USER_AGENT), t.IS_CHROME = !t.IS_EDGE && !t.IS_SOGOU && !t.IS_SOGOUM && !t.IS_TBS && !t.IS_XWEB && !t.IS_EDG && !t.IS_WQQB && !t.IS_MIBROWSER && !t.IS_HUAWEIBROWSER && !t.IS_SAMSUNGBROWSER && !t.IS_OPPOBROWSER && !t.IS_VIVOBROWSER && /Chrome/i.test(t.USER_AGENT), t.CHROME_MAJOR_VERSION = t.IS_CHROME && function() {
          const e2 = t.USER_AGENT.match(/Chrome\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.CHROME_VERSION = t.IS_CHROME && function() {
          const e2 = t.USER_AGENT.match(/Chrome\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.ANY_CHROME_MAJOR_VERSION = function() {
          const e2 = t.USER_AGENT.match(/Chrome\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.IS_IOS_CHROME = /CriOS/i.test(t.USER_AGENT), t.IOS_CHROME_VERSION = t.IS_IOS_CHROME && function() {
          const e2 = t.USER_AGENT.match(/CriOS\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IOS_CHROME_MAJOR_VERSION = t.IS_IOS_CHROME && function() {
          const e2 = t.USER_AGENT.match(/CriOS\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.IS_IOS_EDGE = /EdgiOS/i.test(t.USER_AGENT), t.IOS_EDGE_VERSION = t.IS_IOS_EDGE && function() {
          const e2 = t.USER_AGENT.match(/EdgiOS\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IOS_EDGE_MAJOR_VERSION = t.IS_IOS_EDGE && function() {
          const e2 = t.USER_AGENT.match(/EdgiOS\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.IS_IOS_FIREFOX = /FxiOS/i.test(t.USER_AGENT), t.IOS_FIREFOX_VERSION = t.IS_IOS_FIREFOX && function() {
          const e2 = t.USER_AGENT.match(/FxiOS\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IOS_FIREFOX_MAJOR_VERSION = t.IS_IOS_FIREFOX && function() {
          const e2 = t.USER_AGENT.match(/FxiOS\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.IS_SAFARI = !t.IS_CHROME_ONLY && !t.IS_MQQB && !t.IS_X5MQQB && !t.IS_MACQQB && !t.IS_IPADQQB && /Safari/i.test(t.USER_AGENT), t.IS_ANY_SAFARI = t.IS_SAFARI || t.IS_IOS, t.SAFARI_MAJOR_VERSION = t.IS_SAFARI && function() {
          const e2 = t.USER_AGENT.match(/Version\/(\d+)/);
          return e2 && e2[1] ? parseFloat(e2[1]) : null;
        }(), t.SAFARI_VERSION = t.IS_SAFARI && function() {
          const e2 = t.USER_AGENT.match(/Version\/([\d.]+)/);
          return e2 && e2[1] ? e2[1] : null;
        }(), t.IS_MAC_SAFARI = t.IS_SAFARI && t.IS_MAC, t.IS_IOS_SAFARI = t.IS_SAFARI && t.IS_IOS, t.IS_LOCAL = "file:" === window.location.protocol || "localhost" === window.location.hostname || /^\d+\.\d+\.\d+\.\d+$/.test(window.location.hostname), t.IS_ZH = /zh/i.test(t.USER_LANGUAGE), t.IS_EN = /en/i.test(t.USER_LANGUAGE);
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true });
        const s = r(i(6));
        class a extends Error {
          constructor(e2) {
            let t2 = e2.url ? e2.url : "https://doc.yunxin.163.com/jcyOTA0ODM/docs/zU2MDQ4MjU?platform=web", i2 = e2.advice ? ` advice: ${e2.advice} ` : "";
            super(e2.message + ` <${function(e3) {
              for (let t3 in s.default) if (s.default[t3] === e3) return t3;
              return "UNKNOWN";
            }(e2.code)} ${e2.code.toString()}> ` + i2 + t2), this.code_ = e2.code || 0, this.message_ = e2.message || null, this.advice_ = e2.advice || null, this.extraCode_ = e2.extraCode || null;
          }
          get code() {
            return this.code_;
          }
          get message() {
            return this.message_;
          }
          get extraCode() {
            return this.extraCode_;
          }
          get advice() {
            return this.advice_;
          }
          getCode() {
            return this.code_;
          }
          getMessage() {
            return this.message_;
          }
          getProposal() {
            return this.advice_;
          }
          getExtraCode() {
            return this.extraCode_;
          }
        }
        t.default = a;
      }, function(e, t, i) {
        var r = i(10), s = i(23);
        e.exports = i(12) ? function(e2, t2, i2) {
          return r.f(e2, t2, s(1, i2));
        } : function(e2, t2, i2) {
          return e2[t2] = i2, e2;
        };
      }, function(e, t, i) {
        var r = i(5), s = i(54), a = i(33), o = Object.defineProperty;
        t.f = i(12) ? Object.defineProperty : function(e2, t2, i2) {
          if (r(e2), t2 = a(t2, true), r(i2), s) try {
            return o(e2, t2, i2);
          } catch (e3) {
          }
          if ("get" in i2 || "set" in i2) throw TypeError("Accessors not supported!");
          return "value" in i2 && (e2[t2] = i2.value), e2;
        };
      }, function(e, t) {
        e.exports = function(e2) {
          return "object" == typeof e2 ? null !== e2 : "function" == typeof e2;
        };
      }, function(e, t, i) {
        e.exports = !i(22)(function() {
          return 7 != Object.defineProperty({}, "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e, t) {
        var i = {}.hasOwnProperty;
        e.exports = function(e2, t2) {
          return i.call(e2, t2);
        };
      }, function(e, t, i) {
        var r = i(100), s = i(31);
        e.exports = function(e2) {
          return r(s(e2));
        };
      }, function(e, t) {
        e.exports = true;
      }, function(e, t, i) {
        var r = i(0), s = i(4), a = i(20), o = i(9), n = i(13), d = function(e2, t2, i2) {
          var c, l, u, h = e2 & d.F, p = e2 & d.G, m = e2 & d.S, g = e2 & d.P, f = e2 & d.B, v = e2 & d.W, S = p ? s : s[t2] || (s[t2] = {}), y = S.prototype, _ = p ? r : m ? r[t2] : (r[t2] || {}).prototype;
          for (c in p && (i2 = t2), i2) (l = !h && _ && void 0 !== _[c]) && n(S, c) || (u = l ? _[c] : i2[c], S[c] = p && "function" != typeof _[c] ? i2[c] : f && l ? a(u, r) : v && _[c] == u ? function(e3) {
            var t3 = function(t4, i3, r2) {
              if (this instanceof e3) {
                switch (arguments.length) {
                  case 0:
                    return new e3();
                  case 1:
                    return new e3(t4);
                  case 2:
                    return new e3(t4, i3);
                }
                return new e3(t4, i3, r2);
              }
              return e3.apply(this, arguments);
            };
            return t3.prototype = e3.prototype, t3;
          }(u) : g && "function" == typeof u ? a(Function.call, u) : u, g && ((S.virtual || (S.virtual = {}))[c] = u, e2 & d.R && y && !y[c] && o(y, c, u)));
        };
        d.F = 1, d.G = 2, d.S = 4, d.P = 8, d.B = 16, d.W = 32, d.U = 64, d.R = 128, e.exports = d;
      }, function(e, t) {
        e.exports = {};
      }, function(e, t) {
        var i = {}.toString;
        e.exports = function(e2) {
          return i.call(e2).slice(8, -1);
        };
      }, function(e, t, i) {
        "use strict";
        var r, s, a = e.exports = i(44), o = i(182);
        a.codegen = i(272), a.fetch = i(273), a.path = i(274), a.fs = a.inquire("fs"), a.toArray = function(e2) {
          if (e2) {
            for (var t2 = Object.keys(e2), i2 = new Array(t2.length), r2 = 0; r2 < t2.length; ) i2[r2] = e2[t2[r2++]];
            return i2;
          }
          return [];
        }, a.toObject = function(e2) {
          for (var t2 = {}, i2 = 0; i2 < e2.length; ) {
            var r2 = e2[i2++], s2 = e2[i2++];
            void 0 !== s2 && (t2[r2] = s2);
          }
          return t2;
        };
        var n = /\\/g, d = /"/g;
        a.isReserved = function(e2) {
          return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(e2);
        }, a.safeProp = function(e2) {
          return !/^[$\w_]+$/.test(e2) || a.isReserved(e2) ? '["' + e2.replace(n, "\\\\").replace(d, '\\"') + '"]' : "." + e2;
        }, a.ucFirst = function(e2) {
          return e2.charAt(0).toUpperCase() + e2.substring(1);
        };
        var c = /_([a-z])/g;
        a.camelCase = function(e2) {
          return e2.substring(0, 1) + e2.substring(1).replace(c, function(e3, t2) {
            return t2.toUpperCase();
          });
        }, a.compareFieldsById = function(e2, t2) {
          return e2.id - t2.id;
        }, a.decorateType = function(e2, t2) {
          if (e2.$type) return t2 && e2.$type.name !== t2 && (a.decorateRoot.remove(e2.$type), e2.$type.name = t2, a.decorateRoot.add(e2.$type)), e2.$type;
          r || (r = i(184));
          var s2 = new r(t2 || e2.name);
          return a.decorateRoot.add(s2), s2.ctor = e2, Object.defineProperty(e2, "$type", { value: s2, enumerable: false }), Object.defineProperty(e2.prototype, "$type", { value: s2, enumerable: false }), s2;
        };
        var l = 0;
        a.decorateEnum = function(e2) {
          if (e2.$type) return e2.$type;
          s || (s = i(45));
          var t2 = new s("Enum" + l++, e2);
          return a.decorateRoot.add(t2), Object.defineProperty(e2, "$type", { value: t2, enumerable: false }), t2;
        }, a.setProperty = function(e2, t2, i2) {
          if ("object" != typeof e2) throw TypeError("dst must be an object");
          if (!t2) throw TypeError("path must be specified");
          return function e3(t3, i3, r2) {
            var s2 = i3.shift();
            if (i3.length > 0) t3[s2] = e3(t3[s2] || {}, i3, r2);
            else {
              var a2 = t3[s2];
              a2 && (r2 = [].concat(a2).concat(r2)), t3[s2] = r2;
            }
            return t3;
          }(e2, t2 = t2.split("."), i2);
        }, Object.defineProperty(a, "decorateRoot", { get: function() {
          return o.decorated || (o.decorated = new (i(192))());
        } });
      }, function(e, t, i) {
        var r = i(21);
        e.exports = function(e2, t2, i2) {
          if (r(e2), void 0 === t2) return e2;
          switch (i2) {
            case 1:
              return function(i3) {
                return e2.call(t2, i3);
              };
            case 2:
              return function(i3, r2) {
                return e2.call(t2, i3, r2);
              };
            case 3:
              return function(i3, r2, s) {
                return e2.call(t2, i3, r2, s);
              };
          }
          return function() {
            return e2.apply(t2, arguments);
          };
        };
      }, function(e, t) {
        e.exports = function(e2) {
          if ("function" != typeof e2) throw TypeError(e2 + " is not a function!");
          return e2;
        };
      }, function(e, t) {
        e.exports = function(e2) {
          try {
            return !!e2();
          } catch (e3) {
            return true;
          }
        };
      }, function(e, t) {
        e.exports = function(e2, t2) {
          return { enumerable: !(1 & e2), configurable: !(2 & e2), writable: !(4 & e2), value: t2 };
        };
      }, function(e, t) {
        var i = 0, r = Math.random();
        e.exports = function(e2) {
          return "Symbol(".concat(void 0 === e2 ? "" : e2, ")_", (++i + r).toString(36));
        };
      }, function(e, t, i) {
        var r = i(10).f, s = i(13), a = i(2)("toStringTag");
        e.exports = function(e2, t2, i2) {
          e2 && !s(e2 = i2 ? e2 : e2.prototype, a) && r(e2, a, { configurable: true, value: t2 });
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.SDK_VERSION = t.roomsTaskUrl = t.lbsUrl = t.TAGS_TO_MAIN_DOMAIN = t.LBS_REGION_CONFIG = t.getCloudProxyInfoUrl = t.getChannelInfoUrl = t.ENV = t.ENGINE_VERSION = t.createChannelUrl = t.checkSumUrl = t.BUILD = void 0;
        t.SDK_VERSION = "5.6.50";
        t.ENGINE_VERSION = "5.6.50";
        t.BUILD = "v5.6.50-0-gaaf117b6";
        const r = i(211);
        Object.defineProperty(t, "ENV", { enumerable: true, get: function() {
          return r.ENV;
        } }), Object.defineProperty(t, "LBS_REGION_CONFIG", { enumerable: true, get: function() {
          return r.LBS_REGION_CONFIG;
        } }), Object.defineProperty(t, "TAGS_TO_MAIN_DOMAIN", { enumerable: true, get: function() {
          return r.TAGS_TO_MAIN_DOMAIN;
        } });
        const s = r.Config.checkSumUrl;
        t.checkSumUrl = s;
        const a = r.Config.createChannelUrl;
        t.createChannelUrl = a;
        const o = r.Config.getChannelInfoUrl;
        t.getChannelInfoUrl = o;
        const n = r.Config.roomsTaskUrl;
        t.roomsTaskUrl = n;
        const d = r.Config.getCloudProxyInfoUrl;
        t.getCloudProxyInfoUrl = d;
        const c = r.Config.lbsUrl;
        t.lbsUrl = c;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.generateRandomNumber = t.clone = void 0, t.clone = function(e2, t2 = {}) {
          return void 0 === e2 ? t2 : JSON.parse(JSON.stringify(e2));
        }, t.generateRandomNumber = function() {
          return Math.round(1e7 * Math.random());
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getDefaultLogger = t.Logger = t.updateLogIndex = void 0;
        const r = i(1), s = i(84), a = i(77), o = i(42), n = i(26);
        let d = 0, c = [];
        function l() {
          return d++, ("" + d).padStart(4, "0");
        }
        t.updateLogIndex = l;
        class u {
          constructor(e2) {
            this.style = "color:#1cb977;", this.options = e2, this.tagGen = e2.tagGen, this.supportedBrowsers = ["Chrome", "Safari", "Firefox", "Chrome Mobile", "Electron"], this.cs = console;
          }
          getChild(e2) {
            const t2 = Object.assign({}, this.options), i2 = new u(t2);
            return i2.tagGen = e2, i2.parent = this, i2;
          }
          debug() {
            var e2 = this.formatArgs("DEBUG", [].slice.call(arguments, 0));
            r.getParameters().logLevel <= s.loglevels.DEBUG && this._log("debug", e2), m(e2);
          }
          log() {
            var e2 = this.formatArgs("LOG", [].slice.call(arguments, 0));
            if (-1 !== this.supportedBrowsers.indexOf(a.getBrowserInfo().browserName) && "string" == typeof e2[0]) {
              e2[0] = "%c" + e2[0], e2.splice(1, 0, this.style);
              for (let t2 = 2; t2 < e2.length && "string" == typeof e2[t2]; t2++) e2[0] += "%c" + e2[t2], e2[t2] = "";
            }
            r.getParameters().logLevel <= s.loglevels.INFO && this._log("log", e2), m(e2);
          }
          info() {
            var e2 = this.formatArgs("INFO", [].slice.call(arguments, 0));
            -1 !== this.supportedBrowsers.indexOf(a.getBrowserInfo().browserName) && "string" == typeof e2[0] && (e2[0] = "%c" + e2[0], e2.splice(1, 0, this.style)), r.getParameters().logLevel <= s.loglevels.INFO && this._log("info", e2), m(e2);
          }
          warn() {
            var e2 = this.formatArgs("WARN", [].slice.call(arguments, 0));
            -1 !== this.supportedBrowsers.indexOf(a.getBrowserInfo().browserName) && "string" == typeof e2[0] && (e2[0] = "%c" + e2[0], e2.splice(1, 0, this.style)), r.getParameters().logLevel <= s.loglevels.WARNING && this._log("warn", e2), m(e2);
          }
          error() {
            var e2 = this.formatArgs("ERROR", [].slice.call(arguments, 0));
            -1 !== this.supportedBrowsers.indexOf(a.getBrowserInfo().browserName) && "string" == typeof e2[0] && (e2[0] = "%c" + e2[0], e2.splice(1, 0, this.style)), r.getParameters().logLevel <= s.loglevels.ERROR && this._log("error", e2), m(e2);
          }
          _log(e2, t2) {
            let i2 = this.options.logFunc, r2 = null;
            if (i2 && (i2[e2] && (r2 = i2[e2]), "function" == typeof r2)) r2.apply(i2, t2);
            else if (this.cs[e2]) try {
              this.cs[e2].apply ? this.chrome(e2, t2) : this.ie(e2, t2);
            } catch (e3) {
            }
          }
          chrome(e2, t2) {
            a.getBrowserInfo().browserName;
            this.cs[e2] ? this.cs[e2].apply(this.cs, t2) : this.cs.log ? this.cs.log.apply(this.cs, t2) : this.ie(e2, t2);
          }
          ie(e2, t2) {
            var i2 = this;
            t2.forEach(function(t3) {
              i2.cs[e2](JSON.stringify(t3, null, 4));
            });
          }
          formatArgs(e2, t2) {
            var i2 = /* @__PURE__ */ new Date(), r2 = p("" + (i2.getMonth() + 1)) + "-" + p("" + i2.getDate()) + " " + p("" + i2.getHours()) + ":" + p("" + i2.getMinutes()) + ":" + p("" + i2.getSeconds()) + ":" + p("" + i2.getMilliseconds(), 3);
            let s2 = this, a2 = "";
            for (let e3 = 0; e3 < 3 && (s2.tagGen && (a2 = `[${s2.tagGen()}]` + a2), s2.parent); e3++) s2 = s2.parent;
            return a2 = `[NERTC:${e2}:${l()} ${r2}]${a2}`, t2.splice(0, 0, a2), t2.forEach(function(e3, i3) {
              e3 = o.formatSingleArg(e3), t2[i3] = "object" == typeof e3 ? function e4(t3, i4 = []) {
                if (!(t3 = o.formatSingleArg(t3)) || "object" != typeof t3) return t3;
                let r3 = {};
                for (let s3 in t3) t3.hasOwnProperty && !t3.hasOwnProperty(s3) || (t3[s3] && "object" == typeof t3[s3] ? -1 !== i4.indexOf(t3[s3]) ? r3[s3] = "[Circular obj]" : (i4.push(t3[s3]), r3[s3] = e4(t3[s3], i4)) : r3[s3] = t3[s3]);
                return r3;
              }(e3) : e3;
            }), t2;
          }
        }
        t.Logger = u;
        let h = null;
        t.getDefaultLogger = function() {
          return h || (h = new u({ tagGen: () => "" + n.BUILD })), h;
        };
        var p = function(e2, t2) {
          t2 = t2 || 2;
          for (var i2 = "" + e2; i2.length < t2; ) i2 = "0" + i2;
          return i2;
        };
        function m(e2) {
          if (r.getParameters().logUpload && !r.getParameters().disableAllReports) {
            const t2 = r.getParameters().reportWS;
            if (t2) c.length && (c.forEach((e3) => {
              t2.sendLog(e3.args);
            }), c = []), t2.sendLog(e2);
            else {
              let t3 = Date.now();
              try {
                c.length && c[c.length - 1].args[0].replace("[NERTC", "[缓存][NERTC");
              } catch (e3) {
              }
              c.push({ time: t3, args: e2 });
            }
          }
        }
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Logger = void 0;
        const r = new (i(28)).Logger({ tagGen: void 0 });
        t.Logger = { debug(e2, ...t2) {
          try {
            r.log(`[${e2}] ${t2.join(" ")}`);
          } catch (e3) {
          }
        }, warn(e2, ...t2) {
          try {
            r.warn(`[${e2}] ${t2.join(" ")}`);
          } catch (e3) {
          }
        }, error(e2, ...t2) {
          try {
            r.error(`[${e2}] ${t2.join(" ")}`);
          } catch (e3) {
          }
        } };
      }, function(e, t) {
        var i = Math.ceil, r = Math.floor;
        e.exports = function(e2) {
          return isNaN(e2 = +e2) ? 0 : (e2 > 0 ? r : i)(e2);
        };
      }, function(e, t) {
        e.exports = function(e2) {
          if (null == e2) throw TypeError("Can't call method on  " + e2);
          return e2;
        };
      }, function(e, t, i) {
        var r = i(11), s = i(0).document, a = r(s) && r(s.createElement);
        e.exports = function(e2) {
          return a ? s.createElement(e2) : {};
        };
      }, function(e, t, i) {
        var r = i(11);
        e.exports = function(e2, t2) {
          if (!r(e2)) return e2;
          var i2, s;
          if (t2 && "function" == typeof (i2 = e2.toString) && !r(s = i2.call(e2))) return s;
          if ("function" == typeof (i2 = e2.valueOf) && !r(s = i2.call(e2))) return s;
          if (!t2 && "function" == typeof (i2 = e2.toString) && !r(s = i2.call(e2))) return s;
          throw TypeError("Can't convert object to primitive value");
        };
      }, function(e, t, i) {
        var r = i(57), s = i(37);
        e.exports = Object.keys || function(e2) {
          return r(e2, s);
        };
      }, function(e, t, i) {
        var r = i(36)("keys"), s = i(24);
        e.exports = function(e2) {
          return r[e2] || (r[e2] = s(e2));
        };
      }, function(e, t, i) {
        var r = i(4), s = i(0), a = s["__core-js_shared__"] || (s["__core-js_shared__"] = {});
        (e.exports = function(e2, t2) {
          return a[e2] || (a[e2] = void 0 !== t2 ? t2 : {});
        })("versions", []).push({ version: r.version, mode: i(15) ? "pure" : "global", copyright: "© 2020 Denis Pushkarev (zloirock.ru)" });
      }, function(e, t) {
        e.exports = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",");
      }, function(e, t, i) {
        "use strict";
        var r = i(21);
        function s(e2) {
          var t2, i2;
          this.promise = new e2(function(e3, r2) {
            if (void 0 !== t2 || void 0 !== i2) throw TypeError("Bad Promise constructor");
            t2 = e3, i2 = r2;
          }), this.resolve = r(t2), this.reject = r(i2);
        }
        e.exports.f = function(e2) {
          return new s(e2);
        };
      }, function(e, t, i) {
        t.f = i(2);
      }, function(e, t, i) {
        var r = i(0), s = i(4), a = i(15), o = i(39), n = i(10).f;
        e.exports = function(e2) {
          var t2 = s.Symbol || (s.Symbol = a ? {} : r.Symbol || {});
          "_" == e2.charAt(0) || e2 in t2 || n(t2, e2, { value: o.f(e2) });
        };
      }, function(e, t) {
        t.f = {}.propertyIsEnumerable;
      }, function(e, t, i) {
        "use strict";
        function r(e2, t2 = 1, i2 = 1) {
          return e2 <= 1 ? i2 : r(e2 - 1, i2, t2 + i2);
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.getDomInfo = t.makePrintable = t.formatSingleArg = t.deepCopy = t.randomString = t.randomId = t.generateUUID = t.getReconnectionTimeout = t.fibonacci = void 0, t.fibonacci = r, t.getReconnectionTimeout = function(e2) {
          const t2 = Math.round(e2 / 2) + 1;
          return t2 > 6 ? 13e3 : 1e3 * r(t2);
        };
        t.generateUUID = function() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e2) {
            var t2 = 16 * Math.random() | 0;
            return ("x" == e2 ? t2 : 3 & t2 | 8).toString(16);
          });
        };
        t.randomId = function() {
          return "xxxxxxxxxx".replace(/[xy]/g, function(e2) {
            var t2 = 16 * Math.random() | 0;
            return ("x" == e2 ? t2 : 3 & t2 | 8).toString(16);
          });
        };
        function s(e2) {
          if (window.RTCRtpSender && e2 instanceof RTCRtpSender) {
            return `[RTCRtpSender track: ${s(e2.track)}]`;
          }
          if (e2 instanceof MediaStreamTrack) {
            const t2 = e2;
            return `[MediaStreamTrack kind:${t2.kind} label:${t2.label} readyState:${t2.readyState} id: ${t2.id} enabled:${t2.enabled} muted: ${t2.muted}]`;
          }
          if (e2 instanceof HTMLElement) {
            const t2 = e2;
            return `[${t2.tagName}.${t2.className} ${t2.clientWidth}x${t2.clientHeight}]`;
          }
          if (e2 instanceof MediaStream) {
            const t2 = e2;
            return `[MediaStream active:${t2.active} a:${t2.getAudioTracks().length} v:${t2.getVideoTracks().length}]`;
          }
          if (window.DOMException && e2 instanceof DOMException) {
            return `[Error name:${e2.name} code:${e2.code} message:${e2.message}]`;
          }
          return e2;
        }
        t.randomString = (e2, t2) => {
          if (!e2 || !t2) return "";
          let i2 = "";
          for (var r2 = t2; r2 > 0; --r2) i2 += e2[Math.floor(Math.random() * e2.length)];
          return i2;
        }, t.deepCopy = function e2(t2) {
          var i2 = Array.isArray(t2) ? [] : {};
          for (var r2 in t2) t2.hasOwnProperty(r2) && ("object" == typeof t2[r2] && null !== t2[r2] ? i2[r2] = e2(t2[r2]) : i2[r2] = t2[r2]);
          return i2;
        }, t.formatSingleArg = s, t.makePrintable = function e2(t2, i2, r2 = []) {
          if ("object" != typeof t2 || !(null == t2 ? void 0 : t2.hasOwnProperty)) return t2;
          var a = Array.isArray(t2) ? [] : {};
          for (var o in t2) if (t2.hasOwnProperty(o)) {
            const n = s(t2[o]);
            n && ("client" === o && n.adapterRef || ["adapterRef", "sdkRef", "logger", "_events"].indexOf(o) > -1 || (n && "object" == typeof n ? r2.indexOf(n) > -1 ? a[o] = "[Circular obj]" : (r2.push(a[o]), i2 >= 1 ? a[o] = e2(n, i2 - 1, r2) : (null == n ? void 0 : n.toString) ? a[o] = n.toString() : a[o] = typeof n) : a[o] = n));
          }
          return a;
        }, t.getDomInfo = function(e2) {
          if (!e2) return "" + e2;
          let t2 = e2.tagName;
          return e2.id && (t2 += "#" + e2.id), e2.className && (t2 += "." + e2.className), (e2.offsetWidth || e2.offsetHeight) && (t2 += ` ${e2.offsetWidth}x${e2.offsetHeight}`), t2;
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.reduceCodecs = t.getSupportedCodecs = t.getCurrentProfileLevel = t.VideoCodecList = void 0;
        const o = i(1), n = i(7), d = i(28), c = a(i(7));
        function l(e2) {
          const t2 = { video: [], audio: [] };
          return e2.match(/ H264/i) && t2.video.push("H264"), e2.match(/ VP8/i) && t2.video.push("VP8"), e2.match(/ opus/i) && t2.audio.push("OPUS"), t2;
        }
        function u(e2, t2, i2) {
          const r2 = { video: [], audio: [] };
          if (t2 && t2.codecs && t2.codecs.length) for (let i3 = 0; i3 < t2.codecs.length; i3++) {
            const s2 = t2.codecs[i3];
            "video/H264" == s2.mimeType && -1 === r2.video.indexOf("H264") && ("recv" === e2 && s2.sdpFmtpLine && s2.sdpFmtpLine.indexOf("profile-level-id") > -1 ? o.getParameters().h264StrictHigh ? s2.sdpFmtpLine.indexOf("profile-level-id=64") > -1 && r2.video.push("H264") : r2.video.push("H264") : -1 === r2.video.indexOf("H264") && r2.video.push("H264")), "video/VP8" == s2.mimeType && -1 === r2.video.indexOf("VP8") && r2.video.push("VP8");
          }
          if (i2 && i2.codecs && i2.codecs.length) for (let e3 = 0; e3 < i2.codecs.length; e3++) {
            "audio/opus" == i2.codecs[e3].mimeType && r2.audio.push("OPUS");
          }
          return r2;
        }
        function h(e2) {
          if ("undefined" != typeof RTCRtpSender && "function" == typeof RTCRtpSender.getCapabilities) {
            const t2 = RTCRtpSender.getCapabilities("video");
            if (t2) for (let i2 in t2.codecs) {
              const r2 = t2.codecs[i2];
              if ("video/H264" === r2.mimeType && r2.sdpFmtpLine && r2.sdpFmtpLine.indexOf(e2) > -1) return true;
            }
          }
          return false;
        }
        t.VideoCodecList = ["H264", "VP8"], t.getSupportedCodecs = async function(e2 = "recv", t2 = RTCPeerConnection) {
          if ("recv" === e2) {
            if (c.ANY_CHROME_MAJOR_VERSION && c.ANY_CHROME_MAJOR_VERSION >= 58 && c.ANY_CHROME_MAJOR_VERSION < 69) {
              const e3 = new t2({}), i2 = await e3.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
              if (e3.close(), !i2.sdp) return false;
              return l(i2.sdp);
            }
            if ("undefined" != typeof RTCRtpReceiver && RTCRtpReceiver.getCapabilities) {
              return u(e2, RTCRtpReceiver.getCapabilities("video"), RTCRtpReceiver.getCapabilities("audio"));
            }
            {
              const e3 = new t2({});
              e3.addTransceiver("audio", { direction: "recvonly" }), e3.addTransceiver("video", { direction: "recvonly" });
              const i2 = await e3.createOffer({});
              if (e3.close(), !i2.sdp) return false;
              return l(i2.sdp);
            }
          }
          if ("undefined" != typeof RTCRtpSender && RTCRtpSender.getCapabilities) {
            return u(e2, RTCRtpSender.getCapabilities("video"), RTCRtpSender.getCapabilities("audio"));
          }
          {
            const e3 = new t2({}), i2 = await e3.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
            if (e3.close(), !i2.sdp) return false;
            return l(i2.sdp);
          }
        };
        let p = "";
        t.getCurrentProfileLevel = function() {
          return p;
        }, t.reduceCodecs = function(e2, i2) {
          const r2 = [];
          let s2 = "";
          for (let a2 = 0; a2 < e2.length; a2++) {
            if (e2[a2].mimeType && i2 && t.VideoCodecList.indexOf(e2[a2].mimeType.split("/")[1]) > -1 && e2[a2].mimeType !== i2.mimeType) {
              a2++;
              continue;
            }
            const c2 = e2[a2];
            c2.mimeType && 0 === c2.mimeType.indexOf("video") && ("video/H264" === c2.mimeType && o.getParameters().h264ProfileLevel && (95 === n.CHROME_MAJOR_VERSION ? d.getDefaultLogger().warn("当前浏览器版本无法修改H264 Profile Level：" + o.getParameters().h264ProfileLevel) : c2.parameters["profile-level-id"] && h(o.getParameters().h264ProfileLevel) && (c2.parameters["profile-level-id"] = o.getParameters().h264ProfileLevel)), s2 || (s2 = `${c2.mimeType}/${c2.parameters["profile-level-id"]}`)), r2.push(e2[a2]);
          }
          return s2 && (p = s2), r2;
        };
      }, function(e, t, i) {
        "use strict";
        (function(e2) {
          var r = t;
          function s(e3, t2, i2) {
            for (var r2 = Object.keys(t2), s2 = 0; s2 < r2.length; ++s2) void 0 !== e3[r2[s2]] && i2 || (e3[r2[s2]] = t2[r2[s2]]);
            return e3;
          }
          function a(e3) {
            function t2(e4, i2) {
              if (!(this instanceof t2)) return new t2(e4, i2);
              Object.defineProperty(this, "message", { get: function() {
                return e4;
              } }), Error.captureStackTrace ? Error.captureStackTrace(this, t2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), i2 && s(this, i2);
            }
            return (t2.prototype = Object.create(Error.prototype)).constructor = t2, Object.defineProperty(t2.prototype, "name", { get: function() {
              return e3;
            } }), t2.prototype.toString = function() {
              return this.name + ": " + this.message;
            }, t2;
          }
          r.asPromise = i(179), r.base64 = i(263), r.EventEmitter = i(264), r.float = i(265), r.inquire = i(180), r.utf8 = i(266), r.pool = i(267), r.LongBits = i(268), r.isNode = Boolean(void 0 !== e2 && e2 && e2.process && e2.process.versions && e2.process.versions.node), r.global = r.isNode && e2 || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(e3) {
            return "number" == typeof e3 && isFinite(e3) && Math.floor(e3) === e3;
          }, r.isString = function(e3) {
            return "string" == typeof e3 || e3 instanceof String;
          }, r.isObject = function(e3) {
            return e3 && "object" == typeof e3;
          }, r.isset = r.isSet = function(e3, t2) {
            var i2 = e3[t2];
            return !(null == i2 || !e3.hasOwnProperty(t2)) && ("object" != typeof i2 || (Array.isArray(i2) ? i2.length : Object.keys(i2).length) > 0);
          }, r.Buffer = function() {
            try {
              var e3 = r.inquire("buffer").Buffer;
              return e3.prototype.utf8Write ? e3 : null;
            } catch (e4) {
              return null;
            }
          }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(e3) {
            return "number" == typeof e3 ? r.Buffer ? r._Buffer_allocUnsafe(e3) : new r.Array(e3) : r.Buffer ? r._Buffer_from(e3) : "undefined" == typeof Uint8Array ? e3 : new Uint8Array(e3);
          }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(e3) {
            return e3 ? r.LongBits.from(e3).toHash() : r.LongBits.zeroHash;
          }, r.longFromHash = function(e3, t2) {
            var i2 = r.LongBits.fromHash(e3);
            return r.Long ? r.Long.fromBits(i2.lo, i2.hi, t2) : i2.toNumber(Boolean(t2));
          }, r.merge = s, r.lcFirst = function(e3) {
            return e3.charAt(0).toLowerCase() + e3.substring(1);
          }, r.newError = a, r.ProtocolError = a("ProtocolError"), r.oneOfGetter = function(e3) {
            for (var t2 = {}, i2 = 0; i2 < e3.length; ++i2) t2[e3[i2]] = 1;
            return function() {
              for (var e4 = Object.keys(this), i3 = e4.length - 1; i3 > -1; --i3) if (1 === t2[e4[i3]] && void 0 !== this[e4[i3]] && null !== this[e4[i3]]) return e4[i3];
            };
          }, r.oneOfSetter = function(e3) {
            return function(t2) {
              for (var i2 = 0; i2 < e3.length; ++i2) e3[i2] !== t2 && delete this[e3[i2]];
            };
          }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
            var e3 = r.Buffer;
            e3 ? (r._Buffer_from = e3.from !== Uint8Array.from && e3.from || function(t2, i2) {
              return new e3(t2, i2);
            }, r._Buffer_allocUnsafe = e3.allocUnsafe || function(t2) {
              return new e3(t2);
            }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
          };
        }).call(this, i(70));
      }, function(e, t, i) {
        "use strict";
        e.exports = o;
        var r = i(82);
        ((o.prototype = Object.create(r.prototype)).constructor = o).className = "Enum";
        var s = i(91), a = i(19);
        function o(e2, t2, i2, s2, a2) {
          if (r.call(this, e2, i2), t2 && "object" != typeof t2) throw TypeError("values must be an object");
          if (this.valuesById = {}, this.values = Object.create(this.valuesById), this.comment = s2, this.comments = a2 || {}, this.reserved = void 0, t2) for (var o2 = Object.keys(t2), n = 0; n < o2.length; ++n) "number" == typeof t2[o2[n]] && (this.valuesById[this.values[o2[n]] = t2[o2[n]]] = o2[n]);
        }
        o.fromJSON = function(e2, t2) {
          var i2 = new o(e2, t2.values, t2.options, t2.comment, t2.comments);
          return i2.reserved = t2.reserved, i2;
        }, o.prototype.toJSON = function(e2) {
          var t2 = !!e2 && Boolean(e2.keepComments);
          return a.toObject(["options", this.options, "values", this.values, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "comment", t2 ? this.comment : void 0, "comments", t2 ? this.comments : void 0]);
        }, o.prototype.add = function(e2, t2, i2) {
          if (!a.isString(e2)) throw TypeError("name must be a string");
          if (!a.isInteger(t2)) throw TypeError("id must be an integer");
          if (void 0 !== this.values[e2]) throw Error("duplicate name '" + e2 + "' in " + this);
          if (this.isReservedId(t2)) throw Error("id " + t2 + " is reserved in " + this);
          if (this.isReservedName(e2)) throw Error("name '" + e2 + "' is reserved in " + this);
          if (void 0 !== this.valuesById[t2]) {
            if (!this.options || !this.options.allow_alias) throw Error("duplicate id " + t2 + " in " + this);
            this.values[e2] = t2;
          } else this.valuesById[this.values[e2] = t2] = e2;
          return this.comments[e2] = i2 || null, this;
        }, o.prototype.remove = function(e2) {
          if (!a.isString(e2)) throw TypeError("name must be a string");
          var t2 = this.values[e2];
          if (null == t2) throw Error("name '" + e2 + "' does not exist in " + this);
          return delete this.valuesById[t2], delete this.values[e2], delete this.comments[e2], this;
        }, o.prototype.isReservedId = function(e2) {
          return s.isReservedId(this.reserved, e2);
        }, o.prototype.isReservedName = function(e2) {
          return s.isReservedName(this.reserved, e2);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.RTCEventEmitter = void 0;
        const r = i(3);
        class s extends r.EventEmitter {
          constructor() {
            super(), this._events || (this._events = {});
          }
          safeEmit(e2, ...t2) {
            try {
              e2.match(/^@/) || this.emit("@" + e2, ...t2), this.emit(e2, ...t2);
            } catch (t3) {
              (this.logger || console).error(`Error on event ${e2}: ${t3.name} ${t3.message}`, t3.stack);
            }
          }
        }
        t.RTCEventEmitter = s;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.WebAudio = t.getAudioLevelDestination = t.getAudioContext = t.tryResumeAudioContext = void 0;
        const s = i(3), a = i(165), o = r(i(6)), n = r(i(8)), d = i(143), c = i(1), l = i(212), u = d.RtcSupport.checkWebAudio();
        let h;
        class p {
          constructor(e2) {
            this.id = e2.id, this.label = e2.label, this.audioNode = e2.audioNode, this.gainNode = e2.context.createGain(), this.type = e2.type, this.audioNode.connect(this.gainNode);
          }
          connect(e2) {
            this.gainNode.connect(e2);
          }
          disconnect() {
            try {
              this.audioNode.disconnect(this.gainNode);
            } catch (e2) {
            }
            this.gainNode.disconnect();
          }
        }
        function m() {
          return h ? "suspended" === h.state && (h.resume().catch((e2) => {
          }), true) : null;
        }
        function g() {
          return h ? (m(), h) : c.getParameters().disableWebAudio ? null : u.WebAudio && u.MediaStream ? (h = new window.AudioContext(), h) : null;
        }
        t.tryResumeAudioContext = m, t.getAudioContext = g;
        let f = null;
        function v() {
          if (!f) {
            const e2 = g();
            e2 && (f = e2.createMediaStreamDestination());
          }
          return f;
        }
        t.getAudioLevelDestination = v;
        class S extends s.EventEmitter {
          constructor(e2) {
            super(), this.Jungle = null, this.wetGain = null, this.dryGain = null, this.effectInput = null, this.outputMix = null;
            const { logger: t2, isAnalyze: i2 = false, isRemote: r2 = false } = e2;
            this.support = u.WebAudio && u.MediaStream, this.gain = 1, this.logger = t2, this.audioInArr = [], this.isAnalyze = i2, this.isRemote = r2 || false, this.instant = 0, this.slow = 0, this.clip = 0, this.mediaHelper = e2.mediaHelper, this.mixAudioConf = { state: a.AuidoMixingState.UNSTART, audioSource: null, gainFilter: null, replace: false, cycle: 0, pauseTime: 0, startTime: 0, totalTime: 0, volume: 1, playStartTime: 0, setPlayStartTime: 0, auidoMixingEnd: null }, this.context = g(), this.context ? (this.destination = this.createDestination(), this.musicDestination = this.createDestination(), this.analyzeDestination = this.createDestination()) : (this.destination = null, this.musicDestination = null, this.analyzeDestination = null), this.support && (this.resetMixConf(), this.init());
          }
          createDestination() {
            if (!this.context) throw new Error("AudioContextRequired");
            try {
              return new MediaStreamAudioDestinationNode(this.context);
            } catch (e2) {
              if ("TypeError" === e2.name) return this.context.createMediaStreamDestination();
              throw e2;
            }
          }
          createSource(e2) {
            if (!this.context) throw new Error("AudioContextRequired");
            try {
              return new MediaStreamAudioSourceNode(this.context, e2);
            } catch (t2) {
              if ("TypeError" === t2.name) return this.context.createMediaStreamSource(e2.mediaStream);
              throw t2;
            }
          }
          init() {
            this.isAnalyze && this.initMonitor(), this.initWebAudio(), this.initAudioIn();
          }
          initMonitor() {
            var e2 = this;
            this.context ? (this.script = this.context.createScriptProcessor(0, 1, 1)).onaudioprocess = function(t2) {
              var i2, r2 = t2.inputBuffer.getChannelData(0), s2 = 0, a2 = 0;
              for (i2 = 0; i2 < r2.length; ++i2) s2 += Math.abs(r2[i2]), Math.abs(r2[i2]) > 0.99 && (a2 += 1);
              e2.instant = Math.sqrt(s2 / r2.length), e2.slow = 0.95 * e2.slow + 0.05 * e2.instant, e2.clip = a2 / r2.length;
              let o2 = t2.inputBuffer, n2 = t2.outputBuffer;
              n2.copyToChannel && n2.copyToChannel(o2.getChannelData(0), 0, 0);
            } : e2.logger.error("initMonitor:参数不够");
          }
          initWebAudio() {
            this.context && this.destination ? (this.gainFilter = this.context.createGain(), this.gainFilter.gain.value = this.gain) : this.logger.error("initMonitor:参数不够");
          }
          initAudioIn() {
            var e2, t2, i2, r2, s2;
            const o2 = this;
            if (!o2.context || !o2.gainFilter || !o2.destination) return this.logger.error("initAudioIn:参数不够"), null;
            let n2 = (null === (t2 = null === (e2 = this.mediaHelper.audio.stageAIProcessing) || void 0 === e2 ? void 0 : e2.node) || void 0 === t2 ? void 0 : t2.audioNode) || null, d2 = null === (i2 = this.mediaHelper.audio.stageAIProcessing) || void 0 === i2 ? void 0 : i2.enabled;
            const c2 = "MIX_PLAYING" === this.mixAudioConf.state && this.mixAudioConf.replace;
            if (n2 && !c2) if (d2) n2.connect(o2.gainFilter);
            else try {
              n2.disconnect(o2.gainFilter);
            } catch (e3) {
            }
            for (var l2 = 0; l2 < o2.audioInArr.length; l2++) {
              const e3 = o2.audioInArr[l2];
              if (n2 && !c2) if (d2) {
                try {
                  e3.gainNode.disconnect(o2.gainFilter);
                } catch (e4) {
                }
                e3.connect(n2);
              } else {
                try {
                  e3.gainNode.disconnect(n2);
                } catch (e4) {
                }
                e3.connect(o2.gainFilter);
              }
              else c2 ? this.logger.log("当前正在以Replace模式播放伴音，暂不接入") : e3.connect(o2.gainFilter);
              let t3 = (null === (s2 = null === (r2 = this.mediaHelper.audio.stageAIProcessing) || void 0 === r2 ? void 0 : r2.howlingNode) || void 0 === s2 ? void 0 : s2.audioNode) || null;
              if (t3) if (d2) {
                e3.connect(t3);
                const i3 = v();
                i3 && t3.connect(i3);
              } else try {
                e3.gainNode.disconnect(t3);
              } catch (e4) {
              }
            }
            o2.mixAudioConf.state === a.AuidoMixingState.UNSTART && (o2.script && o2.analyzeDestination && (o2.gainFilter.connect(o2.script), o2.script.connect(o2.analyzeDestination)), o2.gainFilter.connect(o2.destination)), this.logger.log("WebAudio: initAudioIn: 初始化音频 state: ", o2.context.state), "running" !== o2.context.state && o2.context.resume().then(() => {
              this.context && this.logger.log("WebAudio: addMs: 状态变更成功 state: ", this.context.state);
            }).catch((e3) => {
              this.logger.log("WebAudio: addMs: 状态变更出错: ", e3.name, e3.message, e3), this.context && this.context.resume();
            });
          }
          updateTracks(e2) {
            for (let t2 = this.audioInArr.length - 1; t2 >= 0; t2--) {
              const i2 = this.audioInArr[t2];
              e2.find((e3) => e3.track && i2 && e3.track.id === i2.id) || (this.logger.log("updateTracks，删除", i2.label, i2.id), this.audioInArr.splice(t2, 1), i2.disconnect());
            }
            for (let t2 = e2.length - 1; t2 >= 0; t2--) {
              const i2 = e2[t2];
              if (!this.audioInArr.find((e3) => i2.track && i2.track.id === e3.id) && i2.track) if (this.context) {
                const e3 = new MediaStream();
                e3.addTrack(i2.track);
                const t3 = { context: this.context, id: i2.track.id, label: i2.track.label, audioNode: this.createSource({ mediaStream: e3 }), type: i2.type }, r2 = new p(t3);
                r2.gainNode.gain.value = this.gain, this.audioInArr.push(r2);
              } else this.logger.error("updateTracks：没有audioContext");
            }
            this.initAudioIn();
          }
          removeTrack(e2) {
            for (let t2 = this.audioInArr.length - 1; t2 >= 0; t2--) {
              const i2 = this.audioInArr[t2];
              i2.id === e2.id && (this.logger.log("removeTrack，删除track", e2.id, e2.label), this.audioInArr.splice(t2, 1), i2.disconnect());
            }
          }
          setGain(e2, t2) {
            for (let i2 = 0; i2 < this.audioInArr.length; i2++) {
              const r2 = this.audioInArr[i2];
              t2 && t2 !== r2.type || (this.logger.log("WebAudio.setGain", t2, e2, r2.type, r2.label, r2.id), r2.gainNode.gain.value = 0, r2.gainNode.gain.setValueAtTime(e2, this.context.currentTime));
            }
            t2 || (this.gain = e2);
          }
          getGain() {
            if (this.gainFilter) return this.gain;
          }
          getGainMin() {
            let e2 = 1;
            for (let t2 = 0; t2 < this.audioInArr.length; t2++) {
              const i2 = this.audioInArr[t2];
              i2.gainNode.gain.value < e2 && (e2 = i2.gainNode.gain.value);
            }
            return e2;
          }
          stop() {
            this.gainFilter && (this.script ? this.script.disconnect(0) : this.gainFilter.disconnect(0), this.instant = 0);
          }
          start() {
            this.gainFilter && this.destination && (this.script && this.analyzeDestination && (this.gainFilter.connect(this.script), this.script.connect(this.analyzeDestination)), this.gainFilter.connect(this.destination));
          }
          setAudioEffectLite(e2, t2) {
            switch (e2) {
              case "Pitch":
                this.setPitch(t2);
                break;
              case "close":
                this.closeAudioEffect();
                break;
              default:
                this.logger.warn("暂不支持的类型：", e2);
            }
          }
          setPitch(e2) {
            var t2, i2;
            this.context && this.destination && this.gainFilter && (this.Jungle || this.initJungle(), (null === (t2 = this.Jungle) || void 0 === t2 ? void 0 : t2.connected) || this.createPitchShifter(), this.logger.log("setPitch: ", e2), null === (i2 = this.Jungle) || void 0 === i2 || i2.setPitchOffset(e2));
          }
          initJungle() {
            if (this.context && this.destination && this.gainFilter) {
              this.Jungle || (this.Jungle = new l.Jungle(this.context));
              const e2 = this.gainFilter;
              this.outputMix = this.context.createGain(), this.wetGain = this.context.createGain(), this.dryGain = this.context.createGain(), this.effectInput = this.context.createGain(), e2.connect(this.dryGain), e2.connect(this.effectInput), this.dryGain.connect(this.outputMix), this.wetGain.connect(this.outputMix), this.outputMix.connect(this.destination), l.crossfade(1, this.dryGain, this.wetGain), this.logger.log("initJungle: 初始化成功");
            } else this.logger.error("connectJungle: contxt is null");
          }
          createPitchShifter() {
            if (this.logger.log("createPitchShifter: 开始连接"), this.Jungle && this.wetGain && this.gainFilter) {
              const e2 = this.gainFilter;
              e2.disconnect(0), e2.connect(this.Jungle.input), this.Jungle.output.connect(this.wetGain), this.Jungle.connected = true, this.logger.log("createPitchShifter: 连接成功");
            } else this.logger.warn("createPitchShifter: Jungle is null");
          }
          disconnectJungle() {
            var e2, t2;
            this.logger.log("disconnectJungle: 断开连接"), this.destination ? (null === (e2 = this.gainFilter) || void 0 === e2 || e2.disconnect(0), null === (t2 = this.gainFilter) || void 0 === t2 || t2.connect(this.destination)) : this.logger.warn("disconnectJungle: destination is null");
          }
          closeAudioEffect() {
            var e2, t2;
            this.destination && (null === (e2 = this.gainFilter) || void 0 === e2 || e2.disconnect(0), null === (t2 = this.gainFilter) || void 0 === t2 || t2.connect(this.destination)), this.Jungle && (this.Jungle.connected = false);
          }
          resetMixConf() {
            var e2, t2, i2;
            if (null === (e2 = this.mixAudioConf.audioSource) || void 0 === e2 || e2.disconnect(0), null === (t2 = this.mixAudioConf.gainFilter) || void 0 === t2 || t2.disconnect(0), this.mixAudioConf.replace) {
              this.logger.log("伴音停止了，恢复mic");
              if (null === (i2 = this.mediaHelper.audio.stageAIProcessing) || void 0 === i2 ? void 0 : i2.enabled) this.connectAiNode();
              else if (this.gainFilter && this.destination) {
                for (var r2 = 0; r2 < this.audioInArr.length; r2++) {
                  this.audioInArr[r2].gainNode.connect(this.gainFilter);
                }
                this.script && this.analyzeDestination && (this.gainFilter.connect(this.script), this.script.connect(this.analyzeDestination)), this.gainFilter.connect(this.destination);
              }
            }
            this.mixAudioConf = { state: a.AuidoMixingState.UNSTART, audioSource: null, gainFilter: null, replace: false, cycle: 0, pauseTime: 0, startTime: 0, totalTime: 0, volume: 1, playStartTime: 0, setPlayStartTime: 0, auidoMixingEnd: null }, this.gainFilter && 1 === this.gainFilter.gain.value && this.emit("audioFilePlaybackCompleted");
          }
          startMix(e2) {
            var t2;
            if (!this.context || !this.destination || !this.gainFilter) return this.logger.error("startMix: 不支持伴音"), Promise.reject(new n.default({ code: o.default.AUDIO_MIX_NO_SUPPORT, message: "startMix:不支持伴音" }));
            if (this.logger.log("开始混音: ", JSON.stringify(e2)), this.mixAudioConf.audioSource = this.context.createBufferSource(), this.mixAudioConf.gainFilter = this.context.createGain(), this.mixAudioConf.audioSource.buffer = e2.buffer, this.mixAudioConf.replace = e2.replace, this.mixAudioConf.cycle = e2.cycle, this.mixAudioConf.playStartTime = e2.playStartTime, this.mixAudioConf.volume = e2.volume ? e2.volume / 255 : 1, this.mixAudioConf.auidoMixingEnd = e2.auidoMixingEnd, this.mixAudioConf.audioSource.connect(this.mixAudioConf.gainFilter), this.mixAudioConf.gainFilter.connect(this.gainFilter), this.musicDestination && this.mixAudioConf.gainFilter.connect(this.musicDestination), e2.replace) {
              for (var i2 = 0; i2 < this.audioInArr.length; i2++) {
                const e3 = this.audioInArr[i2];
                try {
                  e3.gainNode.disconnect(this.gainFilter), this.logger.log(`已断开音频：【${e3.label}】`);
                } catch (t3) {
                  "InvalidAccessError" === t3.name ? this.logger.log(`音频断开前未连接：【${e3.label}】`) : this.logger.error(`无法断开音频:【${e3.label}】${t3.name}`, t3.message);
                }
              }
              (null === (t2 = this.mediaHelper.audio.stageAIProcessing) || void 0 === t2 ? void 0 : t2.enabled) && this.disconnectAiNode();
            }
            if (this.mixAudioConf.audioSource.onended = (e3) => {
              this.audioEnd(e3);
            }, this.mixAudioConf.totalTime = e2.buffer.duration, (this.mixAudioConf.playStartTime < 0 || this.mixAudioConf.playStartTime >= this.mixAudioConf.totalTime) && (this.mixAudioConf.playStartTime = 0), this.logger.log("设置音量:", this.mixAudioConf.volume), this.mixAudioConf.gainFilter.gain.value = this.mixAudioConf.volume, e2.loopback && e2.cycle > 1) {
              this.mixAudioConf.audioSource.loop = e2.loopback;
              const t3 = e2.cycle * this.mixAudioConf.totalTime - this.mixAudioConf.playStartTime;
              this.logger.log("循环播放: options.playStartTime: ", this.mixAudioConf.playStartTime), this.logger.log("循环播放: totalTime: ", t3), this.mixAudioConf.audioSource.start(0, this.mixAudioConf.playStartTime, t3 - 1);
            } else e2.loopback && 1 == e2.cycle ? (this.mixAudioConf.audioSource.loop = false, this.mixAudioConf.audioSource.start(0, this.mixAudioConf.playStartTime)) : (this.logger.log("无限循环播放 loop: ", e2.loopback), this.mixAudioConf.audioSource.loop = e2.loopback, this.mixAudioConf.audioSource.start(0, this.mixAudioConf.playStartTime));
            return this.mixAudioConf.state = a.AuidoMixingState.PLAYED, this.mixAudioConf.startTime = Date.now(), Promise.resolve();
          }
          pauseAudioMixing() {
            if (!this.mixAudioConf.audioSource || !this.mixAudioConf.gainFilter) return void this.logger.error("pauseAudioMixing: 缺失audioSource/gainFilter");
            this.logger.log("暂停混音"), this.mixAudioConf.audioSource.onended = null, this.mixAudioConf.audioSource.disconnect(0), this.mixAudioConf.gainFilter.disconnect(0), this.mixAudioConf.audioSource.stop(), this.mixAudioConf.pauseTime = Date.now(), this.mixAudioConf.state = a.AuidoMixingState.PAUSED;
            let e2 = (this.mixAudioConf.pauseTime - this.mixAudioConf.startTime) / 1e3 + this.mixAudioConf.playStartTime;
            return this.logger.log("已经播放的时间: ", e2), e2 > this.mixAudioConf.totalTime && (e2 %= this.mixAudioConf.totalTime), this.logger.log("暂停位置:", e2), Promise.resolve();
          }
          resumeAudioMixing(e2) {
            return this.logger.log("恢复混音"), this.mixAudioConf.pauseTime = 0, e2.volume = 255 * this.mixAudioConf.volume, this.startMix(e2);
          }
          stopAudioMixing(e2 = true) {
            return this.mixAudioConf.audioSource && this.mixAudioConf.gainFilter ? (this.logger.log("开始停止混音, isFinished: ", e2), this.mixAudioConf.audioSource.onended = null, this.mixAudioConf.audioSource.disconnect(0), this.mixAudioConf.gainFilter.disconnect(0), this.mixAudioConf.audioSource.stop(), this.mixAudioConf.state = a.AuidoMixingState.STOPED, e2 && this.resetMixConf(), this.logger.log("混音已停止"), Promise.resolve()) : Promise.reject(new n.default({ code: o.default.AUDIO_MIX_NOT_STATE_ERROR, message: "stopAudioMixing() 当前没有开启伴音" }));
          }
          audioEnd(e2) {
            if (this.mixAudioConf.state === a.AuidoMixingState.PLAYED) {
              if (!(this.mixAudioConf.audioSource && this.mixAudioConf.audioSource.loop && this.mixAudioConf.cycle <= 0)) return this.logger.log("伴音播放完成: ", this.mixAudioConf), this.mixAudioConf.audioSource && (this.mixAudioConf.audioSource.onended = null), this.mixAudioConf.auidoMixingEnd && (this.mixAudioConf.auidoMixingEnd(e2), this.mixAudioConf.auidoMixingEnd = null), this.resetMixConf(), Promise.resolve();
              this.logger.log("无限循环时, 伴音播放完成event: ", e2);
            } else this.logger.error("audioEnd:参数不够");
          }
          setAudioMixingVolume(e2) {
            if (this.mixAudioConf.gainFilter) return this.mixAudioConf.gainFilter.gain.value = e2 / 255, this.mixAudioConf.volume = this.mixAudioConf.gainFilter.gain.value, Promise.resolve();
            this.logger.error("setAudioMixingVolume: 参数缺失gainFilter");
          }
          setAudioMixingPlayTime(e2) {
            return this.mixAudioConf.state === a.AuidoMixingState.PLAYED && (this.mixAudioConf.setPlayStartTime = e2.playStartTime), e2.volume = 255 * this.mixAudioConf.volume, this.startMix(e2);
          }
          getAudioMixingPlayedTime() {
            let e2 = Date.now();
            this.mixAudioConf.state == a.AuidoMixingState.PAUSED && this.mixAudioConf.pauseTime && (this.logger.log("当前是暂停状态"), e2 = this.mixAudioConf.pauseTime);
            let t2 = (e2 - this.mixAudioConf.startTime) / 1e3 + this.mixAudioConf.playStartTime;
            return t2 > this.mixAudioConf.totalTime && (t2 %= this.mixAudioConf.totalTime), { playedTime: t2 };
          }
          getAudioMixingTotalTime() {
            return { totalTime: this.mixAudioConf.totalTime };
          }
          createAudioBufferSource(e2) {
            if (!this.context || !this.destination || !this.gainFilter) throw new n.default({ code: o.default.AUDIO_EFFECT_NO_SUPPORT, message: "webAudio_createAudioBufferSource: 接口调用状态异常" });
            const t2 = this.context.createBufferSource();
            t2.buffer = e2;
            const i2 = this.context.createGain();
            t2.connect(i2);
            return { sourceNode: t2, gainNode: i2 };
          }
          startAudioEffectMix(e2) {
            if (!this.context || !this.destination || !this.gainFilter) return Promise.reject(new n.default({ code: o.default.AUDIO_EFFECT_NO_SUPPORT, message: "webAudio_startAudioEffectMix: 接口调用状态异常" }));
            const { sourceNode: t2, gainNode: i2, playOverTime: r2, playStartTime: s2, volume: d2, cycle: c2 } = e2;
            i2 && t2 && (this.logger.log("startAudioEffectMix: ", JSON.stringify(e2)), i2.connect(this.gainFilter), this.musicDestination && i2.connect(this.musicDestination), i2.gain.value = d2 / 100, c2 > 1 ? (t2.loop = true, t2.start(0, s2, r2)) : (t2.loop = false, t2.start(0, s2)), this.mixAudioConf.state = a.AuidoMixingState.PLAYED, this.mixAudioConf.startTime = Date.now());
          }
          stopAudioEffectMix(e2) {
            const { sourceNode: t2, gainNode: i2, playOverTime: r2, playStartTime: s2, volume: a2, cycle: d2 } = e2;
            if (!i2 || !t2) return Promise.reject(new n.default({ code: o.default.AUDIO_EFFECT_NO_SUPPORT, message: "webAudio_startAudioEffectMix: 接口调用状态异常" }));
            this.logger.log("stopAudioEffectMix: ", JSON.stringify(e2)), t2.onended = null, t2.disconnect(0), i2.disconnect(0), t2.stop();
          }
          connectAiNode() {
            var e2, t2;
            if (!this.context || !this.gainFilter) return null;
            let i2 = (null === (t2 = null === (e2 = this.mediaHelper.audio.stageAIProcessing) || void 0 === e2 ? void 0 : e2.node) || void 0 === t2 ? void 0 : t2.audioNode) || null;
            if (i2) try {
              i2.connect(this.gainFilter);
            } catch (e3) {
            }
            for (var r2 = 0; r2 < this.audioInArr.length; r2++) {
              const e3 = this.audioInArr[r2];
              if (i2) try {
                e3.connect(i2);
              } catch (e4) {
              }
            }
          }
          disconnectAiNode() {
            var e2, t2;
            if (!this.context || !this.gainFilter) return null;
            let i2 = (null === (t2 = null === (e2 = this.mediaHelper.audio.stageAIProcessing) || void 0 === e2 ? void 0 : e2.node) || void 0 === t2 ? void 0 : t2.audioNode) || null;
            if (i2) try {
              i2.disconnect(this.gainFilter);
            } catch (e3) {
            }
            for (var r2 = 0; r2 < this.audioInArr.length; r2++) {
              const e3 = this.audioInArr[r2];
              if (i2) try {
                e3.gainNode.disconnect(i2);
              } catch (e4) {
              }
            }
          }
          destroy() {
            this.logger.log("AudioContext 清除"), this.instant = 0, this.slow = 0, this.clip = 0, this.gainFilter && this.gainFilter.disconnect(0), this.script && this.script.disconnect(0);
            for (let e2 = 0; e2 < this.audioInArr.length; e2++) this.audioInArr[e2] && this.audioInArr[e2].disconnect();
            this.audioInArr = [];
          }
          getVolumeData() {
            return this.instant.toFixed(2);
          }
        }
        t.WebAudio = S;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.PlatformType = t.PlatformTypeMap = t.MediaTypeList = t.MediaTypeListVideo = t.MediaTypeListAudio = t.ReconnectReason = t.ConStateChange_reason = t.ConStateChange_state = void 0, function(e2) {
          e2[e2.ChannelIdle = 0] = "ChannelIdle", e2[e2.ChannelJoining = 1] = "ChannelJoining", e2[e2.ChannelJoined = 2] = "ChannelJoined", e2[e2.ChannelLeaving = 3] = "ChannelLeaving", e2[e2.ChannelLeave = 4] = "ChannelLeave", e2[e2.ChannelRejoining = 5] = "ChannelRejoining", e2[e2.ChannelJoinFailed = 6] = "ChannelJoinFailed";
        }(t.ConStateChange_state || (t.ConStateChange_state = {})), function(e2) {
          e2[e2.Idle = 0] = "Idle", e2[e2.Leave = 1] = "Leave", e2[e2.Closed = 2] = "Closed", e2[e2.BeKicked = 3] = "BeKicked", e2[e2.TimeOut = 4] = "TimeOut", e2[e2.Join = 5] = "Join", e2[e2.JoinSucceed = 6] = "JoinSucceed", e2[e2.ReJoinSucceed = 7] = "ReJoinSucceed", e2[e2.MediaDisconnected = 8] = "MediaDisconnected", e2[e2.SignalDisconnected = 9] = "SignalDisconnected", e2[e2.RequestChannelFailed = 10] = "RequestChannelFailed", e2[e2.JoinChannelFailed = 11] = "JoinChannelFailed", e2[e2.RedispatchServer = 12] = "RedispatchServer", e2[e2.GetCloudProxyServer = 13] = "GetCloudProxyServer", e2[e2.BeKickedDueToSameUserId = 14] = "BeKickedDueToSameUserId";
        }(t.ConStateChange_reason || (t.ConStateChange_reason = {})), function(e2) {
          e2[e2.Unknown = 0] = "Unknown", e2[e2.SendPeerIceFailed = 1] = "SendPeerIceFailed", e2[e2.RecvPeerIceFailed = 2] = "RecvPeerIceFailed", e2[e2.WebsocketDisconnect = 3] = "WebsocketDisconnect", e2[e2.ConsumeRequestTimeout = 4] = "ConsumeRequestTimeout", e2[e2.OnTransportClose = 5] = "OnTransportClose", e2[e2.OnSignalRestart = 6] = "OnSignalRestart", e2[e2.MediaCapability = 7] = "MediaCapability";
        }(t.ReconnectReason || (t.ReconnectReason = {})), t.MediaTypeListAudio = ["audio", "audioSlave"], t.MediaTypeListVideo = ["video", "screen", "videoThird", "videoFourth"], t.MediaTypeList = ["audio", "video", "screen", "audioSlave", "videoThird", "videoFourth"], t.PlatformTypeMap = { "-1": "unknown", 1: "aos", 2: "ios", 4: "pc", 8: "winphone", 9: "mac", 16: "web" }, function(e2) {
          e2[e2.unknown = -1] = "unknown", e2[e2.aos = 1] = "aos", e2[e2.ios = 2] = "ios", e2[e2.pc = 4] = "pc", e2[e2.winphone = 8] = "winphone", e2[e2.mac = 9] = "mac", e2[e2.web = 16] = "web";
        }(t.PlatformType || (t.PlatformType = {}));
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.isNumber = t.isExistOptions = t.checkValidEnum = t.checkValidObject = t.checkValidString = t.checkValidInteger = t.checkValidFloat = t.checkValidBoolean = t.checkExists = t.isValidInteger = void 0;
        const n = o(i(6)), d = o(i(8)), c = a(i(7)), l = (e2) => Number.isInteger(e2.value) ? "number" == typeof e2.min && e2.value < e2.min ? { result: false, zhMsg: "参数小于最小值 " + e2.min, enMsg: "The parameter is less than the minimum value " + e2.min } : "number" == typeof e2.max && e2.value > e2.max ? { result: false, zhMsg: "参数大于最大值 " + e2.max, enMsg: "The parameter is greater than the maximum value " + e2.max } : { result: true } : { result: false, zhMsg: "参数不是整数", enMsg: "Parameter is not Number" };
        t.isValidInteger = l;
        t.checkValidInteger = (e2) => {
          const t2 = l(e2);
          if (!t2.result) {
            let i2 = c.IS_ZH ? `checkValidInteger: 参数错误: ${e2.tag}:${t2.zhMsg}` : `checkValidInteger: invalid parameter: ${e2.tag}:${t2.enMsg}`;
            throw new d.default({ code: n.default.INVALID_PARAMETER_ERROR, message: i2 });
          }
        };
        t.checkValidBoolean = (e2) => {
          const t2 = ((e3) => "boolean" != typeof e3.value ? { result: false, enMsg: "The parameter is not Boolean", zhMsg: "参数不是布尔类型" } : { result: true })(e2);
          if (!t2.result) {
            let i2 = c.IS_ZH ? `checkValidBoolean: 参数错误: ${e2.tag}:${t2.zhMsg}` : `checkValidBoolean: invalid parameter: ${e2.tag}:${t2.enMsg}`;
            throw new d.default({ code: n.default.INVALID_PARAMETER_ERROR, message: i2 });
          }
        };
        t.checkValidString = (e2) => {
          const t2 = ((e3) => "string" != typeof e3.value ? { result: false, zhMsg: "参数不是字符串", enMsg: "The parameter is not String" } : "number" == typeof e3.min && e3.value.length < e3.min ? { result: false, zhMsg: "参数长度最小值" + e3.min, enMsg: "The parameter is less than the minimum value " + e3.min } : "number" == typeof e3.max && e3.value.length > e3.max ? { result: false, zhMsg: "参数长度大于最大值" + e3.max, enMsg: "The parameter is greater than the maximum value " + e3.max } : { result: true })(e2);
          if (!t2.result) {
            let i2 = c.IS_ZH ? `checkValidString: 参数错误: ${e2.tag}:${t2.zhMsg}` : `checkValidString: invalid parameter: ${e2.tag}:${t2.enMsg}`;
            throw new d.default({ code: n.default.INVALID_PARAMETER_ERROR, message: i2 });
          }
        };
        t.checkValidEnum = (e2) => {
          const t2 = ((e3) => -1 === e3.enums.indexOf(e3.value) ? { result: false, zhMsg: `参数不符合枚举类型：${e3.value}。有效的类型包括：${e3.enums.join()}`, enMsg: `The param is not enum：${e3.value}。Valid enums are：${e3.enums.join()}` } : { result: true })(e2);
          if (!t2.result) {
            let i2 = c.IS_ZH ? `checkValidEnum: 参数错误: ${e2.tag}:${t2.zhMsg}` : `checkValidEnum: invalid parameter: ${e2.tag}:${t2.enMsg}`;
            throw new d.default({ code: n.default.INVALID_PARAMETER_ERROR, message: i2 });
          }
        };
        t.checkValidObject = (e2) => {
          const t2 = ((e3) => "object" != typeof e3.value ? { result: false, zhMsg: "参数不是对象", enMsg: "The parameter is not Object" } : { result: true })(e2);
          if (!t2.result) {
            let i2 = c.IS_ZH ? `checkValidObject: 参数错误: ${e2.tag}:${t2.zhMsg}` : `checkValidObject: invalid parameter: ${e2.tag}:${t2.enMsg}`;
            throw new d.default({ code: n.default.INVALID_PARAMETER_ERROR, message: i2 });
          }
        };
        t.checkValidFloat = (e2) => {
          const t2 = ((e3) => Number.isFinite(e3.value) ? "number" == typeof e3.min && e3.value < e3.min ? { result: false, zhMsg: "参数小于最小值" + e3.min, enMsg: "The parameter is less than the minimum value " + e3.min } : "number" == typeof e3.max && e3.value > e3.max ? { result: false, zhMsg: "参数大于最大值" + e3.max, enMsg: "The parameter is greater than the maximum value " + e3.max } : { result: true } : { result: false, zhMsg: "参数不是float类型", enMsg: "The parameter is not float" })(e2);
          if (!t2.result) {
            let i2 = c.IS_ZH ? `checkValidFloat: 参数错误: ${e2.tag}:${t2.zhMsg}` : `checkValidFloat: invalid parameter: ${e2.tag}:${t2.enMsg}`;
            throw new d.default({ code: n.default.INVALID_PARAMETER_ERROR, message: i2 });
          }
        };
        const u = (e2) => void 0 === e2.value || null === e2.value ? { result: false, zhMsg: "未填必选参数", enMsg: "Missing required parameters" } : { result: true };
        t.isExistOptions = u;
        t.checkExists = (e2) => {
          const t2 = u(e2);
          if (!t2.result) {
            let i2 = c.IS_ZH ? `checkExists: 参数错误: ${e2.tag}:${t2.zhMsg}` : `checkExists: invalid parameter: ${e2.tag}:${t2.enMsg}`;
            throw new d.default({ code: n.default.INVALID_PARAMETER_ERROR, message: i2 });
          }
        };
        t.isNumber = (e2) => !isNaN(parseFloat(e2)) && "number" == typeof e2;
      }, function(e, t, i) {
        var r = i(223), s = i(224);
        t.write = s, t.parse = r.parse, t.parseParams = r.parseParams, t.parseFmtpConfig = r.parseFmtpConfig, t.parsePayloads = r.parsePayloads, t.parseRemoteCandidates = r.parseRemoteCandidates, t.parseImageAttributes = r.parseImageAttributes, t.parseSimulcastStreamList = r.parseSimulcastStreamList;
      }, function(e, t) {
      }, function(e, t, i) {
        "use strict";
        var r = i(97)(true);
        i(53)(String, "String", function(e2) {
          this._t = String(e2), this._i = 0;
        }, function() {
          var e2, t2 = this._t, i2 = this._i;
          return i2 >= t2.length ? { value: void 0, done: true } : (e2 = r(t2, i2), this._i += e2.length, { value: e2, done: false });
        });
      }, function(e, t, i) {
        "use strict";
        var r = i(15), s = i(16), a = i(55), o = i(9), n = i(17), d = i(98), c = i(25), l = i(103), u = i(2)("iterator"), h = !([].keys && "next" in [].keys()), p = function() {
          return this;
        };
        e.exports = function(e2, t2, i2, m, g, f, v) {
          d(i2, t2, m);
          var S, y, _, R = function(e3) {
            if (!h && e3 in A) return A[e3];
            switch (e3) {
              case "keys":
              case "values":
                return function() {
                  return new i2(this, e3);
                };
            }
            return function() {
              return new i2(this, e3);
            };
          }, b = t2 + " Iterator", T = "values" == g, E = false, A = e2.prototype, I = A[u] || A["@@iterator"] || g && A[g], w = I || R(g), C = g ? T ? R("entries") : w : void 0, O = "Array" == t2 && A.entries || I;
          if (O && (_ = l(O.call(new e2()))) !== Object.prototype && _.next && (c(_, b, true), r || "function" == typeof _[u] || o(_, u, p)), T && I && "values" !== I.name && (E = true, w = function() {
            return I.call(this);
          }), r && !v || !h && !E && A[u] || o(A, u, w), n[t2] = w, n[b] = p, g) if (S = { values: T ? w : R("values"), keys: f ? w : R("keys"), entries: C }, v) for (y in S) y in A || a(A, y, S[y]);
          else s(s.P + s.F * (h || E), t2, S);
          return S;
        };
      }, function(e, t, i) {
        e.exports = !i(12) && !i(22)(function() {
          return 7 != Object.defineProperty(i(32)("div"), "a", { get: function() {
            return 7;
          } }).a;
        });
      }, function(e, t, i) {
        e.exports = i(9);
      }, function(e, t, i) {
        var r = i(5), s = i(99), a = i(37), o = i(35)("IE_PROTO"), n = function() {
        }, d = function() {
          var e2, t2 = i(32)("iframe"), r2 = a.length;
          for (t2.style.display = "none", i(59).appendChild(t2), t2.src = "javascript:", (e2 = t2.contentWindow.document).open(), e2.write("<script>document.F=Object<\/script>"), e2.close(), d = e2.F; r2--; ) delete d.prototype[a[r2]];
          return d();
        };
        e.exports = Object.create || function(e2, t2) {
          var i2;
          return null !== e2 ? (n.prototype = r(e2), i2 = new n(), n.prototype = null, i2[o] = e2) : i2 = d(), void 0 === t2 ? i2 : s(i2, t2);
        };
      }, function(e, t, i) {
        var r = i(13), s = i(14), a = i(101)(false), o = i(35)("IE_PROTO");
        e.exports = function(e2, t2) {
          var i2, n = s(e2), d = 0, c = [];
          for (i2 in n) i2 != o && r(n, i2) && c.push(i2);
          for (; t2.length > d; ) r(n, i2 = t2[d++]) && (~a(c, i2) || c.push(i2));
          return c;
        };
      }, function(e, t, i) {
        var r = i(30), s = Math.min;
        e.exports = function(e2) {
          return e2 > 0 ? s(r(e2), 9007199254740991) : 0;
        };
      }, function(e, t, i) {
        var r = i(0).document;
        e.exports = r && r.documentElement;
      }, function(e, t, i) {
        var r = i(31);
        e.exports = function(e2) {
          return Object(r(e2));
        };
      }, function(e, t, i) {
        i(104);
        for (var r = i(0), s = i(9), a = i(17), o = i(2)("toStringTag"), n = "CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","), d = 0; d < n.length; d++) {
          var c = n[d], l = r[c], u = l && l.prototype;
          u && !u[o] && s(u, o, c), a[c] = a.Array;
        }
      }, function(e, t, i) {
        var r = i(18), s = i(2)("toStringTag"), a = "Arguments" == r(/* @__PURE__ */ function() {
          return arguments;
        }());
        e.exports = function(e2) {
          var t2, i2, o;
          return void 0 === e2 ? "Undefined" : null === e2 ? "Null" : "string" == typeof (i2 = function(e3, t3) {
            try {
              return e3[t3];
            } catch (e4) {
            }
          }(t2 = Object(e2), s)) ? i2 : a ? r(t2) : "Object" == (o = r(t2)) && "function" == typeof t2.callee ? "Arguments" : o;
        };
      }, function(e, t, i) {
        var r = i(5), s = i(21), a = i(2)("species");
        e.exports = function(e2, t2) {
          var i2, o = r(e2).constructor;
          return void 0 === o || null == (i2 = r(o)[a]) ? t2 : s(i2);
        };
      }, function(e, t, i) {
        var r, s, a, o = i(20), n = i(113), d = i(59), c = i(32), l = i(0), u = l.process, h = l.setImmediate, p = l.clearImmediate, m = l.MessageChannel, g = l.Dispatch, f = 0, v = {}, S = function() {
          var e2 = +this;
          if (v.hasOwnProperty(e2)) {
            var t2 = v[e2];
            delete v[e2], t2();
          }
        }, y = function(e2) {
          S.call(e2.data);
        };
        h && p || (h = function(e2) {
          for (var t2 = [], i2 = 1; arguments.length > i2; ) t2.push(arguments[i2++]);
          return v[++f] = function() {
            n("function" == typeof e2 ? e2 : Function(e2), t2);
          }, r(f), f;
        }, p = function(e2) {
          delete v[e2];
        }, "process" == i(18)(u) ? r = function(e2) {
          u.nextTick(o(S, e2, 1));
        } : g && g.now ? r = function(e2) {
          g.now(o(S, e2, 1));
        } : m ? (a = (s = new m()).port2, s.port1.onmessage = y, r = o(a.postMessage, a, 1)) : l.addEventListener && "function" == typeof postMessage && !l.importScripts ? (r = function(e2) {
          l.postMessage(e2 + "", "*");
        }, l.addEventListener("message", y, false)) : r = "onreadystatechange" in c("script") ? function(e2) {
          d.appendChild(c("script")).onreadystatechange = function() {
            d.removeChild(this), S.call(e2);
          };
        } : function(e2) {
          setTimeout(o(S, e2, 1), 0);
        }), e.exports = { set: h, clear: p };
      }, function(e, t) {
        e.exports = function(e2) {
          try {
            return { e: false, v: e2() };
          } catch (e3) {
            return { e: true, v: e3 };
          }
        };
      }, function(e, t, i) {
        var r = i(5), s = i(11), a = i(38);
        e.exports = function(e2, t2) {
          if (r(e2), s(t2) && t2.constructor === e2) return t2;
          var i2 = a.f(e2);
          return (0, i2.resolve)(t2), i2.promise;
        };
      }, function(e, t) {
        t.f = Object.getOwnPropertySymbols;
      }, function(e, t, i) {
        var r = i(57), s = i(37).concat("length", "prototype");
        t.f = Object.getOwnPropertyNames || function(e2) {
          return r(e2, s);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.MEDIA_READYSTATE_REV = t.MEDIA_READYSTATE = t.STREAM_TYPE_REV = t.STREAM_TYPE = t.NERTC_VIDEO_QUALITY_REV = t.NERTC_VIDEO_QUALITY = t.NERTC_VIDEO_QUALITY_ENUM = t.NERTC_RECORD_VIDEO_FRAME_RATE = t.NERTC_RECORD_VIDEO_QUALITY = t.VIDEO_FRAME_RATE = t.VIDEO_FRAME_RATE_ENUM = void 0, function(e2) {
          e2[e2.CHAT_VIDEO_FRAME_RATE_NORMAL = 0] = "CHAT_VIDEO_FRAME_RATE_NORMAL", e2[e2.CHAT_VIDEO_FRAME_RATE_5 = 1] = "CHAT_VIDEO_FRAME_RATE_5", e2[e2.CHAT_VIDEO_FRAME_RATE_10 = 2] = "CHAT_VIDEO_FRAME_RATE_10", e2[e2.CHAT_VIDEO_FRAME_RATE_15 = 3] = "CHAT_VIDEO_FRAME_RATE_15", e2[e2.CHAT_VIDEO_FRAME_RATE_20 = 4] = "CHAT_VIDEO_FRAME_RATE_20", e2[e2.CHAT_VIDEO_FRAME_RATE_25 = 5] = "CHAT_VIDEO_FRAME_RATE_25", e2[e2.CHAT_VIDEO_FRAME_RATE_30 = 6] = "CHAT_VIDEO_FRAME_RATE_30";
        }(t.VIDEO_FRAME_RATE_ENUM || (t.VIDEO_FRAME_RATE_ENUM = {})), t.VIDEO_FRAME_RATE = { CHAT_VIDEO_FRAME_RATE_NORMAL: 0, CHAT_VIDEO_FRAME_RATE_5: 1, CHAT_VIDEO_FRAME_RATE_10: 2, CHAT_VIDEO_FRAME_RATE_15: 3, CHAT_VIDEO_FRAME_RATE_20: 4, CHAT_VIDEO_FRAME_RATE_25: 5, CHAT_VIDEO_FRAME_RATE_30: 6 }, t.NERTC_RECORD_VIDEO_QUALITY = { RECORD_VIDEO_QUALITY_360p: 360, RECORD_VIDEO_QUALITY_480p: 480, RECORD_VIDEO_QUALITY_720p: 720 }, t.NERTC_RECORD_VIDEO_FRAME_RATE = { RECORD_VIDEO_FRAME_RATE_15: 15, RECORD_VIDEO_FRAME_RATE_30: 30 }, function(e2) {
          e2[e2.VIDEO_QUALITY_180p = 2] = "VIDEO_QUALITY_180p", e2[e2.VIDEO_QUALITY_480p = 4] = "VIDEO_QUALITY_480p", e2[e2.VIDEO_QUALITY_720p = 8] = "VIDEO_QUALITY_720p", e2[e2.VIDEO_QUALITY_1080p = 16] = "VIDEO_QUALITY_1080p";
        }(t.NERTC_VIDEO_QUALITY_ENUM || (t.NERTC_VIDEO_QUALITY_ENUM = {})), t.NERTC_VIDEO_QUALITY = { VIDEO_QUALITY_180p: 2, VIDEO_QUALITY_480p: 4, VIDEO_QUALITY_720p: 8, VIDEO_QUALITY_1080p: 16 }, t.NERTC_VIDEO_QUALITY_REV = { [t.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_180p]: "320x180", [t.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_480p]: "640x480", [t.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_720p]: "1280x720", [t.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_1080p]: "1920x1080" }, t.STREAM_TYPE = { HIGH: 0, LOW: 1 }, t.STREAM_TYPE_REV = { 0: "HIGH", 1: "LOW" }, t.MEDIA_READYSTATE = { HAVE_NOTHING: 0, HAVE_METADATA: 1, HAVE_CURRENT_DATA: 2, HAVE_FUTURE_DATA: 3, HAVE_ENOUGH_DATA: 4 }, t.MEDIA_READYSTATE_REV = { 0: "HAVE_NOTHING", 1: "HAVE_METADATA", 2: "HAVE_CURRENT_DATA", 3: "HAVE_FUTURE_DATA", 4: "HAVE_ENOUGH_DATA" };
      }, function(e, t) {
        var i;
        i = /* @__PURE__ */ function() {
          return this;
        }();
        try {
          i = i || new Function("return this")();
        } catch (e2) {
          "object" == typeof window && (i = window);
        }
        e.exports = i;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getStream = t.getScreenStream = t.emptyStreamWith = t.printVideoState = t.printForLongPromise = t.watchTrack = t.checkScreenTrackSurface = void 0;
        const r = i(175), s = i(144), a = i(76), o = i(1), n = i(47), d = i(251), c = i(252), l = i(28), u = i(69), h = i(176), p = i(7), m = new l.Logger({ tagGen: () => "GUM" });
        let g = 0, f = "getSettings" in MediaStreamTrack.prototype;
        function v(e2) {
          const t2 = o.getParameters().forceDisplaySurface;
          if ("default" === t2) return true;
          const i2 = function(e3) {
            if (void 0 !== e3.getSettings().displaySurface) return e3.getSettings().displaySurface;
            return p.IS_FIREFOX ? "" === e3.label || e3.label.indexOf("Primary Monitor") > -1 ? "monitor" : (m.log("getDisplaySurfaceType: ", e3.label), "unknown") : p.IS_SAFARI ? "unknown" : e3.label.indexOf("web-contents") > -1 ? "browser" : e3.label.indexOf("window") > -1 ? "window" : e3.label.indexOf("screen") > -1 ? "monitor" : (m.log("getDisplaySurfaceType: ", e3.label), "unknown");
          }(e2);
          return "unknown" == i2 ? (m.warn("checkScreenTrackSurface: unknown ", e2.label), a.Device.emit("unknown-display-surface", e2.label), true) : (m.log("checkScreenTrackSurface: ", i2), t2 === i2);
        }
        t.getStream = async function(e2, t2) {
          if (e2.audio && "object" == typeof e2.audio) {
            if (!e2.audio.deviceId) {
              const i3 = a.Device.deviceHistory.audioIn.find((e3) => "default" === e3.deviceId);
              i3 && (t2.log("getStream：音频使用默认设备" + i3.label), e2.audio.deviceId = { exact: i3.deviceId });
            }
            s.compatAudioInputList.enabled && (t2.log("兼容模式：constraint强制将channelCount设为2，echoCancellation设为false"), e2.audio.channelCount = 2, e2.audio.echoCancellation = false);
          }
          const i2 = ++g;
          t2.log("getLocalStream constraint: #" + i2, JSON.stringify(e2));
          try {
            const a2 = navigator.mediaDevices.getUserMedia(e2);
            b(a2, "仍在等待 getUserMedia 返回 #" + i2);
            const l2 = await a2;
            t2.log("获取到媒体流: #" + i2, l2.id);
            const u2 = l2.getTracks();
            for (let e3 = 0; e3 < u2.length; e3++) {
              const i3 = u2[e3];
              if (R(i3), "video" === i3.kind) {
                if (d.canShimCanvas()) {
                  t2.warn("使用canvas track取代videoTrack", i3.label);
                  const e4 = d.shimCanvas(i3);
                  R(e4), l2.removeTrack(i3), l2.addTrack(e4);
                }
              } else if ("audio" === i3.kind && s.compatAudioInputList.enabled) {
                let e4;
                e4 = f ? i3.getSettings ? i3.getSettings() : {} : i3.getConstraints ? i3.getConstraints() : {}, e4.channelCount && e4.channelCount >= 2 ? t2.log("该设备支持兼容模式：" + i3.label, e4) : t2.warn("该设备为单声道设备，强行开启兼容模式(右声道无声)：" + i3.label, e4);
                const a3 = n.getAudioContext();
                if (a3) {
                  const e5 = a3.createChannelSplitter(2), n2 = a3.createMediaStreamDestination(), d2 = new MediaStream([i3]), u3 = a3.createMediaStreamSource(d2), h2 = new r.AudioLevel({ stream: d2, logger: t2, sourceNode: u3 });
                  let p2 = 0;
                  "left" === o.getParameters().audioInputcompatMode ? (t2.log("兼容模式：仅使用左声道"), p2 = 0) : "right" === o.getParameters().audioInputcompatMode ? (t2.log("兼容模式：仅使用右声道"), p2 = 1) : "auto" === o.getParameters().audioInputcompatMode && (t2.log("兼容模式：在左右声道间根据音量切换"), h2.on("channel-state-change", (r2) => {
                    "leftLoud" === r2.state && 1 === p2 ? (t2.log("兼容模式切换至左声道：", i3.label), e5.disconnect(n2), e5.connect(n2, 0), p2 = 0) : "rightLoud" === r2.state && 0 === p2 && (t2.log("兼容模式切换至右声道：", i3.label), e5.disconnect(n2), e5.connect(n2, 1), p2 = 1);
                  })), u3.connect(e5), e5.connect(n2, p2);
                  const m2 = n2.stream.getTracks()[0];
                  R(m2), s.compatAudioInputList.compatTracks.push({ source: i3, dest: m2 }), c.syncTrackState(i3, m2, "bidirectional"), l2.removeTrack(i3), l2.addTrack(m2), t2.log("getStream：启用兼容模式成功");
                }
              }
            }
            return l2;
          } catch (r2) {
            if (t2.error(`getUserMedia error: ${r2.name} [${r2.message}] constraint: ${JSON.stringify(e2)}`), e2.video) {
              a.Device.emit("device-open-fail", e2), e2.video = true, t2.log("使用浏览器默认参数，尝试重新获取视频流", JSON.stringify(e2));
              try {
                const r3 = navigator.mediaDevices.getUserMedia(e2);
                b(r3, "仍在等待 getUserMedia 返回 #" + i2);
                const s2 = await r3;
                t2.log("重新获取视频流成功: #" + i2, s2.id);
                const a2 = s2.getTracks();
                for (let e3 = 0; e3 < a2.length; e3++) {
                  const i3 = a2[e3];
                  if (R(i3), "video" === i3.kind) {
                    if (d.canShimCanvas()) {
                      t2.warn("使用canvas track取代videoTrack", i3.label);
                      const e4 = d.shimCanvas(i3);
                      R(e4), s2.removeTrack(i3), s2.addTrack(e4);
                    }
                  } else i3.kind;
                }
                return s2;
              } catch (e3) {
                return t2.error(`重新获取视频流失败, ${e3.name} [${e3.message}]`), Promise.reject(e3);
              }
            }
            return Promise.reject(r2);
          }
        }, t.getScreenStream = async function(e2, t2) {
          var i2;
          const r2 = ++g;
          let s2;
          h.patchScreenConstraints(e2, t2), t2.log("getScreenStream constraint: #" + r2, JSON.stringify(e2, null, " ")), navigator.getDisplayMedia || navigator.mediaDevices.getDisplayMedia;
          try {
            const t3 = navigator.mediaDevices.getDisplayMedia(e2);
            b(t3, "仍在等待 getDisplayMedia 返回 #" + r2), s2 = await t3;
          } catch (o3) {
            if (!((null === (i2 = null == o3 ? void 0 : o3.message) || void 0 === i2 ? void 0 : i2.indexOf("user gesture")) > -1 && a.Device.onUserGestureNeeded)) throw t2.error("屏幕共享获取失败: #" + r2, o3.name, o3.message), o3;
            t2.warn("荧幕共享获取中断，需要手势触发。", r2), a.Device.onUserGestureNeeded(o3);
            try {
              s2 = await new Promise((t3, i3) => {
                a.Device.once("user-gesture-fired", () => {
                  navigator.mediaDevices.getDisplayMedia(e2).then(t3).catch(i3);
                });
              });
            } catch (e3) {
              throw t2.error("第二次屏幕共享获取失败: #" + r2, e3.name, e3.message), e3;
            }
          }
          let o2 = s2.getVideoTracks()[0];
          if (o2) {
            if (!v(o2)) throw t2.error("屏幕共享流和forceDisplaySurface参数设置不同"), s2.getTracks().forEach((e3) => {
              e3.stop();
            }), { name: "DisplaySurfaceError", message: "displaySurface not match" };
          }
          return ((e3) => {
            t2.log("获取到屏幕共享流: #" + r2, e3.id);
            e3.getTracks().forEach((e4) => {
              R(e4);
            }), Promise.resolve(e3);
          })(s2), s2;
        }, t.checkScreenTrackSurface = v;
        let S = Date.now();
        let y = 0;
        const _ = () => {
          const e2 = o.getParameters().tracks.video, t2 = o.getParameters().tracks.audio, i2 = Date.now();
          if (i2 - S > 5e3 && y < o.getParameters().maxEventLoopLagWarning) {
            let e3 = `侦测到主线程事件循环从卡死中恢复。卡顿时间：${i2 - S - 1e3}毫秒。`;
            e3 += "这可能是由于页面切往后台、设备休眠、频繁的dom操作、阻塞性代码引起的。", e3 += `当前页面页面是否隐藏：${document.hidden}，可见性：${document.visibilityState}，网络状态：${navigator.onLine}。`, y += 1, y === o.getParameters().maxEventLoopLagWarning && (e3 += "今后不再提示。"), m.warn(e3);
          }
          S = i2;
          const r2 = (e3, t3) => {
            if (!e3) return;
            let r3 = "";
            if (r3 = e3.canvas ? `CANVASTRACK#${t3}${e3.canvas.width}x${e3.canvas.height}` : `${e3.kind.toUpperCase()}TRACK#${t3}【${e3.label}】`, !e3.endedAt) if ("ended" === e3.readyState) {
              m.log(r3 + ": 已停止"), e3.endedAt = i2;
              const t4 = new CustomEvent("neTrackEnded");
              e3.dispatchEvent(t4);
            } else !e3.canvas && e3.muted && e3.enabled ? (e3.mutedStartAt = e3.mutedStartAt || i2, e3.mutedCnt = e3.mutedCnt || 0, e3.mutedCnt++, 11 !== e3.mutedCnt && 31 !== e3.mutedCnt || (m.warn(`${r3}： 处于无数据状态，请检查设备是否正常:${i2 - e3.mutedStartAt}ms（系统可能休眠了，或者浏览器进程被阻塞）`), function(e4) {
              const t4 = [...o.getParameters().tracks.video, ...o.getParameters().tracks.audio];
              for (let i3 = 0; i3 < t4.length; i3++) {
                const r4 = t4[i3];
                if (r4 && r4.label === e4.label && r4 !== e4 && "ended" !== r4.readyState) return true;
              }
              return false;
            }(e3) && m.warn(r3 + " ：该设备打开了多次"))) : e3.mutedStartAt && (e3.mutedCnt && e3.mutedCnt > 11 && m.warn(`${r3}：数据恢复正常 :${i2 - e3.mutedStartAt}ms`), delete e3.mutedStartAt, delete e3.mutedCnt);
          };
          e2.forEach(r2), t2.forEach(r2);
        };
        function R(e2) {
          if (e2) if ("ended" === e2.readyState && m.error("注意：输入的track已经停止：", e2), "audio" === e2.kind) {
            const t2 = o.getParameters().tracks.audio;
            let i2 = f ? e2.getSettings() : e2.getConstraints();
            m.log("获取到的设备类型: AUDIOTRACK#" + t2.length, e2.kind, e2.label, e2.id, JSON.stringify(i2));
            const r2 = t2.findIndex((t3) => e2 === t3);
            r2 > -1 ? (m.warn(`注意：AUDIOTRACK#${t2.length} 与 AUDIOTRACK#${r2} 相同`), t2.push(null)) : (e2.addEventListener("ended", _), t2.push(e2));
          } else {
            const t2 = o.getParameters().tracks.video;
            let i2 = f ? e2.getSettings() : e2.getConstraints();
            m.log("获取到的设备类型: VIDEOTRACK#" + t2.length, e2.kind, e2.label, e2.id, JSON.stringify(i2));
            const r2 = t2.findIndex((t3) => e2 === t3);
            r2 > -1 ? (m.warn(`注意：VIDEOTRACK#${t2.length} 与 VIDEOTRACK#${r2} 相同`), t2.push(null)) : (e2.addEventListener("ended", _), t2.push(e2));
          }
        }
        async function b(e2, t2) {
          let i2 = 0;
          const r2 = Date.now();
          let s2 = setInterval(() => {
            i2++, l.getDefaultLogger().warn(`${t2} ${Date.now() - r2}ms`), s2 && i2 > 10 && (clearInterval(s2), s2 = null);
          }, 6e3);
          e2.then(() => {
            s2 && (clearInterval(s2), s2 = null);
          }).catch((e3) => {
            s2 && (clearInterval(s2), s2 = null);
          });
        }
        setInterval(_, 1e3), t.watchTrack = R, t.printForLongPromise = b, t.printVideoState = async function(e2, t2, i2, r2) {
          let s2 = 0;
          const a2 = Date.now(), o2 = [1, 5, 10];
          let n2 = setInterval(() => {
            if (s2++, -1 === o2.indexOf(s2)) return;
            let e3 = `播放 ${i2} 的 ${r2}, HTMLMediaElement ReadyState:${u.MEDIA_READYSTATE_REV[t2.readyState]}(${t2.readyState})Paused: ${t2.paused}.Time: ${Date.now() - a2}ms.`;
            const d2 = t2.srcObject, c2 = null == d2 ? void 0 : d2.getTracks()[0];
            c2 ? (e3 += `, 媒体Track enabled: ${c2.enabled} muted:${c2.muted} name:[${c2.label}]`, c2.enabled ? c2.muted ? l.getDefaultLogger().warn("媒体处于mute状态，无数据或者解码失败：" + e3) : l.getDefaultLogger().warn("媒体标签仍在启动播放中：" + e3) : (l.getDefaultLogger().warn("媒体被disable：" + e3), n2 && (clearInterval(n2), n2 = null))) : (l.getDefaultLogger().warn("媒体标签srcObject属性处于异常状态：" + e3), n2 && (clearInterval(n2), n2 = null)), n2 && s2 > o2[o2.length - 1] && (clearInterval(n2), n2 = null);
          }, 6e3);
          e2.then(() => {
            n2 && (clearInterval(n2), n2 = null);
          }).catch((e3) => {
            n2 && (clearInterval(n2), n2 = null);
          });
        }, t.emptyStreamWith = function(e2, t2) {
          let i2 = false;
          e2.getTracks().forEach((r2) => {
            r2 !== t2 ? (e2.removeTrack(r2), e2.onremovetrack && e2.onremovetrack({ track: r2 })) : i2 = true;
          }), !i2 && t2 && (e2.addTrack(t2), e2.onaddtrack && e2.onaddtrack({ track: t2 }));
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.NeAudioNode = t.NeAudioNodeNullable = void 0;
        const r = i(46);
        let s = 0;
        class a extends r.RTCEventEmitter {
          constructor(e2, t2) {
            super(), this.id = s++, this.connectedTo = [], this.connectedFrom = [], this.tag = e2, this.audioNode = t2;
          }
          connect(e2) {
            this.audioNode && e2.audioNode && this.audioNode.connect(e2.audioNode), -1 === this.connectedTo.indexOf(e2) && this.connectedTo.push(e2), -1 === e2.connectedFrom.indexOf(this) && e2.connectedFrom.push(this);
          }
          disconnect(e2) {
            this.audioNode && e2.audioNode && this.audioNode.disconnect(e2.audioNode), -1 !== this.connectedTo.indexOf(e2) && this.connectedTo.splice(this.connectedTo.indexOf(e2), 1), -1 === e2.connectedFrom.indexOf(this) && e2.connectedFrom.splice(e2.connectedFrom.indexOf(this), 1);
          }
          isConnectedTo(e2) {
            return this.connectedTo.indexOf(e2) > -1;
          }
          isConnectedFrom(e2) {
            return this.connectedFrom.indexOf(e2) > -1;
          }
          disconnectFromAll() {
            this.connectedFrom.forEach((e2) => {
              e2.audioNode && this.audioNode && e2.audioNode.disconnect(this.audioNode);
              const t2 = e2.connectedTo.indexOf(this);
              t2 > -1 && e2.connectedTo.splice(t2, 1);
            }), this.connectedFrom.length = 0;
          }
          disconnectToAll() {
            this.connectedTo.forEach((e2) => {
              e2.audioNode && this.audioNode && this.audioNode.disconnect(e2.audioNode);
              const t2 = e2.connectedFrom.indexOf(this);
              t2 > -1 && e2.connectedFrom.splice(t2, 1);
            }), this.connectedTo.length = 0;
          }
          updateNode(e2) {
            this.connectedTo.forEach((t2) => {
              t2.audioNode && (this.audioNode && this.audioNode.disconnect(t2.audioNode), e2.connect(t2.audioNode));
            }), this.connectedFrom.forEach((t2) => {
              t2.audioNode && (this.audioNode && t2.audioNode.disconnect(this.audioNode), t2.audioNode.connect(e2));
            }), this.audioNode = e2;
          }
        }
        t.NeAudioNodeNullable = a;
        t.NeAudioNode = class extends a {
          constructor(e2, t2) {
            super(e2, t2), this.tag = e2, this.audioNode = t2;
          }
        };
      }, function(e, t, i) {
        e.exports = i(93);
      }, function(e, t, i) {
        "use strict";
        t.__esModule = true;
        var r, s = i(95), a = (r = s) && r.__esModule ? r : { default: r };
        t.default = function(e2) {
          return function() {
            var t2 = e2.apply(this, arguments);
            return new a.default(function(e3, i2) {
              return function r2(s2, o) {
                try {
                  var n = t2[s2](o), d = n.value;
                } catch (e4) {
                  return void i2(e4);
                }
                if (!n.done) return a.default.resolve(d).then(function(e4) {
                  r2("next", e4);
                }, function(e4) {
                  r2("throw", e4);
                });
                e3(d);
              }("next");
            });
          };
        };
      }, function(e, t, i) {
        "use strict";
        function r(e2) {
          return e2 > 0 && 0 == (e2 & e2 - 1);
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.loadImageBatch = t.retryLoadImage = t.loadImage = t.createTexture = t.imgDataSize = t.toNthPower = t.isNthPower = void 0, t.isNthPower = r, t.toNthPower = function(e2) {
          if (r(e2)) return e2;
          const t2 = [4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1];
          let i2 = 1 / 0;
          for (let r2 = 0; r2 < t2.length; r2++) {
            const s2 = t2[r2], a2 = Math.abs(e2 - s2);
            if (e2 >= s2) return a2 > i2 ? t2[r2 - 1] : s2;
            i2 = a2;
          }
          return 1;
        }, t.imgDataSize = function(e2, t2, i2) {
          if (i2 = null != i2 ? i2 : Math.min(t2)) {
            const i3 = Math.max(e2, t2);
            if (i3 > 512) {
              const r2 = i3 / 512;
              return { width: e2 / r2 >> 0, height: t2 / r2 >> 0 };
            }
          }
          return { width: e2, height: t2 };
        }, t.createTexture = function e2(t2, i2, r2) {
          const s2 = t2.createTexture();
          if (!s2) return console.error(`texture:[${i2}] created error.`), null;
          const a2 = Object.assign({ flipY: true, wrapS: "clamp", wrapT: "clamp", genMipMaps: false }, r2), o2 = { clamp: t2.CLAMP_TO_EDGE, repeat: t2.REPEAT, mirror: t2.MIRRORED_REPEAT }, n = { glTexture: s2, source: i2, refresh() {
            const { source: e3, glTexture: i3, opts: r3 } = n, { genMipMaps: s3 } = r3, a3 = t2.TEXTURE_2D;
            t2.bindTexture(a3, i3);
            const { flipY: d } = r3;
            d ? t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, true) : t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, false), t2.texParameteri(a3, t2.TEXTURE_WRAP_S, o2[r3.wrapS]), t2.texParameteri(a3, t2.TEXTURE_WRAP_T, o2[r3.wrapT]), t2.texParameteri(a3, t2.TEXTURE_MIN_FILTER, s3 ? t2.LINEAR_MIPMAP_LINEAR : t2.LINEAR), t2.texParameteri(a3, t2.TEXTURE_MAG_FILTER, t2.LINEAR), "width" in r3 && "height" in r3 ? t2.texImage2D(a3, 0, t2.RGBA, r3.width, r3.height, 0, t2.RGBA, t2.UNSIGNED_BYTE, e3) : null !== e3 && t2.texImage2D(a3, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, e3), s3 && t2.generateMipmap(a3);
          }, updateMipMap() {
            const { glTexture: e3, opts: i3 } = n, { genMipMaps: r3 } = i3;
            if (!r3) return;
            const s3 = t2.TEXTURE_2D;
            t2.bindTexture(s3, e3), t2.generateMipmap(s3);
          }, clone: () => e2(t2, n.source, n.opts), opts: a2 };
          return n.refresh(), n;
        };
        const s = {};
        function a(e2, t2, i2) {
          "string" == typeof e2 && e2 && (s[e2] ? null == t2 || t2(s[e2]) : fetch(e2 + "?rdn=" + Date.now()).then((e3) => e3.arrayBuffer()).then((r2) => {
            let a2 = false;
            const o2 = new Blob([r2], { type: "image/*" }), n = new Image();
            new URL(e2, window.location.href).origin !== window.location.origin && (n.crossOrigin = "anonymous"), n.onload = () => {
              a2 || (a2 = true, s[e2] = n, null == t2 || t2(n));
            }, n.onerror = (e3) => {
              null == i2 || i2(e3);
            }, n.src = URL.createObjectURL(o2), setTimeout(() => {
              !a2 && n.complete && n.naturalHeight > 0 && (a2 = true, s[e2] = n, null == t2 || t2(n));
            }, 0);
          }).catch((e3) => {
            null == i2 || i2(e3);
          }));
        }
        function o(e2, t2 = 3, i2, r2) {
          let s2 = null;
          const o2 = (n = 0) => {
            (n += 1) <= t2 ? a(e2, (e3) => {
              null == i2 || i2(e3);
            }, (e3) => {
              s2 = e3, o2(n);
            }) : null == r2 || r2(s2);
          };
          o2();
        }
        t.loadImage = a, t.retryLoadImage = o, t.loadImageBatch = function(e2, t2 = 3, i2) {
          let r2 = {}, s2 = [];
          const a2 = () => {
            Object.keys(r2).length + s2.length === e2.length && (null == i2 || i2(r2, s2));
          };
          e2.forEach((e3) => {
            o(e3, t2, (t3) => {
              r2[e3] = t3, a2();
            }, () => {
              s2.push(e3), a2();
            });
          });
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Device = t.alerter = void 0;
        const s = r(i(6)), a = r(i(8)), o = i(46), n = i(28), d = i(142);
        Object.defineProperty(t, "alerter", { enumerable: true, get: function() {
          return d.alerter;
        } });
        const c = i(144), l = i(1);
        class u extends o.RTCEventEmitter {
          constructor() {
            super(), this.deviceChangeDetectionTimer = null, this.deviceInited = false, this.hasPerm = { audioIn: false, video: false, audioOut: false }, this.deviceHistory = { audioIn: [], video: [], audioOut: [] }, this.compatAudioInputList = c.compatAudioInputList, this.__v_skip = l.getParameters().enableVSkip, this.onUserGestureNeeded = null, this.logger = new n.Logger({ tagGen: () => `Device m${this.deviceHistory.audioIn.length}c${this.deviceHistory.video.length}s${this.deviceHistory.audioOut.length}` }), this.handleDeviceChange = this.detectDeviceChange.bind(this), this.onUserGestureNeeded = this.defaultHandleUserGestureNeeded.bind(this), d.alerter.addListener("@user-gesture-fired", () => {
              this.safeEmit("user-gesture-fired");
            });
          }
          async getDevices(e2) {
            if (!navigator.mediaDevices) throw this.logger.error("navigator.mediaDevices is " + navigator.mediaDevices), new a.default({ code: s.default.NOT_SUPPORT_ERROR, message: "getDevices: 当前浏览器不支持 mediaDevices", url: "https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices" });
            if (!navigator.mediaDevices.enumerateDevices) throw this.logger.error("navigator.mediaDevices is " + navigator.mediaDevices.enumerateDevices), new a.default({ code: s.default.NOT_SUPPORT_ERROR, message: "getDevices: 当前浏览器不支持 enumerateDevices", url: "https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/enumerateDevices" });
            let t2 = { video: [], audioIn: [], audioOut: [] }, i2 = await navigator.mediaDevices.enumerateDevices(), r2 = null;
            if (e2.requestPerm) {
              const t3 = i2.find((t4) => e2.audioinput && "audioinput" == t4.kind && !t4.label), s2 = i2.find((t4) => e2.videoinput && "videoinput" == t4.kind && !t4.label);
              if (t3 || s2) try {
                r2 = await navigator.mediaDevices.getUserMedia({ audio: t3, video: s2 });
              } catch (e3) {
                this.logger.error(e3.name, e3.message, e3.stack);
              }
            }
            return i2 = await navigator.mediaDevices.enumerateDevices(), i2.forEach(function(i3) {
              if (e2.videoinput && "videoinput" === i3.kind) {
                let r3 = { deviceId: i3.deviceId, label: i3.label || (e2.noFillLabel ? i3.label : "camera " + (t2.video.length + 1)) };
                e2.groupId && (r3.groupId = i3.groupId), t2.video.push(r3);
              } else if (e2.audioinput && "audioinput" === i3.kind) {
                let r3;
                r3 = { deviceId: i3.deviceId, label: i3.label || (e2.noFillLabel ? i3.label : "microphone " + (t2.audioIn.length + 1)) }, e2.groupId && (r3.groupId = i3.groupId), t2.audioIn.push(r3);
              } else if (e2.audiooutput && "audiooutput" === i3.kind) {
                let r3 = { deviceId: i3.deviceId, label: i3.label || (e2.noFillLabel ? i3.label : "speaker " + (t2.audioOut.length + 1)) };
                e2.groupId && (r3.groupId = i3.groupId), t2.audioOut.push(r3);
              }
              r2 && r2.getTracks().forEach((e3) => {
                e3.stop();
              });
            }), t2;
          }
          async getCameras(e2) {
            const t2 = await this.getDevices({ videoinput: true, requestPerm: e2 });
            return t2 ? t2.video : [];
          }
          async getMicrophones(e2) {
            const t2 = await this.getDevices({ audioinput: true, requestPerm: e2 });
            return t2 ? t2.audioIn : [];
          }
          async getSpeakers(e2) {
            const t2 = await this.getDevices({ audioinput: true, audiooutput: true, requestPerm: e2 });
            return t2 ? t2.audioOut : [];
          }
          async detectDeviceChange() {
            let e2 = { audioIn: { added: [], changed: [], removed: [] }, video: { added: [], changed: [], removed: [] }, audioOut: { added: [], changed: [], removed: [] } };
            const t2 = await this.getDevices({ audioinput: true, audiooutput: true, videoinput: true, requestPerm: false, groupId: true, noFillLabel: true });
            ["audioIn", "video", "audioOut"].forEach((i2) => {
              if (this.deviceInited) {
                const r2 = t2[i2].find((e3) => e3.deviceId && e3.label);
                r2 ? this.hasPerm[i2] ? (t2[i2].forEach((t3) => {
                  const r3 = this.deviceHistory[i2].find((e3) => e3.deviceId === t3.deviceId || "" === e3.deviceId && "default" === t3.deviceId);
                  if (r3) {
                    if (r3.label !== t3.label || r3.groupId !== t3.groupId) {
                      let s2 = `检测到设备改变：${i2}: deviceId ${t3.deviceId}`;
                      r3.label !== t3.label ? s2 += `【Label ${r3.label} => ${t3.label}】` : s2 += " Label " + t3.label, r3.groupId !== t3.groupId && (s2 += "【groupId changed】"), this.logger.log(s2), e2[i2].changed.push(t3);
                    }
                  } else this.logger.log(`检测到设备新增：${i2}: deviceId ${t3.deviceId} 【${t3.label}】`), e2[i2].added.push(t3);
                }), this.deviceHistory[i2].forEach((r3) => {
                  t2[i2].find((e3) => r3.deviceId === e3.deviceId || "" === r3.deviceId && "default" === e3.deviceId) || (this.logger.log(`检测到设备拔出：${i2}: deviceId ${r3.deviceId} 【${r3.label}】`), e2[i2].removed.push(r3));
                }), this.deviceHistory[i2] = t2[i2], e2[i2].added.forEach((e3) => {
                  "audioIn" === i2 ? this.emit("recording-device-changed", { device: e3, state: "ACTIVE" }) : "video" === i2 ? this.emit("camera-changed", { device: e3, state: "ACTIVE" }) : "audioOut" === i2 && this.emit("playout-device-changed", { device: e3, state: "ACTIVE" });
                }), e2[i2].changed.forEach((e3) => {
                  "audioIn" === i2 ? this.emit("recording-device-changed", { device: e3, state: "CHANGED" }) : "video" === i2 ? this.emit("camera-changed", { device: e3, state: "CHANGED" }) : "audioOut" === i2 && this.emit("playout-device-changed", { device: e3, state: "CHANGED" });
                }), e2[i2].removed.forEach((e3) => {
                  "audioIn" === i2 ? this.emit("recording-device-changed", { device: e3, state: "INACTIVE" }) : "video" === i2 ? this.emit("camera-changed", { device: e3, state: "INACTIVE" }) : "audioOut" === i2 && this.emit("playout-device-changed", { device: e3, state: "INACTIVE" });
                })) : (this.hasPerm[i2] = true, this.deviceHistory[i2] = t2[i2], "audioIn" === i2 ? (this.logger.log(`麦克风设备：${r2.deviceId}【${r2.label}】`), this.emit("recording-device-init")) : "video" === i2 ? (this.logger.log(`摄像头设备：【${t2[i2].map((e3) => e3.label).join("】【")}】`), this.emit("camera-init")) : "audioOut" === i2 && (this.logger.log(`扬声器设备：${r2.deviceId}【${r2.label}】`), this.emit("playout-device-init"))) : this.deviceHistory[i2] = t2[i2];
              } else this.deviceHistory[i2] = t2[i2];
            }), this.deviceInited || (this.deviceInited = true, t2.audioIn.length || this.logger.error("未侦测到可用麦克风"), t2.video.length || this.logger.error("未侦测到可用摄像头"));
          }
          async startDeviceChangeDetection() {
            navigator.mediaDevices && navigator.mediaDevices.enumerateDevices ? (this.deviceChangeDetectionTimer && clearInterval(this.deviceChangeDetectionTimer), await this.handleDeviceChange(), navigator.mediaDevices.ondevicechange ? navigator.mediaDevices.ondevicechange === this.handleDeviceChange || (l.getParameters().forceListenDeviceChange ? navigator.mediaDevices.ondevicechange = this.handleDeviceChange : this.logger.warn("系统设备枚举回调已被占用，设备枚举实效性将受到影响")) : navigator.mediaDevices.ondevicechange = this.handleDeviceChange, l.getParameters().deviceChangeInterval && (this.deviceChangeDetectionTimer = setInterval(this.handleDeviceChange, 1e3))) : this.logger.warn("当前环境不支持设备枚举");
          }
          stopDeviceChangeDetection() {
            this.logger.log("停止监听浏览器设备变化"), this.deviceChangeDetectionTimer && (clearInterval(this.deviceChangeDetectionTimer), this.deviceChangeDetectionTimer = null), navigator.mediaDevices && navigator.mediaDevices.ondevicechange && (navigator.mediaDevices.ondevicechange = null), this.deviceInited = false, this.deviceHistory.audioIn = [], this.deviceHistory.audioOut = [], this.deviceHistory.video = [], this.hasPerm.audioIn = false, this.hasPerm.video = false, this.hasPerm.audioOut = false;
          }
          enableCompatMode() {
            this.logger.log("开启兼容模式"), c.compatAudioInputList.enabled = true, this.handleDeviceChange();
          }
          disableCompatMode() {
            this.logger.log("关闭兼容模式。"), c.compatAudioInputList.enabled = false, this.handleDeviceChange();
          }
          defaultHandleUserGestureNeeded(e2) {
            const t2 = `由于浏览器限制，该操作需手势触发。<br/>${e2.name}<br/>${e2.message}<br/>点击此处以继续`;
            d.alerter.alert(t2), this.logger.warn('为避免看到这个消息，您应该实现 Device.onUserGestureNeeded 方法，引导用户作出手势，并触发 Device.on("user-gesture-fired")事件。');
          }
          clean() {
          }
        }
        const h = new u();
        t.Device = h;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.getBrowserInfo = t.getOSInfo = void 0;
        const o = a(i(7)), n = /* @__PURE__ */ new Map([[o.IS_ANDROID, ["Android", o.ANDROID_VERSION]], [o.IS_IOS, ["iOS", o.IOS_VERSION]], [o.IS_WIN, ["Windows", o.WIN_VERSION]], [o.IS_MAC, ["MacOS", o.MACOS_VERSION]]]);
        t.getOSInfo = function() {
          let e2 = "unknown", t2 = "unknown";
          return n.get(true) && (e2 = n.get(true)[0], t2 = n.get(true)[1]), { osName: e2, osVersion: t2 };
        };
        const d = /* @__PURE__ */ new Map([[o.IS_FIREFOX, ["Firefox", o.FIREFOX_VERSION]], [o.IS_EDG, ["Edg", o.EDG_VERSION]], [o.IS_CHROME, ["Chrome", o.CHROME_VERSION]], [o.IS_SAFARI, ["Safari", o.SAFARI_VERSION]], [o.IS_WECHAT, ["WeChat", o.WECHAT_VERSION]], [o.IS_WQQB, ["QQ(Win)", o.WQQB_VERSION]], [o.IS_MQQB, ["QQ(Mobile)", o.MQQB_VERSION]], [o.IS_X5MQQB, ["QQ(Mobile X5)", o.MQQB_VERSION]], [o.IS_MACQQB, ["QQ(Mac)", o.MACQQB_VERSION]], [o.IS_IPADQQB, ["QQ(iPad)", o.IPADQQB_VERSION]], [o.IS_MIBROWSER, ["MI", o.MI_VERSION]], [o.IS_HUAWEIBROWSER, ["HW", o.HUAWEI_VERSION]], [o.IS_SAMSUNGBROWSER, ["Samsung", o.SAMSUNG_VERSION]], [o.IS_OPPOBROWSER, ["OPPO", o.OPPO_VERSION]], [o.IS_VIVOBROWSER, ["VIVO", o.VIVO_VERSION]], [o.IS_EDGE, ["EDGE", o.EDGE_VERSION]], [o.IS_SOGOUM, ["SogouMobile", o.SOGOUM_VERSION]], [o.IS_SOGOU, ["Sogou", o.SOGOU_VERSION]], [o.IS_ELECTRON, ["Electron", o.ELECTRON_VERSION]]]);
        t.getBrowserInfo = function() {
          let e2 = "unknown", t2 = "unknown";
          return d.get(true) && (e2 = d.get(true)[0], t2 = d.get(true)[1]), { browserName: e2, browserVersion: t2 };
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.InvalidStateError = t.UnsupportedError = void 0;
        class r extends Error {
          constructor(e2) {
            super(e2), this.name = "UnsupportedError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, r) : this.stack = new Error(e2).stack;
          }
        }
        t.UnsupportedError = r;
        class s extends Error {
          constructor(e2) {
            super(e2), this.name = "InvalidStateError", Error.hasOwnProperty("captureStackTrace") ? Error.captureStackTrace(this, s) : this.stack = new Error(e2).stack;
          }
        }
        t.InvalidStateError = s;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.canReceive = t.canSend = t.generateProbatorRtpParameters = t.reduceCodecs = t.getSendingRemoteRtpParameters = t.getSendingRtpParameters = t.getRecvRtpCapabilities = t.getExtendedRtpCapabilities = t.validateSctpStreamParameters = t.validateSctpParameters = t.validateNumSctpStreams = t.validateSctpCapabilities = t.validateRtcpParameters = t.validateRtpEncodingParameters = t.validateRtpHeaderExtensionParameters = t.validateRtpCodecParameters = t.validateRtpParameters = t.validateRtpHeaderExtension = t.validateRtcpFeedback = t.validateRtpCodecCapability = t.validateRtpCapabilities = void 0;
        const o = a(i(225)), n = a(i(27));
        function d(e2) {
          const t2 = new RegExp("^(audio|video)/(.+)", "i");
          if ("object" != typeof e2) throw new TypeError("codec is not an object");
          if (!e2.mimeType || "string" != typeof e2.mimeType) throw new TypeError("missing codec.mimeType");
          const i2 = t2.exec(e2.mimeType);
          if (!i2) throw new TypeError("invalid codec.mimeType");
          if (e2.kind = i2[1].toLowerCase(), e2.preferredPayloadType && "number" != typeof e2.preferredPayloadType) throw new TypeError("invalid codec.preferredPayloadType");
          if ("number" != typeof e2.clockRate) throw new TypeError("missing codec.clockRate");
          "audio" === e2.kind ? "number" != typeof e2.channels && (e2.channels = 1) : delete e2.channels, e2.parameters && "object" == typeof e2.parameters || (e2.parameters = {});
          for (const t3 of Object.keys(e2.parameters)) {
            let i3 = e2.parameters[t3];
            if (void 0 === i3 && (e2.parameters[t3] = "", i3 = ""), "string" != typeof i3 && "number" != typeof i3) throw new TypeError(`invalid codec parameter [key:${t3}s, value:${i3}]`);
            if ("apt" === t3 && "number" != typeof i3) throw new TypeError("invalid codec apt parameter");
          }
          e2.rtcpFeedback && Array.isArray(e2.rtcpFeedback) || (e2.rtcpFeedback = []);
          for (const t3 of e2.rtcpFeedback) c(t3);
        }
        function c(e2) {
          if ("object" != typeof e2) throw new TypeError("fb is not an object");
          if (!e2.type || "string" != typeof e2.type) throw new TypeError("missing fb.type");
          e2.parameter && "string" == typeof e2.parameter || (e2.parameter = "");
        }
        function l(e2) {
          if ("object" != typeof e2) throw new TypeError("ext is not an object");
          if (e2.kind && "string" == typeof e2.kind || (e2.kind = ""), "" !== e2.kind && "audio" !== e2.kind && "video" !== e2.kind) throw new TypeError("invalid ext.kind");
          if (!e2.uri || "string" != typeof e2.uri) throw new TypeError("missing ext.uri");
          if ("number" != typeof e2.preferredId) throw new TypeError("missing ext.preferredId");
          if (e2.preferredEncrypt && "boolean" != typeof e2.preferredEncrypt) throw new TypeError("invalid ext.preferredEncrypt");
          if (e2.preferredEncrypt || (e2.preferredEncrypt = false), e2.direction && "string" != typeof e2.direction) throw new TypeError("invalid ext.direction");
          e2.direction || (e2.direction = "sendrecv");
        }
        function u(e2) {
          if ("object" != typeof e2) throw new TypeError("params is not an object");
          if (e2.mid && "string" != typeof e2.mid) throw new TypeError("params.mid is not a string");
          if (!Array.isArray(e2.codecs)) throw new TypeError("missing params.codecs");
          for (const t2 of e2.codecs) h(t2);
          if (e2.headerExtensions && !Array.isArray(e2.headerExtensions)) throw new TypeError("params.headerExtensions is not an array");
          e2.headerExtensions || (e2.headerExtensions = []);
          for (const t2 of e2.headerExtensions) p(t2);
          if (e2.encodings && !Array.isArray(e2.encodings)) throw new TypeError("params.encodings is not an array");
          e2.encodings || (e2.encodings = []);
          for (const t2 of e2.encodings) m(t2);
          if (e2.rtcp && "object" != typeof e2.rtcp) throw new TypeError("params.rtcp is not an object");
          e2.rtcp || (e2.rtcp = {}), g(e2.rtcp);
        }
        function h(e2) {
          const t2 = new RegExp("^(audio|video)/(.+)", "i");
          if ("object" != typeof e2) throw new TypeError("codec is not an object");
          if (!e2.mimeType || "string" != typeof e2.mimeType) throw new TypeError("missing codec.mimeType");
          const i2 = t2.exec(e2.mimeType);
          if (!i2) throw new TypeError("invalid codec.mimeType");
          if ("number" != typeof e2.payloadType) throw new TypeError("missing codec.payloadType");
          if ("number" != typeof e2.clockRate) throw new TypeError("missing codec.clockRate");
          "audio" === i2[1].toLowerCase() ? "number" != typeof e2.channels && (e2.channels = 1) : delete e2.channels, e2.parameters && "object" == typeof e2.parameters || (e2.parameters = {});
          for (const t3 of Object.keys(e2.parameters)) {
            let i3 = e2.parameters[t3];
            if (void 0 === i3 && (e2.parameters[t3] = "", i3 = ""), "string" != typeof i3 && "number" != typeof i3) throw new TypeError(`invalid codec parameter [key:${t3}s, value:${i3}]`);
            if ("apt" === t3 && "number" != typeof i3) throw new TypeError("invalid codec apt parameter");
          }
          e2.rtcpFeedback && Array.isArray(e2.rtcpFeedback) || (e2.rtcpFeedback = []);
          for (const t3 of e2.rtcpFeedback) c(t3);
        }
        function p(e2) {
          if ("object" != typeof e2) throw new TypeError("ext is not an object");
          if (!e2.uri || "string" != typeof e2.uri) throw new TypeError("missing ext.uri");
          if ("number" != typeof e2.id) throw new TypeError("missing ext.id");
          if (e2.encrypt && "boolean" != typeof e2.encrypt) throw new TypeError("invalid ext.encrypt");
          e2.encrypt || (e2.encrypt = false), e2.parameters && "object" == typeof e2.parameters || (e2.parameters = {});
          for (const t2 of Object.keys(e2.parameters)) {
            let i2 = e2.parameters[t2];
            if (void 0 === i2 && (e2.parameters[t2] = "", i2 = ""), "string" != typeof i2 && "number" != typeof i2) throw new TypeError("invalid header extension parameter");
          }
        }
        function m(e2) {
          if ("object" != typeof e2) throw new TypeError("encoding is not an object");
          if (e2.ssrc && "number" != typeof e2.ssrc) throw new TypeError("invalid encoding.ssrc");
          if (e2.rid && "string" != typeof e2.rid) throw new TypeError("invalid encoding.rid");
          if (e2.rtx && "object" != typeof e2.rtx) throw new TypeError("invalid encoding.rtx");
          if (e2.rtx && "number" != typeof e2.rtx.ssrc) throw new TypeError("missing encoding.rtx.ssrc");
          if (e2.dtx && "boolean" == typeof e2.dtx || (e2.dtx = false), e2.scalabilityMode && "string" != typeof e2.scalabilityMode) throw new TypeError("invalid encoding.scalabilityMode");
        }
        function g(e2) {
          if ("object" != typeof e2) throw new TypeError("rtcp is not an object");
          if (e2.cname && "string" != typeof e2.cname) throw new TypeError("invalid rtcp.cname");
          e2.reducedSize && "boolean" == typeof e2.reducedSize || (e2.reducedSize = true);
        }
        function f(e2) {
          if ("object" != typeof e2) throw new TypeError("numStreams is not an object");
          if ("number" != typeof e2.OS) throw new TypeError("missing numStreams.OS");
          if ("number" != typeof e2.MIS) throw new TypeError("missing numStreams.MIS");
        }
        function v(e2) {
          return !!e2 && /.+\/rtx$/i.test(e2.mimeType);
        }
        function S(e2, t2, { strict: i2 = false, modify: r2 = false } = {}) {
          const s2 = e2.mimeType.toLowerCase();
          if (s2 !== t2.mimeType.toLowerCase()) return false;
          if (e2.clockRate !== t2.clockRate) return false;
          if (e2.channels !== t2.channels) return false;
          switch (s2) {
            case "video/h265":
            case "video/vp9":
            case "video/av1":
              return false;
            case "video/h264":
              if ((e2.parameters["packetization-mode"] || 0) !== (t2.parameters["packetization-mode"] || 0)) return false;
              if (i2) {
                if (!o.isSameProfile(e2.parameters, t2.parameters)) return false;
                let i3;
                try {
                  i3 = o.generateProfileLevelIdForAnswer(e2.parameters, t2.parameters);
                } catch (e3) {
                  return false;
                }
                r2 && (i3 ? e2.parameters["profile-level-id"] = i3 : delete e2.parameters["profile-level-id"]);
              }
              break;
          }
          return true;
        }
        function y(e2, t2) {
          return (!e2.kind || !t2.kind || e2.kind === t2.kind) && e2.uri === t2.uri;
        }
        function _(e2, t2) {
          const i2 = [];
          for (const r2 of e2.rtcpFeedback || []) {
            const e3 = (t2.rtcpFeedback || []).find((e4) => e4.type === r2.type && (e4.parameter === r2.parameter || !e4.parameter && !r2.parameter));
            e3 && i2.push(e3);
          }
          return i2;
        }
        t.validateRtpCapabilities = function(e2) {
          if ("object" != typeof e2) throw new TypeError("caps is not an object");
          if (e2.codecs && !Array.isArray(e2.codecs)) throw new TypeError("caps.codecs is not an array");
          e2.codecs || (e2.codecs = []);
          for (const t2 of e2.codecs) d(t2);
          if (e2.headerExtensions && !Array.isArray(e2.headerExtensions)) throw new TypeError("caps.headerExtensions is not an array");
          e2.headerExtensions || (e2.headerExtensions = []);
          for (const t2 of e2.headerExtensions) l(t2);
        }, t.validateRtpCodecCapability = d, t.validateRtcpFeedback = c, t.validateRtpHeaderExtension = l, t.validateRtpParameters = u, t.validateRtpCodecParameters = h, t.validateRtpHeaderExtensionParameters = p, t.validateRtpEncodingParameters = m, t.validateRtcpParameters = g, t.validateSctpCapabilities = function(e2) {
          if ("object" != typeof e2) throw new TypeError("caps is not an object");
          if (!e2.numStreams || "object" != typeof e2.numStreams) throw new TypeError("missing caps.numStreams");
          f(e2.numStreams);
        }, t.validateNumSctpStreams = f, t.validateSctpParameters = function(e2) {
          if ("object" != typeof e2) throw new TypeError("params is not an object");
          if ("number" != typeof e2.port) throw new TypeError("missing params.port");
          if ("number" != typeof e2.OS) throw new TypeError("missing params.OS");
          if ("number" != typeof e2.MIS) throw new TypeError("missing params.MIS");
          if ("number" != typeof e2.maxMessageSize) throw new TypeError("missing params.maxMessageSize");
        }, t.validateSctpStreamParameters = function(e2) {
          if ("object" != typeof e2) throw new TypeError("params is not an object");
          if ("number" != typeof e2.streamId) throw new TypeError("missing params.streamId");
          let t2 = false;
          if ("boolean" == typeof e2.ordered ? t2 = true : e2.ordered = true, e2.maxPacketLifeTime && "number" != typeof e2.maxPacketLifeTime) throw new TypeError("invalid params.maxPacketLifeTime");
          if (e2.maxRetransmits && "number" != typeof e2.maxRetransmits) throw new TypeError("invalid params.maxRetransmits");
          if (e2.maxPacketLifeTime && e2.maxRetransmits) throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
          if (t2 && e2.ordered && (e2.maxPacketLifeTime || e2.maxRetransmits)) throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
          if (t2 || !e2.maxPacketLifeTime && !e2.maxRetransmits || (e2.ordered = false), e2.label && "string" != typeof e2.label) throw new TypeError("invalid params.label");
          if (e2.protocol && "string" != typeof e2.protocol) throw new TypeError("invalid params.protocol");
        }, t.getExtendedRtpCapabilities = function(e2, t2) {
          const i2 = { codecs: [], headerExtensions: [] };
          for (const r2 of t2.codecs || []) {
            if (v(r2)) continue;
            const t3 = (e2.codecs || []).find((e3) => S(e3, r2, { strict: true, modify: true }));
            if (!t3) continue;
            const s2 = { mimeType: t3.mimeType, kind: t3.kind, clockRate: t3.clockRate, channels: t3.channels, localPayloadType: t3.preferredPayloadType, localRtxPayloadType: void 0, remotePayloadType: r2.preferredPayloadType, remoteRtxPayloadType: void 0, localParameters: t3.parameters, remoteParameters: r2.parameters, rtcpFeedback: _(t3, r2) };
            i2.codecs.push(s2);
          }
          for (const r2 of i2.codecs) {
            const i3 = e2.codecs.find((e3) => v(e3) && e3.parameters.apt === r2.localPayloadType), s2 = t2.codecs.find((e3) => v(e3) && e3.parameters.apt === r2.remotePayloadType);
            i3 && s2 && (r2.localRtxPayloadType = i3.preferredPayloadType, r2.remoteRtxPayloadType = s2.preferredPayloadType);
          }
          for (const r2 of t2.headerExtensions) {
            const t3 = e2.headerExtensions.find((e3) => y(e3, r2));
            if (!t3) continue;
            const s2 = { kind: r2.kind, uri: r2.uri, sendId: t3.preferredId, recvId: r2.preferredId, encrypt: t3.preferredEncrypt, direction: "sendrecv" };
            switch (r2.direction) {
              case "sendrecv":
                s2.direction = "sendrecv";
                break;
              case "recvonly":
                s2.direction = "sendonly";
                break;
              case "sendonly":
                s2.direction = "recvonly";
                break;
              case "inactive":
                s2.direction = "inactive";
            }
            i2.headerExtensions.push(s2);
          }
          return i2;
        }, t.getRecvRtpCapabilities = function(e2) {
          const t2 = { codecs: [], headerExtensions: [] };
          for (const i2 of e2.codecs) {
            const e3 = { mimeType: i2.mimeType, kind: i2.kind, preferredPayloadType: i2.localPayloadType, clockRate: i2.clockRate, channels: i2.channels, parameters: i2.localParameters, rtcpFeedback: i2.rtcpFeedback };
            if (t2.codecs.push(e3), !i2.localRtxPayloadType) continue;
            const r2 = { mimeType: i2.kind + "/rtx", kind: i2.kind, preferredPayloadType: i2.localRtxPayloadType, clockRate: i2.clockRate, parameters: { apt: i2.localPayloadType }, rtcpFeedback: [] };
            t2.codecs.push(r2);
          }
          for (const i2 of e2.headerExtensions) {
            if ("sendrecv" !== i2.direction && "recvonly" !== i2.direction) continue;
            const e3 = { kind: i2.kind, uri: i2.uri, preferredId: i2.sendId, preferredEncrypt: i2.encrypt, direction: i2.direction };
            t2.headerExtensions.push(e3);
          }
          return t2;
        }, t.getSendingRtpParameters = function(e2, t2) {
          const i2 = { mid: void 0, codecs: [], headerExtensions: [], encodings: [], rtcp: {} };
          for (const r2 of t2.codecs) {
            if (r2.kind !== e2) continue;
            const t3 = { mimeType: r2.mimeType, payloadType: r2.localPayloadType, clockRate: r2.clockRate, channels: r2.channels, parameters: r2.localParameters, rtcpFeedback: r2.rtcpFeedback };
            if (i2.codecs.push(t3), r2.localRtxPayloadType) {
              const e3 = { mimeType: r2.kind + "/rtx", payloadType: r2.localRtxPayloadType, clockRate: r2.clockRate, parameters: { apt: r2.localPayloadType }, rtcpFeedback: [] };
              i2.codecs.push(e3);
            }
          }
          for (const r2 of t2.headerExtensions) {
            if (r2.kind && r2.kind !== e2 || "sendrecv" !== r2.direction && "sendonly" !== r2.direction) continue;
            const t3 = { uri: r2.uri, id: r2.sendId, encrypt: r2.encrypt, parameters: {} };
            i2.headerExtensions.push(t3);
          }
          return i2;
        }, t.getSendingRemoteRtpParameters = function(e2, t2) {
          const i2 = { mid: void 0, codecs: [], headerExtensions: [], encodings: [], rtcp: {} };
          for (const r2 of t2.codecs) {
            if (r2.kind !== e2) continue;
            const t3 = { mimeType: r2.mimeType, payloadType: r2.localPayloadType, clockRate: r2.clockRate, channels: r2.channels, parameters: r2.remoteParameters, rtcpFeedback: r2.rtcpFeedback };
            if (i2.codecs.push(t3), r2.localRtxPayloadType) {
              const e3 = { mimeType: r2.kind + "/rtx", payloadType: r2.localRtxPayloadType, clockRate: r2.clockRate, parameters: { apt: r2.localPayloadType }, rtcpFeedback: [] };
              i2.codecs.push(e3);
            }
          }
          for (const r2 of t2.headerExtensions) {
            if (r2.kind && r2.kind !== e2 || "sendrecv" !== r2.direction && "sendonly" !== r2.direction) continue;
            const t3 = { uri: r2.uri, id: r2.sendId, encrypt: r2.encrypt, parameters: {} };
            i2.headerExtensions.push(t3);
          }
          return i2;
        }, t.reduceCodecs = function(e2, t2) {
          const i2 = [];
          if (t2) {
            for (let r2 = 0; r2 < e2.length; ++r2) if (S(e2[r2], t2)) {
              i2.push(e2[r2]), v(e2[r2 + 1]) && i2.push(e2[r2 + 1]);
              break;
            }
            if (0 === i2.length) throw new TypeError("no matching codec found");
          } else i2.push(e2[0]), v(e2[1]) && i2.push(e2[1]);
          return i2;
        }, t.generateProbatorRtpParameters = function(e2, t2) {
          u(e2 = n.clone(e2, {}));
          const i2 = { mid: "probator", codecs: [], headerExtensions: [], encodings: [{ ssrc: t2 }], rtcp: { cname: "probator" } };
          return i2.codecs.push(e2.codecs[0]), i2.codecs[0].payloadType = 127, i2.headerExtensions = e2.headerExtensions, i2;
        }, t.canSend = function(e2, t2) {
          return t2.codecs.some((t3) => t3.kind === e2);
        }, t.canReceive = function(e2, t2) {
          if (u(e2), 0 === e2.codecs.length) return false;
          for (let i2 in e2.codecs) if ("video/rtx" !== e2.codecs[i2].mimeType) {
            for (let r2 in t2.codecs) if (t2.codecs[r2].localPayloadType === e2.codecs[i2].payloadType) return true;
          }
          return false;
        };
      }, function(e, t) {
        var i, r, s = e.exports = {};
        function a() {
          throw new Error("setTimeout has not been defined");
        }
        function o() {
          throw new Error("clearTimeout has not been defined");
        }
        function n(e2) {
          if (i === setTimeout) return setTimeout(e2, 0);
          if ((i === a || !i) && setTimeout) return i = setTimeout, setTimeout(e2, 0);
          try {
            return i(e2, 0);
          } catch (t2) {
            try {
              return i.call(null, e2, 0);
            } catch (t3) {
              return i.call(this, e2, 0);
            }
          }
        }
        !function() {
          try {
            i = "function" == typeof setTimeout ? setTimeout : a;
          } catch (e2) {
            i = a;
          }
          try {
            r = "function" == typeof clearTimeout ? clearTimeout : o;
          } catch (e2) {
            r = o;
          }
        }();
        var d, c = [], l = false, u = -1;
        function h() {
          l && d && (l = false, d.length ? c = d.concat(c) : u = -1, c.length && p());
        }
        function p() {
          if (!l) {
            var e2 = n(h);
            l = true;
            for (var t2 = c.length; t2; ) {
              for (d = c, c = []; ++u < t2; ) d && d[u].run();
              u = -1, t2 = c.length;
            }
            d = null, l = false, function(e3) {
              if (r === clearTimeout) return clearTimeout(e3);
              if ((r === o || !r) && clearTimeout) return r = clearTimeout, clearTimeout(e3);
              try {
                r(e3);
              } catch (t3) {
                try {
                  return r.call(null, e3);
                } catch (t4) {
                  return r.call(this, e3);
                }
              }
            }(e2);
          }
        }
        function m(e2, t2) {
          this.fun = e2, this.array = t2;
        }
        function g() {
        }
        s.nextTick = function(e2) {
          var t2 = new Array(arguments.length - 1);
          if (arguments.length > 1) for (var i2 = 1; i2 < arguments.length; i2++) t2[i2 - 1] = arguments[i2];
          c.push(new m(e2, t2)), 1 !== c.length || l || n(p);
        }, m.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, s.title = "browser", s.browser = true, s.env = {}, s.argv = [], s.version = "", s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.prependListener = g, s.prependOnceListener = g, s.listeners = function(e2) {
          return [];
        }, s.binding = function(e2) {
          throw new Error("process.binding is not supported");
        }, s.cwd = function() {
          return "/";
        }, s.chdir = function(e2) {
          throw new Error("process.chdir is not supported");
        }, s.umask = function() {
          return 0;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.JSONBigStringify = t.JSONBigParse = void 0;
        const r = i(254), s = i(255);
        t.JSONBigParse = s.JSONParse(), t.JSONBigStringify = r.stringify;
      }, function(e, t, i) {
        "use strict";
        e.exports = a, a.className = "ReflectionObject";
        var r, s = i(19);
        function a(e2, t2) {
          if (!s.isString(e2)) throw TypeError("name must be a string");
          if (t2 && !s.isObject(t2)) throw TypeError("options must be an object");
          this.options = t2, this.parsedOptions = null, this.name = e2, this.parent = null, this.resolved = false, this.comment = null, this.filename = null;
        }
        Object.defineProperties(a.prototype, { root: { get: function() {
          for (var e2 = this; null !== e2.parent; ) e2 = e2.parent;
          return e2;
        } }, fullName: { get: function() {
          for (var e2 = [this.name], t2 = this.parent; t2; ) e2.unshift(t2.name), t2 = t2.parent;
          return e2.join(".");
        } } }), a.prototype.toJSON = function() {
          throw Error();
        }, a.prototype.onAdd = function(e2) {
          this.parent && this.parent !== e2 && this.parent.remove(this), this.parent = e2, this.resolved = false;
          var t2 = e2.root;
          t2 instanceof r && t2._handleAdd(this);
        }, a.prototype.onRemove = function(e2) {
          var t2 = e2.root;
          t2 instanceof r && t2._handleRemove(this), this.parent = null, this.resolved = false;
        }, a.prototype.resolve = function() {
          return this.resolved || this.root instanceof r && (this.resolved = true), this;
        }, a.prototype.getOption = function(e2) {
          if (this.options) return this.options[e2];
        }, a.prototype.setOption = function(e2, t2, i2) {
          return i2 && this.options && void 0 !== this.options[e2] || ((this.options || (this.options = {}))[e2] = t2), this;
        }, a.prototype.setParsedOption = function(e2, t2, i2) {
          this.parsedOptions || (this.parsedOptions = []);
          var r2 = this.parsedOptions;
          if (i2) {
            var a2 = r2.find(function(t3) {
              return Object.prototype.hasOwnProperty.call(t3, e2);
            });
            if (a2) {
              var o = a2[e2];
              s.setProperty(o, i2, t2);
            } else (a2 = {})[e2] = s.setProperty({}, i2, t2), r2.push(a2);
          } else {
            var n = {};
            n[e2] = t2, r2.push(n);
          }
          return this;
        }, a.prototype.setOptions = function(e2, t2) {
          if (e2) for (var i2 = Object.keys(e2), r2 = 0; r2 < i2.length; ++r2) this.setOption(i2[r2], e2[i2[r2]], t2);
          return this;
        }, a.prototype.toString = function() {
          var e2 = this.constructor.className, t2 = this.fullName;
          return t2.length ? e2 + " " + t2 : e2;
        }, a._configure = function(e2) {
          r = e2;
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = c;
        var r = i(82);
        ((c.prototype = Object.create(r.prototype)).constructor = c).className = "Field";
        var s, a = i(45), o = i(92), n = i(19), d = /^required|optional|repeated$/;
        function c(e2, t2, i2, s2, a2, c2, l) {
          if (n.isObject(s2) ? (l = a2, c2 = s2, s2 = a2 = void 0) : n.isObject(a2) && (l = c2, c2 = a2, a2 = void 0), r.call(this, e2, c2), !n.isInteger(t2) || t2 < 0) throw TypeError("id must be a non-negative integer");
          if (!n.isString(i2)) throw TypeError("type must be a string");
          if (void 0 !== s2 && !d.test(s2 = s2.toString().toLowerCase())) throw TypeError("rule must be a string rule");
          if (void 0 !== a2 && !n.isString(a2)) throw TypeError("extend must be a string");
          "proto3_optional" === s2 && (s2 = "optional"), this.rule = s2 && "optional" !== s2 ? s2 : void 0, this.type = i2, this.id = t2, this.extend = a2 || void 0, this.required = "required" === s2, this.optional = !this.required, this.repeated = "repeated" === s2, this.map = false, this.message = null, this.partOf = null, this.typeDefault = null, this.defaultValue = null, this.long = !!n.Long && void 0 !== o.long[i2], this.bytes = "bytes" === i2, this.resolvedType = null, this.extensionField = null, this.declaringField = null, this._packed = null, this.comment = l;
        }
        c.fromJSON = function(e2, t2) {
          return new c(e2, t2.id, t2.type, t2.rule, t2.extend, t2.options, t2.comment);
        }, Object.defineProperty(c.prototype, "packed", { get: function() {
          return null === this._packed && (this._packed = false !== this.getOption("packed")), this._packed;
        } }), c.prototype.setOption = function(e2, t2, i2) {
          return "packed" === e2 && (this._packed = null), r.prototype.setOption.call(this, e2, t2, i2);
        }, c.prototype.toJSON = function(e2) {
          var t2 = !!e2 && Boolean(e2.keepComments);
          return n.toObject(["rule", "optional" !== this.rule && this.rule || void 0, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t2 ? this.comment : void 0]);
        }, c.prototype.resolve = function() {
          if (this.resolved) return this;
          if (void 0 === (this.typeDefault = o.defaults[this.type]) && (this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type), this.resolvedType instanceof s ? this.typeDefault = null : this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]), this.options && null != this.options.default && (this.typeDefault = this.options.default, this.resolvedType instanceof a && "string" == typeof this.typeDefault && (this.typeDefault = this.resolvedType.values[this.typeDefault])), this.options && (true !== this.options.packed && (void 0 === this.options.packed || !this.resolvedType || this.resolvedType instanceof a) || delete this.options.packed, Object.keys(this.options).length || (this.options = void 0)), this.long) this.typeDefault = n.Long.fromNumber(this.typeDefault, "u" === this.type.charAt(0)), Object.freeze && Object.freeze(this.typeDefault);
          else if (this.bytes && "string" == typeof this.typeDefault) {
            var e2;
            n.base64.test(this.typeDefault) ? n.base64.decode(this.typeDefault, e2 = n.newBuffer(n.base64.length(this.typeDefault)), 0) : n.utf8.write(this.typeDefault, e2 = n.newBuffer(n.utf8.length(this.typeDefault)), 0), this.typeDefault = e2;
          }
          return this.map ? this.defaultValue = n.emptyObject : this.repeated ? this.defaultValue = n.emptyArray : this.defaultValue = this.typeDefault, this.parent instanceof s && (this.parent.ctor.prototype[this.name] = this.defaultValue), r.prototype.resolve.call(this);
        }, c.d = function(e2, t2, i2, r2) {
          return "function" == typeof t2 ? t2 = n.decorateType(t2).name : t2 && "object" == typeof t2 && (t2 = n.decorateEnum(t2).name), function(s2, a2) {
            n.decorateType(s2.constructor).add(new c(a2, e2, t2, i2, { default: r2 }));
          };
        }, c._configure = function(e2) {
          s = e2;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.loglevelMap = t.loglevels = void 0, function(e2) {
          e2[e2.DEBUG = 0] = "DEBUG", e2[e2.INFO = 1] = "INFO", e2[e2.WARNING = 2] = "WARNING", e2[e2.ERROR = 3] = "ERROR", e2[e2.NONE = 4] = "NONE";
        }(t.loglevels || (t.loglevels = {})), t.loglevelMap = { 0: "DEBUG", 1: "INFO", 2: "WARNING", 3: "ERROR", 4: "NONE" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getWebGLContext = t.get2DContext = void 0;
        const r = i(1);
        t.get2DContext = function(e2, t2) {
          return r.getParameters().disable2dContext ? null : e2.getContext("2d", t2);
        }, t.getWebGLContext = function(e2, t2) {
          return r.getParameters().disableWebGLContext ? null : e2.getContext("webgl", t2);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.EnhancedEventEmitter = void 0;
        const r = i(169), s = i(29), a = "EnhancedEventEmitter";
        class o extends r.EventEmitter {
          constructor() {
            super(), this.setMaxListeners(1 / 0);
          }
          safeEmit(e2, ...t2) {
            const i2 = this.listenerCount(e2);
            try {
              return this.emit(e2, ...t2);
            } catch (t3) {
              return s.Logger.error(a, "safeEmit() | event listener threw an error [event:%s]:%o", e2, t3), Boolean(i2);
            }
          }
          async safeEmitAsPromise(e2, ...t2) {
            return new Promise((i2, r2) => {
              try {
                this.emit(e2, ...t2, i2, r2);
              } catch (t3) {
                s.Logger.error(a, "safeEmitAsPromise() | event listener threw an error [event:%s]:%o", e2, t3), r2(t3);
              }
            });
          }
        }
        t.EnhancedEventEmitter = o;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.HandlerInterface = void 0;
        const r = i(86);
        class s extends r.EnhancedEventEmitter {
          constructor() {
            super();
          }
        }
        t.HandlerInterface = s;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.applyCodecParameters = t.getCname = t.extractDtlsParameters = t.extractRtpCapabilities = void 0;
        const n = a(i(50)), d = o(i(6)), c = o(i(8));
        t.extractRtpCapabilities = function({ sdpObject: e2 }) {
          const t2 = /* @__PURE__ */ new Map(), i2 = [];
          let r2 = false, s2 = false;
          for (const a2 of e2.media) {
            const e3 = a2.type;
            switch (e3) {
              case "audio":
                if (r2) continue;
                r2 = true;
                break;
              case "video":
                if (s2) continue;
                s2 = true;
                break;
              default:
                continue;
            }
            for (const i3 of a2.rtp) {
              const r3 = { kind: e3, mimeType: `${e3}/${i3.codec}`, preferredPayloadType: i3.payload, clockRate: i3.rate, channels: i3.encoding, parameters: {}, rtcpFeedback: [] };
              t2.set(r3.preferredPayloadType, r3);
            }
            for (const e4 of a2.fmtp || []) {
              const i3 = n.parseParams(e4.config), r3 = t2.get(e4.payload);
              r3 && (i3 && i3.hasOwnProperty("profile-level-id") && (i3["profile-level-id"] = String(i3["profile-level-id"])), r3.parameters = i3);
            }
            for (const e4 of a2.rtcpFb || []) {
              const i3 = t2.get(e4.payload);
              if (!i3) continue;
              const r3 = { type: e4.type, parameter: e4.subtype };
              r3.parameter || delete r3.parameter, i3.rtcpFeedback.push(r3);
            }
            for (const t3 of a2.ext || []) {
              if (t3["encrypt-uri"]) continue;
              const r3 = { kind: e3, uri: t3.uri, preferredId: t3.value };
              i2.push(r3);
            }
          }
          return { codecs: Array.from(t2.values()), headerExtensions: i2 };
        }, t.extractDtlsParameters = function({ sdpObject: e2 }) {
          const t2 = (e2.media || []).find((e3) => e3.iceUfrag && 0 !== e3.port);
          if (!t2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "extractDtlsParameters: active media 未找到" });
          const i2 = t2.fingerprint || e2.fingerprint;
          let r2;
          switch (t2.setup) {
            case "active":
              r2 = "client";
              break;
            case "passive":
              r2 = "server";
              break;
            case "actpass":
              r2 = "auto";
          }
          return { role: r2, fingerprints: [{ algorithm: i2.type, value: i2.hash }] };
        }, t.getCname = function({ offerMediaObject: e2 }) {
          const t2 = (e2.ssrcs || []).find((e3) => "cname" === e3.attribute);
          return t2 ? t2.value : "";
        }, t.applyCodecParameters = function({ offerRtpParameters: e2, answerMediaObject: t2 }) {
          for (const i2 of e2.codecs) {
            const e3 = i2.mimeType.toLowerCase();
            if ("audio/opus" !== e3) continue;
            if (!(t2.rtp || []).find((e4) => e4.payload === i2.payloadType)) continue;
            t2.fmtp = t2.fmtp || [];
            let r2 = t2.fmtp.find((e4) => e4.payload === i2.payloadType);
            r2 || (r2 = { payload: i2.payloadType, config: "" }, t2.fmtp.push(r2));
            const s2 = n.parseParams(r2.config);
            switch (e3) {
              case "audio/opus": {
                const e4 = i2.parameters["sprop-stereo"];
                void 0 !== e4 && (s2.stereo = e4 ? 1 : 0);
                break;
              }
            }
            r2.config = "";
            for (const e4 of Object.keys(s2)) r2.config && (r2.config += ";"), r2.config += `${e4}=${s2[e4]}`;
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.filterRembFromRtpParameters = t.filterTransportCCFromSdp = t.filterTransportCCFromRtpParameters = void 0, t.filterTransportCCFromRtpParameters = function(e2) {
          if (e2.headerExtensions) for (let t2 = e2.headerExtensions.length - 1; t2 >= 0; t2--) e2.headerExtensions[t2].uri.indexOf("transport-wide-cc") > -1 && e2.headerExtensions.splice(t2, 1);
          for (let t2 = e2.codecs.length - 1; t2 >= 0; t2--) {
            const i2 = e2.codecs[t2];
            if (i2.rtcpFeedback) for (let e3 = i2.rtcpFeedback.length - 1; e3 >= 0; e3--) "transport-cc" === i2.rtcpFeedback[e3].type && i2.rtcpFeedback.splice(e3, 1);
          }
        }, t.filterTransportCCFromSdp = function(e2) {
          for (let t2 in e2.media) {
            const i2 = e2.media[t2];
            if (i2.ext) for (let e3 = i2.ext.length - 1; e3 >= 0; e3--) i2.ext[e3].uri.indexOf("transport-wide-cc") > -1 && i2.ext.splice(e3, 1);
            if (i2.rtcpFb) for (let e3 = i2.rtcpFb.length - 1; e3 >= 0; e3--) "transport-cc" === i2.rtcpFb[e3].type && i2.rtcpFb.splice(e3, 1);
          }
        }, t.filterRembFromRtpParameters = function(e2) {
          if (e2.headerExtensions) for (let t2 = e2.headerExtensions.length - 1; t2 >= 0; t2--) e2.headerExtensions[t2].uri.indexOf("abs-send-time") > -1 && e2.headerExtensions.splice(t2, 1);
          for (let t2 = e2.codecs.length - 1; t2 >= 0; t2--) {
            const i2 = e2.codecs[t2];
            if (i2.rtcpFeedback) for (let e3 = i2.rtcpFeedback.length - 1; e3 >= 0; e3--) "goog-remb" === i2.rtcpFeedback[e3].type && i2.rtcpFeedback.splice(e3, 1);
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.getBlobUrl = void 0;
        const s = r(i(246)), a = r(i(247)), o = r(i(248)), n = r(i(249)), d = r(i(250)), c = { volumeProcessor: { blobParts: [o.default], options: { type: "text/javascript; charset=utf-8" }, url: "" }, webWorkerTimer: { blobParts: [n.default], options: { type: "text/javascript; charset=utf-8" }, url: "" }, audioAIProcessor: { blobParts: [d.default], options: { type: "text/javascript; charset=utf-8" }, url: "" }, signalProbeWorker: { blobParts: [a.default], options: { type: "text/js-worker" }, url: "" }, rtcTimer: { blobParts: [s.default], options: { type: "text/js-worker" }, url: "" } };
        t.getBlobUrl = function(e2) {
          if (!c[e2].url) {
            const t2 = new Blob(c[e2].blobParts, c[e2].options);
            c[e2].url = window.URL.createObjectURL(t2);
          }
          return c[e2].url;
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = u;
        var r = i(82);
        ((u.prototype = Object.create(r.prototype)).constructor = u).className = "Namespace";
        var s, a, o, n = i(83), d = i(141), c = i(19);
        function l(e2, t2) {
          if (e2 && e2.length) {
            for (var i2 = {}, r2 = 0; r2 < e2.length; ++r2) i2[e2[r2].name] = e2[r2].toJSON(t2);
            return i2;
          }
        }
        function u(e2, t2) {
          r.call(this, e2, t2), this.nested = void 0, this._nestedArray = null;
        }
        function h(e2) {
          return e2._nestedArray = null, e2;
        }
        u.fromJSON = function(e2, t2) {
          return new u(e2, t2.options).addJSON(t2.nested);
        }, u.arrayToJSON = l, u.isReservedId = function(e2, t2) {
          if (e2) {
            for (var i2 = 0; i2 < e2.length; ++i2) if ("string" != typeof e2[i2] && e2[i2][0] <= t2 && e2[i2][1] > t2) return true;
          }
          return false;
        }, u.isReservedName = function(e2, t2) {
          if (e2) {
            for (var i2 = 0; i2 < e2.length; ++i2) if (e2[i2] === t2) return true;
          }
          return false;
        }, Object.defineProperty(u.prototype, "nestedArray", { get: function() {
          return this._nestedArray || (this._nestedArray = c.toArray(this.nested));
        } }), u.prototype.toJSON = function(e2) {
          return c.toObject(["options", this.options, "nested", l(this.nestedArray, e2)]);
        }, u.prototype.addJSON = function(e2) {
          if (e2) for (var t2, i2 = Object.keys(e2), r2 = 0; r2 < i2.length; ++r2) t2 = e2[i2[r2]], this.add((void 0 !== t2.fields ? s.fromJSON : void 0 !== t2.values ? o.fromJSON : void 0 !== t2.methods ? a.fromJSON : void 0 !== t2.id ? n.fromJSON : u.fromJSON)(i2[r2], t2));
          return this;
        }, u.prototype.get = function(e2) {
          return this.nested && this.nested[e2] || null;
        }, u.prototype.getEnum = function(e2) {
          if (this.nested && this.nested[e2] instanceof o) return this.nested[e2].values;
          throw Error("no such enum: " + e2);
        }, u.prototype.add = function(e2) {
          if (!(e2 instanceof n && void 0 !== e2.extend || e2 instanceof s || e2 instanceof o || e2 instanceof a || e2 instanceof u || e2 instanceof d)) throw TypeError("object must be a valid nested object");
          if (this.nested) {
            var t2 = this.get(e2.name);
            if (t2) {
              if (!(t2 instanceof u && e2 instanceof u) || t2 instanceof s || t2 instanceof a) throw Error("duplicate name '" + e2.name + "' in " + this);
              for (var i2 = t2.nestedArray, r2 = 0; r2 < i2.length; ++r2) e2.add(i2[r2]);
              this.remove(t2), this.nested || (this.nested = {}), e2.setOptions(t2.options, true);
            }
          } else this.nested = {};
          return this.nested[e2.name] = e2, e2.onAdd(this), h(this);
        }, u.prototype.remove = function(e2) {
          if (!(e2 instanceof r)) throw TypeError("object must be a ReflectionObject");
          if (e2.parent !== this) throw Error(e2 + " is not a member of " + this);
          return delete this.nested[e2.name], Object.keys(this.nested).length || (this.nested = void 0), e2.onRemove(this), h(this);
        }, u.prototype.define = function(e2, t2) {
          if (c.isString(e2)) e2 = e2.split(".");
          else if (!Array.isArray(e2)) throw TypeError("illegal path");
          if (e2 && e2.length && "" === e2[0]) throw Error("path must be relative");
          for (var i2 = this; e2.length > 0; ) {
            var r2 = e2.shift();
            if (i2.nested && i2.nested[r2]) {
              if (!((i2 = i2.nested[r2]) instanceof u)) throw Error("path conflicts with non-namespace objects");
            } else i2.add(i2 = new u(r2));
          }
          return t2 && i2.addJSON(t2), i2;
        }, u.prototype.resolveAll = function() {
          for (var e2 = this.nestedArray, t2 = 0; t2 < e2.length; ) e2[t2] instanceof u ? e2[t2++].resolveAll() : e2[t2++].resolve();
          return this.resolve();
        }, u.prototype.lookup = function(e2, t2, i2) {
          if ("boolean" == typeof t2 ? (i2 = t2, t2 = void 0) : t2 && !Array.isArray(t2) && (t2 = [t2]), c.isString(e2) && e2.length) {
            if ("." === e2) return this.root;
            e2 = e2.split(".");
          } else if (!e2.length) return this;
          if ("" === e2[0]) return this.root.lookup(e2.slice(1), t2);
          var r2 = this.get(e2[0]);
          if (r2) {
            if (1 === e2.length) {
              if (!t2 || t2.indexOf(r2.constructor) > -1) return r2;
            } else if (r2 instanceof u && (r2 = r2.lookup(e2.slice(1), t2, true))) return r2;
          } else for (var s2 = 0; s2 < this.nestedArray.length; ++s2) if (this._nestedArray[s2] instanceof u && (r2 = this._nestedArray[s2].lookup(e2, t2, true))) return r2;
          return null === this.parent || i2 ? null : this.parent.lookup(e2, t2);
        }, u.prototype.lookupType = function(e2) {
          var t2 = this.lookup(e2, [s]);
          if (!t2) throw Error("no such type: " + e2);
          return t2;
        }, u.prototype.lookupEnum = function(e2) {
          var t2 = this.lookup(e2, [o]);
          if (!t2) throw Error("no such Enum '" + e2 + "' in " + this);
          return t2;
        }, u.prototype.lookupTypeOrEnum = function(e2) {
          var t2 = this.lookup(e2, [s, o]);
          if (!t2) throw Error("no such Type or Enum '" + e2 + "' in " + this);
          return t2;
        }, u.prototype.lookupService = function(e2) {
          var t2 = this.lookup(e2, [a]);
          if (!t2) throw Error("no such Service '" + e2 + "' in " + this);
          return t2;
        }, u._configure = function(e2, t2, i2) {
          s = e2, a = t2, o = i2;
        };
      }, function(e, t, i) {
        "use strict";
        var r = t, s = i(19), a = ["double", "float", "int32", "uint32", "sint32", "fixed32", "sfixed32", "int64", "uint64", "sint64", "fixed64", "sfixed64", "bool", "string", "bytes"];
        function o(e2, t2) {
          var i2 = 0, r2 = {};
          for (t2 |= 0; i2 < e2.length; ) r2[a[i2 + t2]] = e2[i2++];
          return r2;
        }
        r.basic = o([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2, 2]), r.defaults = o([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, false, "", s.emptyArray, null]), r.long = o([0, 0, 0, 1, 1], 7), r.mapKey = o([0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0, 2], 2), r.packed = o([1, 5, 0, 0, 0, 5, 5, 0, 0, 0, 1, 1, 0]);
      }, function(e, t, i) {
        var r = /* @__PURE__ */ function() {
          return this;
        }() || Function("return this")(), s = r.regeneratorRuntime && Object.getOwnPropertyNames(r).indexOf("regeneratorRuntime") >= 0, a = s && r.regeneratorRuntime;
        if (r.regeneratorRuntime = void 0, e.exports = i(94), s) r.regeneratorRuntime = a;
        else try {
          delete r.regeneratorRuntime;
        } catch (e2) {
          r.regeneratorRuntime = void 0;
        }
      }, function(e, t) {
        !function(t2) {
          "use strict";
          var i = Object.prototype, r = i.hasOwnProperty, s = "function" == typeof Symbol ? Symbol : {}, a = s.iterator || "@@iterator", o = s.asyncIterator || "@@asyncIterator", n = s.toStringTag || "@@toStringTag", d = "object" == typeof e, c = t2.regeneratorRuntime;
          if (c) d && (e.exports = c);
          else {
            (c = t2.regeneratorRuntime = d ? e.exports : {}).wrap = g;
            var l = {}, u = {};
            u[a] = function() {
              return this;
            };
            var h = Object.getPrototypeOf, p = h && h(h(I([])));
            p && p !== i && r.call(p, a) && (u = p);
            var m = y.prototype = v.prototype = Object.create(u);
            S.prototype = m.constructor = y, y.constructor = S, y[n] = S.displayName = "GeneratorFunction", c.isGeneratorFunction = function(e2) {
              var t3 = "function" == typeof e2 && e2.constructor;
              return !!t3 && (t3 === S || "GeneratorFunction" === (t3.displayName || t3.name));
            }, c.mark = function(e2) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(e2, y) : (e2.__proto__ = y, n in e2 || (e2[n] = "GeneratorFunction")), e2.prototype = Object.create(m), e2;
            }, c.awrap = function(e2) {
              return { __await: e2 };
            }, _(R.prototype), R.prototype[o] = function() {
              return this;
            }, c.AsyncIterator = R, c.async = function(e2, t3, i2, r2) {
              var s2 = new R(g(e2, t3, i2, r2));
              return c.isGeneratorFunction(t3) ? s2 : s2.next().then(function(e3) {
                return e3.done ? e3.value : s2.next();
              });
            }, _(m), m[n] = "Generator", m[a] = function() {
              return this;
            }, m.toString = function() {
              return "[object Generator]";
            }, c.keys = function(e2) {
              var t3 = [];
              for (var i2 in e2) t3.push(i2);
              return t3.reverse(), function i3() {
                for (; t3.length; ) {
                  var r2 = t3.pop();
                  if (r2 in e2) return i3.value = r2, i3.done = false, i3;
                }
                return i3.done = true, i3;
              };
            }, c.values = I, A.prototype = { constructor: A, reset: function(e2) {
              if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(E), !e2) for (var t3 in this) "t" === t3.charAt(0) && r.call(this, t3) && !isNaN(+t3.slice(1)) && (this[t3] = void 0);
            }, stop: function() {
              this.done = true;
              var e2 = this.tryEntries[0].completion;
              if ("throw" === e2.type) throw e2.arg;
              return this.rval;
            }, dispatchException: function(e2) {
              if (this.done) throw e2;
              var t3 = this;
              function i2(i3, r2) {
                return o2.type = "throw", o2.arg = e2, t3.next = i3, r2 && (t3.method = "next", t3.arg = void 0), !!r2;
              }
              for (var s2 = this.tryEntries.length - 1; s2 >= 0; --s2) {
                var a2 = this.tryEntries[s2], o2 = a2.completion;
                if ("root" === a2.tryLoc) return i2("end");
                if (a2.tryLoc <= this.prev) {
                  var n2 = r.call(a2, "catchLoc"), d2 = r.call(a2, "finallyLoc");
                  if (n2 && d2) {
                    if (this.prev < a2.catchLoc) return i2(a2.catchLoc, true);
                    if (this.prev < a2.finallyLoc) return i2(a2.finallyLoc);
                  } else if (n2) {
                    if (this.prev < a2.catchLoc) return i2(a2.catchLoc, true);
                  } else {
                    if (!d2) throw new Error("try statement without catch or finally");
                    if (this.prev < a2.finallyLoc) return i2(a2.finallyLoc);
                  }
                }
              }
            }, abrupt: function(e2, t3) {
              for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
                var s2 = this.tryEntries[i2];
                if (s2.tryLoc <= this.prev && r.call(s2, "finallyLoc") && this.prev < s2.finallyLoc) {
                  var a2 = s2;
                  break;
                }
              }
              a2 && ("break" === e2 || "continue" === e2) && a2.tryLoc <= t3 && t3 <= a2.finallyLoc && (a2 = null);
              var o2 = a2 ? a2.completion : {};
              return o2.type = e2, o2.arg = t3, a2 ? (this.method = "next", this.next = a2.finallyLoc, l) : this.complete(o2);
            }, complete: function(e2, t3) {
              if ("throw" === e2.type) throw e2.arg;
              return "break" === e2.type || "continue" === e2.type ? this.next = e2.arg : "return" === e2.type ? (this.rval = this.arg = e2.arg, this.method = "return", this.next = "end") : "normal" === e2.type && t3 && (this.next = t3), l;
            }, finish: function(e2) {
              for (var t3 = this.tryEntries.length - 1; t3 >= 0; --t3) {
                var i2 = this.tryEntries[t3];
                if (i2.finallyLoc === e2) return this.complete(i2.completion, i2.afterLoc), E(i2), l;
              }
            }, catch: function(e2) {
              for (var t3 = this.tryEntries.length - 1; t3 >= 0; --t3) {
                var i2 = this.tryEntries[t3];
                if (i2.tryLoc === e2) {
                  var r2 = i2.completion;
                  if ("throw" === r2.type) {
                    var s2 = r2.arg;
                    E(i2);
                  }
                  return s2;
                }
              }
              throw new Error("illegal catch attempt");
            }, delegateYield: function(e2, t3, i2) {
              return this.delegate = { iterator: I(e2), resultName: t3, nextLoc: i2 }, "next" === this.method && (this.arg = void 0), l;
            } };
          }
          function g(e2, t3, i2, r2) {
            var s2 = t3 && t3.prototype instanceof v ? t3 : v, a2 = Object.create(s2.prototype), o2 = new A(r2 || []);
            return a2._invoke = /* @__PURE__ */ function(e3, t4, i3) {
              var r3 = "suspendedStart";
              return function(s3, a3) {
                if ("executing" === r3) throw new Error("Generator is already running");
                if ("completed" === r3) {
                  if ("throw" === s3) throw a3;
                  return w();
                }
                for (i3.method = s3, i3.arg = a3; ; ) {
                  var o3 = i3.delegate;
                  if (o3) {
                    var n2 = b(o3, i3);
                    if (n2) {
                      if (n2 === l) continue;
                      return n2;
                    }
                  }
                  if ("next" === i3.method) i3.sent = i3._sent = i3.arg;
                  else if ("throw" === i3.method) {
                    if ("suspendedStart" === r3) throw r3 = "completed", i3.arg;
                    i3.dispatchException(i3.arg);
                  } else "return" === i3.method && i3.abrupt("return", i3.arg);
                  r3 = "executing";
                  var d2 = f(e3, t4, i3);
                  if ("normal" === d2.type) {
                    if (r3 = i3.done ? "completed" : "suspendedYield", d2.arg === l) continue;
                    return { value: d2.arg, done: i3.done };
                  }
                  "throw" === d2.type && (r3 = "completed", i3.method = "throw", i3.arg = d2.arg);
                }
              };
            }(e2, i2, o2), a2;
          }
          function f(e2, t3, i2) {
            try {
              return { type: "normal", arg: e2.call(t3, i2) };
            } catch (e3) {
              return { type: "throw", arg: e3 };
            }
          }
          function v() {
          }
          function S() {
          }
          function y() {
          }
          function _(e2) {
            ["next", "throw", "return"].forEach(function(t3) {
              e2[t3] = function(e3) {
                return this._invoke(t3, e3);
              };
            });
          }
          function R(e2) {
            var t3;
            this._invoke = function(i2, s2) {
              function a2() {
                return new Promise(function(t4, a3) {
                  !function t5(i3, s3, a4, o2) {
                    var n2 = f(e2[i3], e2, s3);
                    if ("throw" !== n2.type) {
                      var d2 = n2.arg, c2 = d2.value;
                      return c2 && "object" == typeof c2 && r.call(c2, "__await") ? Promise.resolve(c2.__await).then(function(e3) {
                        t5("next", e3, a4, o2);
                      }, function(e3) {
                        t5("throw", e3, a4, o2);
                      }) : Promise.resolve(c2).then(function(e3) {
                        d2.value = e3, a4(d2);
                      }, o2);
                    }
                    o2(n2.arg);
                  }(i2, s2, t4, a3);
                });
              }
              return t3 = t3 ? t3.then(a2, a2) : a2();
            };
          }
          function b(e2, t3) {
            var i2 = e2.iterator[t3.method];
            if (void 0 === i2) {
              if (t3.delegate = null, "throw" === t3.method) {
                if (e2.iterator.return && (t3.method = "return", t3.arg = void 0, b(e2, t3), "throw" === t3.method)) return l;
                t3.method = "throw", t3.arg = new TypeError("The iterator does not provide a 'throw' method");
              }
              return l;
            }
            var r2 = f(i2, e2.iterator, t3.arg);
            if ("throw" === r2.type) return t3.method = "throw", t3.arg = r2.arg, t3.delegate = null, l;
            var s2 = r2.arg;
            return s2 ? s2.done ? (t3[e2.resultName] = s2.value, t3.next = e2.nextLoc, "return" !== t3.method && (t3.method = "next", t3.arg = void 0), t3.delegate = null, l) : s2 : (t3.method = "throw", t3.arg = new TypeError("iterator result is not an object"), t3.delegate = null, l);
          }
          function T(e2) {
            var t3 = { tryLoc: e2[0] };
            1 in e2 && (t3.catchLoc = e2[1]), 2 in e2 && (t3.finallyLoc = e2[2], t3.afterLoc = e2[3]), this.tryEntries.push(t3);
          }
          function E(e2) {
            var t3 = e2.completion || {};
            t3.type = "normal", delete t3.arg, e2.completion = t3;
          }
          function A(e2) {
            this.tryEntries = [{ tryLoc: "root" }], e2.forEach(T, this), this.reset(true);
          }
          function I(e2) {
            if (e2) {
              var t3 = e2[a];
              if (t3) return t3.call(e2);
              if ("function" == typeof e2.next) return e2;
              if (!isNaN(e2.length)) {
                var i2 = -1, s2 = function t4() {
                  for (; ++i2 < e2.length; ) if (r.call(e2, i2)) return t4.value = e2[i2], t4.done = false, t4;
                  return t4.value = void 0, t4.done = true, t4;
                };
                return s2.next = s2;
              }
            }
            return { next: w };
          }
          function w() {
            return { value: void 0, done: true };
          }
        }(/* @__PURE__ */ function() {
          return this;
        }() || Function("return this")());
      }, function(e, t, i) {
        e.exports = { default: i(96), __esModule: true };
      }, function(e, t, i) {
        i(51), i(52), i(61), i(107), i(119), i(120), e.exports = i(4).Promise;
      }, function(e, t, i) {
        var r = i(30), s = i(31);
        e.exports = function(e2) {
          return function(t2, i2) {
            var a, o, n = String(s(t2)), d = r(i2), c = n.length;
            return d < 0 || d >= c ? e2 ? "" : void 0 : (a = n.charCodeAt(d)) < 55296 || a > 56319 || d + 1 === c || (o = n.charCodeAt(d + 1)) < 56320 || o > 57343 ? e2 ? n.charAt(d) : a : e2 ? n.slice(d, d + 2) : o - 56320 + (a - 55296 << 10) + 65536;
          };
        };
      }, function(e, t, i) {
        "use strict";
        var r = i(56), s = i(23), a = i(25), o = {};
        i(9)(o, i(2)("iterator"), function() {
          return this;
        }), e.exports = function(e2, t2, i2) {
          e2.prototype = r(o, { next: s(1, i2) }), a(e2, t2 + " Iterator");
        };
      }, function(e, t, i) {
        var r = i(10), s = i(5), a = i(34);
        e.exports = i(12) ? Object.defineProperties : function(e2, t2) {
          s(e2);
          for (var i2, o = a(t2), n = o.length, d = 0; n > d; ) r.f(e2, i2 = o[d++], t2[i2]);
          return e2;
        };
      }, function(e, t, i) {
        var r = i(18);
        e.exports = Object("z").propertyIsEnumerable(0) ? Object : function(e2) {
          return "String" == r(e2) ? e2.split("") : Object(e2);
        };
      }, function(e, t, i) {
        var r = i(14), s = i(58), a = i(102);
        e.exports = function(e2) {
          return function(t2, i2, o) {
            var n, d = r(t2), c = s(d.length), l = a(o, c);
            if (e2 && i2 != i2) {
              for (; c > l; ) if ((n = d[l++]) != n) return true;
            } else for (; c > l; l++) if ((e2 || l in d) && d[l] === i2) return e2 || l || 0;
            return !e2 && -1;
          };
        };
      }, function(e, t, i) {
        var r = i(30), s = Math.max, a = Math.min;
        e.exports = function(e2, t2) {
          return (e2 = r(e2)) < 0 ? s(e2 + t2, 0) : a(e2, t2);
        };
      }, function(e, t, i) {
        var r = i(13), s = i(60), a = i(35)("IE_PROTO"), o = Object.prototype;
        e.exports = Object.getPrototypeOf || function(e2) {
          return e2 = s(e2), r(e2, a) ? e2[a] : "function" == typeof e2.constructor && e2 instanceof e2.constructor ? e2.constructor.prototype : e2 instanceof Object ? o : null;
        };
      }, function(e, t, i) {
        "use strict";
        var r = i(105), s = i(106), a = i(17), o = i(14);
        e.exports = i(53)(Array, "Array", function(e2, t2) {
          this._t = o(e2), this._i = 0, this._k = t2;
        }, function() {
          var e2 = this._t, t2 = this._k, i2 = this._i++;
          return !e2 || i2 >= e2.length ? (this._t = void 0, s(1)) : s(0, "keys" == t2 ? i2 : "values" == t2 ? e2[i2] : [i2, e2[i2]]);
        }, "values"), a.Arguments = a.Array, r("keys"), r("values"), r("entries");
      }, function(e, t) {
        e.exports = function() {
        };
      }, function(e, t) {
        e.exports = function(e2, t2) {
          return { value: t2, done: !!e2 };
        };
      }, function(e, t, i) {
        "use strict";
        var r, s, a, o, n = i(15), d = i(0), c = i(20), l = i(62), u = i(16), h = i(11), p = i(21), m = i(108), g = i(109), f = i(63), v = i(64).set, S = i(114)(), y = i(38), _ = i(65), R = i(115), b = i(66), T = d.TypeError, E = d.process, A = E && E.versions, I = A && A.v8 || "", w = d.Promise, C = "process" == l(E), O = function() {
        }, k = s = y.f, P = !!function() {
          try {
            var e2 = w.resolve(1), t2 = (e2.constructor = {})[i(2)("species")] = function(e3) {
              e3(O, O);
            };
            return (C || "function" == typeof PromiseRejectionEvent) && e2.then(O) instanceof t2 && 0 !== I.indexOf("6.6") && -1 === R.indexOf("Chrome/66");
          } catch (e3) {
          }
        }(), x = function(e2) {
          var t2;
          return !(!h(e2) || "function" != typeof (t2 = e2.then)) && t2;
        }, M = function(e2, t2) {
          if (!e2._n) {
            e2._n = true;
            var i2 = e2._c;
            S(function() {
              for (var r2 = e2._v, s2 = 1 == e2._s, a2 = 0, o2 = function(t3) {
                var i3, a3, o3, n2 = s2 ? t3.ok : t3.fail, d2 = t3.resolve, c2 = t3.reject, l2 = t3.domain;
                try {
                  n2 ? (s2 || (2 == e2._h && L(e2), e2._h = 1), true === n2 ? i3 = r2 : (l2 && l2.enter(), i3 = n2(r2), l2 && (l2.exit(), o3 = true)), i3 === t3.promise ? c2(T("Promise-chain cycle")) : (a3 = x(i3)) ? a3.call(i3, d2, c2) : d2(i3)) : c2(r2);
                } catch (e3) {
                  l2 && !o3 && l2.exit(), c2(e3);
                }
              }; i2.length > a2; ) o2(i2[a2++]);
              e2._c = [], e2._n = false, t2 && !e2._h && D(e2);
            });
          }
        }, D = function(e2) {
          v.call(d, function() {
            var t2, i2, r2, s2 = e2._v, a2 = N(e2);
            if (a2 && (t2 = _(function() {
              C ? E.emit("unhandledRejection", s2, e2) : (i2 = d.onunhandledrejection) ? i2({ promise: e2, reason: s2 }) : (r2 = d.console) && r2.error && r2.error("Unhandled promise rejection", s2);
            }), e2._h = C || N(e2) ? 2 : 1), e2._a = void 0, a2 && t2.e) throw t2.v;
          });
        }, N = function(e2) {
          return 1 !== e2._h && 0 === (e2._a || e2._c).length;
        }, L = function(e2) {
          v.call(d, function() {
            var t2;
            C ? E.emit("rejectionHandled", e2) : (t2 = d.onrejectionhandled) && t2({ promise: e2, reason: e2._v });
          });
        }, F = function(e2) {
          var t2 = this;
          t2._d || (t2._d = true, (t2 = t2._w || t2)._v = e2, t2._s = 2, t2._a || (t2._a = t2._c.slice()), M(t2, true));
        }, V = function(e2) {
          var t2, i2 = this;
          if (!i2._d) {
            i2._d = true, i2 = i2._w || i2;
            try {
              if (i2 === e2) throw T("Promise can't be resolved itself");
              (t2 = x(e2)) ? S(function() {
                var r2 = { _w: i2, _d: false };
                try {
                  t2.call(e2, c(V, r2, 1), c(F, r2, 1));
                } catch (e3) {
                  F.call(r2, e3);
                }
              }) : (i2._v = e2, i2._s = 1, M(i2, false));
            } catch (e3) {
              F.call({ _w: i2, _d: false }, e3);
            }
          }
        };
        P || (w = function(e2) {
          m(this, w, "Promise", "_h"), p(e2), r.call(this);
          try {
            e2(c(V, this, 1), c(F, this, 1));
          } catch (e3) {
            F.call(this, e3);
          }
        }, (r = function(e2) {
          this._c = [], this._a = void 0, this._s = 0, this._d = false, this._v = void 0, this._h = 0, this._n = false;
        }).prototype = i(116)(w.prototype, { then: function(e2, t2) {
          var i2 = k(f(this, w));
          return i2.ok = "function" != typeof e2 || e2, i2.fail = "function" == typeof t2 && t2, i2.domain = C ? E.domain : void 0, this._c.push(i2), this._a && this._a.push(i2), this._s && M(this, false), i2.promise;
        }, catch: function(e2) {
          return this.then(void 0, e2);
        } }), a = function() {
          var e2 = new r();
          this.promise = e2, this.resolve = c(V, e2, 1), this.reject = c(F, e2, 1);
        }, y.f = k = function(e2) {
          return e2 === w || e2 === o ? new a(e2) : s(e2);
        }), u(u.G + u.W + u.F * !P, { Promise: w }), i(25)(w, "Promise"), i(117)("Promise"), o = i(4).Promise, u(u.S + u.F * !P, "Promise", { reject: function(e2) {
          var t2 = k(this);
          return (0, t2.reject)(e2), t2.promise;
        } }), u(u.S + u.F * (n || !P), "Promise", { resolve: function(e2) {
          return b(n && this === o ? w : this, e2);
        } }), u(u.S + u.F * !(P && i(118)(function(e2) {
          w.all(e2).catch(O);
        })), "Promise", { all: function(e2) {
          var t2 = this, i2 = k(t2), r2 = i2.resolve, s2 = i2.reject, a2 = _(function() {
            var i3 = [], a3 = 0, o2 = 1;
            g(e2, false, function(e3) {
              var n2 = a3++, d2 = false;
              i3.push(void 0), o2++, t2.resolve(e3).then(function(e4) {
                d2 || (d2 = true, i3[n2] = e4, --o2 || r2(i3));
              }, s2);
            }), --o2 || r2(i3);
          });
          return a2.e && s2(a2.v), i2.promise;
        }, race: function(e2) {
          var t2 = this, i2 = k(t2), r2 = i2.reject, s2 = _(function() {
            g(e2, false, function(e3) {
              t2.resolve(e3).then(i2.resolve, r2);
            });
          });
          return s2.e && r2(s2.v), i2.promise;
        } });
      }, function(e, t) {
        e.exports = function(e2, t2, i, r) {
          if (!(e2 instanceof t2) || void 0 !== r && r in e2) throw TypeError(i + ": incorrect invocation!");
          return e2;
        };
      }, function(e, t, i) {
        var r = i(20), s = i(110), a = i(111), o = i(5), n = i(58), d = i(112), c = {}, l = {};
        (t = e.exports = function(e2, t2, i2, u, h) {
          var p, m, g, f, v = h ? function() {
            return e2;
          } : d(e2), S = r(i2, u, t2 ? 2 : 1), y = 0;
          if ("function" != typeof v) throw TypeError(e2 + " is not iterable!");
          if (a(v)) {
            for (p = n(e2.length); p > y; y++) if ((f = t2 ? S(o(m = e2[y])[0], m[1]) : S(e2[y])) === c || f === l) return f;
          } else for (g = v.call(e2); !(m = g.next()).done; ) if ((f = s(g, S, m.value, t2)) === c || f === l) return f;
        }).BREAK = c, t.RETURN = l;
      }, function(e, t, i) {
        var r = i(5);
        e.exports = function(e2, t2, i2, s) {
          try {
            return s ? t2(r(i2)[0], i2[1]) : t2(i2);
          } catch (t3) {
            var a = e2.return;
            throw void 0 !== a && r(a.call(e2)), t3;
          }
        };
      }, function(e, t, i) {
        var r = i(17), s = i(2)("iterator"), a = Array.prototype;
        e.exports = function(e2) {
          return void 0 !== e2 && (r.Array === e2 || a[s] === e2);
        };
      }, function(e, t, i) {
        var r = i(62), s = i(2)("iterator"), a = i(17);
        e.exports = i(4).getIteratorMethod = function(e2) {
          if (null != e2) return e2[s] || e2["@@iterator"] || a[r(e2)];
        };
      }, function(e, t) {
        e.exports = function(e2, t2, i) {
          var r = void 0 === i;
          switch (t2.length) {
            case 0:
              return r ? e2() : e2.call(i);
            case 1:
              return r ? e2(t2[0]) : e2.call(i, t2[0]);
            case 2:
              return r ? e2(t2[0], t2[1]) : e2.call(i, t2[0], t2[1]);
            case 3:
              return r ? e2(t2[0], t2[1], t2[2]) : e2.call(i, t2[0], t2[1], t2[2]);
            case 4:
              return r ? e2(t2[0], t2[1], t2[2], t2[3]) : e2.call(i, t2[0], t2[1], t2[2], t2[3]);
          }
          return e2.apply(i, t2);
        };
      }, function(e, t, i) {
        var r = i(0), s = i(64).set, a = r.MutationObserver || r.WebKitMutationObserver, o = r.process, n = r.Promise, d = "process" == i(18)(o);
        e.exports = function() {
          var e2, t2, i2, c = function() {
            var r2, s2;
            for (d && (r2 = o.domain) && r2.exit(); e2; ) {
              s2 = e2.fn, e2 = e2.next;
              try {
                s2();
              } catch (r3) {
                throw e2 ? i2() : t2 = void 0, r3;
              }
            }
            t2 = void 0, r2 && r2.enter();
          };
          if (d) i2 = function() {
            o.nextTick(c);
          };
          else if (!a || r.navigator && r.navigator.standalone) if (n && n.resolve) {
            var l = n.resolve(void 0);
            i2 = function() {
              l.then(c);
            };
          } else i2 = function() {
            s.call(r, c);
          };
          else {
            var u = true, h = document.createTextNode("");
            new a(c).observe(h, { characterData: true }), i2 = function() {
              h.data = u = !u;
            };
          }
          return function(r2) {
            var s2 = { fn: r2, next: void 0 };
            t2 && (t2.next = s2), e2 || (e2 = s2, i2()), t2 = s2;
          };
        };
      }, function(e, t, i) {
        var r = i(0).navigator;
        e.exports = r && r.userAgent || "";
      }, function(e, t, i) {
        var r = i(9);
        e.exports = function(e2, t2, i2) {
          for (var s in t2) i2 && e2[s] ? e2[s] = t2[s] : r(e2, s, t2[s]);
          return e2;
        };
      }, function(e, t, i) {
        "use strict";
        var r = i(0), s = i(4), a = i(10), o = i(12), n = i(2)("species");
        e.exports = function(e2) {
          var t2 = "function" == typeof s[e2] ? s[e2] : r[e2];
          o && t2 && !t2[n] && a.f(t2, n, { configurable: true, get: function() {
            return this;
          } });
        };
      }, function(e, t, i) {
        var r = i(2)("iterator"), s = false;
        try {
          var a = [7][r]();
          a.return = function() {
            s = true;
          }, Array.from(a, function() {
            throw 2;
          });
        } catch (e2) {
        }
        e.exports = function(e2, t2) {
          if (!t2 && !s) return false;
          var i2 = false;
          try {
            var a2 = [7], o = a2[r]();
            o.next = function() {
              return { done: i2 = true };
            }, a2[r] = function() {
              return o;
            }, e2(a2);
          } catch (e3) {
          }
          return i2;
        };
      }, function(e, t, i) {
        "use strict";
        var r = i(16), s = i(4), a = i(0), o = i(63), n = i(66);
        r(r.P + r.R, "Promise", { finally: function(e2) {
          var t2 = o(this, s.Promise || a.Promise), i2 = "function" == typeof e2;
          return this.then(i2 ? function(i3) {
            return n(t2, e2()).then(function() {
              return i3;
            });
          } : e2, i2 ? function(i3) {
            return n(t2, e2()).then(function() {
              throw i3;
            });
          } : e2);
        } });
      }, function(e, t, i) {
        "use strict";
        var r = i(16), s = i(38), a = i(65);
        r(r.S, "Promise", { try: function(e2) {
          var t2 = s.f(this), i2 = a(e2);
          return (i2.e ? t2.reject : t2.resolve)(i2.v), t2.promise;
        } });
      }, function(e, t, i) {
        "use strict";
        t.__esModule = true;
        var r = o(i(122)), s = o(i(124)), a = "function" == typeof s.default && "symbol" == typeof r.default ? function(e2) {
          return typeof e2;
        } : function(e2) {
          return e2 && "function" == typeof s.default && e2.constructor === s.default && e2 !== s.default.prototype ? "symbol" : typeof e2;
        };
        function o(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        t.default = "function" == typeof s.default && "symbol" === a(r.default) ? function(e2) {
          return void 0 === e2 ? "undefined" : a(e2);
        } : function(e2) {
          return e2 && "function" == typeof s.default && e2.constructor === s.default && e2 !== s.default.prototype ? "symbol" : void 0 === e2 ? "undefined" : a(e2);
        };
      }, function(e, t, i) {
        e.exports = { default: i(123), __esModule: true };
      }, function(e, t, i) {
        i(52), i(61), e.exports = i(39).f("iterator");
      }, function(e, t, i) {
        e.exports = { default: i(125), __esModule: true };
      }, function(e, t, i) {
        i(126), i(51), i(132), i(133), e.exports = i(4).Symbol;
      }, function(e, t, i) {
        "use strict";
        var r = i(0), s = i(13), a = i(12), o = i(16), n = i(55), d = i(127).KEY, c = i(22), l = i(36), u = i(25), h = i(24), p = i(2), m = i(39), g = i(40), f = i(128), v = i(129), S = i(5), y = i(11), _ = i(60), R = i(14), b = i(33), T = i(23), E = i(56), A = i(130), I = i(131), w = i(67), C = i(10), O = i(34), k = I.f, P = C.f, x = A.f, M = r.Symbol, D = r.JSON, N = D && D.stringify, L = p("_hidden"), F = p("toPrimitive"), V = {}.propertyIsEnumerable, H = l("symbol-registry"), j = l("symbols"), U = l("op-symbols"), B = Object.prototype, $ = "function" == typeof M && !!w.f, W = r.QObject, G = !W || !W.prototype || !W.prototype.findChild, J = a && c(function() {
          return 7 != E(P({}, "a", { get: function() {
            return P(this, "a", { value: 7 }).a;
          } })).a;
        }) ? function(e2, t2, i2) {
          var r2 = k(B, t2);
          r2 && delete B[t2], P(e2, t2, i2), r2 && e2 !== B && P(B, t2, r2);
        } : P, q = function(e2) {
          var t2 = j[e2] = E(M.prototype);
          return t2._k = e2, t2;
        }, z = $ && "symbol" == typeof M.iterator ? function(e2) {
          return "symbol" == typeof e2;
        } : function(e2) {
          return e2 instanceof M;
        }, Y = function(e2, t2, i2) {
          return e2 === B && Y(U, t2, i2), S(e2), t2 = b(t2, true), S(i2), s(j, t2) ? (i2.enumerable ? (s(e2, L) && e2[L][t2] && (e2[L][t2] = false), i2 = E(i2, { enumerable: T(0, false) })) : (s(e2, L) || P(e2, L, T(1, {})), e2[L][t2] = true), J(e2, t2, i2)) : P(e2, t2, i2);
        }, K = function(e2, t2) {
          S(e2);
          for (var i2, r2 = f(t2 = R(t2)), s2 = 0, a2 = r2.length; a2 > s2; ) Y(e2, i2 = r2[s2++], t2[i2]);
          return e2;
        }, Q = function(e2) {
          var t2 = V.call(this, e2 = b(e2, true));
          return !(this === B && s(j, e2) && !s(U, e2)) && (!(t2 || !s(this, e2) || !s(j, e2) || s(this, L) && this[L][e2]) || t2);
        }, X = function(e2, t2) {
          if (e2 = R(e2), t2 = b(t2, true), e2 !== B || !s(j, t2) || s(U, t2)) {
            var i2 = k(e2, t2);
            return !i2 || !s(j, t2) || s(e2, L) && e2[L][t2] || (i2.enumerable = true), i2;
          }
        }, Z = function(e2) {
          for (var t2, i2 = x(R(e2)), r2 = [], a2 = 0; i2.length > a2; ) s(j, t2 = i2[a2++]) || t2 == L || t2 == d || r2.push(t2);
          return r2;
        }, ee = function(e2) {
          for (var t2, i2 = e2 === B, r2 = x(i2 ? U : R(e2)), a2 = [], o2 = 0; r2.length > o2; ) !s(j, t2 = r2[o2++]) || i2 && !s(B, t2) || a2.push(j[t2]);
          return a2;
        };
        $ || (n((M = function() {
          if (this instanceof M) throw TypeError("Symbol is not a constructor!");
          var e2 = h(arguments.length > 0 ? arguments[0] : void 0), t2 = function(i2) {
            this === B && t2.call(U, i2), s(this, L) && s(this[L], e2) && (this[L][e2] = false), J(this, e2, T(1, i2));
          };
          return a && G && J(B, e2, { configurable: true, set: t2 }), q(e2);
        }).prototype, "toString", function() {
          return this._k;
        }), I.f = X, C.f = Y, i(68).f = A.f = Z, i(41).f = Q, w.f = ee, a && !i(15) && n(B, "propertyIsEnumerable", Q, true), m.f = function(e2) {
          return q(p(e2));
        }), o(o.G + o.W + o.F * !$, { Symbol: M });
        for (var te = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), ie = 0; te.length > ie; ) p(te[ie++]);
        for (var re = O(p.store), se = 0; re.length > se; ) g(re[se++]);
        o(o.S + o.F * !$, "Symbol", { for: function(e2) {
          return s(H, e2 += "") ? H[e2] : H[e2] = M(e2);
        }, keyFor: function(e2) {
          if (!z(e2)) throw TypeError(e2 + " is not a symbol!");
          for (var t2 in H) if (H[t2] === e2) return t2;
        }, useSetter: function() {
          G = true;
        }, useSimple: function() {
          G = false;
        } }), o(o.S + o.F * !$, "Object", { create: function(e2, t2) {
          return void 0 === t2 ? E(e2) : K(E(e2), t2);
        }, defineProperty: Y, defineProperties: K, getOwnPropertyDescriptor: X, getOwnPropertyNames: Z, getOwnPropertySymbols: ee });
        var ae = c(function() {
          w.f(1);
        });
        o(o.S + o.F * ae, "Object", { getOwnPropertySymbols: function(e2) {
          return w.f(_(e2));
        } }), D && o(o.S + o.F * (!$ || c(function() {
          var e2 = M();
          return "[null]" != N([e2]) || "{}" != N({ a: e2 }) || "{}" != N(Object(e2));
        })), "JSON", { stringify: function(e2) {
          for (var t2, i2, r2 = [e2], s2 = 1; arguments.length > s2; ) r2.push(arguments[s2++]);
          if (i2 = t2 = r2[1], (y(t2) || void 0 !== e2) && !z(e2)) return v(t2) || (t2 = function(e3, t3) {
            if ("function" == typeof i2 && (t3 = i2.call(this, e3, t3)), !z(t3)) return t3;
          }), r2[1] = t2, N.apply(D, r2);
        } }), M.prototype[F] || i(9)(M.prototype, F, M.prototype.valueOf), u(M, "Symbol"), u(Math, "Math", true), u(r.JSON, "JSON", true);
      }, function(e, t, i) {
        var r = i(24)("meta"), s = i(11), a = i(13), o = i(10).f, n = 0, d = Object.isExtensible || function() {
          return true;
        }, c = !i(22)(function() {
          return d(Object.preventExtensions({}));
        }), l = function(e2) {
          o(e2, r, { value: { i: "O" + ++n, w: {} } });
        }, u = e.exports = { KEY: r, NEED: false, fastKey: function(e2, t2) {
          if (!s(e2)) return "symbol" == typeof e2 ? e2 : ("string" == typeof e2 ? "S" : "P") + e2;
          if (!a(e2, r)) {
            if (!d(e2)) return "F";
            if (!t2) return "E";
            l(e2);
          }
          return e2[r].i;
        }, getWeak: function(e2, t2) {
          if (!a(e2, r)) {
            if (!d(e2)) return true;
            if (!t2) return false;
            l(e2);
          }
          return e2[r].w;
        }, onFreeze: function(e2) {
          return c && u.NEED && d(e2) && !a(e2, r) && l(e2), e2;
        } };
      }, function(e, t, i) {
        var r = i(34), s = i(67), a = i(41);
        e.exports = function(e2) {
          var t2 = r(e2), i2 = s.f;
          if (i2) for (var o, n = i2(e2), d = a.f, c = 0; n.length > c; ) d.call(e2, o = n[c++]) && t2.push(o);
          return t2;
        };
      }, function(e, t, i) {
        var r = i(18);
        e.exports = Array.isArray || function(e2) {
          return "Array" == r(e2);
        };
      }, function(e, t, i) {
        var r = i(14), s = i(68).f, a = {}.toString, o = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
        e.exports.f = function(e2) {
          return o && "[object Window]" == a.call(e2) ? function(e3) {
            try {
              return s(e3);
            } catch (e4) {
              return o.slice();
            }
          }(e2) : s(r(e2));
        };
      }, function(e, t, i) {
        var r = i(41), s = i(23), a = i(14), o = i(33), n = i(13), d = i(54), c = Object.getOwnPropertyDescriptor;
        t.f = i(12) ? c : function(e2, t2) {
          if (e2 = a(e2), t2 = o(t2, true), d) try {
            return c(e2, t2);
          } catch (e3) {
          }
          if (n(e2, t2)) return s(!r.f.call(e2, t2), e2[t2]);
        };
      }, function(e, t, i) {
        i(40)("asyncIterator");
      }, function(e, t, i) {
        i(40)("observable");
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createFrameBuffer = void 0;
        const r = i(75);
        t.createFrameBuffer = function(e2, t2, i2, s) {
          const a = e2.createFramebuffer();
          if (!a) return console.error("framebuffer created error."), null;
          const o = r.createTexture(e2, null, { width: t2, height: i2, genMipMaps: null != s && s });
          return o ? (e2.bindFramebuffer(e2.FRAMEBUFFER, a), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, o.glTexture, 0), e2.bindFramebuffer(e2.FRAMEBUFFER, null), { framebuffer: a, targetTexture: o, bind: (t3) => {
            t3 ? e2.bindFramebuffer(e2.FRAMEBUFFER, null) : e2.bindFramebuffer(e2.FRAMEBUFFER, a);
          } }) : null;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Program = void 0;
        const r = i(314), s = i(156), a = i(315), o = i(316);
        t.Program = class {
          constructor(e2, t2) {
            this.shaders = {}, this.uniforms = {}, this.attributes = {}, this.indices = null, this.gl = e2, this.draw = t2, this._program = e2.createProgram(), this.setShader(r.defaultShader.vShader, "VERTEX"), this.setShader(r.defaultShader.fShader, "FRAGMENT");
          }
          get program() {
            return this._program || console.error("program create error."), this._program;
          }
          parseUniforms() {
            const e2 = o.parseUniforms(this.gl, this.program);
            for (const t2 in e2) t2 in this.uniforms && e2[t2].setter(this.uniforms[t2].value);
            this.uniforms = e2;
          }
          parseAttributes() {
            const e2 = this.gl, t2 = s.parseAttributes(this.gl, this.program);
            for (const i2 in this.attributes) {
              const r2 = this.attributes[i2];
              if (i2 in t2) {
                const e3 = r2.attributeBuffer;
                e3 && t2[i2].bufferSetter(e3);
              } else e2.deleteBuffer(r2.buffer);
            }
            this.attributes = t2;
          }
          get count() {
            const e2 = this.attributes;
            let t2 = -1;
            for (const i2 in e2) {
              const r2 = e2[i2];
              -1 !== t2 && t2 !== r2.count && console.warn("inconsistent attribute length."), t2 = Math.max(t2, r2.count);
            }
            return t2;
          }
          setShader(e2, t2) {
            const i2 = this.gl, s2 = this.program, o2 = a.createShader(i2, e2, t2);
            if (o2) {
              const e3 = this.shaders[t2];
              e3 && (i2.detachShader(s2, e3), i2.deleteShader(e3)), i2.attachShader(s2, o2), this.shaders[t2] = o2, this.shaders.VERTEX && this.shaders.FRAGMENT && (i2.linkProgram(s2), this.parseUniforms(), this.parseAttributes());
            } else "VERTEX" === t2 ? this.setShader(r.defaultShader.vShader, "VERTEX") : this.setShader(r.defaultShader.fShader, "FRAGMENT");
          }
          getUniform(e2) {
            var t2;
            const i2 = null !== (t2 = this.uniforms[e2]) && void 0 !== t2 ? t2 : null;
            return i2 || console.warn(`uniform:[${e2}] does not exist.`), i2;
          }
          setUniform(e2, t2) {
            var i2;
            null === (i2 = this.getUniform(e2)) || void 0 === i2 || i2.setter(t2);
          }
          updateUniform(e2, t2) {
            var i2;
            const r2 = this.getUniform(e2);
            null == r2 || r2.setter(null !== (i2 = t2(r2.value)) && void 0 !== i2 ? i2 : r2.value);
          }
          setAttributeBuffer(e2) {
            var t2;
            e2 && (null === (t2 = this.getAttribute(e2.name)) || void 0 === t2 || t2.bufferSetter(e2));
          }
          getAttribute(e2) {
            return this.attributes[e2] || console.warn(`attribute:[${e2}] does not exist.`), this.attributes[e2];
          }
          setAttribute(e2, t2) {
            var i2;
            null === (i2 = this.getAttribute(e2)) || void 0 === i2 || i2.setter(t2);
          }
          updateAttribute(e2, t2) {
            var i2;
            const r2 = this.getAttribute(e2);
            null == r2 || r2.setter(null !== (i2 = t2(r2.typedArray)) && void 0 !== i2 ? i2 : r2.typedArray);
          }
          setIndices(e2) {
            if (e2 && "indices" === e2.name) {
              const t2 = this.gl;
              t2.bindBuffer(e2.target, e2.buffer), t2.bufferData(e2.target, e2.typedArray, e2.usage);
            }
            this.indices = e2;
          }
          render() {
            const e2 = this.gl, t2 = this.program;
            e2.useProgram(t2);
            const i2 = this.uniforms;
            for (const e3 in i2) i2[e3].setter();
            const r2 = this.attributes;
            for (const e3 in r2) {
              r2[e3].setter();
            }
            this.indices && e2.bindBuffer(this.indices.target, this.indices.buffer), this.draw ? this.draw() : e2.drawArrays(e2.TRIANGLE_STRIP, 0, this.count);
          }
          destroy(e2 = true) {
            var t2, i2;
            const r2 = this.gl;
            if (e2) {
              for (const e3 in this.attributes) {
                const t3 = this.attributes[e3];
                if (t3) {
                  const i3 = r2.getAttribLocation(this.program, e3);
                  r2.disableVertexAttribArray(i3), r2.deleteBuffer(t3.buffer);
                }
              }
              this.indices && r2.deleteBuffer(this.indices.buffer);
            }
            r2.deleteShader(null !== (t2 = this.shaders.VERTEX) && void 0 !== t2 ? t2 : null), r2.deleteShader(null !== (i2 = this.shaders.FRAGMENT) && void 0 !== i2 ? i2 : null), r2.deleteProgram(this.program);
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.baseTextureShader = void 0, t.baseTextureShader = { vShader: "\n    attribute vec4 position;\n    attribute vec2 uv;\n    varying vec2 vuv;\n    void main() {\n        gl_Position = position;\n        vuv = uv;\n    }\n", fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    varying vec2 vuv;\n    void main() {\n        gl_FragColor = texture2D(map, vuv);\n    }\n", yFlipFShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    varying vec2 vuv;\n    void main() {\n        gl_FragColor = texture2D(map, vec2(vuv.x, 1.0 - vuv.y));\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Filter = void 0;
        const r = i(3);
        class s extends r.EventEmitter {
          constructor(e2, t2, i2, r2) {
            super(), this.programs = {}, this.framebuffers = {}, this.renderer = e2, this._map = t2, this.posBuffer = i2, this.uvBuffer = r2;
          }
          get map() {
            return this._map;
          }
          set map(e2) {
          }
          get output() {
            return this._map;
          }
          updateSize() {
          }
          render() {
          }
          destroy(e2 = true) {
            this.removeAllListeners();
            const t2 = this.renderer.gl, i2 = this.framebuffers, r2 = this.programs;
            for (const e3 in i2) {
              const r3 = i2[e3];
              r3.bind(true), null == t2 || t2.deleteTexture(r3.targetTexture.glTexture), null == t2 || t2.deleteFramebuffer(r3.framebuffer);
            }
            for (const t3 in r2) {
              r2[t3].destroy(e2);
            }
          }
        }
        t.Filter = s;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.RemoteSdp = void 0;
        const o = a(i(50)), n = a(i(7)), d = i(1), c = i(29), l = i(229);
        t.RemoteSdp = class {
          constructor({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2, plainRtpParameters: s2, planB: a2 = false }) {
            if (this._mediaSections = [], this._midToIndex = /* @__PURE__ */ new Map(), this._iceParameters = e2, this._iceCandidates = t2, this._dtlsParameters = i2, this._sctpParameters = r2, this._plainRtpParameters = s2, this._planB = a2, this._sdpObject = { version: 0, origin: { address: "0.0.0.0", ipVer: 4, netType: "IN", sessionId: 1e4, sessionVersion: 0, username: "mediasoup-client" }, name: "-", timing: { start: 0, stop: 0 }, media: [] }, e2 && e2.iceLite && (this._sdpObject.icelite = "ice-lite"), i2) {
              this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
              const e3 = this._dtlsParameters.fingerprints.length;
              this._sdpObject.fingerprint = { type: i2.fingerprints[e3 - 1].algorithm, hash: i2.fingerprints[e3 - 1].value }, this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
            }
            s2 && (this._sdpObject.origin.address = s2.ip, this._sdpObject.origin.ipVer = s2.ipVersion);
          }
          updateIceParameters(e2) {
            c.Logger.debug("RemoteSdp", "updateIceParameters() [iceParameters:%o]", e2), this._iceParameters = e2, this._sdpObject.icelite = e2.iceLite ? "ice-lite" : void 0;
            for (const t2 of this._mediaSections) t2.setIceParameters(e2);
          }
          updateDtlsRole(e2) {
            c.Logger.debug("RemoteSdp", `updateDtlsRole() [role: ${e2}]`), this._dtlsParameters && (this._dtlsParameters.role = e2);
            for (const t2 of this._mediaSections) t2.setDtlsRole(e2);
          }
          getNextMediaSectionIdx() {
            if (d.getParameters().reuseMid) for (let e2 = 0; e2 < this._mediaSections.length; ++e2) {
              const t2 = this._mediaSections[e2];
              if (t2.closed) return { idx: e2, reuseMid: t2.mid };
            }
            return { idx: this._mediaSections.length };
          }
          send({ offerMediaObjectArr: e2, reuseMid: t2, offerRtpParameters: i2, answerRtpParameters: r2, codecOptions: s2, extmapAllowMixed: a2 = false }) {
            (null == e2 ? void 0 : e2.length) && e2.forEach((e3, o2) => {
              if (!e3) return;
              const n2 = new l.AnswerMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, plainRtpParameters: this._plainRtpParameters, planB: this._planB, offerMediaObject: e3, offerRtpParameters: i2, answerRtpParameters: r2, codecOptions: s2 ? s2[o2] : void 0, extmapAllowMixed: a2 });
              t2 ? this._replaceMediaSection(n2, t2) : this._addMediaSection(n2);
            });
          }
          receive({ mid: e2, kind: t2, offerRtpParameters: i2, streamId: r2, trackId: s2, reuseMid: a2 = null, reuseMediaSection: o2 }) {
            const n2 = this._midToIndex.get(e2);
            let d2;
            void 0 !== n2 && (d2 = this._mediaSections[n2]), d2 ? (d2 = new l.OfferMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, plainRtpParameters: this._plainRtpParameters, planB: this._planB, mid: e2, kind: t2, offerRtpParameters: i2, streamId: r2, trackId: s2 }), this._replaceMediaSection(d2, e2)) : (d2 = new l.OfferMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, plainRtpParameters: this._plainRtpParameters, planB: this._planB, mid: e2, kind: t2, offerRtpParameters: i2, streamId: r2, trackId: s2 }), null === a2 ? this._addMediaSection(d2) : this._replaceMediaSection(d2, a2));
          }
          disableMediaSection(e2) {
            const t2 = this._midToIndex.get(e2);
            if (void 0 === t2) return;
            this._mediaSections[t2].disable();
          }
          closeMediaSection(e2) {
            const t2 = this._midToIndex.get(e2);
            if (void 0 === t2) return;
            const i2 = this._mediaSections[t2];
            e2 === this._firstMid && c.Logger.debug("RemoteSdp", "closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", e2), i2.close();
          }
          planBStopReceiving({ mid: e2, offerRtpParameters: t2 }) {
            const i2 = this._midToIndex.get(e2);
            if (void 0 === i2) return;
            const r2 = this._mediaSections[i2];
            r2.planBStopReceiving({ offerRtpParameters: t2 }), this._replaceMediaSection(r2);
          }
          sendSctpAssociation({ offerMediaObject: e2 }) {
            const t2 = new l.AnswerMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, sctpParameters: this._sctpParameters, plainRtpParameters: this._plainRtpParameters, offerMediaObject: e2 });
            this._addMediaSection(t2);
          }
          receiveSctpAssociation({ oldDataChannelSpec: e2 = false } = {}) {
            const t2 = new l.OfferMediaSection({ iceParameters: this._iceParameters, iceCandidates: this._iceCandidates, dtlsParameters: this._dtlsParameters, sctpParameters: this._sctpParameters, plainRtpParameters: this._plainRtpParameters, mid: "datachannel", kind: "application", oldDataChannelSpec: e2 });
            this._addMediaSection(t2);
          }
          getSdp() {
            return this._sdpObject.origin.sessionVersion++, n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION >= 72 && this._sdpObject.media.sort(function(e2, t2) {
              return e2.mid - t2.mid;
            }), o.write(this._sdpObject);
          }
          _addMediaSection(e2) {
            this._firstMid || (this._firstMid = e2.mid), this._mediaSections.push(e2), this._midToIndex.set(e2.mid, this._mediaSections.length - 1), this._sdpObject.media.push(e2.getObject()), this._regenerateBundleMids();
          }
          _replaceMediaSection(e2, t2) {
            if ("string" == typeof t2) {
              const i2 = this._midToIndex.get(t2);
              if (void 0 === i2) return;
              const r2 = this._mediaSections[i2];
              this._mediaSections[i2] = e2, this._midToIndex.delete(r2.mid), this._midToIndex.set(e2.mid, i2), this._sdpObject.media[i2] = e2.getObject(), this._regenerateBundleMids();
            } else {
              const t3 = this._midToIndex.get(e2.mid);
              if (void 0 === t3) return;
              this._mediaSections[t3] = e2, this._sdpObject.media[t3] = e2.getObject();
            }
          }
          _regenerateBundleMids() {
            this._dtlsParameters && (this._sdpObject.groups[0].mids = this._mediaSections.filter((e2) => !e2.closed).map((e2) => e2.mid).join(" "));
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.addNackSuppportForOpus = t.mangleRtpParameters = t.getCapabilities = void 0;
        const o = a(i(27));
        t.getCapabilities = function() {
          const e2 = RTCRtpReceiver.getCapabilities(), t2 = o.clone(e2, {});
          for (const e3 of t2.codecs) {
            if (e3.channels = e3.numChannels, delete e3.numChannels, e3.mimeType = e3.mimeType || `${e3.kind}/${e3.name}`, e3.parameters) {
              const t3 = e3.parameters;
              t3.apt && (t3.apt = Number(t3.apt)), t3["packetization-mode"] && (t3["packetization-mode"] = Number(t3["packetization-mode"]));
            }
            for (const t3 of e3.rtcpFeedback || []) t3.parameter || (t3.parameter = "");
          }
          return t2;
        }, t.mangleRtpParameters = function(e2) {
          const t2 = o.clone(e2, {});
          t2.mid && (t2.muxId = t2.mid, delete t2.mid);
          for (const e3 of t2.codecs) e3.channels && (e3.numChannels = e3.channels, delete e3.channels), e3.mimeType && !e3.name && (e3.name = e3.mimeType.split("/")[1]), delete e3.mimeType;
          return t2;
        }, t.addNackSuppportForOpus = function(e2) {
          var t2;
          for (const i2 of e2.codecs || []) "audio/opus" !== i2.mimeType.toLowerCase() || (null === (t2 = i2.rtcpFeedback) || void 0 === t2 ? void 0 : t2.some((e3) => "nack" === e3.type && !e3.parameter)) || (i2.rtcpFeedback || (i2.rtcpFeedback = []), i2.rtcpFeedback.push({ type: "nack" }));
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.SimpleBig = void 0;
        class r {
          constructor(e2) {
            this.isSimpleBig = true, "string" == typeof e2 ? this.numStr = e2 : e2 > Number.MIN_SAFE_INTEGER ? this.numStr = e2.toString() : (console.error("Invalid numStr:", e2), this.numStr = "-1");
          }
          toString() {
            return this.numStr;
          }
          static fromHex(e2) {
            if (e2.length < 13) return parseInt(e2, 16);
            let t2 = "0";
            return e2.split("").forEach((e3) => {
              var i2 = parseInt(e3, 16);
              for (let e4 = 8; e4; e4 >>= 1) t2 = s(t2, t2), i2 & e4 && (t2 = s(t2, "1"));
            }), new r(t2);
          }
        }
        function s(e2, t2) {
          let i2 = 0, r2 = [], s2 = e2.split("").map(Number), a = t2.split("").map(Number);
          for (; s2.length || a.length; ) {
            const e3 = (s2.pop() || 0) + (a.pop() || 0) + i2;
            r2.unshift(e3 < 10 ? e3 : e3 - 10), i2 = e3 < 10 ? 0 : 1;
          }
          return i2 && r2.unshift(i2), r2.join("");
        }
        t.SimpleBig = r;
      }, function(e, t, i) {
        "use strict";
        e.exports = o;
        var r = i(82);
        ((o.prototype = Object.create(r.prototype)).constructor = o).className = "OneOf";
        var s = i(83), a = i(19);
        function o(e2, t2, i2, s2) {
          if (Array.isArray(t2) || (i2 = t2, t2 = void 0), r.call(this, e2, i2), void 0 !== t2 && !Array.isArray(t2)) throw TypeError("fieldNames must be an Array");
          this.oneof = t2 || [], this.fieldsArray = [], this.comment = s2;
        }
        function n(e2) {
          if (e2.parent) for (var t2 = 0; t2 < e2.fieldsArray.length; ++t2) e2.fieldsArray[t2].parent || e2.parent.add(e2.fieldsArray[t2]);
        }
        o.fromJSON = function(e2, t2) {
          return new o(e2, t2.oneof, t2.options, t2.comment);
        }, o.prototype.toJSON = function(e2) {
          var t2 = !!e2 && Boolean(e2.keepComments);
          return a.toObject(["options", this.options, "oneof", this.oneof, "comment", t2 ? this.comment : void 0]);
        }, o.prototype.add = function(e2) {
          if (!(e2 instanceof s)) throw TypeError("field must be a Field");
          return e2.parent && e2.parent !== this.parent && e2.parent.remove(e2), this.oneof.push(e2.name), this.fieldsArray.push(e2), e2.partOf = this, n(this), this;
        }, o.prototype.remove = function(e2) {
          if (!(e2 instanceof s)) throw TypeError("field must be a Field");
          var t2 = this.fieldsArray.indexOf(e2);
          if (t2 < 0) throw Error(e2 + " is not a member of " + this);
          return this.fieldsArray.splice(t2, 1), (t2 = this.oneof.indexOf(e2.name)) > -1 && this.oneof.splice(t2, 1), e2.partOf = null, this;
        }, o.prototype.onAdd = function(e2) {
          r.prototype.onAdd.call(this, e2);
          for (var t2 = 0; t2 < this.oneof.length; ++t2) {
            var i2 = e2.get(this.oneof[t2]);
            i2 && !i2.partOf && (i2.partOf = this, this.fieldsArray.push(i2));
          }
          n(this);
        }, o.prototype.onRemove = function(e2) {
          for (var t2, i2 = 0; i2 < this.fieldsArray.length; ++i2) (t2 = this.fieldsArray[i2]).parent && t2.parent.remove(t2);
          r.prototype.onRemove.call(this, e2);
        }, o.d = function() {
          for (var e2 = new Array(arguments.length), t2 = 0; t2 < arguments.length; ) e2[t2] = arguments[t2++];
          return function(t3, i2) {
            a.decorateType(t3.constructor).add(new o(i2, e2)), Object.defineProperty(t3, i2, { get: a.oneOfGetter(e2), set: a.oneOfSetter(e2) });
          };
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.alerter = void 0;
        const o = i(164), n = a(i(7)), d = i(46), c = i(1), l = i(47);
        class u extends d.RTCEventEmitter {
          constructor() {
            super(...arguments), this.elem = null;
          }
          alert(e2, t2) {
            t2 || (t2 = { resume: false }), this.elem || (this.elem = document.createElement("div"), this.elem.style.fontSize = "20px", this.elem.style.position = "fixed", this.elem.style.background = "yellow", this.elem.style.margin = "auto", this.elem.style.width = "100%", this.elem.style.zIndex = "9999", this.elem.style.top = "0", this.elem.addEventListener("click", () => {
              var e3;
              (null === (e3 = this.elem) || void 0 === e3 ? void 0 : e3.parentNode) && this.elem.parentNode.removeChild(this.elem), this.safeEmit("@user-gesture-fired");
            })), this.elem.style.display = "block", this.elem.innerHTML = e2, document.body.appendChild(this.elem), t2.resume && this.elem.addEventListener("click", h, { once: true });
          }
          watchClient(e2) {
            e2.addListener("@pairing-join-start", () => {
              if (0 === o.systemChecker.checkCnt || "always" === c.getParameters().enableAlerter) {
                const e3 = 72;
                if (n.IS_CHROME && (n.IS_MAC || n.IS_WIN) && n.CHROME_MAJOR_VERSION && n.CHROME_MAJOR_VERSION < e3) {
                  let e4 = `您当前正在使用的Chrome浏览器版本为${n.CHROME_MAJOR_VERSION}, 不在NERTC的支持范围。请更新您的浏览器。<br/>您看到这条提示是因为您未调用 NERTC.checkSystemRequirements()，并且浏览器版本过低。`;
                  this.alert(e4);
                }
              }
            }), e2.addListener("@connection-state-change", (t2) => {
              if ("DISCONNECTING" === t2.curState && "CONNECTING" === t2.prevState && (e2._events && !e2._events["connection-state-change"] && !e2._events.SOCKET_ERROR || "always" === c.getParameters().enableAlerter)) {
                let e3 = "由于网络原因，您当前已经退出房间。<br/>您看到这条提示是因为您未监听 connection-state-change 或 SOCKET_ERROR 事件，并且加入房间后意外退出了房间。";
                this.alert(e3);
              }
            });
          }
          watchLocalStream(e2) {
            e2.on("@notAllowedError", (t2) => {
              if (!e2._events.notAllowedError || "always" === c.getParameters().enableAlerter) {
                let e3 = "音频播放需要手势触发。<br/>您看到这条提示是因为您未监听 notAllowedError 事件，并且遇到了浏览器自动播放策略问题。";
                this.alert(e3, { resume: true });
              }
            });
          }
          watchRemoteStream(e2) {
            e2.on("@notAllowedError", (t2) => {
              if (!e2._events.notAllowedError || "always" === c.getParameters().enableAlerter) {
                let e3 = "音频播放需要手势触发。<br/>您看到这条提示是因为您未监听 notAllowedError 事件，并且遇到了浏览器自动播放策略问题。";
                this.alert(e3, { resume: true });
              }
            });
          }
        }
        function h() {
          const e2 = c.getParameters().clients;
          for (let t3 = 0; t3 < e2.length; t3++) {
            const i3 = e2[t3];
            if (!i3.destroyed) for (let e3 in i3.adapterRef.remoteStreamMap) {
              i3.adapterRef.remoteStreamMap[e3].resume();
            }
          }
          const t2 = c.getParameters().localStreams;
          for (let e3 = 0; e3 < t2.length; e3++) {
            const i3 = t2[e3];
            i3.destroyed || i3.resume();
          }
          const i2 = l.getAudioContext();
          "suspended" === (null == i2 ? void 0 : i2.state) && (e2[0] && e2[0].logger.warn("尝试恢复 AudioContext"), i2.resume());
        }
        t.alerter = new u();
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.isHttpProtocol = t.checkBrowserCompatibility = t.isBrowserSupported = t.isPullStreamSupported = t.isPushStreamSupported = t.RtcSupport = void 0;
        const o = i(76), n = i(43), d = a(i(7)), c = i(77);
        let l = { isPullStreamSupport: false, isPushStreamSupport: false, isScreenShareSupport: false }, u = { video: [], audio: [] }, h = { video: [], audio: [] };
        var p = null;
        d.IS_IOS && d.IS_WECHAT || (p = navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
        var m = window.AudioContext = window.AudioContext || window.webkitAudioContext || window.mozAudioContext || window.msAudioContext, g = window.RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection, f = window.MediaStream = window.MediaStream || window.webkitMediaStream;
        function v(e2) {
          let t2;
          return t2 || (t2 = document.createElement("video")), !!t2.canPlayType({ ogg: 'video/ogg; codecs="theora"', h264: 'video/mp4; codecs="avc1.42E01E"', webm: 'video/webm; codecs="vp8, vorbis"', vp9: 'video/webm; codecs="vp9"', hls: 'application/x-mpegURL; codecs="avc1.42E01E"' }[e2] || e2);
        }
        const S = { WebRTC: !!g && !!f, RTCPeerConnection: !!g, Vp8: v("webm"), Vp9: v("vp9"), H264: v("h264"), GetUserMedia: !!p && !!navigator.mediaDevices, DataChannel: !!(g && "undefined" != typeof RTCDataChannel && g.prototype && g.prototype.createDataChannel), WebAudio: !(!m || !m.prototype.createMediaStreamSource), MediaStream: !!f };
        function y() {
          let e2 = c.getBrowserInfo().browserName, t2 = c.getBrowserInfo().browserVersion;
          return t2 = t2 && t2.match(/\d+/)[0], { prefix: e2, version: t2 };
        }
        const _ = { checkWebRtc: () => S, checkWebAudio: () => ({ WebAudio: S.WebAudio, MediaStream: S.MediaStream }), checkCompatibility() {
          let e2 = Object.assign(y(), { system: c.getOSInfo().osName + " " + c.getOSInfo().osVersion, browser: c.getBrowserInfo().browserName, version: c.getBrowserInfo().browserVersion });
          return new Promise(function(t2, i2) {
            (async () => {
              const i3 = Object.assign(e2, S, { ScreenSharing: false }), r2 = await o.Device.getDevices({ audiooutput: true, audioinput: true, videoinput: true, requestPerm: true }).catch((e3) => t2(i3));
              i3.MicrophoneList = r2 && r2.audioIn || [], i3.CameraList = r2 && r2.video || [], i3.Microphone = r2 && r2.audioIn && r2.audioIn.length > 0 || false, i3.Camera = r2 && r2.video && r2.video.length > 0 || false, t2(i3);
            })();
          });
        }, checkVersion: () => y() };
        t.RtcSupport = _;
        const R = function() {
          return ["RTCPeerConnection", "webkitRTCPeerConnection", "mozRTCPeerConnection"].filter((e2) => e2 in window).length > 0;
        }, b = function() {
          return !!window.WebSocket && !!window.WebSocket.prototype.send;
        };
        async function T() {
          return await async function() {
            return !!u.video.length || (u = await n.getSupportedCodecs("send"), u.video.indexOf("H264") > -1 || u.video.indexOf("VP8") > -1);
          }() && R() && b() && function() {
            if (!navigator.mediaDevices) return false;
            const e2 = ["getUserMedia", "enumerateDevices"];
            return e2.filter((e3) => e3 in navigator.mediaDevices).length === e2.length;
          }() && async function() {
            return !!g.prototype.getStats || !!RTCRtpSender.prototype.getStats;
          }();
        }
        async function E() {
          return await async function() {
            return !!h.video.length || (h = await n.getSupportedCodecs("recv"), h.video.indexOf("H264") > -1 || h.video.indexOf("VP8") > -1);
          }() && R() && b() && async function() {
            return !!g.prototype.getStats || !!RTCRtpReceiver.prototype.getStats;
          }();
        }
        t.isPushStreamSupported = T, t.isPullStreamSupported = E;
        t.isBrowserSupported = function() {
          return !!(d.IS_CHROME && d.CHROME_MAJOR_VERSION >= 72) || (!!(d.IS_MAC_SAFARI && d.SAFARI_MAJOR_VERSION >= 12) || (!(!(d.IS_IOS_SAFARI && d.SAFARI_MAJOR_VERSION >= 13) || d.IS_WECHAT) || (!!(d.IS_EDG && d.EDG_MAJOR_VERSION >= 80) || (!!(d.IS_FIREFOX && d.FIREFOX_MAJOR_VERSION >= 66) || (!(!d.IS_IOS || !d.IS_MQQB) || (!!(d.IS_IOS && d.IOS_VERSION && parseFloat(d.IOS_VERSION) >= 14.3 && d.IS_WECHAT && d.WECHAT_VERSION && parseFloat(d.WECHAT_VERSION) >= 6.5) || !(!d.IS_ANDROID || !d.IS_TBS && !d.IS_XWEB)))))));
        };
        t.checkBrowserCompatibility = async function() {
          const e2 = function() {
            if (d.IS_ELECTRON) return true;
            {
              let e3 = navigator.mediaDevices;
              return !(!e3 || !e3.getDisplayMedia);
            }
          }(), t2 = await T(), i2 = await E();
          return l.isScreenShareSupport = e2, l.isPushStreamSupport = t2, l.isPullStreamSupport = i2, l;
        };
        const A = "file:" === location.protocol || "localhost" === location.hostname || /^\d+\.\d+\.\d+\.\d+$/.test(location.hostname);
        t.isHttpProtocol = function() {
          return "http:" === location.protocol && !A;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.compatAudioInputList = void 0;
        const r = i(1);
        t.compatAudioInputList = new class {
          constructor() {
            this.enabled = r.getParameters().enableCompatAudio, this.compatTracks = [];
          }
          findSource(e2) {
            const t2 = this.compatTracks.find((t3) => t3.dest.id === e2);
            return t2 ? t2.source : null;
          }
        }();
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.encryptionModeToInt = t.EncryptionModes = t.Encryption = void 0;
        const s = i(3), a = r(i(146)), o = { none: -1, "sm4-128-ecb": 0 };
        t.EncryptionModes = o, t.encryptionModeToInt = function(e2) {
          return "none" === e2 || "sm4-128-ecb" === e2 ? o[e2] : void 0;
        };
        class n extends s.EventEmitter {
          constructor(e2) {
            super(), this.encryptionMode = "none", this.encryptionSecret = "", this.encodedInsertableStreams = false, this.adapterRef = e2;
          }
          setEncryptionMode(e2) {
            this.encryptionMode = e2;
          }
          setEncryptionSecret(e2) {
            this.encryptionSecret = a.default(e2);
          }
          handleUpstreamTransform(e2, t2, i2) {
            e2.index++, 1 === e2.index && this.adapterRef.logger.log("生成第一帧上行自定义加密（明文）。长度:", t2.data.byteLength, e2.mediaType, e2.streamType), this.adapterRef.instance.safeEmit("sender-transform", { uid: this.adapterRef.channelInfo.uid, mediaType: e2.mediaType, streamType: e2.streamType, encodedFrame: t2, controller: i2 });
          }
          handleDownstreamTransform(e2, t2, i2) {
            e2.index++, 1 === e2.index && this.adapterRef.logger.log("收到第一帧下行自定义加密（密文）。长度:", t2.data.byteLength, e2.uid, e2.mediaType), "key" === t2.type && this.adapterRef.state.videoFirstIframeTime < this.adapterRef.state.signalJoinSuccessTime && (this.adapterRef.state.videoFirstIframeTime = Date.now()), this.adapterRef.instance.safeEmit("receiver-transform", { uid: e2.uid, mediaType: e2.mediaType, encodedFrame: t2, controller: i2 });
          }
        }
        t.Encryption = n;
      }, function(e, t, i) {
        var r, s, a, o, n;
        r = i(213), s = i(166).utf8, a = i(214), o = i(166).bin, (n = function(e2, t2) {
          e2.constructor == String ? e2 = t2 && "binary" === t2.encoding ? o.stringToBytes(e2) : s.stringToBytes(e2) : a(e2) ? e2 = Array.prototype.slice.call(e2, 0) : Array.isArray(e2) || e2.constructor === Uint8Array || (e2 = e2.toString());
          for (var i2 = r.bytesToWords(e2), d = 8 * e2.length, c = 1732584193, l = -271733879, u = -1732584194, h = 271733878, p = 0; p < i2.length; p++) i2[p] = 16711935 & (i2[p] << 8 | i2[p] >>> 24) | 4278255360 & (i2[p] << 24 | i2[p] >>> 8);
          i2[d >>> 5] |= 128 << d % 32, i2[14 + (d + 64 >>> 9 << 4)] = d;
          var m = n._ff, g = n._gg, f = n._hh, v = n._ii;
          for (p = 0; p < i2.length; p += 16) {
            var S = c, y = l, _ = u, R = h;
            c = m(c, l, u, h, i2[p + 0], 7, -680876936), h = m(h, c, l, u, i2[p + 1], 12, -389564586), u = m(u, h, c, l, i2[p + 2], 17, 606105819), l = m(l, u, h, c, i2[p + 3], 22, -1044525330), c = m(c, l, u, h, i2[p + 4], 7, -176418897), h = m(h, c, l, u, i2[p + 5], 12, 1200080426), u = m(u, h, c, l, i2[p + 6], 17, -1473231341), l = m(l, u, h, c, i2[p + 7], 22, -45705983), c = m(c, l, u, h, i2[p + 8], 7, 1770035416), h = m(h, c, l, u, i2[p + 9], 12, -1958414417), u = m(u, h, c, l, i2[p + 10], 17, -42063), l = m(l, u, h, c, i2[p + 11], 22, -1990404162), c = m(c, l, u, h, i2[p + 12], 7, 1804603682), h = m(h, c, l, u, i2[p + 13], 12, -40341101), u = m(u, h, c, l, i2[p + 14], 17, -1502002290), c = g(c, l = m(l, u, h, c, i2[p + 15], 22, 1236535329), u, h, i2[p + 1], 5, -165796510), h = g(h, c, l, u, i2[p + 6], 9, -1069501632), u = g(u, h, c, l, i2[p + 11], 14, 643717713), l = g(l, u, h, c, i2[p + 0], 20, -373897302), c = g(c, l, u, h, i2[p + 5], 5, -701558691), h = g(h, c, l, u, i2[p + 10], 9, 38016083), u = g(u, h, c, l, i2[p + 15], 14, -660478335), l = g(l, u, h, c, i2[p + 4], 20, -405537848), c = g(c, l, u, h, i2[p + 9], 5, 568446438), h = g(h, c, l, u, i2[p + 14], 9, -1019803690), u = g(u, h, c, l, i2[p + 3], 14, -187363961), l = g(l, u, h, c, i2[p + 8], 20, 1163531501), c = g(c, l, u, h, i2[p + 13], 5, -1444681467), h = g(h, c, l, u, i2[p + 2], 9, -51403784), u = g(u, h, c, l, i2[p + 7], 14, 1735328473), c = f(c, l = g(l, u, h, c, i2[p + 12], 20, -1926607734), u, h, i2[p + 5], 4, -378558), h = f(h, c, l, u, i2[p + 8], 11, -2022574463), u = f(u, h, c, l, i2[p + 11], 16, 1839030562), l = f(l, u, h, c, i2[p + 14], 23, -35309556), c = f(c, l, u, h, i2[p + 1], 4, -1530992060), h = f(h, c, l, u, i2[p + 4], 11, 1272893353), u = f(u, h, c, l, i2[p + 7], 16, -155497632), l = f(l, u, h, c, i2[p + 10], 23, -1094730640), c = f(c, l, u, h, i2[p + 13], 4, 681279174), h = f(h, c, l, u, i2[p + 0], 11, -358537222), u = f(u, h, c, l, i2[p + 3], 16, -722521979), l = f(l, u, h, c, i2[p + 6], 23, 76029189), c = f(c, l, u, h, i2[p + 9], 4, -640364487), h = f(h, c, l, u, i2[p + 12], 11, -421815835), u = f(u, h, c, l, i2[p + 15], 16, 530742520), c = v(c, l = f(l, u, h, c, i2[p + 2], 23, -995338651), u, h, i2[p + 0], 6, -198630844), h = v(h, c, l, u, i2[p + 7], 10, 1126891415), u = v(u, h, c, l, i2[p + 14], 15, -1416354905), l = v(l, u, h, c, i2[p + 5], 21, -57434055), c = v(c, l, u, h, i2[p + 12], 6, 1700485571), h = v(h, c, l, u, i2[p + 3], 10, -1894986606), u = v(u, h, c, l, i2[p + 10], 15, -1051523), l = v(l, u, h, c, i2[p + 1], 21, -2054922799), c = v(c, l, u, h, i2[p + 8], 6, 1873313359), h = v(h, c, l, u, i2[p + 15], 10, -30611744), u = v(u, h, c, l, i2[p + 6], 15, -1560198380), l = v(l, u, h, c, i2[p + 13], 21, 1309151649), c = v(c, l, u, h, i2[p + 4], 6, -145523070), h = v(h, c, l, u, i2[p + 11], 10, -1120210379), u = v(u, h, c, l, i2[p + 2], 15, 718787259), l = v(l, u, h, c, i2[p + 9], 21, -343485551), c = c + S >>> 0, l = l + y >>> 0, u = u + _ >>> 0, h = h + R >>> 0;
          }
          return r.endian([c, l, u, h]);
        })._ff = function(e2, t2, i2, r2, s2, a2, o2) {
          var n2 = e2 + (t2 & i2 | ~t2 & r2) + (s2 >>> 0) + o2;
          return (n2 << a2 | n2 >>> 32 - a2) + t2;
        }, n._gg = function(e2, t2, i2, r2, s2, a2, o2) {
          var n2 = e2 + (t2 & r2 | i2 & ~r2) + (s2 >>> 0) + o2;
          return (n2 << a2 | n2 >>> 32 - a2) + t2;
        }, n._hh = function(e2, t2, i2, r2, s2, a2, o2) {
          var n2 = e2 + (t2 ^ i2 ^ r2) + (s2 >>> 0) + o2;
          return (n2 << a2 | n2 >>> 32 - a2) + t2;
        }, n._ii = function(e2, t2, i2, r2, s2, a2, o2) {
          var n2 = e2 + (i2 ^ (t2 | ~r2)) + (s2 >>> 0) + o2;
          return (n2 << a2 | n2 >>> 32 - a2) + t2;
        }, n._blocksize = 16, n._digestsize = 16, e.exports = function(e2, t2) {
          if (null == e2) throw new Error("Illegal argument " + e2);
          var i2 = r.wordsToBytes(n(e2, t2));
          return t2 && t2.asBytes ? i2 : t2 && t2.asString ? o.bytesToString(i2) : r.bytesToHex(i2);
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Record = void 0;
        const n = i(3), d = o(i(6)), c = o(i(8)), l = a(i(7));
        class u extends n.EventEmitter {
          constructor(e2) {
            super(), this._status = { recordedChunks: [], isRecording: false, stream: null, option: null, contentTypes: [], mimeType: "", audioController: null, opStream: null, state: "init", timer: null, fileName: null, recordId: 0, recordStatus: "init", recordUrl: null, startTime: null, endTime: null }, this._recorder = null, this.logger = e2.logger.getChild(() => "recorder " + this._status.recordStatus), this._reset(), this.client = e2.client;
          }
          get recoder() {
            return this._recorder;
          }
          async start(e2) {
            const { stream: t2 = null, uid: i2 = "0", type: r2 = "video", reset: s2 = false, recordName: a2 } = e2;
            this.logger.log("开始本地录制: ", JSON.stringify(e2, null, ""));
            let o2 = null;
            if (!window.MediaRecorder || !MediaRecorder.isTypeSupported || !l.IS_CHROME) throw o2 = "Record.start: 当前浏览器不支持本地录制", this.logger.warn(o2), new c.default({ code: d.default.RECORDING_NOT_SUPPORT, message: o2 });
            if (this._status.isRecording) throw o2 = "Record.start: 操作异常, 当前正在录制中", this.logger.warn(o2), new c.default({ code: d.default.REPEAT_RECORDING_ERROR, message: o2 });
            if (this._status.recordUrl && "downloaded" !== this._status.recordStatus) {
              if (!e2.reset) throw o2 = "Record.start: 操作异常, 请先下载或重置上一段录制文件", this.logger.warn(o2), new c.default({ code: d.default.RECORDING_CACHE_ERROR, message: o2 });
              this.logger.warn("Record.start: 存在未下载视频，强制清除..."), await this.clean();
            }
            o2 && this.client.apiFrequencyControl({ name: "startMediaRecording", code: -1, param: JSON.stringify({ reason: o2, uid: i2, mediaType: r2, recordName: "" }, null, " ") }), this._status.stream = t2, this._status.option = e2, this._status.fileName = this._getFilename(a2), this._status.startTime = this._getTimeStamp();
            let n2 = ["video/mp4;codecs=opus", "video/webm", "video/webm;codecs=h264", "video/x-matroska;codecs=opus", "video/invalid"];
            if ("audio" === e2.type && (n2 = ["audio/wav", "audio/ogg", "audio/pcm", "audio/webm"]), !(this._status.mimeType = this._validation(n2)[0])) return "RecordBrowserNotSupport";
            try {
              await this._format(), await this._start(), this.client.apiFrequencyControl({ name: "startMediaRecording", code: 0, param: JSON.stringify({ uid: i2, mediaType: r2, recordName: "" }, null, " ") });
            } catch (e3) {
              return this.logger.error("Record.start 内部异常: ", e3.name, e3.message), this.client.apiFrequencyControl({ name: "startMediaRecording", code: -1, param: JSON.stringify({ reason: e3.message, uid: i2, mediaType: r2, recordName: "" }, null, " ") }), Promise.reject(new c.default({ code: d.default.RECORDING_ERROR, message: "Record.start: 录制异常 " + e3.message }));
            }
          }
          stop(e2) {
            let t2 = null;
            return this._status.isRecording && this._recorder || (this.logger.log("Record.stop 当前没有进行录制"), t2 = "RecordNotExist"), this._recorder && "started" !== this._status.state && (this.logger.warn("Record.stop: record stopping when " + this._recorder.state), t2 = "RecordStateError"), t2 ? (e2 && false === e2.isUser || this.client.apiFrequencyControl({ name: "stopMediaRecording", code: -1, param: "" }), Promise.resolve()) : (this._status.state = "stopped", this._status.recordStatus = "stopping", new Promise((t3, i2) => {
              var r2;
              this._status.fileName = this._status.fileName, this._recorder.onstop = () => {
                this._onStop(t3);
              }, null === (r2 = null == this ? void 0 : this._recorder) || void 0 === r2 || r2.stop(), this.client.apiFrequencyControl({ name: "stopMediaRecording", code: 0, param: "" }), e2 && e2.isUser && this.client.apiFrequencyControl({ name: "stopMediaRecording", code: -1, param: "" });
            }));
          }
          play(e2) {
            return "stopped" !== this._status.state ? (this.client.apiFrequencyControl({ name: "playMediaRecording", code: -1, param: JSON.stringify({ reason: "RecordStateError" }, null, " ") }), this.logger.warn("MediaRecordHelper: record stopping when " + (this._recorder && this._recorder.state)), Promise.resolve()) : (this.client.apiFrequencyControl({ name: "playMediaRecording", code: 0, param: JSON.stringify({ recordId: "" }, null, " ") }), this._play(e2));
          }
          download(e2 = true) {
            return Promise.resolve().then(() => this._status.isRecording ? (this.logger.log("Record.download: 正在录制中，立即停止..."), this.stop({ isUser: false })) : Promise.resolve()).then(() => {
              if (this._status.recordUrl) {
                const e3 = document.createElement("a");
                document.body.appendChild(e3), e3.style.display = "none", e3.href = this._status.recordUrl, e3.download = (this._status.fileName || this._getTimeStamp()) + ".webm", e3.click(), this._status.recordStatus = "downloaded";
              } else this.logger.log("Record.download: cannot download media without url ...");
              return e2 && this.client.apiFrequencyControl({ name: "downloadMediaRecording", code: 0, param: "" }), Promise.resolve(this._status);
            });
          }
          async clean() {
            this.client.apiFrequencyControl({ name: "cleanMediaRecording", code: 0, param: "" }), this._status.isRecording && this._recorder && await this.stop(), this._status.recordUrl && (window.URL.revokeObjectURL(this._status.recordUrl), this._status.recordUrl = null), this._destroy(), this._status.recordStatus = "init";
          }
          leave(e2 = { uid: 0 }) {
            if (!this._status.isRecording || !this._recorder) return Promise.resolve();
            const { uid: t2 } = e2;
            return t2 && this._status.option ? t2 === +this._status.option.uid ? this.stop() : void 0 : Promise.resolve();
          }
          pause() {
            this._recorder && this._recorder.pause();
          }
          resume() {
            this._recorder && this._recorder.resume();
          }
          _reset() {
            this._recorder = null, Object.assign(this._status, { recordedChunks: [], isRecording: false, stream: null, option: null, contentTypes: [], mimeType: "", audioController: null, opStream: null, state: "init", timer: null, fileName: null, recordId: 0, recordStatus: "init", recordUrl: null, startTime: null, endTime: null });
          }
          _getTimeStamp() {
            return Math.floor(Date.now() / 1e3);
          }
          _getFilename(e2) {
            let t2 = "";
            e2 && (t2 += e2 + "_");
            const i2 = /* @__PURE__ */ new Date();
            return t2 += `${i2.getFullYear()}${(i2.getMonth() + 1).toString().padStart(2, "0")}${i2.getDate().toString().padStart(2, "0")}`, t2 += `${i2.getHours().toString().padStart(2, "0")}${i2.getMinutes().toString().padStart(2, "0")}${i2.getSeconds().toString().padStart(2, "0")}${i2.getMilliseconds().toString().padStart(3, "0")}`, t2;
          }
          _validation(e2) {
            return e2.filter((e3) => MediaRecorder.isTypeSupported(e3));
          }
          _format() {
            let e2 = this._status.stream, t2 = this._status.option;
            return new Promise((i2, r2) => {
              let s2 = new MediaStream();
              if (!e2) return r2(new c.default({ code: d.default.RECORDING_ERROR, message: "Record._format: stream 未明确" }));
              if (this._matchLocalStreamConstructor(e2.constructor.toString()) && (e2 = [e2]), Array.isArray(e2)) {
                if (e2.forEach((e3) => {
                  e3 && this._matchLocalStreamConstructor(e3.constructor.toString()) && e3.getTracks().forEach((e4) => {
                    "audio" === (null == t2 ? void 0 : t2.type) ? "audio" === e4.kind && s2.addTrack(e4) : s2.addTrack(e4);
                  });
                }), 0 === s2.getTracks().length) return this.logger.error("_format: No tracks available"), i2(s2);
                this._status.opStream = s2, i2(s2);
              }
            });
          }
          _matchLocalStreamConstructor(e2) {
            return /(LocalMediaStream|MediaStream)/.test(e2);
          }
          _start() {
            let e2 = { audioBitsPerSecond: 128e3, videoBitsPerSecond: 25e5, mimeType: this._status.mimeType };
            if (!this._status.opStream) return Promise.reject(new c.default({ code: d.default.RECORDING_ERROR, message: "Record._start: opStream 未明确" }));
            const t2 = this._status.opStream.getAudioTracks();
            let i2;
            i2 = t2.length > 1 ? new MediaStream([t2[0]]) : this._status.opStream;
            let r2 = this._recorder = new MediaRecorder(i2, e2);
            return r2.ondataavailable = this._onDataAvailable.bind(this), r2.onstop = () => {
              this.logger.log("MediaRecordHelper: _start: record stop automatically ..."), this._onStop();
            }, this._status.recordUrl && (window.URL.revokeObjectURL(this._status.recordUrl), this._status.recordUrl = null), this._status.recordedChunks = [], this._status.isRecording = true, this._status.state = "started", this._status.recordId += 1, this._status.recordStatus = "starting", this._recorder.start(), this._clearTimer(), this._startTimer(), Promise.resolve(this._status.recordId);
          }
          _startTimer() {
            this._status.timer || (this._status.timer = setInterval(() => {
              this.logger.log(`MediaRecordHelper: startTimer: ${(/* @__PURE__ */ new Date()).toLocaleString()} --> MediaRecorder status: ${this._recorder && this._recorder.state}`);
            }, 5e3));
          }
          _onStop(e2) {
            this.logger.log("MediaRecordHelper: _onStop: record stoped !!!"), this._clearTimer(), this._status.recordStatus = "stopped", this._status.isRecording = false, this._status.endTime = this._getTimeStamp();
            let t2 = new Blob(this._status.recordedChunks, { type: this._status.mimeType });
            this._status.recordUrl = URL.createObjectURL(t2), this.emit("media-recording-stopped", this.getRecordStatus()), e2 && e2(this._status.fileName);
          }
          _play(e2) {
            let t2 = null;
            if (-1 != this._status.mimeType.indexOf("audio")) t2 = document.createElement("audio");
            else {
              if (-1 == this._status.mimeType.indexOf("video")) return Promise.reject(new c.default({ code: d.default.NOT_SUPPORT_ERROR, message: "_play: 当前浏览器不支持 MIME type " + this._status.mimeType }));
              t2 = document.createElement("video"), t2.autoplay = true;
            }
            return this._status.recordUrl ? (e2.appendChild(t2), t2.srcObject = null, t2.src = this._status.recordUrl, t2.controls = false, t2.play(), Promise.resolve(this._status.option)) : Promise.reject(new c.default({ code: d.default.RECORDING_ERROR, message: "Record._play: 录制 url 未明确" }));
          }
          async _destroy() {
            this._status.audioController && this._status.audioController.destroy(), this._status.isRecording && await this.stop({ isUser: false }), this._clearTimer(), this._recorder = null, Object.assign(this._status, { stream: null, recordedChunks: [], isRecording: false, audioController: null, status: "init" });
          }
          _clearTimer() {
            this._status.timer && (clearInterval(this._status.timer), this._status.timer = null);
          }
          _onDataAvailable(e2) {
            if (this._status.recordStatus = "recording", this.logger.log("MediaRecordHelper: ondataavailable: data received"), !(e2.data.size > 0)) return this.logger.warn("MediaRecordHelper: ondataavailable: no data"), void this.stop();
            this._status.recordedChunks.push(e2.data);
          }
          checkIsRecording() {
            return this._status.isRecording;
          }
          getRecordStatus() {
            const e2 = Object.assign({ id: this._status.recordId, type: this._status.mimeType, name: this._status.fileName, status: this._status.recordStatus, isRecording: this._status.isRecording, startTime: this._status.startTime, endTime: this._status.endTime }, this._status.option);
            return this.client.apiFrequencyControl({ name: "listMediaRecording", code: 0, param: "" }), e2;
          }
          destroy() {
            this._destroy();
          }
        }
        t.Record = u;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.addLegacySimulcast = t.getRtpEncodings = void 0;
        const s = r(i(6)), a = r(i(8));
        t.getRtpEncodings = function({ offerMediaObject: e2 }) {
          const t2 = /* @__PURE__ */ new Set();
          for (const i3 of e2.ssrcs || []) {
            const e3 = i3.id;
            t2.add(e3);
          }
          if (0 === t2.size) throw new a.default({ code: s.default.UNKNOWN_TYPE_ERROR, message: "getRtpEncodings: a=ssrc 行未找到" });
          const i2 = /* @__PURE__ */ new Map();
          for (const r3 of e2.ssrcGroups || []) {
            if ("FID" !== r3.semantics) continue;
            let [e3, s2] = r3.ssrcs.split(/\s+/);
            e3 = Number(e3), s2 = Number(s2), t2.has(e3) && (t2.delete(e3), t2.delete(s2), i2.set(e3, s2));
          }
          for (const e3 of t2) i2.set(e3, null);
          const r2 = [];
          for (const [e3, t3] of i2) {
            const i3 = { ssrc: e3 };
            t3 && (i3.rtx = { ssrc: t3 }), r2.push(i3);
          }
          return r2;
        }, t.addLegacySimulcast = function({ offerMediaObject: e2, numStreams: t2 }) {
          if (t2 <= 1) throw new TypeError("numStreams must be greater than 1");
          const i2 = (e2.ssrcs || []).find((e3) => "msid" === e3.attribute);
          if (!i2) throw new a.default({ code: s.default.UNKNOWN_TYPE_ERROR, message: "addLegacySimulcast: a=ssrc 行的 msid 信息未找到" });
          const [r2, o] = i2.value.split(" "), n = i2.id;
          let d;
          (e2.ssrcGroups || []).some((e3) => {
            if ("FID" !== e3.semantics) return false;
            const t3 = e3.ssrcs.split(/\s+/);
            return Number(t3[0]) === n && (d = Number(t3[1]), true);
          });
          const c = e2.ssrcs.find((e3) => "cname" === e3.attribute).value, l = [], u = [];
          for (let e3 = 0; e3 < t2; ++e3) l.push(n + e3), d && u.push(d + e3);
          e2.ssrcGroups = [], e2.ssrcs = [], e2.ssrcGroups.push({ semantics: "SIM", ssrcs: l.join(" ") });
          for (let t3 = 0; t3 < l.length; ++t3) {
            const i3 = l[t3];
            e2.ssrcs.push({ id: i3, attribute: "cname", value: c }), e2.ssrcs.push({ id: i3, attribute: "msid", value: `${r2} ${o}` });
          }
          for (let t3 = 0; t3 < u.length; ++t3) {
            const i3 = l[t3], s2 = u[t3];
            e2.ssrcs.push({ id: s2, attribute: "cname", value: c }), e2.ssrcs.push({ id: s2, attribute: "msid", value: `${r2} ${o}` }), e2.ssrcGroups.push({ semantics: "FID", ssrcs: `${i3} ${s2}` });
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.isIosFromRtpStats = t.getNativeRtpCapabilities = t.detectRtcCapabilities = void 0;
        const o = a(i(50)), n = a(i(88)), d = i(139);
        let c = null;
        async function l() {
          const e2 = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require", sdpSemantics: "unified-plan" });
          try {
            e2.addTransceiver("audio"), e2.addTransceiver("video");
            const t2 = await e2.createOffer();
            (null == t2 ? void 0 : t2.sdp.indexOf("a=rtcp-fb:111")) && -1 === t2.sdp.indexOf("a=rtcp-fb:111 nack") && (t2.sdp = t2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack"));
            let i2 = false;
            try {
              await e2.getStats(() => {
              });
            } catch (e3) {
              "TypeError" === e3.name && (i2 = true);
            }
            try {
              e2.close();
            } catch (e3) {
            }
            const r2 = o.parse(t2.sdp), s2 = n.extractRtpCapabilities({ sdpObject: r2 });
            d.addNackSuppportForOpus(s2);
            const a2 = { nativeRtpCapabilities: s2, isIOS: i2 };
            return c = a2, a2;
          } catch (t2) {
            try {
              e2.close();
            } catch (e3) {
            }
            throw t2;
          }
        }
        t.detectRtcCapabilities = l, t.getNativeRtpCapabilities = async function() {
          c || (c = await l());
          try {
            return JSON.parse(JSON.stringify(c.nativeRtpCapabilities));
          } catch (e2) {
            return c.nativeRtpCapabilities;
          }
        }, t.isIosFromRtpStats = function() {
          return null == c ? void 0 : c.isIOS;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.RTCCanvas = void 0;
        const r = i(85);
        t.RTCCanvas = class {
          constructor(e2, t2) {
            this.isAppend = false, this.title = e2, this.isAppend = t2, this.createCanvas();
          }
          get _canvas() {
            return this.canvas;
          }
          get _ctx() {
            return this.ctx;
          }
          createCanvas() {
            this.canvas = document.createElement("canvas"), this.ctx = r.get2DContext(this.canvas), this.isAppend && document.body.appendChild(this.canvas);
          }
          setSize(e2, t2) {
            this.canvas && (this.canvas.width = e2, this.canvas.height = t2);
          }
          destroy() {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height), this.isAppend && document.body.removeChild(this.canvas), this.canvas = null;
          }
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = u;
        var r, s = i(44), a = s.LongBits, o = s.base64, n = s.utf8;
        function d(e2, t2, i2) {
          this.fn = e2, this.len = t2, this.next = void 0, this.val = i2;
        }
        function c() {
        }
        function l(e2) {
          this.head = e2.head, this.tail = e2.tail, this.len = e2.len, this.next = e2.states;
        }
        function u() {
          this.len = 0, this.head = new d(c, 0, 0), this.tail = this.head, this.states = null;
        }
        var h = function() {
          return s.Buffer ? function() {
            return (u.create = function() {
              return new r();
            })();
          } : function() {
            return new u();
          };
        };
        function p(e2, t2, i2) {
          t2[i2] = 255 & e2;
        }
        function m(e2, t2) {
          this.len = e2, this.next = void 0, this.val = t2;
        }
        function g(e2, t2, i2) {
          for (; e2.hi; ) t2[i2++] = 127 & e2.lo | 128, e2.lo = (e2.lo >>> 7 | e2.hi << 25) >>> 0, e2.hi >>>= 7;
          for (; e2.lo > 127; ) t2[i2++] = 127 & e2.lo | 128, e2.lo = e2.lo >>> 7;
          t2[i2++] = e2.lo;
        }
        function f(e2, t2, i2) {
          t2[i2] = 255 & e2, t2[i2 + 1] = e2 >>> 8 & 255, t2[i2 + 2] = e2 >>> 16 & 255, t2[i2 + 3] = e2 >>> 24;
        }
        u.create = h(), u.alloc = function(e2) {
          return new s.Array(e2);
        }, s.Array !== Array && (u.alloc = s.pool(u.alloc, s.Array.prototype.subarray)), u.prototype._push = function(e2, t2, i2) {
          return this.tail = this.tail.next = new d(e2, t2, i2), this.len += t2, this;
        }, m.prototype = Object.create(d.prototype), m.prototype.fn = function(e2, t2, i2) {
          for (; e2 > 127; ) t2[i2++] = 127 & e2 | 128, e2 >>>= 7;
          t2[i2] = e2;
        }, u.prototype.uint32 = function(e2) {
          return this.len += (this.tail = this.tail.next = new m((e2 >>>= 0) < 128 ? 1 : e2 < 16384 ? 2 : e2 < 2097152 ? 3 : e2 < 268435456 ? 4 : 5, e2)).len, this;
        }, u.prototype.int32 = function(e2) {
          return e2 < 0 ? this._push(g, 10, a.fromNumber(e2)) : this.uint32(e2);
        }, u.prototype.sint32 = function(e2) {
          return this.uint32((e2 << 1 ^ e2 >> 31) >>> 0);
        }, u.prototype.uint64 = function(e2) {
          var t2 = a.from(e2);
          return this._push(g, t2.length(), t2);
        }, u.prototype.int64 = u.prototype.uint64, u.prototype.sint64 = function(e2) {
          var t2 = a.from(e2).zzEncode();
          return this._push(g, t2.length(), t2);
        }, u.prototype.bool = function(e2) {
          return this._push(p, 1, e2 ? 1 : 0);
        }, u.prototype.fixed32 = function(e2) {
          return this._push(f, 4, e2 >>> 0);
        }, u.prototype.sfixed32 = u.prototype.fixed32, u.prototype.fixed64 = function(e2) {
          var t2 = a.from(e2);
          return this._push(f, 4, t2.lo)._push(f, 4, t2.hi);
        }, u.prototype.sfixed64 = u.prototype.fixed64, u.prototype.float = function(e2) {
          return this._push(s.float.writeFloatLE, 4, e2);
        }, u.prototype.double = function(e2) {
          return this._push(s.float.writeDoubleLE, 8, e2);
        };
        var v = s.Array.prototype.set ? function(e2, t2, i2) {
          t2.set(e2, i2);
        } : function(e2, t2, i2) {
          for (var r2 = 0; r2 < e2.length; ++r2) t2[i2 + r2] = e2[r2];
        };
        u.prototype.bytes = function(e2) {
          var t2 = e2.length >>> 0;
          if (!t2) return this._push(p, 1, 0);
          if (s.isString(e2)) {
            var i2 = u.alloc(t2 = o.length(e2));
            o.decode(e2, i2, 0), e2 = i2;
          }
          return this.uint32(t2)._push(v, t2, e2);
        }, u.prototype.string = function(e2) {
          var t2 = n.length(e2);
          return t2 ? this.uint32(t2)._push(n.write, t2, e2) : this._push(p, 1, 0);
        }, u.prototype.fork = function() {
          return this.states = new l(this), this.head = this.tail = new d(c, 0, 0), this.len = 0, this;
        }, u.prototype.reset = function() {
          return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new d(c, 0, 0), this.len = 0), this;
        }, u.prototype.ldelim = function() {
          var e2 = this.head, t2 = this.tail, i2 = this.len;
          return this.reset().uint32(i2), i2 && (this.tail.next = e2.next, this.tail = t2, this.len += i2), this;
        }, u.prototype.finish = function() {
          for (var e2 = this.head.next, t2 = this.constructor.alloc(this.len), i2 = 0; e2; ) e2.fn(e2.val, t2, i2), i2 += e2.len, e2 = e2.next;
          return t2;
        }, u._configure = function(e2) {
          r = e2, u.create = h(), r._configure();
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = d;
        var r, s = i(44), a = s.LongBits, o = s.utf8;
        function n(e2, t2) {
          return RangeError("index out of range: " + e2.pos + " + " + (t2 || 1) + " > " + e2.len);
        }
        function d(e2) {
          this.buf = e2, this.pos = 0, this.len = e2.length;
        }
        var c, l = "undefined" != typeof Uint8Array ? function(e2) {
          if (e2 instanceof Uint8Array || Array.isArray(e2)) return new d(e2);
          throw Error("illegal buffer");
        } : function(e2) {
          if (Array.isArray(e2)) return new d(e2);
          throw Error("illegal buffer");
        }, u = function() {
          return s.Buffer ? function(e2) {
            return (d.create = function(e3) {
              return s.Buffer.isBuffer(e3) ? new r(e3) : l(e3);
            })(e2);
          } : l;
        };
        function h() {
          var e2 = new a(0, 0), t2 = 0;
          if (!(this.len - this.pos > 4)) {
            for (; t2 < 3; ++t2) {
              if (this.pos >= this.len) throw n(this);
              if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128) return e2;
            }
            return e2.lo = (e2.lo | (127 & this.buf[this.pos++]) << 7 * t2) >>> 0, e2;
          }
          for (; t2 < 4; ++t2) if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 7 * t2) >>> 0, this.buf[this.pos++] < 128) return e2;
          if (e2.lo = (e2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, e2.hi = (e2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return e2;
          if (t2 = 0, this.len - this.pos > 4) {
            for (; t2 < 5; ++t2) if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128) return e2;
          } else for (; t2 < 5; ++t2) {
            if (this.pos >= this.len) throw n(this);
            if (e2.hi = (e2.hi | (127 & this.buf[this.pos]) << 7 * t2 + 3) >>> 0, this.buf[this.pos++] < 128) return e2;
          }
          throw Error("invalid varint encoding");
        }
        function p(e2, t2) {
          return (e2[t2 - 4] | e2[t2 - 3] << 8 | e2[t2 - 2] << 16 | e2[t2 - 1] << 24) >>> 0;
        }
        function m() {
          if (this.pos + 8 > this.len) throw n(this, 8);
          return new a(p(this.buf, this.pos += 4), p(this.buf, this.pos += 4));
        }
        d.create = u(), d.prototype._slice = s.Array.prototype.subarray || s.Array.prototype.slice, d.prototype.uint32 = (c = 4294967295, function() {
          if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c;
          if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c;
          if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c;
          if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c;
          if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c;
          if ((this.pos += 5) > this.len) throw this.pos = this.len, n(this, 10);
          return c;
        }), d.prototype.int32 = function() {
          return 0 | this.uint32();
        }, d.prototype.sint32 = function() {
          var e2 = this.uint32();
          return e2 >>> 1 ^ -(1 & e2) | 0;
        }, d.prototype.bool = function() {
          return 0 !== this.uint32();
        }, d.prototype.fixed32 = function() {
          if (this.pos + 4 > this.len) throw n(this, 4);
          return p(this.buf, this.pos += 4);
        }, d.prototype.sfixed32 = function() {
          if (this.pos + 4 > this.len) throw n(this, 4);
          return 0 | p(this.buf, this.pos += 4);
        }, d.prototype.float = function() {
          if (this.pos + 4 > this.len) throw n(this, 4);
          var e2 = s.float.readFloatLE(this.buf, this.pos);
          return this.pos += 4, e2;
        }, d.prototype.double = function() {
          if (this.pos + 8 > this.len) throw n(this, 4);
          var e2 = s.float.readDoubleLE(this.buf, this.pos);
          return this.pos += 8, e2;
        }, d.prototype.bytes = function() {
          var e2 = this.uint32(), t2 = this.pos, i2 = this.pos + e2;
          if (i2 > this.len) throw n(this, e2);
          return this.pos += e2, Array.isArray(this.buf) ? this.buf.slice(t2, i2) : t2 === i2 ? new this.buf.constructor(0) : this._slice.call(this.buf, t2, i2);
        }, d.prototype.string = function() {
          var e2 = this.bytes();
          return o.read(e2, 0, e2.length);
        }, d.prototype.skip = function(e2) {
          if ("number" == typeof e2) {
            if (this.pos + e2 > this.len) throw n(this, e2);
            this.pos += e2;
          } else do {
            if (this.pos >= this.len) throw n(this);
          } while (128 & this.buf[this.pos++]);
          return this;
        }, d.prototype.skipType = function(e2) {
          switch (e2) {
            case 0:
              this.skip();
              break;
            case 1:
              this.skip(8);
              break;
            case 2:
              this.skip(this.uint32());
              break;
            case 3:
              for (; 4 != (e2 = 7 & this.uint32()); ) this.skipType(e2);
              break;
            case 5:
              this.skip(4);
              break;
            default:
              throw Error("invalid wire type " + e2 + " at offset " + this.pos);
          }
          return this;
        }, d._configure = function(e2) {
          r = e2, d.create = u(), r._configure();
          var t2 = s.Long ? "toLong" : "toNumber";
          s.merge(d.prototype, { int64: function() {
            return h.call(this)[t2](false);
          }, uint64: function() {
            return h.call(this)[t2](true);
          }, sint64: function() {
            return h.call(this).zzDecode()[t2](false);
          }, fixed64: function() {
            return m.call(this)[t2](true);
          }, sfixed64: function() {
            return m.call(this)[t2](false);
          } });
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = s;
        var r = i(44);
        function s(e2) {
          if (e2) for (var t2 = Object.keys(e2), i2 = 0; i2 < t2.length; ++i2) this[t2[i2]] = e2[t2[i2]];
        }
        s.create = function(e2) {
          return this.$type.create(e2);
        }, s.encode = function(e2, t2) {
          return this.$type.encode(e2, t2);
        }, s.encodeDelimited = function(e2, t2) {
          return this.$type.encodeDelimited(e2, t2);
        }, s.decode = function(e2) {
          return this.$type.decode(e2);
        }, s.decodeDelimited = function(e2) {
          return this.$type.decodeDelimited(e2);
        }, s.verify = function(e2) {
          return this.$type.verify(e2);
        }, s.fromObject = function(e2) {
          return this.$type.fromObject(e2);
        }, s.toObject = function(e2, t2) {
          return this.$type.toObject(e2, t2);
        }, s.prototype.toJSON = function() {
          return this.$type.toObject(this, r.toJSONOptions);
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.ajax = t.getFormData = void 0;
        const s = r(i(6)), a = r(i(8)), o = i(81);
        t.getFormData = (e2) => Object.keys(e2).map((t2) => encodeURIComponent(t2) + "=" + encodeURIComponent(/Object/i.test(e2[t2]) ? o.JSONBigStringify(e2[t2]) : e2[t2])).join("&"), t.ajax = function(e2) {
          if (!e2 || !e2.url) return Promise.reject(new a.default({ code: s.default.NETWORK_REQUEST_ERROR, message: "ajax: 参数异常" }));
          e2.dataType = e2.dataType || "json";
          var i2 = new XMLHttpRequest();
          i2.open(e2.type || "GET", e2.url, true), i2.responseType = "" + e2.dataType;
          const r2 = e2.contentType || "application/json;charset=UTF-8";
          return i2.setRequestHeader("Content-type", r2), e2.header && Object.keys(e2.header).map((t2) => {
            e2.header && e2.header[t2] && i2.setRequestHeader(t2, e2.header[t2]);
          }), new Promise((n, d) => {
            i2.onload = function() {
              if (i2.status > 400) return Promise.reject(new a.default({ code: s.default.NETWORK_REQUEST_ERROR, message: "ajax: 响应异常, code: " + i2.status }));
              var e3 = i2.response;
              n(e3);
            }, i2.onerror = function(e3) {
              d(e3);
            }, i2.ontimeout = function(t2) {
              d({ code: 456, desc: "ERR_TIMED_OUT " + e2.url });
            }, r2.indexOf("x-www-form-urlencoded") >= 0 ? e2.data ? i2.send(t.getFormData(e2.data)) : i2.send() : e2.data ? e2.header && "gzip" === e2.header["Content-Encoding"] ? i2.send(e2.data) : i2.send(o.JSONBigStringify(e2.data)) : i2.send();
          });
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.audioPlugins = t.videoPlugins = void 0;
        t.videoPlugins = ["VirtualBackground", "AdvancedBeauty"], t.audioPlugins = ["AIAudioEffects", "AIhowling"], t.default = ["VirtualBackground", "AdvancedBeauty", "AIAudioEffects", "AIhowling"];
      }, function(e, t, i) {
        "use strict";
        function r(e2, t2) {
          return { ARRAY_BUFFER: e2.ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER: e2.ELEMENT_ARRAY_BUFFER }[null != t2 ? t2 : "ARRAY_BUFFER"];
        }
        function s(e2, t2) {
          return { STATIC_DRAW: e2.STATIC_DRAW, DYNAMIC_DRAW: e2.DYNAMIC_DRAW, STREAM_DRAW: e2.STREAM_DRAW }[null != t2 ? t2 : "STATIC_DRAW"];
        }
        function a(e2, t2) {
          const i2 = { Int8Array: e2.BYTE, Uint8Array: e2.UNSIGNED_BYTE, Int16Array: e2.SHORT, Uint16Array: e2.UNSIGNED_SHORT, Int32Array: e2.INT, Uint32Array: e2.UNSIGNED_INT, Float32Array: e2.FLOAT }[Object.prototype.toString.call(t2).replace(/object|\[|\]|\s/g, "")];
          return void 0 === i2 ? (console.warn("attribute buffer type error.\n legal type may << Int8Array、Uint8Array、Int16Array、Uint16Array、Float32Array."), e2.FLOAT) : i2;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.parseAttributes = t.createAttributeBuffer = void 0, t.createAttributeBuffer = function(e2, t2, i2, o, n, d, c, l, u) {
          const h = e2.createBuffer();
          if (!h) return console.error("buffer created failed."), null;
          const p = i2.length;
          return { type: a(e2, i2), buffer: h, name: t2, typedArray: i2, itemSize: null != o ? o : 1, count: p / (null != o ? o : 1) >> 0, normalized: null != c && c, target: r(e2, n), usage: s(e2, d), stride: null != l ? l : 0, offset: null != u ? u : 0 };
        }, t.parseAttributes = function(e2, t2) {
          const i2 = e2.getProgramParameter(t2, e2.ACTIVE_ATTRIBUTES), o = {};
          for (let n = 0; n < i2; n++) {
            const i3 = e2.getActiveAttrib(t2, n);
            if (i3) {
              const { name: n2 } = i3, d = e2.getAttribLocation(t2, n2);
              if (null !== d) {
                const t3 = { type: e2.FLOAT, buffer: null, typedArray: null, itemSize: 1, count: 0, normalized: false, target: r(e2), usage: s(e2), stride: 0, offset: 0, setter: (i4) => {
                  if (i4) {
                    const { buffer: r2 } = t3;
                    if (!r2) return void console.error(`buffer of attribute:[${n2}] is not initialized.`);
                    const { type: s2 } = t3;
                    if (a(e2, i4) !== s2) return void console.error(`typedArray's type of attribute:[${n2}] is inconsistent.`);
                    t3.typedArray = i4;
                    const { itemSize: o2, normalized: c, target: l, usage: u, stride: h, offset: p } = t3;
                    e2.bindBuffer(l, r2), e2.bufferData(l, i4, u), e2.enableVertexAttribArray(d), e2.vertexAttribPointer(d, o2, s2, c, h, p);
                  } else {
                    const { buffer: i5, type: r2, itemSize: s2, normalized: a2, target: o2, stride: n3, offset: c } = t3;
                    e2.bindBuffer(o2, i5), e2.vertexAttribPointer(d, s2, r2, a2, n3, c);
                  }
                }, bufferSetter: (e3) => {
                  if (e3) {
                    const { name: i4 } = e3;
                    i4 === n2 && (t3.type = e3.type, t3.buffer = e3.buffer, t3.itemSize = e3.itemSize, t3.count = e3.count, t3.normalized = e3.normalized, t3.target = e3.target, t3.usage = e3.usage, t3.stride = e3.stride, t3.offset = e3.offset, t3.setter(e3.typedArray));
                  }
                }, get attributeBuffer() {
                  return null === t3.buffer ? null : { type: t3.type, buffer: t3.buffer, name: n2, typedArray: t3.typedArray, itemSize: t3.itemSize, count: t3.count, normalized: t3.normalized, target: t3.target, usage: t3.usage, stride: t3.stride, offset: t3.offset };
                } };
                o[n2] = t3;
              } else console.warn(`attribute:[${n2}] is null.`);
            }
          }
          return o;
        };
      }, , , , , , , , function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.checkSystemRequirements = t.systemChecker = void 0;
        t.systemChecker = new class {
          constructor() {
            this.checkCnt = 0;
          }
          checkSystemRequirements() {
            this.checkCnt++;
            const e2 = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
            return e2 ? e2.prototype.getSenders && e2.prototype.addTransceiver && e2.prototype.getTransceivers || e2.prototype.addStream ? !!window.WebSocket || (console.warn("checkSystemRequirements: 没有 WebSocket 对象。"), false) : (console.warn("checkSystemRequirements: RTCPeerConnection不符合sdk要求"), false) : (console.warn("checkSystemRequirements: 没有 RTCPeerConnection 对象。"), false);
          }
        }(), t.checkSystemRequirements = function() {
          return t.systemChecker.checkSystemRequirements();
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AuidoMixingState = void 0, t.AuidoMixingState = { UNSTART: "MIX_UNSTART", STARTING: "MIX_STARTING", PLAYED: "MIX_PLAYING", PAUSED: "MIX_PAUSED", STOPED: "MIX_STOPED" };
      }, function(e, t) {
        var i = { utf8: { stringToBytes: function(e2) {
          return i.bin.stringToBytes(unescape(encodeURIComponent(e2)));
        }, bytesToString: function(e2) {
          return decodeURIComponent(escape(i.bin.bytesToString(e2)));
        } }, bin: { stringToBytes: function(e2) {
          for (var t2 = [], i2 = 0; i2 < e2.length; i2++) t2.push(255 & e2.charCodeAt(i2));
          return t2;
        }, bytesToString: function(e2) {
          for (var t2 = [], i2 = 0; i2 < e2.length; i2++) t2.push(String.fromCharCode(e2[i2]));
          return t2.join("");
        } } };
        e.exports = i;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.parseScalabilityMode = t.Device = t.detectDevice = t.version = t.types = void 0;
        const o = i(168);
        Object.defineProperty(t, "detectDevice", { enumerable: true, get: function() {
          return o.detectDevice;
        } }), Object.defineProperty(t, "Device", { enumerable: true, get: function() {
          return o.Device;
        } });
        const n = a(i(240));
        t.types = n, t.version = "__MEDIASOUP_CLIENT_VERSION__";
        var d = i(243);
        Object.defineProperty(t, "parseScalabilityMode", { enumerable: true, get: function() {
          return d.parse;
        } });
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Device = t.detectDevice = void 0;
        const o = i(86), n = i(78), d = i(222), c = i(230), l = i(236), u = i(237), h = i(29), p = a(i(79)), m = i(171), g = a(i(27)), f = a(i(7)), v = i(77), S = i(149), y = "Device";
        function _() {
          return "object" == typeof navigator && "string" == typeof navigator.userAgent ? f.IS_CHROME_ONLY && f.CHROME_MAJOR_VERSION && f.CHROME_MAJOR_VERSION >= 58 && f.CHROME_MAJOR_VERSION < 69 ? "Chrome58" : f.IS_CHROME_ONLY && f.CHROME_MAJOR_VERSION && f.CHROME_MAJOR_VERSION >= 69 || f.IS_EDG && f.IS_CHROME_ONLY && f.ANY_CHROME_MAJOR_VERSION && f.ANY_CHROME_MAJOR_VERSION >= 69 ? "Chrome74" : f.IS_ANDROID ? f.ANY_CHROME_MAJOR_VERSION && f.ANY_CHROME_MAJOR_VERSION >= 58 && f.ANY_CHROME_MAJOR_VERSION < 69 ? "Chrome58" : "Chrome74" : f.IS_ELECTRON && f.IS_CHROME_ONLY && f.ANY_CHROME_MAJOR_VERSION && f.ANY_CHROME_MAJOR_VERSION >= 69 ? "Chrome74" : f.IS_FIREFOX && f.FIREFOX_MAJOR_VERSION && f.FIREFOX_MAJOR_VERSION >= 58 ? "Firefox60" : f.IS_ANY_SAFARI && f.SAFARI_MAJOR_VERSION && f.SAFARI_MAJOR_VERSION >= 12 || f.IS_ANY_SAFARI && f.IS_WECHAT || S.isIosFromRtpStats() ? "Safari12" : (h.Logger.warn(y, "this._detectDevice() | browser not supported [name:%s, version:%s], using Chrome72 as default", v.getBrowserInfo().browserName, v.getBrowserInfo().browserVersion), "Chrome74") : (h.Logger.warn(y, "this._detectDevice() | unknown device, using Chrome 72 as default"), "Chrome74");
        }
        t.detectDevice = _;
        t.Device = class {
          constructor({ handlerName: e2, handlerFactory: t2, Handler: i2 } = {}) {
            if (this._loaded = false, this._observer = new o.EnhancedEventEmitter(), h.Logger.debug(y, "constructor()"), i2) {
              if (h.Logger.warn(y, "constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead"), "string" != typeof i2) throw new TypeError("non string Handler option no longer supported, use handlerFactory instead");
              e2 = i2;
            }
            if (e2 && t2) throw new TypeError("just one of handlerName or handlerInterface can be given");
            if (t2) this._handlerFactory = t2;
            else {
              if (e2) h.Logger.debug(y, "constructor() | handler given: %s", e2);
              else {
                if (!(e2 = _())) throw new n.UnsupportedError("device not supported");
                h.Logger.debug(y, "constructor() | detected handler: %s", e2);
              }
              switch (e2) {
                case "Chrome58":
                  this._handlerFactory = c.Chrome58.createFactory();
                  break;
                case "Chrome74":
                  this._handlerFactory = d.Chrome74.createFactory();
                  break;
                case "Safari12":
                  this._handlerFactory = u.Safari12.createFactory();
                  break;
                case "Firefox60":
                  this._handlerFactory = l.Firefox60.createFactory();
                  break;
                default:
                  h.Logger.warn(`unknown browser handlerName "${e2}, using Chrome 74 as default"`), this._handlerFactory = d.Chrome74.createFactory();
              }
            }
            const r2 = this._handlerFactory();
            this._handlerName = r2.name, r2.close(), this._extendedRtpCapabilities = void 0, this._recvRtpCapabilities = void 0, this._canProduceByKind = { audio: false, video: false }, this._sctpCapabilities = void 0;
          }
          get handlerName() {
            return this._handlerName;
          }
          get loaded() {
            return this._loaded;
          }
          get rtpCapabilities() {
            if (!this._loaded) throw new n.InvalidStateError("not loaded");
            return this._recvRtpCapabilities;
          }
          get sctpCapabilities() {
            if (!this._loaded) throw new n.InvalidStateError("not loaded");
            return this._sctpCapabilities;
          }
          get observer() {
            return this._observer;
          }
          async load({ routerRtpCapabilities: e2 }) {
            let t2;
            h.Logger.debug(y, "load()"), e2 = g.clone(e2, void 0);
            try {
              if (this._loaded) throw new n.InvalidStateError("already loaded");
              p.validateRtpCapabilities(e2), t2 = this._handlerFactory();
              const i2 = await t2.getNativeRtpCapabilities();
              h.Logger.debug(y, "load() | got native RTP capabilities"), p.validateRtpCapabilities(i2), this._extendedRtpCapabilities = p.getExtendedRtpCapabilities(i2, e2), h.Logger.debug(y, "load() | got extended RTP capabilities"), this._canProduceByKind.audio = p.canSend("audio", this._extendedRtpCapabilities), this._canProduceByKind.video = p.canSend("video", this._extendedRtpCapabilities), this._recvRtpCapabilities = p.getRecvRtpCapabilities(this._extendedRtpCapabilities), p.validateRtpCapabilities(this._recvRtpCapabilities), h.Logger.debug(y, "load() | got receiving RTP capabilities"), this._sctpCapabilities = await t2.getNativeSctpCapabilities(), h.Logger.debug(y, "load() | got native SCTP capabilities"), p.validateSctpCapabilities(this._sctpCapabilities), h.Logger.debug(y, "load() succeeded"), this._loaded = true, t2.close();
            } catch (e3) {
              throw t2 && t2.close(), e3;
            }
          }
          canProduce(e2) {
            if (!this._loaded) throw new n.InvalidStateError("not loaded");
            if ("audio" !== e2 && "video" !== e2) throw new TypeError(`invalid kind "${e2}"`);
            return this._canProduceByKind[e2];
          }
          createSendTransport({ id: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: n2, proprietaryConstraints: d2, appData: c2 = {} }) {
            return h.Logger.debug(y, "createSendTransport()"), this._createTransport({ direction: "send", id: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: n2, proprietaryConstraints: d2, appData: c2 });
          }
          createRecvTransport({ id: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: n2, proprietaryConstraints: d2, appData: c2 = {} }) {
            return h.Logger.debug(y, "createRecvTransport()"), this._createTransport({ direction: "recv", id: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: n2, proprietaryConstraints: d2, appData: c2 });
          }
          _createTransport({ direction: e2, id: t2, iceParameters: i2, iceCandidates: r2, dtlsParameters: s2, sctpParameters: a2, iceServers: o2, iceTransportPolicy: d2, additionalSettings: c2, proprietaryConstraints: l2, appData: u2 = {} }) {
            if (!this._loaded) throw new n.InvalidStateError("not loaded");
            if (u2 && "object" != typeof u2) throw new TypeError("if given, appData must be an object");
            const h2 = new m.Transport({ direction: e2, id: t2, iceParameters: i2, iceCandidates: r2, dtlsParameters: s2, sctpParameters: a2, iceServers: o2, iceTransportPolicy: d2, additionalSettings: c2, proprietaryConstraints: l2, appData: u2, handlerFactory: this._handlerFactory, extendedRtpCapabilities: this._extendedRtpCapabilities, canProduceByKind: this._canProduceByKind });
            return this._observer.safeEmit("newtransport", h2), h2;
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r, s = "object" == typeof Reflect ? Reflect : null, a = s && "function" == typeof s.apply ? s.apply : function(e2, t2, i2) {
          return Function.prototype.apply.call(e2, t2, i2);
        };
        r = s && "function" == typeof s.ownKeys ? s.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var o = Number.isNaN || function(e2) {
          return e2 != e2;
        };
        function n() {
          n.init.call(this);
        }
        e.exports = n, e.exports.once = function(e2, t2) {
          return new Promise(function(i2, r2) {
            function s2(i3) {
              e2.removeListener(t2, a2), r2(i3);
            }
            function a2() {
              "function" == typeof e2.removeListener && e2.removeListener("error", s2), i2([].slice.call(arguments));
            }
            v(e2, t2, a2, { once: true }), "error" !== t2 && function(e3, t3, i3) {
              "function" == typeof e3.on && v(e3, "error", t3, i3);
            }(e2, s2, { once: true });
          });
        }, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._eventsCount = 0, n.prototype._maxListeners = void 0;
        var d = 10;
        function c(e2) {
          if ("function" != typeof e2) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function l(e2) {
          return void 0 === e2._maxListeners ? n.defaultMaxListeners : e2._maxListeners;
        }
        function u(e2, t2, i2, r2) {
          var s2, a2, o2, n2;
          if (c(i2), void 0 === (a2 = e2._events) ? (a2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== a2.newListener && (e2.emit("newListener", t2, i2.listener ? i2.listener : i2), a2 = e2._events), o2 = a2[t2]), void 0 === o2) o2 = a2[t2] = i2, ++e2._eventsCount;
          else if ("function" == typeof o2 ? o2 = a2[t2] = r2 ? [i2, o2] : [o2, i2] : r2 ? o2.unshift(i2) : o2.push(i2), (s2 = l(e2)) > 0 && o2.length > s2 && !o2.warned) {
            o2.warned = true;
            var d2 = new Error("Possible EventEmitter memory leak detected. " + o2.length + " " + String(t2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            d2.name = "MaxListenersExceededWarning", d2.emitter = e2, d2.type = t2, d2.count = o2.length, n2 = d2, console && console.warn && console.warn(n2);
          }
          return e2;
        }
        function h() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function p(e2, t2, i2) {
          var r2 = { fired: false, wrapFn: void 0, target: e2, type: t2, listener: i2 }, s2 = h.bind(r2);
          return s2.listener = i2, r2.wrapFn = s2, s2;
        }
        function m(e2, t2, i2) {
          var r2 = e2._events;
          if (void 0 === r2) return [];
          var s2 = r2[t2];
          return void 0 === s2 ? [] : "function" == typeof s2 ? i2 ? [s2.listener || s2] : [s2] : i2 ? function(e3) {
            for (var t3 = new Array(e3.length), i3 = 0; i3 < t3.length; ++i3) t3[i3] = e3[i3].listener || e3[i3];
            return t3;
          }(s2) : f(s2, s2.length);
        }
        function g(e2) {
          var t2 = this._events;
          if (void 0 !== t2) {
            var i2 = t2[e2];
            if ("function" == typeof i2) return 1;
            if (void 0 !== i2) return i2.length;
          }
          return 0;
        }
        function f(e2, t2) {
          for (var i2 = new Array(t2), r2 = 0; r2 < t2; ++r2) i2[r2] = e2[r2];
          return i2;
        }
        function v(e2, t2, i2, r2) {
          if ("function" == typeof e2.on) r2.once ? e2.once(t2, i2) : e2.on(t2, i2);
          else {
            if ("function" != typeof e2.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
            e2.addEventListener(t2, function s2(a2) {
              r2.once && e2.removeEventListener(t2, s2), i2(a2);
            });
          }
        }
        Object.defineProperty(n, "defaultMaxListeners", { enumerable: true, get: function() {
          return d;
        }, set: function(e2) {
          if ("number" != typeof e2 || e2 < 0 || o(e2)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          d = e2;
        } }), n.init = function() {
          void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, n.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || e2 < 0 || o(e2)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, n.prototype.getMaxListeners = function() {
          return l(this);
        }, n.prototype.emit = function(e2) {
          for (var t2 = [], i2 = 1; i2 < arguments.length; i2++) t2.push(arguments[i2]);
          var r2 = "error" === e2, s2 = this._events;
          if (void 0 !== s2) r2 = r2 && void 0 === s2.error;
          else if (!r2) return false;
          if (r2) {
            var o2;
            if (t2.length > 0 && (o2 = t2[0]), o2 instanceof Error) throw o2;
            var n2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
            throw n2.context = o2, n2;
          }
          var d2 = s2[e2];
          if (void 0 === d2) return false;
          if ("function" == typeof d2) a(d2, this, t2);
          else {
            var c2 = d2.length, l2 = f(d2, c2);
            for (i2 = 0; i2 < c2; ++i2) a(l2[i2], this, t2);
          }
          return true;
        }, n.prototype.addListener = function(e2, t2) {
          return u(this, e2, t2, false);
        }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function(e2, t2) {
          return u(this, e2, t2, true);
        }, n.prototype.once = function(e2, t2) {
          return c(t2), this.on(e2, p(this, e2, t2)), this;
        }, n.prototype.prependOnceListener = function(e2, t2) {
          return c(t2), this.prependListener(e2, p(this, e2, t2)), this;
        }, n.prototype.removeListener = function(e2, t2) {
          var i2, r2, s2, a2, o2;
          if (c(t2), void 0 === (r2 = this._events)) return this;
          if (void 0 === (i2 = r2[e2])) return this;
          if (i2 === t2 || i2.listener === t2) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r2[e2], r2.removeListener && this.emit("removeListener", e2, i2.listener || t2));
          else if ("function" != typeof i2) {
            for (s2 = -1, a2 = i2.length - 1; a2 >= 0; a2--) if (i2[a2] === t2 || i2[a2].listener === t2) {
              o2 = i2[a2].listener, s2 = a2;
              break;
            }
            if (s2 < 0) return this;
            0 === s2 ? i2.shift() : function(e3, t3) {
              for (; t3 + 1 < e3.length; t3++) e3[t3] = e3[t3 + 1];
              e3.pop();
            }(i2, s2), 1 === i2.length && (r2[e2] = i2[0]), void 0 !== r2.removeListener && this.emit("removeListener", e2, o2 || t2);
          }
          return this;
        }, n.prototype.off = n.prototype.removeListener, n.prototype.removeAllListeners = function(e2) {
          var t2, i2, r2;
          if (void 0 === (i2 = this._events)) return this;
          if (void 0 === i2.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== i2[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete i2[e2]), this;
          if (0 === arguments.length) {
            var s2, a2 = Object.keys(i2);
            for (r2 = 0; r2 < a2.length; ++r2) "removeListener" !== (s2 = a2[r2]) && this.removeAllListeners(s2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if ("function" == typeof (t2 = i2[e2])) this.removeListener(e2, t2);
          else if (void 0 !== t2) for (r2 = t2.length - 1; r2 >= 0; r2--) this.removeListener(e2, t2[r2]);
          return this;
        }, n.prototype.listeners = function(e2) {
          return m(this, e2, true);
        }, n.prototype.rawListeners = function(e2) {
          return m(this, e2, false);
        }, n.listenerCount = function(e2, t2) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t2) : g.call(e2, t2);
        }, n.prototype.listenerCount = g, n.prototype.eventNames = function() {
          return this._eventsCount > 0 ? r(this._events) : [];
        };
      }, function(e, t) {
        var i = e.exports = { v: [{ name: "version", reg: /^(\d*)$/ }], o: [{ name: "origin", reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/, names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"], format: "%s %s %d %s IP%d %s" }], s: [{ name: "name" }], i: [{ name: "description" }], u: [{ name: "uri" }], e: [{ name: "email" }], p: [{ name: "phone" }], z: [{ name: "timezones" }], r: [{ name: "repeats" }], t: [{ name: "timing", reg: /^(\d*) (\d*)/, names: ["start", "stop"], format: "%d %d" }], c: [{ name: "connection", reg: /^IN IP(\d) (\S*)/, names: ["version", "ip"], format: "IN IP%d %s" }], b: [{ push: "bandwidth", reg: /^(TIAS|AS|CT|RR|RS):(\d*)/, names: ["type", "limit"], format: "%s:%s" }], m: [{ reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/, names: ["type", "port", "protocol", "payloads"], format: "%s %d %s %s" }], a: [{ push: "rtp", reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/, names: ["payload", "codec", "rate", "encoding"], format: function(e2) {
          return e2.encoding ? "rtpmap:%d %s/%s/%s" : e2.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
        } }, { push: "fmtp", reg: /^fmtp:(\d*) ([\S| ]*)/, names: ["payload", "config"], format: "fmtp:%d %s" }, { name: "control", reg: /^control:(.*)/, format: "control:%s" }, { name: "rtcp", reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/, names: ["port", "netType", "ipVer", "address"], format: function(e2) {
          return null != e2.address ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
        } }, { push: "rtcpFbTrrInt", reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/, names: ["payload", "value"], format: "rtcp-fb:%s trr-int %d" }, { push: "rtcpFb", reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/, names: ["payload", "type", "subtype"], format: function(e2) {
          return null != e2.subtype ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
        } }, { push: "ext", reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/, names: ["value", "direction", "encrypt-uri", "uri", "config"], format: function(e2) {
          return "extmap:%d" + (e2.direction ? "/%s" : "%v") + (e2["encrypt-uri"] ? " %s" : "%v") + " %s" + (e2.config ? " %s" : "");
        } }, { name: "extmapAllowMixed", reg: /^(extmap-allow-mixed)/ }, { push: "crypto", reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/, names: ["id", "suite", "config", "sessionConfig"], format: function(e2) {
          return null != e2.sessionConfig ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
        } }, { name: "setup", reg: /^setup:(\w*)/, format: "setup:%s" }, { name: "connectionType", reg: /^connection:(new|existing)/, format: "connection:%s" }, { name: "mid", reg: /^mid:([^\s]*)/, format: "mid:%s" }, { name: "msid", reg: /^msid:(.*)/, format: "msid:%s" }, { name: "ptime", reg: /^ptime:(\d*(?:\.\d*)*)/, format: "ptime:%d" }, { name: "maxptime", reg: /^maxptime:(\d*(?:\.\d*)*)/, format: "maxptime:%d" }, { name: "direction", reg: /^(sendrecv|recvonly|sendonly|inactive)/ }, { name: "icelite", reg: /^(ice-lite)/ }, { name: "iceUfrag", reg: /^ice-ufrag:(\S*)/, format: "ice-ufrag:%s" }, { name: "icePwd", reg: /^ice-pwd:(\S*)/, format: "ice-pwd:%s" }, { name: "fingerprint", reg: /^fingerprint:(\S*) (\S*)/, names: ["type", "hash"], format: "fingerprint:%s %s" }, { push: "candidates", reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/, names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"], format: function(e2) {
          var t2 = "candidate:%s %d %s %d %s %d typ %s";
          return t2 += null != e2.raddr ? " raddr %s rport %d" : "%v%v", t2 += null != e2.tcptype ? " tcptype %s" : "%v", null != e2.generation && (t2 += " generation %d"), t2 += null != e2["network-id"] ? " network-id %d" : "%v", t2 += null != e2["network-cost"] ? " network-cost %d" : "%v";
        } }, { name: "endOfCandidates", reg: /^(end-of-candidates)/ }, { name: "remoteCandidates", reg: /^remote-candidates:(.*)/, format: "remote-candidates:%s" }, { name: "iceOptions", reg: /^ice-options:(\S*)/, format: "ice-options:%s" }, { push: "ssrcs", reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/, names: ["id", "attribute", "value"], format: function(e2) {
          var t2 = "ssrc:%d";
          return null != e2.attribute && (t2 += " %s", null != e2.value && (t2 += ":%s")), t2;
        } }, { push: "ssrcGroups", reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/, names: ["semantics", "ssrcs"], format: "ssrc-group:%s %s" }, { name: "msidSemantic", reg: /^msid-semantic:\s?(\w*) (\S*)/, names: ["semantic", "token"], format: "msid-semantic: %s %s" }, { push: "groups", reg: /^group:(\w*) (.*)/, names: ["type", "mids"], format: "group:%s %s" }, { name: "rtcpMux", reg: /^(rtcp-mux)/ }, { name: "rtcpRsize", reg: /^(rtcp-rsize)/ }, { name: "sctpmap", reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/, names: ["sctpmapNumber", "app", "maxMessageSize"], format: function(e2) {
          return null != e2.maxMessageSize ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
        } }, { name: "xGoogleFlag", reg: /^x-google-flag:([^\s]*)/, format: "x-google-flag:%s" }, { push: "rids", reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/, names: ["id", "direction", "params"], format: function(e2) {
          return e2.params ? "rid:%s %s %s" : "rid:%s %s";
        } }, { push: "imageattrs", reg: new RegExp("^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"), names: ["pt", "dir1", "attrs1", "dir2", "attrs2"], format: function(e2) {
          return "imageattr:%s %s %s" + (e2.dir2 ? " %s %s" : "");
        } }, { name: "simulcast", reg: new RegExp("^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"), names: ["dir1", "list1", "dir2", "list2"], format: function(e2) {
          return "simulcast:%s %s" + (e2.dir2 ? " %s %s" : "");
        } }, { name: "simulcast_03", reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/, names: ["value"], format: "simulcast: %s" }, { name: "framerate", reg: /^framerate:(\d+(?:$|\.\d+))/, format: "framerate:%s" }, { name: "sourceFilter", reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/, names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"], format: "source-filter: %s %s %s %s %s" }, { name: "bundleOnly", reg: /^(bundle-only)/ }, { name: "label", reg: /^label:(.+)/, format: "label:%s" }, { name: "sctpPort", reg: /^sctp-port:(\d+)$/, format: "sctp-port:%s" }, { name: "maxMessageSize", reg: /^max-message-size:(\d+)$/, format: "max-message-size:%s" }, { push: "tsRefClocks", reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/, names: ["clksrc", "clksrcExt"], format: function(e2) {
          return "ts-refclk:%s" + (null != e2.clksrcExt ? "=%s" : "");
        } }, { name: "mediaClk", reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/, names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"], format: function(e2) {
          var t2 = "mediaclk:";
          return t2 += null != e2.id ? "id=%s %s" : "%v%s", t2 += null != e2.mediaClockValue ? "=%s" : "", t2 += null != e2.rateNumerator ? " rate=%s" : "", t2 += null != e2.rateDenominator ? "/%s" : "";
        } }, { name: "keywords", reg: /^keywds:(.+)$/, format: "keywds:%s" }, { name: "content", reg: /^content:(.+)/, format: "content:%s" }, { name: "bfcpFloorCtrl", reg: /^floorctrl:(c-only|s-only|c-s)/, format: "floorctrl:%s" }, { name: "bfcpConfId", reg: /^confid:(\d+)/, format: "confid:%s" }, { name: "bfcpUserId", reg: /^userid:(\d+)/, format: "userid:%s" }, { name: "bfcpFloorId", reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/, names: ["id", "mStream"], format: "floorid:%s mstrm:%s" }, { push: "invalid", names: ["value"] }] };
        Object.keys(i).forEach(function(e2) {
          i[e2].forEach(function(e3) {
            e3.reg || (e3.reg = /(.*)/), e3.format || (e3.format = "%s");
          });
        });
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Transport = void 0;
        const o = i(239), n = a(i(7)), d = i(1), c = i(172), l = i(86), u = i(78), h = i(29), p = a(i(79)), m = i(173), g = a(i(27)), f = "Transport";
        let v = 0;
        class S extends l.EnhancedEventEmitter {
          constructor({ direction: e2, id: t2, iceParameters: i2, iceCandidates: r2, dtlsParameters: s2, sctpParameters: a2, iceServers: n2, iceTransportPolicy: d2, additionalSettings: c2, proprietaryConstraints: p2, appData: m2, handlerFactory: S2, extendedRtpCapabilities: y, canProduceByKind: _ }) {
            super(), this.idx = ++v, this._closed = false, this._iceGatheringState = "new", this._connectionState = "new", this._producers = /* @__PURE__ */ new Map(), this._consumers = /* @__PURE__ */ new Map(), this._probatorConsumerCreated = false, this._awaitQueue = new o.AwaitQueue({ ClosedErrorClass: u.InvalidStateError }), this._observer = new l.EnhancedEventEmitter(), this.send = [], this.recv = [], h.Logger.debug(f, `constructor() [id: ${t2}, direction: ${e2}]`), this._id = t2, this._direction = e2, this._extendedRtpCapabilities = y, this._canProduceByKind = _, this._maxSctpMessageSize = a2 ? a2.maxMessageSize : null, delete (c2 = g.clone(c2, {})).iceServers, delete c2.iceTransportPolicy, delete c2.bundlePolicy, delete c2.rtcpMuxPolicy, delete c2.sdpSemantics, this._handler = S2(), this._handler.run({ direction: e2, iceParameters: i2, iceCandidates: r2, dtlsParameters: s2, sctpParameters: a2, iceServers: n2, iceTransportPolicy: d2, additionalSettings: c2, proprietaryConstraints: p2, extendedRtpCapabilities: y, appData: m2 }), this._appData = m2, this._handleHandler();
          }
          get id() {
            return this._id;
          }
          get closed() {
            return this._closed;
          }
          get direction() {
            return this._direction;
          }
          get handler() {
            return this._handler;
          }
          get iceGatheringState() {
            return this._iceGatheringState;
          }
          get connectionState() {
            return this._connectionState;
          }
          get appData() {
            return this._appData;
          }
          set appData(e2) {
          }
          get observer() {
            return this._observer;
          }
          close() {
            if (!this._closed) {
              h.Logger.debug(f, "close()"), this._closed = true, this._awaitQueue.close(), this._handler.close();
              for (const e2 of this._producers.values()) e2.transportClosed();
              this._producers.clear();
              for (const e2 of this._consumers.values()) e2.transportClosed();
              this._consumers.clear(), this._observer.safeEmit("close");
            }
          }
          async getStats() {
            if (this._closed) throw new u.InvalidStateError("closed");
            return this._handler.getTransportStats();
          }
          async restartIce({ iceParameters: e2 }) {
            if (h.Logger.debug(f, "restartIce()"), this._closed) throw new u.InvalidStateError("closed");
            if (!e2) throw new TypeError("missing iceParameters");
            return this._awaitQueue.push(async () => this._handler.restartIce(e2), "transport.restartIce()");
          }
          async updateIceServers({ iceServers: e2 } = {}) {
            if (h.Logger.debug(f, "updateIceServers()"), this._closed) throw new u.InvalidStateError("closed");
            if (!Array.isArray(e2)) throw new TypeError("missing iceServers");
            return this._handler.updateIceServers(e2);
          }
          async produce({ track: e2, trackLow: t2, encodings: i2, codecOptions: r2, codec: s2, stopTracks: a2 = false, disableTrackOnPause: o2 = true, zeroRtpOnPause: n2 = false, appData: d2 }) {
            if (h.Logger.debug(f, "produce()"), !e2) throw new TypeError("missing track");
            if ("send" !== this._direction) throw new u.UnsupportedError("not a sending Transport");
            if (!this._canProduceByKind[e2.kind]) throw new u.UnsupportedError("cannot produce " + e2.kind);
            if ("ended" === e2.readyState) throw new u.InvalidStateError("track ended");
            if (0 === this.listenerCount("produce")) throw new TypeError('no "produce" listener set into this transport');
            if (d2 && "object" != typeof d2) throw new TypeError("if given, appData must be an object");
            return this._awaitQueue.push(async () => {
              let c2;
              if (i2 && !Array.isArray(i2)) throw TypeError("encodings must be an array");
              i2 && 0 === i2.length ? c2 = void 0 : i2 && (c2 = i2.map((e3) => {
                const t3 = { active: true };
                return false === e3.active && (t3.active = false), "boolean" == typeof e3.dtx && (t3.dtx = e3.dtx), "string" == typeof e3.scalabilityMode && (t3.scalabilityMode = e3.scalabilityMode), "number" == typeof e3.scaleResolutionDownBy && (t3.scaleResolutionDownBy = e3.scaleResolutionDownBy), "number" == typeof e3.maxBitrate && (t3.maxBitrate = e3.maxBitrate), "number" == typeof e3.maxFramerate && (t3.maxFramerate = e3.maxFramerate), "boolean" == typeof e3.adaptivePtime && (t3.adaptivePtime = e3.adaptivePtime), "string" == typeof e3.priority && (t3.priority = e3.priority), "string" == typeof e3.networkPriority && (t3.networkPriority = e3.networkPriority), t3;
              }));
              const { localId: l2, localIdLow: u2, rtpParameters: h2, rtpSender: g2, rtpSenderLow: f2, dtlsParameters: v2, offer: S2 } = await this._handler.send({ track: e2, trackLow: t2, encodings: c2, codecOptions: r2, appData: d2, codec: s2 });
              g2 && this.updateSenderInfo(g2, "screenShare" === d2.mediaType ? "screen" : d2.mediaType, "high", l2), f2 && u2 && this.updateSenderInfo(f2, "screenShare" === d2.mediaType ? "screen" : d2.mediaType, "low", u2);
              try {
                p.validateRtpParameters(h2);
                const { id: i3 } = await this.safeEmitAsPromise("produce", { kind: e2.kind, rtpParameters: h2, track: e2, trackLow: t2, appData: d2, localDtlsParameters: v2, offer: S2 }), r3 = new m.Producer({ id: i3, localId: l2, localIdLow: u2, rtpSender: g2, rtpSenderLow: f2, track: e2, trackLow: t2, rtpParameters: h2, stopTracks: a2, disableTrackOnPause: o2, zeroRtpOnPause: n2, appData: d2 });
                return this._producers.set(r3.id, r3), this._handleProducer(r3), this._observer.safeEmit("newproducer", r3), r3;
              } catch (e3) {
                throw this._handler.stopSending(l2, d2.mediaType).catch(() => {
                }), e3;
              }
            }, "transport.produce()").catch((e3) => {
              throw e3;
            });
          }
          async fillRemoteRecvSdp({ kind: e2, appData: t2, iceParameters: i2, iceCandidates: r2, dtlsParameters: s2, sctpParameters: a2, sendingRtpParameters: o2, codecOptions: n2, offer: d2, audioProfile: c2, codec: l2, resetVideoSdp: u2 = false }) {
            await this._handler.fillRemoteRecvSdp({ kind: e2, appData: t2, iceParameters: i2, iceCandidates: r2, dtlsParameters: s2, sctpParameters: a2, sendingRtpParameters: o2, codecOptions: n2, offer: d2, codec: l2, audioProfile: c2, resetVideoSdp: u2 });
          }
          async prepareLocalSdp(e2, t2, i2) {
            try {
              const { dtlsParameters: r2, rtpCapabilities: s2, offer: a2, mid: o2, iceUfragReg: n2 } = await this._handler.prepareLocalSdp(e2, i2);
              if (!this._recvRtpCapabilities || !p.canSend("audio", this._recvRtpCapabilities) || !p.canSend("video", this._recvRtpCapabilities)) {
                let e3 = p.getExtendedRtpCapabilities(s2, t2);
                this._recvRtpCapabilities = p.getRecvRtpCapabilities(e3), p.validateRtpCapabilities(this._recvRtpCapabilities);
              }
              return { dtlsParameters: r2, rtpCapabilities: this._recvRtpCapabilities, offer: a2, mid: o2, iceUfragReg: n2 };
            } catch (e3) {
              throw e3;
            }
          }
          async recoverLocalSdp(e2, t2, i2) {
            if (!(n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION >= 58 && n.ANY_CHROME_MAJOR_VERSION < 69)) try {
              return void await this._handler.recoverTransceiver(e2, t2, i2);
            } catch (e3) {
              throw e3;
            }
          }
          updateSenderInfo(e2, t2, i2, r2) {
            let s2 = this.send.find((t3) => t3.sender === e2);
            return s2 ? (s2.mediaType !== t2 || s2.streamType || i2 || s2.localId !== r2) && (h.Logger.debug(f, `Sender Change. mediaType:${s2.mediaType} => ${t2}, StreamType: ${s2.streamType} => ${i2}, LocalId: ${s2.localId} => ${r2} index: ${s2.index}`), s2.mediaType = t2, s2.streamType = i2, s2.localId = r2, s2.index = 0) : (s2 = { sender: e2, mediaType: t2, streamType: i2, localId: r2, index: 0 }, this.send.unshift(s2)), s2;
          }
          updateReceiverInfo(e2, t2, i2, r2) {
            let s2 = this.recv.find((t3) => t3.receiver === e2);
            return s2 ? s2.uid === t2 && s2.mediaType === i2 && s2.localId === r2 || (h.Logger.debug(f, `Receiver Change. uid:${s2.uid} => ${t2}, mediaType:${s2.mediaType} => ${i2} localId: ${s2.localId} => ${r2} index: ${s2.index}`), s2.uid = t2, s2.mediaType = i2, s2.localId = r2, s2.index = 0) : (s2 = { receiver: e2, uid: t2, mediaType: i2, localId: r2, index: 0 }, this.recv.unshift(s2)), s2;
          }
          async consume({ id: e2, producerId: t2, kind: i2, uid: r2, mediaType: s2, rtpParameters: a2, appData: o2 = {}, offer: n2, iceParameters: l2, iceCandidates: p2, dtlsParameters: m2, sctpParameters: v2, probeSSrc: S2 }) {
            if (h.Logger.debug(f, "consume()"), a2 = g.clone(a2, void 0), this._closed) throw new u.InvalidStateError("closed");
            if ("recv" !== this._direction) throw new u.UnsupportedError("not a receiving Transport");
            if ("string" != typeof e2) throw new TypeError("missing id");
            if ("string" != typeof t2) throw new TypeError("missing producerId");
            if ("audio" !== i2 && "video" !== i2) throw new TypeError(`invalid kind '${i2}'`);
            if (o2 && "object" != typeof o2) throw new TypeError("if given, appData must be an object");
            return this._awaitQueue.push(async () => {
              const { localId: u2, rtpReceiver: g2, track: y } = await this._handler.receive({ iceParameters: l2, iceCandidates: p2, dtlsParameters: m2, sctpParameters: v2, trackId: e2, kind: i2, rtpParameters: a2, offer: n2, probeSSrc: S2, remoteUid: o2.remoteUid, extendedRtpCapabilities: this._extendedRtpCapabilities, appData: o2 });
              g2 && (this.updateReceiverInfo(g2, r2, s2, u2), "audio" === g2.track.kind && d.getParameters().audioPlayoutDelayHint && (g2.playoutDelayHint = d.getParameters().audioPlayoutDelayHint, h.Logger.debug(f, "audioPlayoutDelayHint: ", d.getParameters().audioPlayoutDelayHint)), "video" === g2.track.kind && d.getParameters().videoPlayoutDelayHint && (g2.playoutDelayHint = d.getParameters().videoPlayoutDelayHint, h.Logger.debug(f, "videoPlayoutDelayHint: ", d.getParameters().videoPlayoutDelayHint)));
              const _ = new c.Consumer({ id: e2, localId: u2, producerId: t2, rtpReceiver: g2, track: y, rtpParameters: a2, appData: o2 });
              return this._consumers.set(_.id, _), this._handleConsumer(_), this._observer.safeEmit("newconsumer", _), _;
            }, "transport.consume()");
          }
          _handleHandler() {
            const e2 = this._handler;
            e2.on("@connect", ({ dtlsParameters: e3 }, t2, i2) => {
              this._closed ? i2(new u.InvalidStateError("closed")) : this.safeEmit("connect", { dtlsParameters: e3 }, t2, i2);
            }), e2.on("@icegatheringstatechange", (e3) => {
              e3 !== this._iceGatheringState && (h.Logger.debug(f, "ICE gathering state changed to %s", e3), this._iceGatheringState = e3, this._closed || this.safeEmit("icegatheringstatechange", e3));
            }), e2.on("@connectionstatechange", (e3) => {
              e3 !== this._connectionState && (h.Logger.debug(f, "connection state changed to %s", e3), this._connectionState = e3, this._closed || this.safeEmit("connectionstatechange", e3));
            });
          }
          _handleProducer(e2) {
            e2.on("@close", () => {
              this._closed || (h.Logger.debug(f, "producer 关闭: ", e2.localId), this._awaitQueue.push(async () => this._handler.stopSending(e2.localId, e2.appData.mediaType)).catch((e3) => h.Logger.warn(f, "producer.close() failed:%o", e3)));
            }), e2.on("@replacetrack", (t2, i2, r2) => {
              this._awaitQueue.push(async () => this._handler.replaceTrack(e2.localId, t2), "producer @replacetrack event").then(i2).catch(r2);
            }), e2.on("@setmaxspatiallayer", (t2, i2, r2) => {
              this._awaitQueue.push(async () => this._handler.setMaxSpatialLayer(e2.localId, t2), "producer @setmaxspatiallayer event").then(i2).catch(r2);
            }), e2.on("@setrtpencodingparameters", (t2, i2, r2) => {
              this._awaitQueue.push(async () => this._handler.setRtpEncodingParameters(e2.localId, t2), "producer @setrtpencodingparameters event").then(i2).catch(r2);
            }), e2.on("@getstats", (t2, i2) => {
              if (this._closed) return i2(new u.InvalidStateError("closed"));
              this._handler.getSenderStats(e2.localId).then(t2).catch(i2);
            });
          }
          _handleConsumer(e2) {
            e2.on("@close", () => {
              this._consumers.delete(e2.id), this._closed || this._awaitQueue.push(async () => this._handler.stopReceiving(e2.localId), "consumer @close event").catch(() => {
              });
            }), e2.on("@getstats", (t2, i2) => {
              if (this._closed) return i2(new u.InvalidStateError("closed"));
              this._handler.getReceiverStats(e2.localId).then(t2).catch(i2);
            });
          }
        }
        t.Transport = S;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Consumer = void 0;
        const r = i(86), s = i(78), a = i(29), o = "Consumer";
        class n extends r.EnhancedEventEmitter {
          constructor({ id: e2, localId: t2, producerId: i2, rtpReceiver: s2, track: n2, rtpParameters: d, appData: c }) {
            super(), this._closed = false, this._observer = new r.EnhancedEventEmitter(), a.Logger.debug(o, "constructor()"), this._id = e2, this._localId = t2, this._producerId = i2, this._rtpReceiver = s2, this._track = n2, this._rtpParameters = d, this._paused = !n2.enabled, this._appData = c, this._onTrackEnded = this._onTrackEnded.bind(this), this._handleTrack();
          }
          get id() {
            return this._id;
          }
          get localId() {
            return this._localId;
          }
          get producerId() {
            return this._producerId;
          }
          get closed() {
            return this._closed;
          }
          get kind() {
            return this._track.kind;
          }
          get rtpReceiver() {
            return this._rtpReceiver;
          }
          get track() {
            return this._track;
          }
          get rtpParameters() {
            return this._rtpParameters;
          }
          get paused() {
            return this._paused;
          }
          get appData() {
            return this._appData;
          }
          set appData(e2) {
          }
          get observer() {
            return this._observer;
          }
          close() {
            this._closed || (a.Logger.debug(o, "close()"), this._closed = true, this._destroyTrack(), this.emit("@close"), this._observer.safeEmit("close"));
          }
          transportClosed() {
            this._closed || (a.Logger.debug(o, "transportClosed()"), this._closed = true, this._destroyTrack(), this.safeEmit("transportclose"), this._observer.safeEmit("close"));
          }
          async getStats() {
            if (this._closed) throw new s.InvalidStateError("closed");
            return this.safeEmitAsPromise("@getstats");
          }
          pause() {
            a.Logger.debug(o, "pause()"), this._closed ? a.Logger.error(o, "pause() | Consumer closed") : this._paused ? a.Logger.debug("pause() | Consumer is already paused") : (this._paused = true, this._track.enabled = false, this._observer.safeEmit("pause"));
          }
          resume() {
            a.Logger.debug(o, "resume()"), this._closed ? a.Logger.error(o, "resume() | Consumer closed") : this._paused ? (this._paused = false, this._track.enabled = true, this._observer.safeEmit("resume")) : a.Logger.debug("resume() | Consumer is already resumed");
          }
          _onTrackEnded() {
            a.Logger.debug(o, 'track "ended" event, %o, %s', this.id, this.kind), this.safeEmit("trackended"), this._observer.safeEmit("trackended");
          }
          _handleTrack() {
            this._track.addEventListener("ended", this._onTrackEnded);
          }
          _destroyTrack() {
            a.Logger.debug(o, "don not stop receiver track");
          }
        }
        t.Consumer = n;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Producer = void 0;
        const o = a(i(7)), n = i(1), d = i(86), c = i(78), l = i(29), u = "Producer";
        class h extends d.EnhancedEventEmitter {
          constructor({ id: e2, localId: t2, localIdLow: i2, rtpSender: r2, rtpSenderLow: s2, track: a2, trackLow: o2, rtpParameters: n2, stopTracks: c2, disableTrackOnPause: h2, zeroRtpOnPause: p, appData: m }) {
            super(), this._closed = false, this._observer = new d.EnhancedEventEmitter(), l.Logger.debug(u, "constructor()", t2), this._id = e2, this._localId = t2, this._localIdLow = i2, this._rtpSender = r2, this._rtpSenderLow = s2, this._track = a2, this._trackLow = o2, this._kind = a2.kind, this._rtpParameters = n2, this._paused = !!h2 && !a2.enabled, this._maxSpatialLayer = void 0, this._stopTracks = c2, this._disableTrackOnPause = h2, this._zeroRtpOnPause = p, this._appData = m, this._onTrackEnded = this._onTrackEnded.bind(this), this._handleTrack();
          }
          get id() {
            return this._id;
          }
          get localId() {
            return this._localId;
          }
          get closed() {
            return this._closed;
          }
          get kind() {
            return this._kind;
          }
          get rtpSender() {
            return this._rtpSender;
          }
          get track() {
            return this._track;
          }
          get rtpParameters() {
            return this._rtpParameters;
          }
          get paused() {
            return this._paused;
          }
          get maxSpatialLayer() {
            return this._maxSpatialLayer;
          }
          get appData() {
            return this._appData;
          }
          set appData(e2) {
          }
          get observer() {
            return this._observer;
          }
          close() {
            this._closed || (l.Logger.debug(u, "close()"), this._closed = true, this.emit("@close"), this._observer.safeEmit("close"));
          }
          transportClosed() {
            this._closed || (l.Logger.debug(u, "transportClosed()"), this._closed = true, this.safeEmit("transportclose"), this._observer.safeEmit("close"));
          }
          async getStats() {
            if (this._closed) throw new c.InvalidStateError("closed");
            return this.safeEmitAsPromise("@getstats");
          }
          pause() {
            l.Logger.debug(u, "pause()"), this._closed ? l.Logger.error(u, "pause() | Producer closed") : (this._paused = true, o.SAFARI_VERSION && 15.1 === parseFloat(o.SAFARI_VERSION) || this._disableTrackOnPause && (this._track && (this._track.enabled = false), this._trackLow && (this._trackLow.enabled = false)), this._zeroRtpOnPause && this.safeEmitAsPromise("@replacetrack", null).catch(() => {
            }), this._observer.safeEmit("pause"));
          }
          resume() {
            l.Logger.debug(u, "resume()"), this._closed ? l.Logger.error(u, "resume() | Producer closed") : (this._paused = false, this._disableTrackOnPause && (this._track && (this._track.enabled = true), this._trackLow && (this._trackLow.enabled = true)), this._zeroRtpOnPause && this.safeEmitAsPromise("@replacetrack", this._track).catch(() => {
            }), this._observer.safeEmit("resume"));
          }
          async replaceTrack({ track: e2 }) {
            if (l.Logger.debug(u, "replaceTrack()"), this._closed) {
              if (e2 && this._stopTracks) try {
                if ("audio" === e2.kind) {
                  const t2 = n.getParameters().tracks.audio.findIndex((t3) => e2 === t3);
                  l.Logger.warn(`Stopping AUDIOTRACK#${t2} ${e2.id}, ${e2.label}, ${e2.readyState}`);
                } else {
                  const t2 = n.getParameters().tracks.video.findIndex((t3) => e2 === t3);
                  l.Logger.warn(`Stopping VIDEOTRACK#${t2} ${e2.id}, ${e2.label}, ${e2.readyState}`);
                }
                e2.stop();
              } catch (e3) {
              }
              throw new c.InvalidStateError("closed");
            }
            if (e2 && "ended" === e2.readyState) throw new c.InvalidStateError("track ended");
            e2 !== this._track ? (this._zeroRtpOnPause && this._paused || await this.safeEmitAsPromise("@replacetrack", e2), this._destroyTrack(), this._track = e2, this._track && this._disableTrackOnPause && (this._paused ? this._paused && (this._track.enabled = false) : this._track.enabled = true), this._handleTrack()) : l.Logger.debug(u, "replaceTrack() | same track, ignored");
          }
          async setMaxSpatialLayer(e2) {
            if (this._closed) throw new c.InvalidStateError("closed");
            if ("video" !== this._kind) throw new c.UnsupportedError("not a video Producer");
            if ("number" != typeof e2) throw new TypeError("invalid spatialLayer");
            e2 !== this._maxSpatialLayer && (await this.safeEmitAsPromise("@setmaxspatiallayer", e2), this._maxSpatialLayer = e2);
          }
          async setRtpEncodingParameters(e2) {
            if (this._closed) throw new c.InvalidStateError("closed");
            if ("object" != typeof e2) throw new TypeError("invalid params");
            await this.safeEmitAsPromise("@setrtpencodingparameters", e2);
          }
          _onTrackEnded() {
            l.Logger.debug(u, 'track "ended" event'), this.safeEmit("trackended"), this._observer.safeEmit("trackended");
          }
          _handleTrack() {
            this._track && this._track.addEventListener("ended", this._onTrackEnded);
          }
          _destroyTrack() {
            this._track && l.Logger.warn(u, "don not stop sender track");
          }
        }
        t.Producer = h;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getRTCTimer = void 0;
        const r = i(90);
        class s {
          constructor(e2 = { from: { native: true, worker: true, webAudio: true }, minInterval: 8 }) {
            this.history = [], this.timers = [void 0], this.worker = null, this.options = e2;
            const t2 = (e3) => {
              const t3 = { source: e3, ts: Date.now() }, i2 = this.history[this.history.length - 1];
              if (!(i2 && t3.ts - i2.ts < this.options.minInterval)) {
                this.history.push(t3), this.history.length > 1e3 && this.history.shift();
                for (let e4 = 0; e4 < this.timers.length; e4++) {
                  const i3 = this.timers[e4];
                  if (i3 && !(i3.cntMax <= i3.cnt || t3.ts - i3.lastCalledAt < i3.interval - 1)) {
                    i3.cnt++, i3.lastCalledAt = t3.ts;
                    try {
                      i3.handler();
                    } catch (e5) {
                      console.error(e5);
                    }
                  }
                }
              }
            };
            if (e2.from.native && (this.nativeTimer = setInterval(() => {
              t2("native");
            }, this.options.minInterval)), e2.from.worker && void 0 !== typeof Worker) try {
              this.worker = new Worker(r.getBlobUrl("rtcTimer")), this.worker.onmessage = () => {
                t2("worker");
              };
            } catch (e3) {
              console.warn("无法启动RTCTimer/Worker Timer。页面在后台运行时计时可能不准", e3.name, e3.message);
            }
          }
          setInterval(e2, t2) {
            const i2 = { handler: e2, id: this.timers.length, interval: t2, lastCalledAt: Date.now(), cnt: 0, cntMax: Number.MAX_SAFE_INTEGER };
            return this.timers.push(i2), i2.id;
          }
          clearInterval(e2) {
            if (!e2) return;
            const t2 = this.timers[e2];
            t2 && (t2.id === e2 ? delete this.timers[e2] : console.error("timer错位", e2, t2));
          }
        }
        let a = null;
        function o() {
          return a || (a = new s()), a;
        }
        t.getRTCTimer = o;
        Date.now();
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AudioLevel = void 0;
        const r = i(3), s = i(90), a = i(47);
        let o = "NOTREADY", n = null;
        class d extends r.EventEmitter {
          constructor(e2) {
            super(), this.volume = 0, this.left = null, this.right = null, this.channelState = "balance", this.stateChangeCnt = 0, this.sampleRate = 48e3, this.bufferTime = 1, this.lastAudioDuration = 0, this.bufferSize = this.sampleRate * this.bufferTime, this.leftData = new Float32Array(this.bufferSize), this.rightData = new Float32Array(this.bufferSize), this.dataIndex = 0, this.audioData = null, this.enableData = false, this.onAudioData = () => {
            }, this.support = null, this.logger = e2.logger.getChild(() => {
              let e3 = "AudioLevel";
              return e3 += "READY" !== o ? " " + o : " " + this.channelState, this.stateChangeCnt && (e3 += " change" + this.stateChangeCnt), e3;
            });
            const t2 = a.getAudioContext(), i2 = e2.stream;
            t2 && (this.support = { stream: i2, context: t2 }, this.updateStream(i2, e2.sourceNode));
          }
          async updateStream(e2, t2) {
            var i2;
            if (this.logger.log("AudioLevel updateStream"), this.support) {
              if (!t2 && e2.getAudioTracks().length > 0) try {
                t2 = this.support.context.createMediaStreamSource(e2);
              } catch (i3) {
                if ("TypeError" !== i3.name) return void this.logger.error("无法创建MediaStreamAudioSourceNode", i3.name, i3.message);
                t2 = new MediaStreamAudioSourceNode(this.support.context, { mediaStream: e2 });
              }
              if (this.support.sourceNode && this.support.sourceNode.disconnect(), this.support.sourceNode = t2, !this.support.audioWorkletNode) {
                if (!this.support.context.audioWorklet) return void this.logger.error("该环境不支持音量模块");
                n ? "LOADING" === o && await n : (o = "LOADING", this.logger.log("正在载入音量模块"), n = this.support.context.audioWorklet.addModule(s.getBlobUrl("volumeProcessor")), await n, o = "READY", this.logger.log("载入音量模块成功")), this.support.audioWorkletNode = new AudioWorkletNode(this.support.context, "vumeter"), this.support.audioWorkletNode.port.onmessage = (e3) => {
                  var t3, i3;
                  const r3 = Date.now(), s2 = Math.floor(r3);
                  this.volume = e3.data.volume, this.sampleRate !== e3.data.sampleRate && (this.sampleRate = e3.data.sampleRate, this._resetAudioDataBuffer(), this.logger.warn("采样率变更 " + e3.data.sampleRate));
                  const a2 = e3.data.leftData, o2 = e3.data.rightData;
                  if (this.enableData) {
                    this.dataIndex + a2.length > this.leftData.length && (this.audioData = [this.leftData.subarray(0, this.dataIndex)], o2 && this.audioData.push(this.rightData.subarray(0, this.dataIndex)), this.lastAudioDuration = Math.round(this.audioData[0].length / this.sampleRate * 1e3), this.emit("audio-data", { data: this.audioData, duration: this.lastAudioDuration, sampleRate: this.sampleRate }), this._resetAudioDataBuffer());
                    try {
                      this.leftData.set(a2, this.dataIndex), o2 && this.rightData.set(o2, this.dataIndex), this.dataIndex += a2.length;
                    } catch (e4) {
                      this._resetAudioDataBuffer();
                    }
                  }
                  if (e3.data.left > -1) this.left || (this.left = { volume: 0, history: [] }), this.left.history.length && this.left.history[0].sec === s2 || this.left.history.unshift({ sec: s2, sum: 0 }), this.left.volume = e3.data.left, this.left.history[0].sum += e3.data.left, this.left.history.length > 2 && this.left.history.pop();
                  else {
                    const e4 = this.channelState;
                    this.channelState = "mono", e4 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e4} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e4 }));
                  }
                  if (e3.data.right > -1 && (this.right || (this.right = { volume: 0, history: [] }), this.right.history.length && this.right.history[0].sec === s2 || this.right.history.unshift({ sec: s2, sum: 0 }), this.right.volume = e3.data.right, this.right.history[0].sum += e3.data.right, this.right.history.length > 2 && this.right.history.pop()), (null === (t3 = this.left) || void 0 === t3 ? void 0 : t3.history[1]) && (null === (i3 = this.right) || void 0 === i3 ? void 0 : i3.history[1])) if (this.left.history[1].sum > 4 * this.right.history[1].sum) {
                    const e4 = this.channelState;
                    this.channelState = "leftLoud", e4 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e4} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e4 }));
                  } else if (this.right.history[1].sum > 4 * this.left.history[1].sum) {
                    const e4 = this.channelState;
                    this.channelState = "rightLoud", e4 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e4} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e4 }));
                  } else {
                    if (this.left.history[1].sum > this.right.history[1].sum && "leftLoud" !== this.channelState) {
                      const e4 = this.channelState;
                      this.channelState = "balance", e4 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e4} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e4 }));
                    }
                    if (this.right.history[1].sum > this.left.history[1].sum && "rightLoud" !== this.channelState) {
                      const e4 = this.channelState;
                      this.channelState = "balance", e4 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e4} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e4 }));
                    }
                  }
                };
              }
              null === (i2 = this.support.sourceNode) || void 0 === i2 || i2.connect(this.support.audioWorkletNode);
              const r2 = a.getAudioLevelDestination();
              r2 && this.support.audioWorkletNode.connect(r2), this.volume = 0;
            }
          }
          _resetAudioDataBuffer() {
            this.bufferSize = this.sampleRate * this.bufferTime, this.leftData = new Float32Array(this.bufferSize), this.rightData = new Float32Array(this.bufferSize), this.dataIndex = 0;
          }
          getAudioLevel() {
            return this.volume;
          }
          set enableAudioData(e2) {
            this.enableData = e2, e2 || this._resetAudioDataBuffer();
          }
          get enableAudioData() {
            return this.enableData;
          }
          getAudioData() {
            return { data: this.audioData, duration: this.lastAudioDuration, sampleRate: this.sampleRate };
          }
          setBufferTime(e2) {
            return this.bufferTime = e2 / 1e3, this._resetAudioDataBuffer(), true;
          }
          destroy() {
            var e2, t2;
            this.logger.log("destroy() AudioLevel模块"), null === (t2 = null === (e2 = this.support) || void 0 === e2 ? void 0 : e2.sourceNode) || void 0 === t2 || t2.disconnect(), this.support = null, this.dataIndex > 0 && (this.audioData = [this.leftData.subarray(0, this.dataIndex)], this.audioData.push(this.rightData.subarray(0, this.dataIndex)), this.lastAudioDuration = Math.round(this.audioData[0].length / this.sampleRate * 1e3), this.emit("audio-data", { data: this.audioData, duration: this.lastAudioDuration, sampleRate: this.sampleRate }), this.audioData = null, this.dataIndex = 0, this.enableAudioData = false);
          }
        }
        t.AudioLevel = d;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.forceAudioConstraints = t.set3AConstraint = t.patchScreenConstraints = void 0;
        const s = i(1), a = r(i(6)), o = r(i(8));
        function n(e2, t2, i2) {
          if (e2 && "boolean" == typeof i2) switch (t2) {
            case "AEC":
              e2.echoCancellation = i2, e2.googEchoCancellation = i2, e2.googEchoCancellation2 = i2;
              break;
            case "ANS":
              e2.noiseSuppression = i2, e2.googNoiseSuppression = i2, e2.googNoiseSuppression2 = i2;
              break;
            case "AGC":
              e2.autoGainControl = i2, e2.googAutoGainControl = i2, e2.googAutoGainControl2 = i2;
          }
        }
        t.patchScreenConstraints = function(e2, t2) {
          if ("default" !== s.getParameters().screenFocus) try {
            if ("undefined" != typeof CaptureController) {
              const i2 = new CaptureController();
              i2.setFocusBehavior(s.getParameters().screenFocus), e2.controller = i2, t2.log("屏幕共享跳转控制：" + s.getParameters().screenFocus);
            } else t2.log("当前浏览器不支持屏幕共享跳转控制:" + s.getParameters().screenFocus);
          } catch (e3) {
          }
          if ("default" !== s.getParameters().screenDisplaySurface && e2.video && (e2.video.displaySurface = s.getParameters().screenDisplaySurface), "default" !== s.getParameters().screenSurfaceSwitching && (e2.surfaceSwitching = s.getParameters().screenSurfaceSwitching), s.getParameters().screenPreferCurrentTab && (e2.preferCurrentTab = s.getParameters().screenPreferCurrentTab), "default" !== s.getParameters().screenSelfBrowserSurface && (e2.selfBrowserSurface = s.getParameters().screenSelfBrowserSurface), e2.preferCurrentTab && "exclude" === e2.selfBrowserSurface) throw t2.log("屏幕共享参数 preferCurrentTab: true 和 selfBrowserSurface: 'exclude' 互斥，不能同时存在"), new o.default({ code: a.default.INVALID_PARAMETER_ERROR, message: "screenShare: preferCurrentTab: true 和 selfBrowserSurface: 'exclude' 互斥，不能同时存在" });
          "default" !== s.getParameters().forceDisplaySurface && e2.video && (e2.video.displaySurface = s.getParameters().forceDisplaySurface);
        }, t.set3AConstraint = n, t.forceAudioConstraints = function(e2) {
          "no" !== s.getParameters().forceAEC && n(e2, "AEC", "on" === s.getParameters().forceAEC), "no" !== s.getParameters().forceANS && n(e2, "ANS", "on" === s.getParameters().forceANS), "no" !== s.getParameters().forceAGC && n(e2, "AGC", "on" === s.getParameters().forceAGC), -1 !== s.getParameters().forceChannelCount && (e2.channelCount = s.getParameters().forceChannelCount), -1 !== s.getParameters().forceSampleRate && (e2.sampleRate = s.getParameters().forceSampleRate), -1 !== s.getParameters().forceLatency && (e2.latency = s.getParameters().forceLatency);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.DataReport = void 0;
        const r = i(26), s = i(42), a = i(7), o = i(257);
        let n = "https://statistic.live.126.net/statics/report/common/form";
        t.DataReport = class {
          constructor(e2) {
            this.localStorageKey = "EVENT_REPORT_CATCH", this.localStorageMaxLength = 1e3;
            const t2 = e2.adapterRef;
            e2.sdkRef;
            this.adapterRef = t2;
            let i2 = t2.instance, r2 = t2.channelInfo || {};
            this.cid = r2.cid || r2.channelId || 0, this.uid = r2.uid || 0;
            const s2 = i2._params && i2._params.appkey;
            this.time = r2.clientNtpTime - r2.T4, this.common = { name: "common", ver: "2.0", sdk_type: "nrtc2", session_id: this.adapterRef.deviceId, app_key: s2 }, this.eventKeys = [], this.eventMap = {}, this.api = [], this.heartbeat = null;
          }
          addEvent(e2, t2) {
            return -1 == this.eventKeys.indexOf(e2) && this.eventKeys.push(e2), t2.time ? t2.time = t2.time + this.time : (this.adapterRef.logger.warn(`addEvent:事件${e2}没有time属性。使用当前时间戳`), t2.time = Date.now()), this.eventMap[e2] = t2, this;
          }
          updateCommon(e2) {
            return Object.assign(this.common, e2), this;
          }
          setHeartbeat(e2) {
            this.heartbeat = e2;
            const t2 = Object.keys(this.adapterRef.apiEvent), i2 = Object.keys(this.adapterRef.apiEvents), r2 = t2.concat(i2.filter((e3) => !t2.includes(e3)));
            let s2 = [];
            for (let e3 in r2) {
              const t3 = r2[e3];
              this.adapterRef.apiEvents[t3] && this.adapterRef.apiEvents[t3].length ? (s2 = s2.concat(this.adapterRef.apiEvents[t3]), this.adapterRef.apiEvents[t3] = []) : this.adapterRef.apiEvent[t3] && this.adapterRef.apiEvent[t3].length && (s2 = s2.concat(this.adapterRef.apiEvent[t3]), this.adapterRef.apiEvent[t3] = []);
            }
            return this.api = this.api.concat(s2), this;
          }
          setNetworkChange(e2) {
            return this.addEvent("networkChange", e2), this;
          }
          setLogin(e2) {
            var t2, i2, s2;
            e2.sdk_ver = e2.sdk_ver || r.SDK_VERSION, e2.platform = e2.platform || "Web", e2.app_key = e2.app_key || this.common.app_key, e2.meeting_mode = e2.meeting_mode || 1, e2.model = e2.model, e2.build = r.BUILD, e2.supported_codec_send = null === (t2 = this.adapterRef.mediaCapability.supportedCodecSend) || void 0 === t2 ? void 0 : t2.join(","), e2.supported_codec_recv = null === (i2 = this.adapterRef.mediaCapability.supportedCodecRecv) || void 0 === i2 ? void 0 : i2.join(","), e2.preferred_codec_send = null === (s2 = this.adapterRef.mediaCapability.preferredCodecSend.video) || void 0 === s2 ? void 0 : s2.join(","), e2.extra_info = JSON.stringify({ proc: o.processManager.processId, page: o.processManager.pageId, brow: o.processManager.browserId, userAgent: a.USER_AGENT }), e2.lbs_addrs = this.adapterRef.lbsManager.getReportField("nrtc"), this.addEvent("login", e2);
          }
          setRelogin(e2) {
            this.addEvent("relogin", e2);
          }
          setLogout(e2) {
            this.addEvent("logout", e2);
          }
          deviceAbnormal(e2) {
            this.addEvent("deviceAbnormal", e2);
          }
          setDisconnect(e2) {
            this.addEvent("disconnect", e2);
          }
          setRecvFirstFrame(e2) {
            this.addEvent("recvFirstFrame", e2);
          }
          setSendFirstPackage(e2) {
            this.addEvent("firstPacketSent", e2);
          }
          setRecvFirstPackage(e2) {
            this.addEvent("recvFirstPackage", e2);
          }
          setFunction(e2) {
            this.addEvent("function", e2);
          }
          setRequestLbs(e2) {
            this.addEvent("requestLBS", e2);
          }
          setAudioVideoBanned(e2) {
            this.addEvent("audioVideoBanned", e2);
          }
          setStreamException(e2) {
            this.addEvent("streamException", e2);
          }
          setUserCustomEvent(e2) {
            this.addEvent("userCustomEvent", e2);
          }
          setException(e2) {
            this.addEvent("exception", e2);
          }
          setAsrCaptions(e2) {
            this.addEvent("asrCaptions", e2);
          }
          setConnectionStateChange(e2) {
            this.addEvent("connectionStateChange", e2);
          }
          reset() {
            this.eventKeys = [], this.api = [], this.heartbeat = null;
          }
          send(e2) {
            let t2 = { common: this.common };
            if (e2 || (e2 = this.eventKeys), this.heartbeat && (t2.heartbeat = this.heartbeat, this.api.length && (this.api.forEach((e3) => {
              e3.uid || (e3.uid = this.adapterRef.channelInfo && this.adapterRef.channelInfo.uid), e3.cid || (e3.cid = this.adapterRef.channelInfo && this.adapterRef.channelInfo.cid), e3.param && "object" == typeof e3.param && void 0 !== e3.param.clientUid && (e3.param.clientUid = e3.uid);
            }), t2.event = { apiEvent: this.api }, this.api = [])), e2) {
              if (e2.length) {
                let i3 = 0, r2 = {};
                for (let t3 = e2.length - 1; t3 >= 0; t3--) {
                  const s2 = e2[t3];
                  this.eventMap[s2] && (i3++, r2[s2] = this.eventMap[s2], delete this.eventMap[s2], e2.splice(t3, 1));
                }
                i3 && (t2.event = r2);
              }
            } else if (!this.heartbeat) return this;
            this.adapterRef.instance._params.neRtcServerAddresses.statisticsServer && (n = this.adapterRef.instance._params.neRtcServerAddresses.statisticsServer);
            let i2 = s.generateUUID();
            try {
              const e3 = null === window.localStorage.getItem(this.localStorageKey) ? [] : JSON.parse(window.localStorage.getItem(this.localStorageKey));
              e3.length >= this.localStorageMaxLength && e3.shift(), e3.push({ sdktype: this.common.sdk_type, appkey: this.common.app_key, data: t2, requestid: i2 }), window.localStorage.setItem(this.localStorageKey, JSON.stringify(e3));
            } catch (e3) {
            }
            return this.adapterRef.lbsManager.ajax({ type: "post", url: n, data: t2, header: { sdktype: this.common.sdk_type, appkey: this.common.app_key, platform: "web", sdkver: r.SDK_VERSION } }).then(() => {
              e2 === this.eventKeys && this.reset();
              try {
                let e3 = null === window.localStorage.getItem(this.localStorageKey) ? [] : JSON.parse(window.localStorage.getItem(this.localStorageKey));
                e3 = e3.filter((e4, t3, r2) => e4.requestid !== i2), i2 = null, window.localStorage.setItem(this.localStorageKey, JSON.stringify(e3));
              } catch (e3) {
              }
            }).catch((e3) => {
              this.adapterRef.logger.log("dataReport, send error: ", e3.name, e3.message, e3), this.reset();
            }), this;
          }
          async sendCacheEvent() {
            try {
              const e2 = null === window.localStorage.getItem(this.localStorageKey) ? [] : JSON.parse(window.localStorage.getItem(this.localStorageKey));
              for (let t2 = 0; t2 < e2.length; t2++) try {
                await this.adapterRef.lbsManager.ajax({ type: "post", url: n, data: e2[t2].data, header: { sdktype: e2[t2].sdktype, appkey: e2[t2].appkey, platform: "web", sdkver: r.SDK_VERSION } }), e2.splice(t2, 1), t2--;
              } catch (e3) {
                this.adapterRef.logger.log("sendCacheEvent send error: ", e3.name, e3.message);
              }
              window.localStorage.setItem(this.localStorageKey, JSON.stringify(e2));
            } catch (e2) {
              this.adapterRef.logger.log("sendCacheEvent error: ", e2.name, e2.message);
            }
          }
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = i(261);
      }, function(e, t, i) {
        "use strict";
        e.exports = function(e2, t2) {
          var i2 = new Array(arguments.length - 1), r = 0, s = 2, a = true;
          for (; s < arguments.length; ) i2[r++] = arguments[s++];
          return new Promise(function(s2, o) {
            i2[r] = function(e3) {
              if (a) if (a = false, e3) o(e3);
              else {
                for (var t3 = new Array(arguments.length - 1), i3 = 0; i3 < t3.length; ) t3[i3++] = arguments[i3];
                s2.apply(null, t3);
              }
            };
            try {
              e2.apply(t2 || null, i2);
            } catch (e3) {
              a && (a = false, o(e3));
            }
          });
        };
      }, function(module, exports, __webpack_require__) {
        "use strict";
        function inquire(moduleName) {
          try {
            var mod = eval("quire".replace(/^/, "re"))(moduleName);
            if (mod && (mod.length || Object.keys(mod).length)) return mod;
          } catch (e) {
          }
          return null;
        }
        module.exports = inquire;
      }, function(e, t, i) {
        "use strict";
        t.Service = i(271);
      }, function(e, t, i) {
        "use strict";
        e.exports = {};
      }, function(e, t, i) {
        "use strict";
        e.exports = function(e2) {
          for (var t2, i2 = a.codegen(["m", "w"], e2.name + "$encode")("if(!w)")("w=Writer.create()"), n = e2.fieldsArray.slice().sort(a.compareFieldsById), d = 0; d < n.length; ++d) {
            var c = n[d].resolve(), l = e2._fieldsArray.indexOf(c), u = c.resolvedType instanceof r ? "int32" : c.type, h = s.basic[u];
            t2 = "m" + a.safeProp(c.name), c.map ? (i2("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", t2, c.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", t2)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (c.id << 3 | 2) >>> 0, 8 | s.mapKey[c.keyType], c.keyType), void 0 === h ? i2("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", l, t2) : i2(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | h, u, t2), i2("}")("}")) : c.repeated ? (i2("if(%s!=null&&%s.length){", t2, t2), c.packed && void 0 !== s.packed[u] ? i2("w.uint32(%i).fork()", (c.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", t2)("w.%s(%s[i])", u, t2)("w.ldelim()") : (i2("for(var i=0;i<%s.length;++i)", t2), void 0 === h ? o(i2, c, l, t2 + "[i]") : i2("w.uint32(%i).%s(%s[i])", (c.id << 3 | h) >>> 0, u, t2)), i2("}")) : (c.optional && i2("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", t2, c.name), void 0 === h ? o(i2, c, l, t2) : i2("w.uint32(%i).%s(%s)", (c.id << 3 | h) >>> 0, u, t2));
          }
          return i2("return w");
        };
        var r = i(45), s = i(92), a = i(19);
        function o(e2, t2, i2, r2) {
          return t2.resolvedType.group ? e2("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", i2, r2, (t2.id << 3 | 3) >>> 0, (t2.id << 3 | 4) >>> 0) : e2("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", i2, r2, (t2.id << 3 | 2) >>> 0);
        }
      }, function(e, t, i) {
        "use strict";
        e.exports = S;
        var r = i(91);
        ((S.prototype = Object.create(r.prototype)).constructor = S).className = "Type";
        var s = i(45), a = i(141), o = i(83), n = i(185), d = i(186), c = i(153), l = i(152), u = i(151), h = i(19), p = i(183), m = i(188), g = i(189), f = i(190), v = i(191);
        function S(e2, t2) {
          r.call(this, e2, t2), this.fields = {}, this.oneofs = void 0, this.extensions = void 0, this.reserved = void 0, this.group = void 0, this._fieldsById = null, this._fieldsArray = null, this._oneofsArray = null, this._ctor = null;
        }
        function y(e2) {
          return e2._fieldsById = e2._fieldsArray = e2._oneofsArray = null, delete e2.encode, delete e2.decode, delete e2.verify, e2;
        }
        Object.defineProperties(S.prototype, { fieldsById: { get: function() {
          if (this._fieldsById) return this._fieldsById;
          this._fieldsById = {};
          for (var e2 = Object.keys(this.fields), t2 = 0; t2 < e2.length; ++t2) {
            var i2 = this.fields[e2[t2]], r2 = i2.id;
            if (this._fieldsById[r2]) throw Error("duplicate id " + r2 + " in " + this);
            this._fieldsById[r2] = i2;
          }
          return this._fieldsById;
        } }, fieldsArray: { get: function() {
          return this._fieldsArray || (this._fieldsArray = h.toArray(this.fields));
        } }, oneofsArray: { get: function() {
          return this._oneofsArray || (this._oneofsArray = h.toArray(this.oneofs));
        } }, ctor: { get: function() {
          return this._ctor || (this.ctor = S.generateConstructor(this)());
        }, set: function(e2) {
          var t2 = e2.prototype;
          t2 instanceof c || ((e2.prototype = new c()).constructor = e2, h.merge(e2.prototype, t2)), e2.$type = e2.prototype.$type = this, h.merge(e2, c, true), this._ctor = e2;
          for (var i2 = 0; i2 < this.fieldsArray.length; ++i2) this._fieldsArray[i2].resolve();
          var r2 = {};
          for (i2 = 0; i2 < this.oneofsArray.length; ++i2) r2[this._oneofsArray[i2].resolve().name] = { get: h.oneOfGetter(this._oneofsArray[i2].oneof), set: h.oneOfSetter(this._oneofsArray[i2].oneof) };
          i2 && Object.defineProperties(e2.prototype, r2);
        } } }), S.generateConstructor = function(e2) {
          for (var t2, i2 = h.codegen(["p"], e2.name), r2 = 0; r2 < e2.fieldsArray.length; ++r2) (t2 = e2._fieldsArray[r2]).map ? i2("this%s={}", h.safeProp(t2.name)) : t2.repeated && i2("this%s=[]", h.safeProp(t2.name));
          return i2("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
        }, S.fromJSON = function(e2, t2) {
          var i2 = new S(e2, t2.options);
          i2.extensions = t2.extensions, i2.reserved = t2.reserved;
          for (var c2 = Object.keys(t2.fields), l2 = 0; l2 < c2.length; ++l2) i2.add((void 0 !== t2.fields[c2[l2]].keyType ? n.fromJSON : o.fromJSON)(c2[l2], t2.fields[c2[l2]]));
          if (t2.oneofs) for (c2 = Object.keys(t2.oneofs), l2 = 0; l2 < c2.length; ++l2) i2.add(a.fromJSON(c2[l2], t2.oneofs[c2[l2]]));
          if (t2.nested) for (c2 = Object.keys(t2.nested), l2 = 0; l2 < c2.length; ++l2) {
            var u2 = t2.nested[c2[l2]];
            i2.add((void 0 !== u2.id ? o.fromJSON : void 0 !== u2.fields ? S.fromJSON : void 0 !== u2.values ? s.fromJSON : void 0 !== u2.methods ? d.fromJSON : r.fromJSON)(c2[l2], u2));
          }
          return t2.extensions && t2.extensions.length && (i2.extensions = t2.extensions), t2.reserved && t2.reserved.length && (i2.reserved = t2.reserved), t2.group && (i2.group = true), t2.comment && (i2.comment = t2.comment), i2;
        }, S.prototype.toJSON = function(e2) {
          var t2 = r.prototype.toJSON.call(this, e2), i2 = !!e2 && Boolean(e2.keepComments);
          return h.toObject(["options", t2 && t2.options || void 0, "oneofs", r.arrayToJSON(this.oneofsArray, e2), "fields", r.arrayToJSON(this.fieldsArray.filter(function(e3) {
            return !e3.declaringField;
          }), e2) || {}, "extensions", this.extensions && this.extensions.length ? this.extensions : void 0, "reserved", this.reserved && this.reserved.length ? this.reserved : void 0, "group", this.group || void 0, "nested", t2 && t2.nested || void 0, "comment", i2 ? this.comment : void 0]);
        }, S.prototype.resolveAll = function() {
          for (var e2 = this.fieldsArray, t2 = 0; t2 < e2.length; ) e2[t2++].resolve();
          var i2 = this.oneofsArray;
          for (t2 = 0; t2 < i2.length; ) i2[t2++].resolve();
          return r.prototype.resolveAll.call(this);
        }, S.prototype.get = function(e2) {
          return this.fields[e2] || this.oneofs && this.oneofs[e2] || this.nested && this.nested[e2] || null;
        }, S.prototype.add = function(e2) {
          if (this.get(e2.name)) throw Error("duplicate name '" + e2.name + "' in " + this);
          if (e2 instanceof o && void 0 === e2.extend) {
            if (this._fieldsById ? this._fieldsById[e2.id] : this.fieldsById[e2.id]) throw Error("duplicate id " + e2.id + " in " + this);
            if (this.isReservedId(e2.id)) throw Error("id " + e2.id + " is reserved in " + this);
            if (this.isReservedName(e2.name)) throw Error("name '" + e2.name + "' is reserved in " + this);
            return e2.parent && e2.parent.remove(e2), this.fields[e2.name] = e2, e2.message = this, e2.onAdd(this), y(this);
          }
          return e2 instanceof a ? (this.oneofs || (this.oneofs = {}), this.oneofs[e2.name] = e2, e2.onAdd(this), y(this)) : r.prototype.add.call(this, e2);
        }, S.prototype.remove = function(e2) {
          if (e2 instanceof o && void 0 === e2.extend) {
            if (!this.fields || this.fields[e2.name] !== e2) throw Error(e2 + " is not a member of " + this);
            return delete this.fields[e2.name], e2.parent = null, e2.onRemove(this), y(this);
          }
          if (e2 instanceof a) {
            if (!this.oneofs || this.oneofs[e2.name] !== e2) throw Error(e2 + " is not a member of " + this);
            return delete this.oneofs[e2.name], e2.parent = null, e2.onRemove(this), y(this);
          }
          return r.prototype.remove.call(this, e2);
        }, S.prototype.isReservedId = function(e2) {
          return r.isReservedId(this.reserved, e2);
        }, S.prototype.isReservedName = function(e2) {
          return r.isReservedName(this.reserved, e2);
        }, S.prototype.create = function(e2) {
          return new this.ctor(e2);
        }, S.prototype.setup = function() {
          for (var e2 = this.fullName, t2 = [], i2 = 0; i2 < this.fieldsArray.length; ++i2) t2.push(this._fieldsArray[i2].resolve().resolvedType);
          this.encode = p(this)({ Writer: u, types: t2, util: h }), this.decode = m(this)({ Reader: l, types: t2, util: h }), this.verify = g(this)({ types: t2, util: h }), this.fromObject = f.fromObject(this)({ types: t2, util: h }), this.toObject = f.toObject(this)({ types: t2, util: h });
          var r2 = v[e2];
          if (r2) {
            var s2 = Object.create(this);
            s2.fromObject = this.fromObject, this.fromObject = r2.fromObject.bind(s2), s2.toObject = this.toObject, this.toObject = r2.toObject.bind(s2);
          }
          return this;
        }, S.prototype.encode = function(e2, t2) {
          return this.setup().encode(e2, t2);
        }, S.prototype.encodeDelimited = function(e2, t2) {
          return this.encode(e2, t2 && t2.len ? t2.fork() : t2).ldelim();
        }, S.prototype.decode = function(e2, t2) {
          return this.setup().decode(e2, t2);
        }, S.prototype.decodeDelimited = function(e2) {
          return e2 instanceof l || (e2 = l.create(e2)), this.decode(e2, e2.uint32());
        }, S.prototype.verify = function(e2) {
          return this.setup().verify(e2);
        }, S.prototype.fromObject = function(e2) {
          return this.setup().fromObject(e2);
        }, S.prototype.toObject = function(e2, t2) {
          return this.setup().toObject(e2, t2);
        }, S.d = function(e2) {
          return function(t2) {
            h.decorateType(t2, e2);
          };
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = o;
        var r = i(83);
        ((o.prototype = Object.create(r.prototype)).constructor = o).className = "MapField";
        var s = i(92), a = i(19);
        function o(e2, t2, i2, s2, o2, n) {
          if (r.call(this, e2, t2, s2, void 0, void 0, o2, n), !a.isString(i2)) throw TypeError("keyType must be a string");
          this.keyType = i2, this.resolvedKeyType = null, this.map = true;
        }
        o.fromJSON = function(e2, t2) {
          return new o(e2, t2.id, t2.keyType, t2.type, t2.options, t2.comment);
        }, o.prototype.toJSON = function(e2) {
          var t2 = !!e2 && Boolean(e2.keepComments);
          return a.toObject(["keyType", this.keyType, "type", this.type, "id", this.id, "extend", this.extend, "options", this.options, "comment", t2 ? this.comment : void 0]);
        }, o.prototype.resolve = function() {
          if (this.resolved) return this;
          if (void 0 === s.mapKey[this.keyType]) throw Error("invalid key type: " + this.keyType);
          return r.prototype.resolve.call(this);
        }, o.d = function(e2, t2, i2) {
          return "function" == typeof i2 ? i2 = a.decorateType(i2).name : i2 && "object" == typeof i2 && (i2 = a.decorateEnum(i2).name), function(r2, s2) {
            a.decorateType(r2.constructor).add(new o(s2, e2, t2, i2));
          };
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = n;
        var r = i(91);
        ((n.prototype = Object.create(r.prototype)).constructor = n).className = "Service";
        var s = i(187), a = i(19), o = i(181);
        function n(e2, t2) {
          r.call(this, e2, t2), this.methods = {}, this._methodsArray = null;
        }
        function d(e2) {
          return e2._methodsArray = null, e2;
        }
        n.fromJSON = function(e2, t2) {
          var i2 = new n(e2, t2.options);
          if (t2.methods) for (var r2 = Object.keys(t2.methods), a2 = 0; a2 < r2.length; ++a2) i2.add(s.fromJSON(r2[a2], t2.methods[r2[a2]]));
          return t2.nested && i2.addJSON(t2.nested), i2.comment = t2.comment, i2;
        }, n.prototype.toJSON = function(e2) {
          var t2 = r.prototype.toJSON.call(this, e2), i2 = !!e2 && Boolean(e2.keepComments);
          return a.toObject(["options", t2 && t2.options || void 0, "methods", r.arrayToJSON(this.methodsArray, e2) || {}, "nested", t2 && t2.nested || void 0, "comment", i2 ? this.comment : void 0]);
        }, Object.defineProperty(n.prototype, "methodsArray", { get: function() {
          return this._methodsArray || (this._methodsArray = a.toArray(this.methods));
        } }), n.prototype.get = function(e2) {
          return this.methods[e2] || r.prototype.get.call(this, e2);
        }, n.prototype.resolveAll = function() {
          for (var e2 = this.methodsArray, t2 = 0; t2 < e2.length; ++t2) e2[t2].resolve();
          return r.prototype.resolve.call(this);
        }, n.prototype.add = function(e2) {
          if (this.get(e2.name)) throw Error("duplicate name '" + e2.name + "' in " + this);
          return e2 instanceof s ? (this.methods[e2.name] = e2, e2.parent = this, d(this)) : r.prototype.add.call(this, e2);
        }, n.prototype.remove = function(e2) {
          if (e2 instanceof s) {
            if (this.methods[e2.name] !== e2) throw Error(e2 + " is not a member of " + this);
            return delete this.methods[e2.name], e2.parent = null, d(this);
          }
          return r.prototype.remove.call(this, e2);
        }, n.prototype.create = function(e2, t2, i2) {
          for (var r2, s2 = new o.Service(e2, t2, i2), n2 = 0; n2 < this.methodsArray.length; ++n2) {
            var d2 = a.lcFirst((r2 = this._methodsArray[n2]).resolve().name).replace(/[^$\w_]/g, "");
            s2[d2] = a.codegen(["r", "c"], a.isReserved(d2) ? d2 + "_" : d2)("return this.rpcCall(m,q,s,r,c)")({ m: r2, q: r2.resolvedRequestType.ctor, s: r2.resolvedResponseType.ctor });
          }
          return s2;
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = a;
        var r = i(82);
        ((a.prototype = Object.create(r.prototype)).constructor = a).className = "Method";
        var s = i(19);
        function a(e2, t2, i2, a2, o, n, d, c, l) {
          if (s.isObject(o) ? (d = o, o = n = void 0) : s.isObject(n) && (d = n, n = void 0), void 0 !== t2 && !s.isString(t2)) throw TypeError("type must be a string");
          if (!s.isString(i2)) throw TypeError("requestType must be a string");
          if (!s.isString(a2)) throw TypeError("responseType must be a string");
          r.call(this, e2, d), this.type = t2 || "rpc", this.requestType = i2, this.requestStream = !!o || void 0, this.responseType = a2, this.responseStream = !!n || void 0, this.resolvedRequestType = null, this.resolvedResponseType = null, this.comment = c, this.parsedOptions = l;
        }
        a.fromJSON = function(e2, t2) {
          return new a(e2, t2.type, t2.requestType, t2.responseType, t2.requestStream, t2.responseStream, t2.options, t2.comment, t2.parsedOptions);
        }, a.prototype.toJSON = function(e2) {
          var t2 = !!e2 && Boolean(e2.keepComments);
          return s.toObject(["type", "rpc" !== this.type && this.type || void 0, "requestType", this.requestType, "requestStream", this.requestStream, "responseType", this.responseType, "responseStream", this.responseStream, "options", this.options, "comment", t2 ? this.comment : void 0, "parsedOptions", this.parsedOptions]);
        }, a.prototype.resolve = function() {
          return this.resolved ? this : (this.resolvedRequestType = this.parent.lookupType(this.requestType), this.resolvedResponseType = this.parent.lookupType(this.responseType), r.prototype.resolve.call(this));
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = function(e2) {
          var t2 = a.codegen(["r", "l"], e2.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (e2.fieldsArray.filter(function(e3) {
            return e3.map;
          }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
          e2.group && t2("if((t&7)===4)")("break");
          t2("switch(t>>>3){");
          for (var i2 = 0; i2 < e2.fieldsArray.length; ++i2) {
            var n = e2._fieldsArray[i2].resolve(), d = n.resolvedType instanceof r ? "int32" : n.type, c = "m" + a.safeProp(n.name);
            t2("case %i:", n.id), n.map ? (t2("if(%s===util.emptyObject)", c)("%s={}", c)("var c2 = r.uint32()+r.pos"), void 0 !== s.defaults[n.keyType] ? t2("k=%j", s.defaults[n.keyType]) : t2("k=null"), void 0 !== s.defaults[d] ? t2("value=%j", s.defaults[d]) : t2("value=null"), t2("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", n.keyType)("case 2:"), void 0 === s.basic[d] ? t2("value=types[%i].decode(r,r.uint32())", i2) : t2("value=r.%s()", d), t2("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"), void 0 !== s.long[n.keyType] ? t2('%s[typeof k==="object"?util.longToHash(k):k]=value', c) : t2("%s[k]=value", c)) : n.repeated ? (t2("if(!(%s&&%s.length))", c, c)("%s=[]", c), void 0 !== s.packed[d] && t2("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", c, d)("}else"), void 0 === s.basic[d] ? t2(n.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", c, i2) : t2("%s.push(r.%s())", c, d)) : void 0 === s.basic[d] ? t2(n.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", c, i2) : t2("%s=r.%s()", c, d), t2("break");
          }
          for (t2("default:")("r.skipType(t&7)")("break")("}")("}"), i2 = 0; i2 < e2._fieldsArray.length; ++i2) {
            var l = e2._fieldsArray[i2];
            l.required && t2("if(!m.hasOwnProperty(%j))", l.name)("throw util.ProtocolError(%j,{instance:m})", o(l));
          }
          return t2("return m");
        };
        var r = i(45), s = i(92), a = i(19);
        function o(e2) {
          return "missing required '" + e2.name + "'";
        }
      }, function(e, t, i) {
        "use strict";
        e.exports = function(e2) {
          var t2 = s.codegen(["m"], e2.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected"), i2 = e2.oneofsArray, r2 = {};
          i2.length && t2("var p={}");
          for (var d = 0; d < e2.fieldsArray.length; ++d) {
            var c = e2._fieldsArray[d].resolve(), l = "m" + s.safeProp(c.name);
            if (c.optional && t2("if(%s!=null&&m.hasOwnProperty(%j)){", l, c.name), c.map) t2("if(!util.isObject(%s))", l)("return%j", a(c, "object"))("var k=Object.keys(%s)", l)("for(var i=0;i<k.length;++i){"), n(t2, c, "k[i]"), o(t2, c, d, l + "[k[i]]")("}");
            else if (c.repeated) t2("if(!Array.isArray(%s))", l)("return%j", a(c, "array"))("for(var i=0;i<%s.length;++i){", l), o(t2, c, d, l + "[i]")("}");
            else {
              if (c.partOf) {
                var u = s.safeProp(c.partOf.name);
                1 === r2[c.partOf.name] && t2("if(p%s===1)", u)("return%j", c.partOf.name + ": multiple values"), r2[c.partOf.name] = 1, t2("p%s=1", u);
              }
              o(t2, c, d, l);
            }
            c.optional && t2("}");
          }
          return t2("return null");
        };
        var r = i(45), s = i(19);
        function a(e2, t2) {
          return e2.name + ": " + t2 + (e2.repeated && "array" !== t2 ? "[]" : e2.map && "object" !== t2 ? "{k:" + e2.keyType + "}" : "") + " expected";
        }
        function o(e2, t2, i2, s2) {
          if (t2.resolvedType) if (t2.resolvedType instanceof r) {
            e2("switch(%s){", s2)("default:")("return%j", a(t2, "enum value"));
            for (var o2 = Object.keys(t2.resolvedType.values), n2 = 0; n2 < o2.length; ++n2) e2("case %i:", t2.resolvedType.values[o2[n2]]);
            e2("break")("}");
          } else e2("{")("var e=types[%i].verify(%s);", i2, s2)("if(e)")("return%j+e", t2.name + ".")("}");
          else switch (t2.type) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
              e2("if(!util.isInteger(%s))", s2)("return%j", a(t2, "integer"));
              break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              e2("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", s2, s2, s2, s2)("return%j", a(t2, "integer|Long"));
              break;
            case "float":
            case "double":
              e2('if(typeof %s!=="number")', s2)("return%j", a(t2, "number"));
              break;
            case "bool":
              e2('if(typeof %s!=="boolean")', s2)("return%j", a(t2, "boolean"));
              break;
            case "string":
              e2("if(!util.isString(%s))", s2)("return%j", a(t2, "string"));
              break;
            case "bytes":
              e2('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', s2, s2, s2)("return%j", a(t2, "buffer"));
          }
          return e2;
        }
        function n(e2, t2, i2) {
          switch (t2.keyType) {
            case "int32":
            case "uint32":
            case "sint32":
            case "fixed32":
            case "sfixed32":
              e2("if(!util.key32Re.test(%s))", i2)("return%j", a(t2, "integer key"));
              break;
            case "int64":
            case "uint64":
            case "sint64":
            case "fixed64":
            case "sfixed64":
              e2("if(!util.key64Re.test(%s))", i2)("return%j", a(t2, "integer|Long key"));
              break;
            case "bool":
              e2("if(!util.key2Re.test(%s))", i2)("return%j", a(t2, "boolean key"));
          }
          return e2;
        }
      }, function(e, t, i) {
        "use strict";
        var r = t, s = i(45), a = i(19);
        function o(e2, t2, i2, r2) {
          if (t2.resolvedType) if (t2.resolvedType instanceof s) {
            e2("switch(d%s){", r2);
            for (var a2 = t2.resolvedType.values, o2 = Object.keys(a2), n2 = 0; n2 < o2.length; ++n2) t2.repeated && a2[o2[n2]] === t2.typeDefault && e2("default:"), e2("case%j:", o2[n2])("case %i:", a2[o2[n2]])("m%s=%j", r2, a2[o2[n2]])("break");
            e2("}");
          } else e2('if(typeof d%s!=="object")', r2)("throw TypeError(%j)", t2.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", r2, i2, r2);
          else {
            var d = false;
            switch (t2.type) {
              case "double":
              case "float":
                e2("m%s=Number(d%s)", r2, r2);
                break;
              case "uint32":
              case "fixed32":
                e2("m%s=d%s>>>0", r2, r2);
                break;
              case "int32":
              case "sint32":
              case "sfixed32":
                e2("m%s=d%s|0", r2, r2);
                break;
              case "uint64":
                d = true;
              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                e2("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", r2, r2, d)('else if(typeof d%s==="string")', r2)("m%s=parseInt(d%s,10)", r2, r2)('else if(typeof d%s==="number")', r2)("m%s=d%s", r2, r2)('else if(typeof d%s==="object")', r2)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", r2, r2, r2, d ? "true" : "");
                break;
              case "bytes":
                e2('if(typeof d%s==="string")', r2)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", r2, r2, r2)("else if(d%s.length)", r2)("m%s=d%s", r2, r2);
                break;
              case "string":
                e2("m%s=String(d%s)", r2, r2);
                break;
              case "bool":
                e2("m%s=Boolean(d%s)", r2, r2);
            }
          }
          return e2;
        }
        function n(e2, t2, i2, r2) {
          if (t2.resolvedType) t2.resolvedType instanceof s ? e2("d%s=o.enums===String?types[%i].values[m%s]:m%s", r2, i2, r2, r2) : e2("d%s=types[%i].toObject(m%s,o)", r2, i2, r2);
          else {
            var a2 = false;
            switch (t2.type) {
              case "double":
              case "float":
                e2("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", r2, r2, r2, r2);
                break;
              case "uint64":
                a2 = true;
              case "int64":
              case "sint64":
              case "fixed64":
              case "sfixed64":
                e2('if(typeof m%s==="number")', r2)("d%s=o.longs===String?String(m%s):m%s", r2, r2, r2)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", r2, r2, r2, r2, a2 ? "true" : "", r2);
                break;
              case "bytes":
                e2("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", r2, r2, r2, r2, r2);
                break;
              default:
                e2("d%s=m%s", r2, r2);
            }
          }
          return e2;
        }
        r.fromObject = function(e2) {
          var t2 = e2.fieldsArray, i2 = a.codegen(["d"], e2.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
          if (!t2.length) return i2("return new this.ctor");
          i2("var m=new this.ctor");
          for (var r2 = 0; r2 < t2.length; ++r2) {
            var n2 = t2[r2].resolve(), d = a.safeProp(n2.name);
            n2.map ? (i2("if(d%s){", d)('if(typeof d%s!=="object")', d)("throw TypeError(%j)", n2.fullName + ": object expected")("m%s={}", d)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", d), o(i2, n2, r2, d + "[ks[i]]")("}")("}")) : n2.repeated ? (i2("if(d%s){", d)("if(!Array.isArray(d%s))", d)("throw TypeError(%j)", n2.fullName + ": array expected")("m%s=[]", d)("for(var i=0;i<d%s.length;++i){", d), o(i2, n2, r2, d + "[i]")("}")("}")) : (n2.resolvedType instanceof s || i2("if(d%s!=null){", d), o(i2, n2, r2, d), n2.resolvedType instanceof s || i2("}"));
          }
          return i2("return m");
        }, r.toObject = function(e2) {
          var t2 = e2.fieldsArray.slice().sort(a.compareFieldsById);
          if (!t2.length) return a.codegen()("return {}");
          for (var i2 = a.codegen(["m", "o"], e2.name + "$toObject")("if(!o)")("o={}")("var d={}"), r2 = [], o2 = [], d = [], c = 0; c < t2.length; ++c) t2[c].partOf || (t2[c].resolve().repeated ? r2 : t2[c].map ? o2 : d).push(t2[c]);
          if (r2.length) {
            for (i2("if(o.arrays||o.defaults){"), c = 0; c < r2.length; ++c) i2("d%s=[]", a.safeProp(r2[c].name));
            i2("}");
          }
          if (o2.length) {
            for (i2("if(o.objects||o.defaults){"), c = 0; c < o2.length; ++c) i2("d%s={}", a.safeProp(o2[c].name));
            i2("}");
          }
          if (d.length) {
            for (i2("if(o.defaults){"), c = 0; c < d.length; ++c) {
              var l = d[c], u = a.safeProp(l.name);
              if (l.resolvedType instanceof s) i2("d%s=o.enums===String?%j:%j", u, l.resolvedType.valuesById[l.typeDefault], l.typeDefault);
              else if (l.long) i2("if(util.Long){")("var n=new util.Long(%i,%i,%j)", l.typeDefault.low, l.typeDefault.high, l.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", u)("}else")("d%s=o.longs===String?%j:%i", u, l.typeDefault.toString(), l.typeDefault.toNumber());
              else if (l.bytes) {
                var h = "[" + Array.prototype.slice.call(l.typeDefault).join(",") + "]";
                i2("if(o.bytes===String)d%s=%j", u, String.fromCharCode.apply(String, l.typeDefault))("else{")("d%s=%s", u, h)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", u, u)("}");
              } else i2("d%s=%j", u, l.typeDefault);
            }
            i2("}");
          }
          var p = false;
          for (c = 0; c < t2.length; ++c) {
            l = t2[c];
            var m = e2._fieldsArray.indexOf(l);
            u = a.safeProp(l.name);
            l.map ? (p || (p = true, i2("var ks2")), i2("if(m%s&&(ks2=Object.keys(m%s)).length){", u, u)("d%s={}", u)("for(var j=0;j<ks2.length;++j){"), n(i2, l, m, u + "[ks2[j]]")("}")) : l.repeated ? (i2("if(m%s&&m%s.length){", u, u)("d%s=[]", u)("for(var j=0;j<m%s.length;++j){", u), n(i2, l, m, u + "[j]")("}")) : (i2("if(m%s!=null&&m.hasOwnProperty(%j)){", u, l.name), n(i2, l, m, u), l.partOf && i2("if(o.oneofs)")("d%s=%j", a.safeProp(l.partOf.name), l.name)), i2("}");
          }
          return i2("return d");
        };
      }, function(e, t, i) {
        "use strict";
        var r = t, s = i(153);
        r[".google.protobuf.Any"] = { fromObject: function(e2) {
          if (e2 && e2["@type"]) {
            var t2 = e2["@type"].substring(e2["@type"].lastIndexOf("/") + 1), i2 = this.lookup(t2);
            if (i2) {
              var r2 = "." === e2["@type"].charAt(0) ? e2["@type"].substr(1) : e2["@type"];
              return -1 === r2.indexOf("/") && (r2 = "/" + r2), this.create({ type_url: r2, value: i2.encode(i2.fromObject(e2)).finish() });
            }
          }
          return this.fromObject(e2);
        }, toObject: function(e2, t2) {
          var i2 = "", r2 = "";
          if (t2 && t2.json && e2.type_url && e2.value) {
            r2 = e2.type_url.substring(e2.type_url.lastIndexOf("/") + 1), i2 = e2.type_url.substring(0, e2.type_url.lastIndexOf("/") + 1);
            var a = this.lookup(r2);
            a && (e2 = a.decode(e2.value));
          }
          if (!(e2 instanceof this.ctor) && e2 instanceof s) {
            var o = e2.$type.toObject(e2, t2);
            return "" === i2 && (i2 = "type.googleapis.com/"), r2 = i2 + ("." === e2.$type.fullName[0] ? e2.$type.fullName.substr(1) : e2.$type.fullName), o["@type"] = r2, o;
          }
          return this.toObject(e2, t2);
        } };
      }, function(e, t, i) {
        "use strict";
        e.exports = u;
        var r = i(91);
        ((u.prototype = Object.create(r.prototype)).constructor = u).className = "Root";
        var s, a, o, n = i(83), d = i(45), c = i(141), l = i(19);
        function u(e2) {
          r.call(this, "", e2), this.deferred = [], this.files = [];
        }
        function h() {
        }
        u.fromJSON = function(e2, t2) {
          return t2 || (t2 = new u()), e2.options && t2.setOptions(e2.options), t2.addJSON(e2.nested);
        }, u.prototype.resolvePath = l.path.resolve, u.prototype.fetch = l.fetch, u.prototype.load = function e2(t2, i2, r2) {
          "function" == typeof i2 && (r2 = i2, i2 = void 0);
          var s2 = this;
          if (!r2) return l.asPromise(e2, s2, t2, i2);
          var n2 = r2 === h;
          function d2(e3, t3) {
            if (r2) {
              var i3 = r2;
              if (r2 = null, n2) throw e3;
              i3(e3, t3);
            }
          }
          function c2(e3) {
            var t3 = e3.lastIndexOf("google/protobuf/");
            if (t3 > -1) {
              var i3 = e3.substring(t3);
              if (i3 in o) return i3;
            }
            return null;
          }
          function u2(e3, t3) {
            try {
              if (l.isString(t3) && "{" === t3.charAt(0) && (t3 = JSON.parse(t3)), l.isString(t3)) {
                a.filename = e3;
                var r3, o2 = a(t3, s2, i2), u3 = 0;
                if (o2.imports) for (; u3 < o2.imports.length; ++u3) (r3 = c2(o2.imports[u3]) || s2.resolvePath(e3, o2.imports[u3])) && p2(r3);
                if (o2.weakImports) for (u3 = 0; u3 < o2.weakImports.length; ++u3) (r3 = c2(o2.weakImports[u3]) || s2.resolvePath(e3, o2.weakImports[u3])) && p2(r3, true);
              } else s2.setOptions(t3.options).addJSON(t3.nested);
            } catch (e4) {
              d2(e4);
            }
            n2 || m2 || d2(null, s2);
          }
          function p2(e3, t3) {
            if (!(s2.files.indexOf(e3) > -1)) if (s2.files.push(e3), e3 in o) n2 ? u2(e3, o[e3]) : (++m2, setTimeout(function() {
              --m2, u2(e3, o[e3]);
            }));
            else if (n2) {
              var i3;
              try {
                i3 = l.fs.readFileSync(e3).toString("utf8");
              } catch (e4) {
                return void (t3 || d2(e4));
              }
              u2(e3, i3);
            } else ++m2, s2.fetch(e3, function(i4, a2) {
              --m2, r2 && (i4 ? t3 ? m2 || d2(null, s2) : d2(i4) : u2(e3, a2));
            });
          }
          var m2 = 0;
          l.isString(t2) && (t2 = [t2]);
          for (var g, f = 0; f < t2.length; ++f) (g = s2.resolvePath("", t2[f])) && p2(g);
          if (n2) return s2;
          m2 || d2(null, s2);
        }, u.prototype.loadSync = function(e2, t2) {
          if (!l.isNode) throw Error("not supported");
          return this.load(e2, t2, h);
        }, u.prototype.resolveAll = function() {
          if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function(e2) {
            return "'extend " + e2.extend + "' in " + e2.parent.fullName;
          }).join(", "));
          return r.prototype.resolveAll.call(this);
        };
        var p = /^[A-Z]/;
        function m(e2, t2) {
          var i2 = t2.parent.lookup(t2.extend);
          if (i2) {
            var r2 = new n(t2.fullName, t2.id, t2.type, t2.rule, void 0, t2.options);
            return r2.declaringField = t2, t2.extensionField = r2, i2.add(r2), true;
          }
          return false;
        }
        u.prototype._handleAdd = function(e2) {
          if (e2 instanceof n) void 0 === e2.extend || e2.extensionField || m(0, e2) || this.deferred.push(e2);
          else if (e2 instanceof d) p.test(e2.name) && (e2.parent[e2.name] = e2.values);
          else if (!(e2 instanceof c)) {
            if (e2 instanceof s) for (var t2 = 0; t2 < this.deferred.length; ) m(0, this.deferred[t2]) ? this.deferred.splice(t2, 1) : ++t2;
            for (var i2 = 0; i2 < e2.nestedArray.length; ++i2) this._handleAdd(e2._nestedArray[i2]);
            p.test(e2.name) && (e2.parent[e2.name] = e2);
          }
        }, u.prototype._handleRemove = function(e2) {
          if (e2 instanceof n) {
            if (void 0 !== e2.extend) if (e2.extensionField) e2.extensionField.parent.remove(e2.extensionField), e2.extensionField = null;
            else {
              var t2 = this.deferred.indexOf(e2);
              t2 > -1 && this.deferred.splice(t2, 1);
            }
          } else if (e2 instanceof d) p.test(e2.name) && delete e2.parent[e2.name];
          else if (e2 instanceof r) {
            for (var i2 = 0; i2 < e2.nestedArray.length; ++i2) this._handleRemove(e2._nestedArray[i2]);
            p.test(e2.name) && delete e2.parent[e2.name];
          }
        }, u._configure = function(e2, t2, i2) {
          s = e2, a = t2, o = i2;
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.MediaHelper = void 0;
        const n = i(3), d = i(165), c = i(69), l = i(154), u = o(i(6)), h = o(i(8)), p = a(i(71)), m = i(71), g = i(49), f = i(283), v = a(i(7)), S = i(29), y = i(144), _ = i(76), R = i(1), b = i(284), T = i(47), E = i(285), A = i(176);
        class I extends n.EventEmitter {
          constructor(e2) {
            super(), this.audio = { audioStream: new MediaStream(), audioSourceStream: new MediaStream(), musicStream: new MediaStream(), micStream: new MediaStream(), pipeline: null, audioSource: null, micTrack: null, deviceInfo: { mic: { compatAudio: false, label: "" } }, webAudio: null, micConstraint: null, mixAudioConf: { index: 0, audioBuffer: {}, sounds: {} }, stageAIProcessing: null, audioRoutingEnabled: false, audioDom: null }, this.video = { videoStream: new MediaStream(), renderStream: new MediaStream(), low: null, cameraTrack: null, cameraConstraint: { video: {} }, videoSource: null, preProcessingEnabled: false, preProcessing: null, captureConfig: { high: { width: 640, height: 480, frameRate: 15 } }, encoderConfig: { high: { maxBitrate: 8e5, contentHint: null }, low: { maxBitrate: 1e5, contentHint: "motion" } } }, this.screen = { screenVideoStream: new MediaStream(), renderStream: new MediaStream(), low: null, screenVideoTrack: null, screenVideoSource: null, preProcessingEnabled: false, preProcessing: null, captureConfig: { high: { width: 1920, height: 1080, frameRate: 5 } }, encoderConfig: { high: { maxBitrate: 15e5, contentHint: null }, low: { maxBitrate: 2e5, contentHint: "motion" } } }, this.videoThird = { videoThirdStream: new MediaStream(), renderStream: new MediaStream(), low: null, videoThirdTrack: null, videoThirdSource: null, preProcessingEnabled: false, preProcessing: null, captureConfig: { high: { width: 1920, height: 1080, frameRate: 5 } }, encoderConfig: { high: { maxBitrate: 15e5, contentHint: null }, low: { maxBitrate: 2e5, contentHint: "motion" } } }, this.videoFourth = { videoFourthStream: new MediaStream(), renderStream: new MediaStream(), low: null, videoFourthTrack: null, videoFourthSource: null, preProcessingEnabled: false, preProcessing: null, captureConfig: { high: { width: 1920, height: 1080, frameRate: 5 } }, encoderConfig: { high: { maxBitrate: 15e5, contentHint: null }, low: { maxBitrate: 2e5, contentHint: "motion" } } }, this.screenAudio = { screenAudioStream: new MediaStream(), screenAudioTrack: null, screenAudioSource: null, pipeline: null }, this.listenToTrackEnded = (e3) => {
              e3 && ("ended" === e3.readyState && this.logger.error("注意:刚刚获取到的的track已经停止: ", e3.label, e3.id), e3.addEventListener("ended", async () => {
                var t2;
                v.ANY_CHROME_MAJOR_VERSION && v.ANY_CHROME_MAJOR_VERSION < 62 && await this.delay(100), this.logger.log("Track ended", e3.label, e3.id), this.stream.isRemote || this.stream.localStreamId !== (null === (t2 = this.stream.client.adapterRef.localStream) || void 0 === t2 ? void 0 : t2.localStreamId) || (e3 !== this.audio.micTrack && e3 !== this.audio.audioSource || (this.logger.warn("音频轨道已停止"), this.stream.client.safeEmit("audioTrackEnded"), this.stream.client.safeEmit("TrackEnded", "audio"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "audioTrackEnded", mediaType: "audio" })), e3 !== this.video.cameraTrack && e3 !== this.video.videoSource || (this.logger.warn("视频轨道已停止"), this.stream.client.safeEmit("videoTrackEnded"), this.stream.client.safeEmit("TrackEnded", "video"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "videoTrackEnded", mediaType: "video" })), (e3 === this.screen.screenVideoTrack || e3 === this.screen.screenVideoSource || e3.label.indexOf("screen") > -1 || e3.label.indexOf("window") > -1 || e3.label.indexOf("web-") > -1) && (this.logger.warn("屏幕共享已停止"), this.stream.client.safeEmit("stopScreenSharing"), this.stream.client.safeEmit("TrackEnded", "screen"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "videoTrackEnded", mediaType: "screen" })), e3 === this.screenAudio.screenAudioTrack && (this.logger.warn("屏幕共享音频已停止"), this.stream.client.safeEmit("stopScreenAudio"), this.stream.client.safeEmit("TrackEnded", "screenAudio"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "stopScreenAudio", mediaType: "screenAudio" })));
              }), e3.muted && this._handleTrackMuted(e3), e3.addEventListener("mute", () => {
                this.logger.warn("Track muted", e3.label, e3.id), this._handleTrackMuted(e3);
              }), e3.addEventListener("unmute", () => {
                this.logger.log("Track unmuted", e3.label, e3.id);
              }));
            }, this._handleTrackMuted = (e3) => {
              e3 !== this.audio.micTrack && e3 !== this.audio.audioSource || (this.logger.warn("音频轨道已mute"), this.stream.client.safeEmit("TrackMuted", "audio"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "audioTrackMuted", mediaType: "audio" })), e3 !== this.video.cameraTrack && e3 !== this.video.videoSource || (this.logger.warn("视频轨道已mute"), this.stream.client.safeEmit("TrackMuted", "video"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "videoTrackkMuted", mediaType: "video" })), (e3 === this.screen.screenVideoTrack || e3 === this.screen.screenVideoSource || e3.label.indexOf("screen") > -1 || e3.label.indexOf("window") > -1 || e3.label.indexOf("web-") > -1) && (this.logger.warn("屏幕共享已mute"), this.stream.client.safeEmit("TrackMuted", "screen"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "screenTrackkMuted", mediaType: "screen" })), e3 === this.screenAudio.screenAudioTrack && (this.logger.warn("屏幕共享音频已mute"), this.stream.client.safeEmit("TrackMuted", "screenAudio"), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: "screenAudioTrackkMuted", mediaType: "screenAudio" }));
            }, this.stream = e2.stream, this.logger = e2.stream.logger.getChild(() => {
              var e3;
              let t2 = "mediaHelper";
              return this.audio.audioRoutingEnabled && (t2 += " WebAudio"), this.audio.webAudio && (this.audio.webAudio.context && "running" !== this.audio.webAudio.context.state && (t2 += " " + this.audio.webAudio.context.state), this.audio.webAudio.mixAudioConf.state !== d.AuidoMixingState.UNSTART && (t2 += " " + (null === (e3 = this.audio.webAudio) || void 0 === e3 ? void 0 : e3.mixAudioConf.state))), t2;
            }), this.getSettingsEnabled = "getSettings" in MediaStreamTrack.prototype, this.bindRenderStream(), _.Device.on("recording-device-changed", (e3) => {
              if (this.audio.micTrack && this.audio.deviceInfo.mic.deviceId === e3.device.deviceId) if ("INACTIVE" === e3.state) this.logger.error("当前使用的麦克风设备被移除，需重新启用设备", e3.device), this.stream.emit("recording-device-changed", e3);
              else {
                _.Device.deviceHistory.audioIn.find((e4) => {
                  e4.groupId, this.audio.deviceInfo.mic.groupId;
                }) || (this.logger.error(`当前麦克风已由【${this.audio.deviceInfo.mic.label}】切换至【${e3.device.label}】，可能会影响通话质量`), this.audio.deviceInfo.mic.label = e3.device.label, this.audio.deviceInfo.mic.groupId = e3.device.groupId, this.stream.emit("recording-device-changed", e3));
              }
            });
          }
          getOrCreateAudioPipeline(e2 = "audio") {
            let t2;
            const i2 = T.getAudioContext();
            if (!i2) return this.logger.error("getOrCreateAudioPipeline: AudioContext is not supported"), null;
            if ("audio" === e2) if (this.audio.pipeline ? t2 = this.audio.pipeline : (t2 = new E.AudioPipeline({ logger: this.logger, outputStream: this.audio.audioStream, context: i2 }), this.audio.pipeline = t2, this.logger.log("getOrCreateAudioPipeline: 初始化成功")), this.stream.isRemote) t2.inputs.remote.track !== this.audio.micTrack && (this.logger.log("getOrCreateAudioPipeline: 更新输入的Track"), t2.setInput("remote", this.audio.micTrack, "remote" + this.stream.streamID));
            else {
              const e3 = this.audio.micTrack || this.audio.audioSource;
              t2.inputs.local.track !== e3 && (this.logger.log("getOrCreateAudioPipeline: 更新输入的Track"), t2.setInput("local", e3, (null == e3 ? void 0 : e3.label) || "empty"));
            }
            else if (this.screenAudio.pipeline ? t2 = this.screenAudio.pipeline : (t2 = new E.AudioPipeline({ logger: this.logger, outputStream: this.screenAudio.screenAudioStream, context: i2 }), this.screenAudio.pipeline = t2, this.logger.log("getOrCreateAudioPipeline/screenAudio: 初始化成功")), this.stream.isRemote) t2.inputs.remote.track !== this.screenAudio.screenAudioTrack && (this.logger.log("getOrCreateAudioPipeline/screenAudio: 更新输入的Track"), t2.setInput("remote", this.screenAudio.screenAudioTrack, `remote${this.stream.streamID}/screenAudio`));
            else {
              const e3 = this.screenAudio.screenAudioTrack || this.screenAudio.screenAudioSource;
              t2.inputs.local.track !== e3 && (this.logger.log("getOrCreateAudioPipeline/screenAudio: 更新输入的Track"), t2.setInput("local", e3, (null == e3 ? void 0 : e3.label) || "empty"));
            }
            return t2;
          }
          bindRenderStream() {
            v.IS_SAFARI && "safari" === R.getParameters().shimLocalCanvas || "all" === R.getParameters().shimLocalCanvas ? (this.video.videoStream.onaddtrack = async (e2) => {
              if ("undefined" != typeof CanvasCaptureMediaStreamTrack && e2.track instanceof CanvasCaptureMediaStreamTrack) {
                const t2 = f.pcCloneTrack(e2.track);
                m.watchTrack(t2), this.logger.warn("renderStream cloned track for video:", e2.track, t2), m.emptyStreamWith(this.video.renderStream, t2);
              } else m.emptyStreamWith(this.video.renderStream, e2.track);
            }, this.video.videoStream.onremovetrack = (e2) => {
              m.emptyStreamWith(this.video.renderStream, null);
            }, this.screen.screenVideoStream.onaddtrack = async (e2) => {
              if ("undefined" != typeof CanvasCaptureMediaStreamTrack && e2.track instanceof CanvasCaptureMediaStreamTrack) {
                const t2 = f.pcCloneTrack(e2.track);
                m.watchTrack(t2), this.logger.warn("renderStream cloned track for screen:", e2.track, t2), m.emptyStreamWith(this.screen.renderStream, t2);
              } else m.emptyStreamWith(this.screen.renderStream, e2.track);
            }, this.screen.screenVideoStream.onremovetrack = (e2) => {
              m.emptyStreamWith(this.screen.renderStream, null);
            }, this.videoThird.videoThirdStream.onaddtrack = async (e2) => {
              if ("undefined" != typeof CanvasCaptureMediaStreamTrack && e2.track instanceof CanvasCaptureMediaStreamTrack) {
                const t2 = f.pcCloneTrack(e2.track);
                m.watchTrack(t2), this.logger.warn("renderStream cloned track for videoThird:", e2.track, t2), m.emptyStreamWith(this.videoThird.videoThirdStream, t2);
              } else m.emptyStreamWith(this.videoThird.videoThirdStream, e2.track);
            }, this.videoThird.videoThirdStream.onremovetrack = (e2) => {
              m.emptyStreamWith(this.videoThird.renderStream, null);
            }, this.videoFourth.videoFourthStream.onaddtrack = async (e2) => {
              if ("undefined" != typeof CanvasCaptureMediaStreamTrack && e2.track instanceof CanvasCaptureMediaStreamTrack) {
                const t2 = f.pcCloneTrack(e2.track);
                m.watchTrack(t2), this.logger.warn("renderStream cloned track for videoFourth:", e2.track, t2), m.emptyStreamWith(this.videoFourth.renderStream, t2);
              } else m.emptyStreamWith(this.videoFourth.renderStream, e2.track);
            }, this.videoFourth.videoFourthStream.onremovetrack = (e2) => {
              m.emptyStreamWith(this.videoFourth.renderStream, null);
            }) : (this.video.renderStream = this.video.videoStream, this.screen.renderStream = this.screen.screenVideoStream, this.videoThird.renderStream = this.videoThird.videoThirdStream, this.videoFourth.renderStream = this.videoFourth.videoFourthStream);
          }
          assertLive() {
            if (!this.stream.isRemote && !this.stream.isRemote && this.stream.destroyed) {
              throw this._reset(), new h.default({ code: u.default.LOCALSTREAM_NOT_FOUND_ERROR, message: "assertLive: localStream 已经销毁" });
            }
          }
          _reset() {
            this.stopAllEffects(), this.audio.webAudio && (this.audio.webAudio.off("audioFilePlaybackCompleted"), this.audio.webAudio.destroy()), this.audio.webAudio = null, this.audio.micConstraint = null, this.audio.audioRoutingEnabled = false, this.audio.micTrack && (this.audio.micTrack.stop(), this.audio.micTrack = null), this.video.low && (this.video.low.destroy(), this.video.low = null), this.video.videoSource = null, this.video.cameraTrack && !this.stream.isRemote && (this.video.cameraTrack.stop(), this.video.cameraTrack = null), this.screen.screenVideoTrack && !this.stream.isRemote && (this.screen.screenVideoTrack.stop(), this.screen.screenVideoTrack = null), this.videoThird.videoThirdTrack && !this.stream.isRemote && (this.videoThird.videoThirdTrack.stop(), this.videoThird.videoThirdTrack = null), this.videoFourth.videoFourthTrack && !this.stream.isRemote && (this.videoFourth.videoFourthTrack.stop(), this.videoFourth.videoFourthTrack = null), this.video.cameraConstraint = { video: {} }, this.screenAudio.screenAudioTrack && (this.screenAudio.screenAudioTrack.stop(), this.screenAudio.screenAudioTrack = null), this.audio.mixAudioConf = { index: 0, audioBuffer: {}, sounds: {} }, this.audio.audioDom = null, m.emptyStreamWith(this.audio.audioStream, null), m.emptyStreamWith(this.audio.musicStream, null), m.emptyStreamWith(this.audio.micStream, null), m.emptyStreamWith(this.screenAudio.screenAudioStream, null), m.emptyStreamWith(this.video.videoStream, null), m.emptyStreamWith(this.screen.screenVideoStream, null), m.emptyStreamWith(this.screenAudio.screenAudioStream, null), m.emptyStreamWith(this.videoThird.videoThirdStream, null), m.emptyStreamWith(this.videoFourth.videoFourthStream, null);
          }
          updateWebAudio() {
            var e2, t2;
            if (!this.audio.webAudio) {
              this.audio.webAudio = new T.WebAudio({ mediaHelper: this, logger: this.logger }), this.audio.webAudio.on("audioFilePlaybackCompleted", this._audioFilePlaybackCompletedEvent.bind(this));
              const i2 = null === (t2 = null === (e2 = this.audio.webAudio) || void 0 === e2 ? void 0 : e2.musicDestination) || void 0 === t2 ? void 0 : t2.stream.getAudioTracks()[0];
              i2 && m.emptyStreamWith(this.audio.musicStream, i2);
            }
            this.audio.webAudio.updateTracks([{ track: this.audio.micTrack || this.audio.audioSource, type: "microphone" }]);
          }
          async getScreenSource(e2) {
            let t2;
            const { width: i2, height: r2, frameRate: s2 } = this.screen.captureConfig.high;
            try {
              return t2 = { video: { width: { ideal: i2 }, height: { ideal: r2 }, frameRate: { ideal: s2, max: s2 } } }, this.replaceConstraint(t2, "screen"), await p.getScreenStream(t2, this.logger);
            } catch (e3) {
              const t3 = "screen";
              return e3.message && e3.message.indexOf("ermission") > -1 && e3.message.indexOf("denied") > -1 ? this.stream.client.safeEmit("accessDenied", t3) : e3.message && e3.message.indexOf("not found") > -1 ? this.stream.client.safeEmit("notFound", t3) : e3.message && e3.message.indexOf("not start video source") > -1 ? this.stream.client.safeEmit("beOccupied", t3) : "DisplaySurfaceError" === e3.name ? this.stream.client.safeEmit("displaySurfaceError", t3) : this.stream.client.safeEmit("deviceError", t3), this.stream.emit("device-error", { type: t3, error: e3 }), Promise.reject(e3);
            }
          }
          getTrackByMediaType(e2) {
            return "audio" === e2 ? this.audio.micTrack || this.audio.audioSource : "audioSlave" === e2 ? this.screenAudio.screenAudioTrack || this.screenAudio.screenAudioSource : "video" === e2 ? this.video.cameraTrack || this.video.videoSource : "screen" === e2 ? this.screen.screenVideoTrack || this.screen.screenVideoSource : "videoThird" === e2 ? this.videoThird.videoThirdTrack || this.videoThird.videoThirdSource : "videoFourth" === e2 ? this.videoFourth.videoFourthTrack || this.videoFourth.videoFourthSource : null;
          }
          async getStream(e2) {
            let { audio: t2 = false, audioDeviceId: i2 = "", video: r2 = false, videoDeviceId: s2 = "", screen: a2 = false, sourceId: o2 = "", screenAudio: n2 = false, facingMode: d2 = "", audioSource: c2 = null, videoSource: l2 = null, screenAudioSource: u2 = null, screenVideoSource: h2 = null, deviceId: g2 = "" } = e2;
            if (c2 && (t2 = true), l2 && (r2 = true), h2 && (a2 = true), u2 && (n2 = true), this.stream.isRemote) return void this.logger.error("getStream: 远端流不能够调用getStream");
            if (!(t2 || r2 || a2 || n2)) return void this.logger.error("getStream: 必须指定媒体类型");
            if (c2) {
              if ("ended" === c2.readyState) return void this.logger.error("不应输入已经停止的轨道:", c2.kind, c2.label);
              m.watchTrack(c2), this.audio.audioSource = c2, m.emptyStreamWith(this.audio.audioSourceStream, c2), this.updateWebAudio(), this.audio.audioRoutingEnabled || (this.getAudioInputTracks().length > 1 ? this.enableAudioRouting() : (m.emptyStreamWith(this.audio.audioStream, c2), this.updateAudioSender(c2))), t2 = false, this.stream.client.updateRecordingAudioStream();
            }
            if (l2) {
              if ("ended" === l2.readyState) return void this.logger.error("不应输入已经停止的轨道:", l2.kind, l2.label);
              m.watchTrack(l2), this.video.videoSource = l2, m.emptyStreamWith(this.video.videoStream, l2), this.video.videoStream.getVideoTracks().length && "string" == typeof this.video.encoderConfig.high.contentHint && this.video.videoStream.getVideoTracks()[0].contentHint !== this.video.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint video high", this.video.encoderConfig.high.contentHint), this.video.videoStream.getVideoTracks()[0].contentHint = this.video.encoderConfig.high.contentHint), r2 = false;
            }
            if (u2) {
              if ("ended" === u2.readyState) return void this.logger.error("不应输入已经停止的轨道:", u2.kind, u2.label);
              m.watchTrack(u2), this.screenAudio.screenAudioSource = u2, m.emptyStreamWith(this.screenAudio.screenAudioStream, u2), this.listenToTrackEnded(this.screenAudio.screenAudioSource), m.emptyStreamWith(this.screenAudio.screenAudioStream, u2), n2 = false;
            }
            if (h2) {
              if ("ended" === h2.readyState) return void this.logger.error("不应输入已经停止的轨道:", h2.kind, h2.label);
              m.watchTrack(h2), this.screen.screenVideoSource = h2, m.emptyStreamWith(this.screen.screenVideoStream, h2), this.screen.screenVideoStream.getVideoTracks().length && "string" == typeof this.screen.encoderConfig.high.contentHint && this.screen.screenVideoStream.getVideoTracks()[0].contentHint !== this.screen.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint screen high", this.screen.encoderConfig.high.contentHint), this.screen.screenVideoStream.getVideoTracks()[0].contentHint = this.screen.encoderConfig.high.contentHint), a2 = false;
            }
            let f2 = null, v2 = null, S2 = null;
            try {
              if (a2) {
                const { width: e3, height: i3, frameRate: r3 } = this.screen.captureConfig.high;
                if (o2) {
                  S2 = { video: { mandatory: { maxWidth: e3, maxHeight: i3, maxFrameRate: r3, minFrameRate: 5, chromeMediaSource: "desktop", chromeMediaSourceId: o2 } } }, this.replaceConstraint(S2, "screen");
                  const t3 = (await p.getStream(S2, this.logger)).getVideoTracks()[0];
                  this.screen.screenVideoTrack = t3, m.emptyStreamWith(this.screen.screenVideoStream, t3);
                } else {
                  S2 = { video: { width: { ideal: e3 }, height: { ideal: i3 }, frameRate: { ideal: r3, max: r3 } }, audio: n2 && this.getAudioConstraints("audioSlave") ? this.getAudioConstraints("audioSlave") : n2 }, this.replaceConstraint(S2, "screen");
                  let t3 = await p.getScreenStream(S2, this.logger);
                  if (this.screen.screenVideoTrack = t3.getVideoTracks()[0], this.listenToTrackEnded(this.screen.screenVideoTrack), m.emptyStreamWith(this.screen.screenVideoStream, this.screen.screenVideoTrack), this.screen.screenVideoStream.getVideoTracks().length && "string" == typeof this.screen.encoderConfig.high.contentHint && this.screen.screenVideoStream.getVideoTracks()[0].contentHint !== this.screen.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint screen high", this.screen.encoderConfig.high.contentHint), this.screen.screenVideoStream.getVideoTracks()[0].contentHint = this.screen.encoderConfig.high.contentHint), n2) {
                    const e4 = t3.getAudioTracks()[0];
                    e4 ? (this.screenAudio.screenAudioTrack = e4, m.emptyStreamWith(this.screenAudio.screenAudioStream, e4), this.listenToTrackEnded(e4), this.stream.client.apiEventReport("setFunction", { name: "pub_second_audio", oper: "1", value: JSON.stringify({ result: "success", constaints: S2.audio }, null, " ") })) : (this.logger.warn("getStream screenAudio: 未获取到屏幕共享音频"), this.stream.screenAudio = false, this.stream.client.emit("error", "screenAudioNotAllowed"));
                  }
                }
                if (this.stream.client.apiEventReport("setFunction", { name: "set_screen", oper: "1", value: JSON.stringify({ result: "success", constaints: S2 }, null, " ") }), t2) {
                  f2 = { audio: this.getAudioConstraints("audio") }, this.replaceConstraint(f2, "audio");
                  let e4 = await p.getStream(f2, this.logger);
                  this.audio.micTrack = e4.getAudioTracks()[0], m.emptyStreamWith(this.audio.micStream, this.audio.micTrack), this.listenToTrackEnded(this.audio.micTrack), this.updateWebAudio(), this.audio.audioRoutingEnabled || (this.getAudioInputTracks().length > 1 ? this.enableAudioRouting() : (m.emptyStreamWith(this.audio.audioStream, this.audio.micTrack), this.updateAudioSender(this.audio.micTrack)));
                  const t3 = y.compatAudioInputList.findSource(this.audio.micTrack.id);
                  if (t3) {
                    if (this.audio.deviceInfo.mic.compatAudio = true, this.getSettingsEnabled) {
                      const e5 = t3.getSettings();
                      this.audio.deviceInfo.mic.label = t3.label, this.audio.deviceInfo.mic.deviceId = e5.deviceId, this.audio.deviceInfo.mic.groupId = e5.groupId;
                    }
                  } else if (this.audio.deviceInfo.mic.compatAudio = false, this.getSettingsEnabled) {
                    const e5 = this.audio.micTrack.getSettings();
                    this.audio.deviceInfo.mic.label = this.audio.micTrack.label, this.audio.deviceInfo.mic.deviceId = e5.deviceId, this.audio.deviceInfo.mic.groupId = e5.groupId;
                  }
                  this.stream.client.apiEventReport("setFunction", { name: "set_mic", oper: "1", value: JSON.stringify({ result: "success", constaints: f2.audio, track: { enabled: this.audio.micTrack.enabled, muted: this.audio.micTrack.muted, label: this.audio.micTrack.label } }, null, " ") });
                }
              } else if (n2) this.logger.error("无法单独获取屏幕共享音频");
              else if (t2 || r2) {
                if (this.stream.isRemote) return void this.logger.error("MediaHelper.getStream:远端流不能调用getStream");
                const { height: e3, width: a3, frameRate: o3 } = this.video.captureConfig.high;
                v2 = { audio: t2 && this.getAudioConstraints("audio") ? this.getAudioConstraints("audio") : void 0, video: r2 ? { width: { ideal: a3 }, height: { ideal: e3 }, frameRate: { ideal: o3 || 15 } } : void 0 }, i2 && "object" == typeof v2.audio && (v2.audio.deviceId = { exact: i2 }), v2.video && (d2 ? v2.video.facingMode = { exact: d2 } : s2 && (v2.video.deviceId = { exact: s2 })), this.replaceConstraint(v2, "video");
                const n3 = await p.getStream(v2, this.logger), c3 = n3.getVideoTracks()[0], l3 = n3.getAudioTracks()[0];
                if (l3) {
                  this.audio.micTrack = l3, this.listenToTrackEnded(this.audio.micTrack), m.emptyStreamWith(this.audio.micStream, this.audio.micTrack), this.updateWebAudio(), this.audio.audioRoutingEnabled || (this.getAudioInputTracks().length > 1 ? this.enableAudioRouting() : (m.emptyStreamWith(this.audio.audioStream, this.audio.micTrack), this.updateAudioSender(this.audio.micTrack)));
                  const e4 = y.compatAudioInputList.findSource(this.audio.micTrack.id);
                  if (e4) {
                    if (this.audio.deviceInfo.mic.compatAudio = true, this.getSettingsEnabled) {
                      const t3 = e4.getSettings();
                      this.audio.deviceInfo.mic.label = e4.label, this.audio.deviceInfo.mic.deviceId = t3.deviceId, this.audio.deviceInfo.mic.groupId = t3.groupId;
                    }
                  } else if (this.audio.deviceInfo.mic.compatAudio = false, this.getSettingsEnabled) {
                    const e5 = this.audio.micTrack.getSettings();
                    this.audio.deviceInfo.mic.label = this.audio.micTrack.label, this.audio.deviceInfo.mic.deviceId = e5.deviceId, this.audio.deviceInfo.mic.groupId = e5.groupId;
                  }
                  this.stream.client.apiEventReport("setFunction", { name: "set_mic", oper: "1", value: JSON.stringify({ result: "success", constaints: v2.audio, track: { enabled: l3.enabled, muted: l3.muted, label: l3.label } }, null, " ") }), "object" == typeof v2.audio && (this.audio.micConstraint = { audio: v2.audio }), this.stream.client.updateRecordingAudioStream();
                }
                c3 && (this.video.cameraTrack = c3, m.emptyStreamWith(this.video.videoStream, c3), this.video.videoStream.getVideoTracks().length && "string" == typeof this.video.encoderConfig.high.contentHint && this.video.videoStream.getVideoTracks()[0].contentHint !== this.video.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint video high", this.video.encoderConfig.high.contentHint), this.video.videoStream.getVideoTracks()[0].contentHint = this.video.encoderConfig.high.contentHint), this.listenToTrackEnded(this.video.cameraTrack), this.stream.client.apiEventReport("setFunction", { name: "set_camera", oper: "1", value: JSON.stringify({ result: "success", constaints: v2.video, track: { enabled: c3.enabled, muted: c3.muted, label: c3.label } }) }), "object" == typeof v2.video && (this.video.cameraConstraint = { video: v2.video }));
              }
              this.assertLive();
            } catch (e3) {
              this.logger.error("getStream error:", e3.name, e3.message);
              let i3 = "audio";
              return t2 && this.stream.client.apiEventReport("setFunction", { name: "set_mic", oper: "1", value: JSON.stringify({ result: "fail", reason: "" + e3.message }, null, " ") }), r2 && (i3 = "video", this.stream.client.apiEventReport("setFunction", { name: "set_camera", oper: "1", value: JSON.stringify({ result: "fail", reason: `${e3.name} + ${e3.message}` }, null, " ") })), a2 && (i3 = "screen", this.stream.client.apiEventReport("setFunction", { name: "set_screen", oper: "1", value: JSON.stringify({ result: "fail", reason: `${e3.name} + ${e3.message}` }, null, " ") })), "NotAllowedError" === e3.name || "PermissionDeniedError" === e3.name ? this.stream.client.safeEmit("accessDenied", i3) : "NotFoundError" === e3.name ? this.stream.client.safeEmit("notFound", i3) : "NotReadableError" === e3.name ? this.stream.client.safeEmit("beOccupied", i3) : "OverconstrainedError" === e3.name ? this.stream.client.safeEmit("deviceError", i3) : "DisplaySurfaceError" === e3.name && this.stream.client.safeEmit("displaySurfaceError", i3), this.stream.emit("device-error", { type: i3, error: e3 }), this.stream.client.apiEventReport("setStreamException", { name: "pushStreamException", value: `getUserMediaError: ${e3.name} + ${e3.message}`, mediaType: i3 }), Promise.reject(e3);
            }
          }
          async getSecondStream(e2) {
            let { audio: t2 = false, video: i2 = false } = e2;
            if (!this.stream.isRemote) try {
              this.replaceConstraint(e2, "video");
              const t3 = await p.getStream(e2, this.logger), i3 = t3.getAudioTracks()[0], r2 = t3.getVideoTracks()[0];
              if (this.logger.log(`getSecondStream: ${i3 ? i3.label : ""} ${r2 ? r2.label : ""}`), i3) {
                "object" == typeof e2.audio && (this.audio.micConstraint = { audio: e2.audio }), this.audio.micTrack = i3, this._stopTrack(this.audio.micStream), m.emptyStreamWith(this.audio.micStream, this.audio.micTrack), this.listenToTrackEnded(this.audio.micTrack), this.updateWebAudio(), this.audio.audioRoutingEnabled || (this.getAudioInputTracks().length > 1 ? this.enableAudioRouting() : (m.emptyStreamWith(this.audio.audioStream, this.audio.micTrack), this.updateAudioSender(this.audio.micTrack)));
                const t4 = y.compatAudioInputList.findSource(this.audio.micTrack.id);
                if (t4) {
                  if (this.audio.deviceInfo.mic.compatAudio = true, this.getSettingsEnabled) {
                    const e3 = t4.getSettings();
                    this.audio.deviceInfo.mic.label = t4.label, this.audio.deviceInfo.mic.deviceId = e3.deviceId, this.audio.deviceInfo.mic.groupId = e3.groupId;
                  }
                } else if (this.audio.deviceInfo.mic.compatAudio = false, this.getSettingsEnabled) {
                  const e3 = this.audio.micTrack.getSettings();
                  this.audio.deviceInfo.mic.label = this.audio.micTrack.label, this.audio.deviceInfo.mic.deviceId = e3.deviceId, this.audio.deviceInfo.mic.groupId = e3.groupId;
                }
                this.stream.client.updateRecordingAudioStream(), this.stream.client.apiEventReport("setFunction", { name: "set_mic", oper: "1", value: JSON.stringify({ result: "success", constaints: e2.audio }, null, " ") });
              }
              if (r2) {
                "object" == typeof e2.video && (this.video.cameraConstraint = { video: e2.video }), this.video.cameraTrack = r2, this._stopTrack(this.video.videoStream), m.emptyStreamWith(this.video.videoStream, this.video.cameraTrack), this.video.videoStream.getVideoTracks().length && "string" == typeof this.video.encoderConfig.high.contentHint && this.video.videoStream.getVideoTracks()[0].contentHint !== this.video.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint video high", this.video.encoderConfig.high.contentHint), this.video.videoStream.getVideoTracks()[0].contentHint = this.video.encoderConfig.high.contentHint), this.stream.client.apiEventReport("setFunction", { name: "set_camera", oper: "1", value: JSON.stringify({ result: "success", constaints: e2.video, func: "switchDevices", track: { enabled: r2.enabled, muted: r2.muted, label: r2.label } }, null, " ") });
                const t4 = this.stream._play.video.view;
                t4 && (await this.stream.play(t4), "width" in this.stream.renderMode.local.video && this.stream.setLocalRenderMode(this.stream.renderMode.local.video, "video"));
                const i4 = this.stream.getSender("video", "high");
                (null == i4 ? void 0 : i4.track) ? i4.replaceTrack(r2) : this.logger.warn("getSecondStream video: 此时未发布流");
              }
            } catch (e3) {
              this.logger.error("getStream error", e3.message);
              const i3 = t2 ? "set_mic" : "set_camera";
              return this.stream.client.apiEventReport("setFunction", { name: i3, oper: "1", value: JSON.stringify({ result: "fail", reason: e3.message }, null, " ") }), Promise.reject(e3);
            }
          }
          convert(e2) {
            const t2 = e2.resolution, i2 = e2.frameRate;
            let r2 = { width: 640, height: 480, frameRate: 15 };
            return 2 === t2 ? (r2.width = 320, r2.height = 180) : 4 === t2 ? (r2.width = 640, r2.height = 480) : 8 === t2 || v.IS_IOS_SAFARI ? (r2.width = 1280, r2.height = 720) : 16 === t2 && (r2.width = 1920, r2.height = 1080), i2 === c.VIDEO_FRAME_RATE_ENUM.CHAT_VIDEO_FRAME_RATE_NORMAL ? r2.frameRate = 15 : i2 === c.VIDEO_FRAME_RATE_ENUM.CHAT_VIDEO_FRAME_RATE_5 ? r2.frameRate = 5 : i2 === c.VIDEO_FRAME_RATE_ENUM.CHAT_VIDEO_FRAME_RATE_10 ? r2.frameRate = 10 : i2 === c.VIDEO_FRAME_RATE_ENUM.CHAT_VIDEO_FRAME_RATE_15 ? r2.frameRate = 15 : i2 === c.VIDEO_FRAME_RATE_ENUM.CHAT_VIDEO_FRAME_RATE_20 ? r2.frameRate = 20 : i2 === c.VIDEO_FRAME_RATE_ENUM.CHAT_VIDEO_FRAME_RATE_25 ? r2.frameRate = 25 : i2 === c.VIDEO_FRAME_RATE_ENUM.CHAT_VIDEO_FRAME_RATE_30 && (r2.frameRate = 30), r2;
          }
          getAudioConstraints(e2) {
            if (this.stream.isRemote) return void this.logger.error("Remote Stream dont have audio constraints");
            const t2 = this.stream, i2 = t2.constraintSettings[e2];
            let r2 = { channelCount: "audio" === e2 ? 1 : 2 };
            switch ("audioSlave" === e2 && (A.set3AConstraint(r2, "AEC", false), A.set3AConstraint(r2, "ANS", false), A.set3AConstraint(r2, "AGC", false)), t2.audioProfile) {
              case "standard_stereo":
              case "high_quality_stereo":
                A.set3AConstraint(r2, "AGC", false), A.set3AConstraint(r2, "AEC", false), A.set3AConstraint(r2, "ANS", false), r2.channelCount = 2;
            }
            for (let e3 in i2) if (["AEC", "ANS", "AGC"].indexOf(e3) > -1) {
              const t3 = e3;
              A.set3AConstraint(r2, t3, i2[t3]);
            } else r2[e3] = i2[e3];
            return A.forceAudioConstraints(r2), r2;
          }
          getTrackSettings() {
            const e2 = {};
            try {
              if (this.audio.micTrack) {
                const t2 = y.compatAudioInputList.findSource(this.audio.micTrack.id);
                e2.mic = t2 ? { compat: true, settings: this.getSettingsEnabled ? t2.getSettings() : t2.getConstraints(), label: t2.label, readyState: t2.readyState } : { settings: this.getSettingsEnabled ? this.audio.micTrack.getSettings() : this.audio.micTrack.getConstraints(), label: this.audio.micTrack.label, readyState: this.audio.micTrack.readyState };
              }
              this.audio.audioSource && (e2.audioSource = { settings: this.getSettingsEnabled ? this.audio.audioSource.getSettings() : this.audio.audioSource.getConstraints(), label: this.audio.audioSource.label, readyState: this.audio.audioSource.readyState }), this.video.cameraTrack && (e2.camera = { settings: this.getSettingsEnabled ? this.video.cameraTrack.getSettings() : this.video.cameraTrack.getConstraints(), label: this.video.cameraTrack.label, readyState: this.video.cameraTrack.readyState }), this.video.videoSource && (e2.videoSource = { settings: this.getSettingsEnabled ? this.video.videoSource.getSettings() : this.video.videoSource.getConstraints(), label: this.video.videoSource.label, readyState: this.video.videoSource.readyState }), this.screen.screenVideoTrack && (e2.screen = { settings: this.getSettingsEnabled ? this.screen.screenVideoTrack.getSettings() : this.screen.screenVideoTrack.getConstraints(), label: this.screen.screenVideoTrack.label, readyState: this.screen.screenVideoTrack.readyState }), this.screen.screenVideoSource && (e2.screenVideoSource = { settings: this.getSettingsEnabled ? this.screen.screenVideoSource.getSettings() : this.screen.screenVideoSource.getConstraints(), label: this.screen.screenVideoSource.label, readyState: this.screen.screenVideoSource.readyState }), this.screenAudio.screenAudioTrack && (e2.screenAudio = { settings: this.getSettingsEnabled ? this.screenAudio.screenAudioTrack.getSettings() : this.screenAudio.screenAudioTrack.getConstraints(), label: this.screenAudio.screenAudioTrack.label, readyState: this.screenAudio.screenAudioTrack.readyState }), this.screenAudio.screenAudioSource && (e2.screenAudioSource = { settings: this.getSettingsEnabled ? this.screenAudio.screenAudioSource.getSettings() : this.screenAudio.screenAudioSource.getConstraints(), label: this.screenAudio.screenAudioSource.label, readyState: this.screenAudio.screenAudioSource.readyState }), _.Device.deviceHistory.audioOut[0] && (e2.audioOutDefault = _.Device.deviceHistory.audioOut[0]);
            } catch (t2) {
              e2.errName = t2.name, e2.errMessage = t2.message;
            }
            return e2;
          }
          updateStream(e2, t2) {
            "audio" === e2 ? (this.audio.micTrack = t2, m.emptyStreamWith(this.audio.audioStream, t2), this.updateWebAudio(), this.stream._play.audio.dom && (this.stream._play.audio.dom.srcObject = this.audio.audioStream)) : "audioSlave" === e2 ? (this.screenAudio.screenAudioTrack = t2, m.emptyStreamWith(this.screenAudio.screenAudioStream, t2), this.stream._play.audioSlave.dom && (this.stream._play.audioSlave.dom.srcObject = this.screenAudio.screenAudioStream)) : "video" === e2 ? (this.video.cameraTrack = t2, m.emptyStreamWith(this.video.videoStream, t2), this.video.videoStream.getVideoTracks().length && "string" == typeof this.video.encoderConfig.high.contentHint && this.video.videoStream.getVideoTracks()[0].contentHint !== this.video.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint video high", this.video.encoderConfig.high.contentHint), this.video.videoStream.getVideoTracks()[0].contentHint = this.video.encoderConfig.high.contentHint), this.stream._play.video.dom && (this.stream._play.video.dom.srcObject = this.video.renderStream)) : "screen" === e2 ? (this.screen.screenVideoTrack = t2, m.emptyStreamWith(this.screen.screenVideoStream, t2), this.screen.screenVideoStream.getVideoTracks().length && "string" == typeof this.screen.encoderConfig.high.contentHint && this.screen.screenVideoStream.getVideoTracks()[0].contentHint !== this.screen.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint screen high", this.screen.encoderConfig.high.contentHint), this.screen.screenVideoStream.getVideoTracks()[0].contentHint = this.screen.encoderConfig.high.contentHint), this.stream._play.screen.dom && (this.stream._play.screen.dom.srcObject = this.screen.renderStream)) : "videoThird" === e2 ? (this.videoThird.videoThirdTrack = t2, m.emptyStreamWith(this.videoThird.videoThirdStream, t2), this.videoThird.videoThirdStream.getVideoTracks().length && "string" == typeof this.videoThird.encoderConfig.high.contentHint && this.videoThird.videoThirdStream.getVideoTracks()[0].contentHint !== this.videoThird.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint videoThird high", this.videoThird.encoderConfig.high.contentHint), this.videoThird.videoThirdStream.getVideoTracks()[0].contentHint = this.videoThird.encoderConfig.high.contentHint), this.stream._play.videoThird.dom && (this.stream._play.videoThird.dom.srcObject = this.videoThird.renderStream)) : "videoFourth" === e2 && (this.videoFourth.videoFourthTrack = t2, m.emptyStreamWith(this.videoFourth.videoFourthStream, t2), this.videoFourth.videoFourthStream.getVideoTracks().length && "string" == typeof this.videoFourth.encoderConfig.high.contentHint && this.videoFourth.videoFourthStream.getVideoTracks()[0].contentHint !== this.videoFourth.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint videoFourth high", this.videoFourth.encoderConfig.high.contentHint), this.videoFourth.videoFourthStream.getVideoTracks()[0].contentHint = this.videoFourth.encoderConfig.high.contentHint), this.stream._play.videoFourth.dom && (this.stream._play.videoFourth.dom.srcObject = this.videoFourth.renderStream));
          }
          stopStream(e2) {
            var t2, i2, r2, s2, a2, o2, n2, d2;
            let c2 = "set_mic";
            "audio" === e2 ? (R.getParameters().tracks.audio = R.getParameters().tracks.audio.filter((e3) => this.audio.micTrack !== e3), null === (t2 = this.audio.micTrack) || void 0 === t2 || t2.stop(), this.audio.micTrack = null, m.emptyStreamWith(this.audio.micStream, null), this.audio.audioSource = null, m.emptyStreamWith(this.audio.audioSourceStream, null), this.updateWebAudio(), this.canDisableAudioRouting() && this.disableAudioRouting(), this.stream.isRemote || null === (i2 = this.stream.audioLevelHelper) || void 0 === i2 || i2.updateStream(this.screenAudio.screenAudioStream)) : "screenAudio" === e2 ? (null === (r2 = this.screenAudio.screenAudioTrack) || void 0 === r2 || r2.stop(), this.screenAudio.screenAudioTrack = null, this.screenAudio.screenAudioSource = null, m.emptyStreamWith(this.screenAudio.screenAudioStream, null), this.stream.isRemote || null === (s2 = this.stream.audioLevelHelperSlave) || void 0 === s2 || s2.updateStream(this.screenAudio.screenAudioStream), c2 = "pub_second_audio") : "video" === e2 ? (c2 = "set_camera", R.getParameters().tracks.video = R.getParameters().tracks.video.filter((e3) => this.video.cameraTrack !== e3), null === (a2 = this.video.cameraTrack) || void 0 === a2 || a2.stop(), this.video.cameraTrack = null, this.video.videoSource = null, m.emptyStreamWith(this.video.videoStream, null)) : "screen" === e2 ? (c2 = "set_screen", null === (o2 = this.screen.screenVideoTrack) || void 0 === o2 || o2.stop(), this.screen.screenVideoTrack = null, this.screen.screenVideoSource = null, m.emptyStreamWith(this.screen.screenVideoStream, null)) : "videoThird" === e2 ? (c2 = "set_video_third", null === (n2 = this.videoThird.videoThirdTrack) || void 0 === n2 || n2.stop(), this.videoThird.videoThirdTrack = null, m.emptyStreamWith(this.videoThird.videoThirdStream, null)) : "videoFourth" === e2 && (c2 = "set_video_fourth", null === (d2 = this.videoFourth.videoFourthTrack) || void 0 === d2 || d2.stop(), this.videoFourth.videoFourthTrack = null, m.emptyStreamWith(this.videoFourth.videoFourthStream, null)), this.stream.client.apiEventReport("setFunction", { name: c2, oper: "0", value: "success" });
          }
          _stopTrack(e2) {
            if (!e2) return;
            if (this.stream.isRemote) return;
            this.logger.log("清除stream: ", e2);
            const t2 = e2.getTracks();
            this.logger.log("清除stream tracks: ", ...t2), t2 && 0 !== t2.length && t2.forEach((t3) => {
              if ("audio" === t3.kind) {
                const e3 = R.getParameters().tracks.audio.findIndex((e4) => t3 === e4);
                S.Logger.warn(`Stopping AUDIOTRACK#${e3} ${t3.id}, ${t3.label}, ${t3.readyState}`), R.getParameters().tracks.audio = R.getParameters().tracks.audio.filter((e4) => t3 !== e4);
              } else {
                const e3 = R.getParameters().tracks.video.findIndex((e4) => t3 === e4);
                S.Logger.warn(`Stopping VIDEOTRACK#${e3} ${t3.id}, ${t3.label}, ${t3.readyState}`), R.getParameters().tracks.video = R.getParameters().tracks.video.filter((e4) => t3 !== e4);
              }
              t3.stop(), e2.removeTrack(t3), this.audio.micTrack === t3 && (this.audio.micTrack = null, this.audio.deviceInfo.mic = { compatAudio: y.compatAudioInputList.enabled, label: "" }, this.updateWebAudio()), this.screenAudio.screenAudioTrack === t3 && (this.screenAudio.screenAudioTrack = null, this.updateWebAudio()), this.video.cameraTrack === t3 && (this.video.cameraTrack = null), this.screen.screenVideoTrack === t3 && (this.screen.screenVideoTrack = null), this.videoThird.videoThirdTrack === t3 && (this.videoThird.videoThirdTrack = null), this.videoFourth.videoFourthTrack === t3 && (this.videoFourth.videoFourthTrack = null);
            });
          }
          getAudioTrack() {
            var e2;
            return null === (e2 = this.audio) || void 0 === e2 ? void 0 : e2.audioStream.getAudioTracks()[0];
          }
          getVideoTrack() {
            var e2;
            return null === (e2 = this.video) || void 0 === e2 ? void 0 : e2.videoStream.getVideoTracks()[0];
          }
          setGain(e2, t2) {
            this.audio.webAudio ? (this.logger.log("setGain", e2), this.audio.webAudio.setGain(e2, t2), this.canDisableAudioRouting() && this.disableAudioRouting()) : this.logger.log("setGain: 缺失本地音频");
          }
          getGain() {
            var e2;
            return (null === (e2 = this.audio.webAudio) || void 0 === e2 ? void 0 : e2.getVolumeData()) || "0.0";
          }
          canDisableAudioRouting() {
            var e2, t2;
            let i2 = true;
            if (!this.audio.webAudio) return false;
            if (null === (e2 = this.audio.stageAIProcessing) || void 0 === e2 ? void 0 : e2.enabled) return false;
            this.audio.webAudio.mixAudioConf.state !== d.AuidoMixingState.PLAYED && this.audio.webAudio.mixAudioConf.state !== d.AuidoMixingState.PAUSED || (i2 = false), Object.values(this.audio.mixAudioConf.sounds).forEach((e3) => {
              "STARTING" !== e3.state && "PLAYED" !== e3.state && "PAUSED" !== e3.state || (i2 = false);
            });
            const r2 = this.audio.webAudio.getGainMin();
            return !(null === (t2 = this.audio.webAudio.Jungle) || void 0 === t2 ? void 0 : t2.connected) && (i2 && 1 === r2 && this.audio.webAudio.audioInArr.length <= 1);
          }
          setAudioEffectLite(e2, t2) {
            this.audio.webAudio ? this.audio.webAudio.setAudioEffectLite(e2, t2) : this.logger.warn("WebAudio is not available");
          }
          _audioFilePlaybackCompletedEvent() {
            this.canDisableAudioRouting() && this.disableAudioRouting();
          }
          startAudioMixing(e2) {
            let t2, i2;
            return this.logger.log("开始伴音:", JSON.stringify(e2, null, " ")), Object.assign(this.audio.mixAudioConf, e2), this.audio.mixAudioConf.audioFilePath ? 0 !== this.getAudioInputTracks().length && this.stream.pubStatus.audio.audio ? this.audio.webAudio && this.audio.webAudio.context || (i2 = "startAudioMixing() 浏览器环境不支持伴音", t2 = u.default.AUDIO_MIX_NO_SUPPORT) : (i2 = "startAudioMixing() 当前没有开启过麦克风", t2 = u.default.AUDIO_MIX_NO_AUDIO) : (i2 = "startAudioMixing() 没有设置云端文件路径", t2 = u.default.AUDIO_MIX_FILE_ERROR), t2 ? (this.logger.error(i2), this.stream.client.apiFrequencyControl({ name: "startAudioMixing", code: -1, param: JSON.stringify(Object.assign(this.audio.mixAudioConf, { reason: t2 }), null, " ") }), Promise.reject(new h.default({ code: t2, message: i2 }))) : (this.stream.client.apiFrequencyControl({ name: "startAudioMixing", code: 0, param: JSON.stringify(this.audio.mixAudioConf, null, " ") }), this.audio.webAudio && (this.audio.webAudio.mixAudioConf && this.audio.webAudio.mixAudioConf.audioSource && this.audio.webAudio.mixAudioConf.state === d.AuidoMixingState.PLAYED && (this.logger.log("startAudioMixing() 当前已经开启伴音，先关闭之前的伴音"), this.stopAudioMixing()), this.audio.webAudio.mixAudioConf.state, d.AuidoMixingState.STARTING), this.audio.mixAudioConf.audioFilePath && this.audio.mixAudioConf.audioBuffer[this.audio.mixAudioConf.audioFilePath] ? (this.logger.log("startAudioMixing() 开始伴音, 已经加载过云端音乐"), this.startMix(this.audio.mixAudioConf.index)) : (this.logger.log("startAudioMixing() 开始伴音, 先加载云端音乐"), this.loadRemoteAudioFile(this.audio.mixAudioConf.index)));
          }
          loadRemoteAudioFile(e2) {
            const t2 = this.audio.mixAudioConf.audioFilePath;
            return t2 ? l.ajax({ url: t2, type: "GET", dataType: "arraybuffer" }).then((i2) => (this.logger.log("loadRemoteAudioFile 加载云端音乐成功"), new Promise((r2, s2) => {
              var a2, o2;
              null === (o2 = null === (a2 = this.audio.webAudio) || void 0 === a2 ? void 0 : a2.context) || void 0 === o2 || o2.decodeAudioData(i2, (i3) => {
                var s3;
                this.logger.log("loadRemoteAudioFile 云端音乐解码成功"), this.audio.mixAudioConf.audioBuffer[t2] = i3, null === (s3 = this.startMix(e2)) || void 0 === s3 || s3.then((e3) => {
                  r2(e3);
                });
              }, (e3) => {
                s2(new h.default({ code: u.default.AUDIO_MIX_FILE_ERROR, message: "loadRemoteAudioFile: 云端音乐解码失败: " + e3.message }));
              });
            }))).catch((e3) => Promise.reject(new h.default({ code: u.default.AUDIO_MIX_FILE_ERROR, message: `loadRemoteAudioFile: 加载云端音乐失败: ${e3.name} ${e3.message}` }))) : (this.logger.warn("loadRemoteAudioFile() audioFilePath未设置"), Promise.resolve());
          }
          delay(e2) {
            return new Promise((t2) => setTimeout(t2, e2));
          }
          startMix(e2) {
            var t2;
            if (this.logger.log("startMix 开始混音:", JSON.stringify(this.audio.mixAudioConf)), e2 !== this.audio.mixAudioConf.index) return this.logger.log("startMix: 该次伴音已经取消"), Promise.resolve();
            this.audio.audioRoutingEnabled || this.enableAudioRouting();
            const { audioFilePath: i2 = "", loopback: r2 = false, replace: s2 = false, cycle: a2 = 0, playStartTime: o2 = 0, volume: n2 = 255, auidoMixingEnd: d2 = null } = this.audio.mixAudioConf;
            return null === (t2 = this.audio.webAudio) || void 0 === t2 ? void 0 : t2.startMix({ buffer: this.audio.mixAudioConf.audioBuffer[i2], loopback: r2, replace: s2, cycle: a2, playStartTime: o2, volume: n2, auidoMixingEnd: d2 });
          }
          stopAudioMixing(e2 = true) {
            var t2;
            return (null === (t2 = this.audio.webAudio) || void 0 === t2 ? void 0 : t2.mixAudioConf) && this.audio.webAudio.mixAudioConf.audioSource ? (this.stream.client.apiFrequencyControl({ name: "stopAudioMixing", code: 0, param: JSON.stringify(this.audio.mixAudioConf, null, " ") }), this.audio.webAudio.stopAudioMixing(e2)) : (this.logger.error("stopAudioMixing() 当前没有开启伴音"), this.stream.client.apiFrequencyControl({ name: "stopAudioMixing", code: -1, param: JSON.stringify(Object.assign(this.audio.mixAudioConf, { reason: "stopAudioMixing() 当前没有开启伴音" }), null, " ") }), Promise.reject(new h.default({ code: u.default.AUDIO_MIX_NOT_STATE_ERROR, message: "stopAudioMixing() 当前没有开启伴音" })));
          }
          pauseAudioMixing() {
            var e2;
            return (null === (e2 = this.audio.webAudio) || void 0 === e2 ? void 0 : e2.mixAudioConf) && this.audio.webAudio.mixAudioConf.audioSource && this.audio.webAudio.mixAudioConf.state === d.AuidoMixingState.PLAYED ? (this.stream.client.apiFrequencyControl({ name: "pauseAudioMixing", code: 0, param: JSON.stringify(this.audio.mixAudioConf, null, " ") }), this.audio.webAudio && this.audio.webAudio.pauseAudioMixing()) : (this.logger.error("pauseAudioMixing() 当前没有开启伴音"), this.stream.client.apiFrequencyControl({ name: "pauseAudioMixing", code: -1, param: JSON.stringify(Object.assign(this.audio.mixAudioConf, { reason: "pauseAudioMixing() 当前没有开启伴音" }), null, " ") }), Promise.reject(new h.default({ code: u.default.AUDIO_MIX_NOT_STATE_ERROR, message: "pauseAudioMixing() 当前没有开启伴音" })));
          }
          resumeAudioMixing() {
            var e2;
            let t2, i2;
            if ((null === (e2 = this.audio.webAudio) || void 0 === e2 ? void 0 : e2.mixAudioConf) && this.audio.webAudio.mixAudioConf.audioSource ? this.audio.webAudio.mixAudioConf.state !== d.AuidoMixingState.PAUSED && (i2 = "resumeAudioMixing() 当前没有暂停伴音", t2 = u.default.AUDIO_MIX_NOT_PAUSE) : (i2 = "resumeAudioMixing() 当前没有开启伴音", t2 = u.default.AUDIO_MIX_NOT_STATE_ERROR), this.stream.client.apiFrequencyControl({ name: "resumeAudioMixing", code: t2 ? -1 : 0, param: JSON.stringify(Object.assign(this.audio.mixAudioConf, { reason: i2 || "" }), null, " ") }), t2) return this.logger.error(i2), Promise.reject(new h.default({ code: t2, message: i2 }));
            if (!this.audio.webAudio) return;
            let { audioFilePath: r2 = "", loopback: s2 = false, replace: a2 = false, cycle: o2 = 0, playStartTime: n2 = 0, auidoMixingEnd: c2 = null } = this.audio.mixAudioConf, l2 = (this.audio.webAudio.mixAudioConf.pauseTime - this.audio.webAudio.mixAudioConf.startTime) / 1e3 + this.audio.webAudio.mixAudioConf.playStartTime;
            return l2 > this.audio.webAudio.mixAudioConf.totalTime && (this.logger.log("播放过的圈数 playedCycle: ", Math.floor(l2 / this.audio.webAudio.mixAudioConf.totalTime)), o2 -= Math.floor(l2 / this.audio.webAudio.mixAudioConf.totalTime), this.audio.mixAudioConf.cycle = o2), this.audio.webAudio.mixAudioConf.setPlayStartTime ? (this.logger.log("暂停期间，用户设置混音播放时间: ", this.audio.webAudio.mixAudioConf.setPlayStartTime), n2 = this.audio.webAudio.mixAudioConf.setPlayStartTime, this.audio.webAudio.mixAudioConf.setPlayStartTime = 0) : (this.logger.log("恢复混音:", JSON.stringify(this.audio.webAudio.mixAudioConf)), this.logger.log("已经播放的时间: ", l2), l2 > this.audio.webAudio.mixAudioConf.totalTime && (l2 %= this.audio.webAudio.mixAudioConf.totalTime), n2 = l2), this.logger.log("回复重置的时间点：", n2), this.audio.webAudio.resumeAudioMixing({ buffer: this.audio.mixAudioConf.audioBuffer[r2], loopback: s2, replace: a2, cycle: o2, playStartTime: n2, auidoMixingEnd: c2 });
          }
          setAudioMixingVolume(e2) {
            var t2;
            let i2, r2;
            return (null === (t2 = this.audio.webAudio) || void 0 === t2 ? void 0 : t2.mixAudioConf) && this.audio.webAudio.mixAudioConf.audioSource ? (!Number.isInteger(e2) || e2 < 0 || e2 > 255) && (r2 = "adjustAudioMixingVolume() volume应该是1-255的number类型", i2 = u.default.AUDIO_MIX_VOLUME_ERROR) : (r2 = "adjustAudioMixingVolume() 当前没有开启伴音", i2 = u.default.AUDIO_MIX_NOT_STATE_ERROR), this.stream.client.apiFrequencyControl({ name: "adjustAudioMixingVolume", code: i2 ? -1 : 0, param: JSON.stringify(Object.assign(this.audio.mixAudioConf, { reason: r2 || "", volume: e2 }), null, " ") }), i2 ? (this.logger.error(r2), Promise.reject(new h.default({ code: i2, message: r2 }))) : this.audio.webAudio && this.audio.webAudio.setAudioMixingVolume(e2);
          }
          setAudioMixingPlayTime(e2) {
            var t2;
            let i2, r2;
            if ((null === (t2 = this.audio.webAudio) || void 0 === t2 ? void 0 : t2.mixAudioConf) && this.audio.webAudio.mixAudioConf.audioSource) {
              if (e2 < 0) r2 = "setAudioMixingPosition(): 设置的playStartTime 小于 0 了", i2 = u.default.AUDIO_MIX_PLAY_START_TIME_ERROR;
              else if (e2 >= this.audio.webAudio.mixAudioConf.totalTime) r2 = "setAudioMixingPosition(): 设置的playStartTime大于音频文件总时长了", i2 = u.default.AUDIO_MIX_PLAY_START_TIME_ERROR;
              else if (this.audio.webAudio.mixAudioConf.state === d.AuidoMixingState.PAUSED) return this.audio.webAudio.mixAudioConf.setPlayStartTime = e2, this.logger.log("setAudioMixingPosition() 当前正在暂停，记录设置的播放位置，在恢复伴音时，跳转到此次设置的播放位置: ", e2), Promise.resolve();
            } else r2 = "setAudioMixingPosition(): 当前没有开启伴音", i2 = u.default.AUDIO_MIX_NOT_STATE_ERROR;
            return this.stream.client.apiFrequencyControl({ name: "setAudioMixingPosition", code: i2 ? -1 : 0, param: JSON.stringify({ playTime: e2, reason: r2 || "" }, null, " ") }), i2 ? (this.logger.error(r2), Promise.reject(new h.default({ code: i2, message: r2 }))) : new Promise((t3, i3) => {
              this.stopAudioMixing(false).then((r3) => {
                if (!this.audio.webAudio) return;
                this.audio.mixAudioConf.playStartTime = e2;
                let { audioFilePath: s2 = "", loopback: a2 = false, replace: o2 = false, cycle: n2 = 0, playStartTime: d2 = 0, auidoMixingEnd: c2 = null } = this.audio.mixAudioConf;
                this.logger.log("设置混音的播放位置:", this.audio.webAudio.mixAudioConf);
                let l2 = (Date.now() - this.audio.webAudio.mixAudioConf.startTime) / 1e3 + this.audio.webAudio.mixAudioConf.playStartTime;
                this.logger.log("已经播放的时间: ", l2), l2 > this.audio.webAudio.mixAudioConf.totalTime && (this.logger.log("播放过的圈数 playedCycle: ", Math.floor(l2 / this.audio.webAudio.mixAudioConf.totalTime)), n2 -= Math.floor(l2 / this.audio.webAudio.mixAudioConf.totalTime), this.audio.mixAudioConf.cycle = n2), this.logger.log(`setAudioMixingPlayTime, playTime: ${e2}, cycle: ${n2}`), this.audio.webAudio.setAudioMixingPlayTime({ buffer: this.audio.mixAudioConf.audioBuffer[s2], loopback: a2, replace: o2, cycle: n2, playStartTime: d2, auidoMixingEnd: c2 }).then((i4) => {
                  this.stream.client.apiFrequencyControl({ name: "setAudioMixingPosition", code: 0, param: JSON.stringify({ playTime: e2 }, null, " ") }), t3(i4);
                }).catch((t4) => {
                  this.stream.client.apiFrequencyControl({ name: "setAudioMixingPosition", code: -1, param: JSON.stringify({ playTime: e2, reason: "重新播放伴音失败" + t4.message }, null, " ") }), i3(t4);
                });
              }).catch((t4) => (this.stream.client.apiFrequencyControl({ name: "setAudioMixingPosition", code: -1, param: JSON.stringify({ playTime: e2, reason: "暂停当前播放失败" + t4.message }, null, " ") }), Promise.reject(t4)));
            });
          }
          getAudioMixingPlayedTime() {
            var e2, t2;
            return (null === (e2 = this.audio.webAudio) || void 0 === e2 ? void 0 : e2.mixAudioConf) && this.audio.webAudio.mixAudioConf.audioSource ? (this.stream.client.apiFrequencyControl({ name: "getAudioMixingCurrentPosition", code: 0, param: JSON.stringify({ playTime: null === (t2 = this.audio.webAudio.getAudioMixingPlayedTime()) || void 0 === t2 ? void 0 : t2.playedTime }, null, " ") }), this.audio.webAudio.getAudioMixingPlayedTime()) : (this.logger.log("getAudioMixingCurrentPosition() 当前没有开启伴音"), Promise.reject(new h.default({ code: u.default.AUDIO_MIX_NOT_STATE_ERROR, message: "getAudioMixingCurrentPosition() 当前没有开启伴音" })));
          }
          getAudioMixingTotalTime() {
            var e2, t2;
            return (null === (e2 = this.audio.webAudio) || void 0 === e2 ? void 0 : e2.mixAudioConf) && this.audio.webAudio.mixAudioConf.audioSource ? (this.stream.client.apiFrequencyControl({ name: "getAudioMixingDuration", code: 0, param: JSON.stringify({ totalTime: null === (t2 = this.audio.webAudio.getAudioMixingTotalTime()) || void 0 === t2 ? void 0 : t2.totalTime }, null, " ") }), this.audio.webAudio.getAudioMixingTotalTime()) : (this.logger.log("getAudioMixingDuration() 当前没有开启伴音"), Promise.reject(new h.default({ code: u.default.AUDIO_MIX_NOT_STATE_ERROR, message: "getAudioMixingDuration() 当前没有开启伴音" })));
          }
          isMixAuido() {
            return !!(this.audio.webAudio && this.audio.webAudio.mixAudioConf && this.audio.webAudio.mixAudioConf.audioSource);
          }
          _initSoundIfNotExists(e2, t2) {
            this.audio.mixAudioConf.sounds[e2] || (this.audio.mixAudioConf.sounds[e2] = { soundId: e2, state: "UNSTART", filePath: t2 || "", volume: 100, sourceNode: null, gainNode: null, cycle: 1, playStartTime: 0, playOverTime: 0, pauseTime: 0, startTime: 0, totalTime: 0, options: {} }), t2 && (this.audio.mixAudioConf.sounds[e2].filePath = t2);
          }
          async playEffect(e2, t2) {
            const { soundId: i2, filePath: r2, cycle: s2 = 1 } = e2, a2 = { tag: "Stream.playEffect:filePath", value: r2 };
            g.checkExists(a2);
            const o2 = { tag: "Stream.playEffect:soundId", value: i2, min: 1, max: 1e4 };
            g.isExistOptions(o2).result && g.checkValidInteger(o2);
            const n2 = { tag: "Stream.playEffect:cycle", value: s2, min: 1, max: 1e4 };
            if (g.isExistOptions(n2).result && g.checkValidInteger(n2), this._initSoundIfNotExists(i2, r2), this.audio.audioRoutingEnabled || this.enableAudioRouting(), 0 === this.getAudioInputTracks().length || !this.stream.pubStatus.audio.audio) return Promise.reject(new h.default({ code: u.default.AUDIO_EFFECT_NO_AUDIO, message: "playEffect() 当前没有开启麦克风，无法使用音效功能" }));
            if (!this.audio.webAudio || !this.audio.webAudio.context) return this.logger.log("playEffect() 浏览器不支持"), Promise.reject(new h.default({ code: u.default.AUDIO_EFFECT_NO_SUPPORT, message: "playEffect() 当前浏览器不支持音效功能" }));
            if (this.audio.mixAudioConf.sounds[i2] && ("STARTING" === this.audio.mixAudioConf.sounds[i2].state || "PLAYED" === this.audio.mixAudioConf.sounds[i2].state || "PAUSED" === this.audio.mixAudioConf.sounds[i2].state) && (this.logger.log(`pauseEffect: 该音效文件正处于: ${this.audio.mixAudioConf.sounds[i2].state} 状态`), void 0 === t2)) return Promise.reject(new h.default({ code: u.default.AUDIO_EFFECT_ERROR, message: "playEffect() playStartTime 异常" }));
            this.audio.mixAudioConf.sounds[i2].state = "STARTING", this.audio.mixAudioConf.audioBuffer[r2] ? this.logger.log("playEffect: 已经 load 音效文件") : (this.logger.log("playEffect, 先 load 音效文件"), await this.preloadEffect(i2, r2));
            try {
              const a3 = this.audio.webAudio.createAudioBufferSource(this.audio.mixAudioConf.audioBuffer[r2]);
              this.audio.mixAudioConf.sounds[i2].sourceNode = a3.sourceNode, a3 && a3.sourceNode && (a3.sourceNode.onended = (e3) => {
                this.stopEffect(i2);
              }), this.audio.mixAudioConf.sounds[i2].gainNode = a3.gainNode, this.audio.mixAudioConf.sounds[i2].totalTime = this.audio.mixAudioConf.audioBuffer[r2] && this.audio.mixAudioConf.audioBuffer[r2].duration, this.audio.mixAudioConf.sounds[i2].cycle = s2;
              const o3 = this.audio.mixAudioConf.audioBuffer[r2] && this.audio.mixAudioConf.audioBuffer[r2].duration;
              this.audio.mixAudioConf.sounds[i2].playOverTime = o3, s2 > 1 && (this.audio.mixAudioConf.sounds[i2].playOverTime = s2 * o3 - this.audio.mixAudioConf.sounds[i2].playStartTime), this.audio.mixAudioConf.sounds[i2].playStartTime = t2 || 0, this.audio.webAudio.startAudioEffectMix(this.audio.mixAudioConf.sounds[i2]), this.audio.mixAudioConf.sounds[i2].state = "PLAYED", this.audio.mixAudioConf.sounds[i2].startTime = Date.now(), this.stream.client.apiFrequencyControl({ name: "playEffect", code: 0, param: JSON.stringify(e2, null, " ") });
            } catch (e3) {
            }
          }
          async stopEffect(e2) {
            var t2;
            const i2 = { tag: "Stream.stopEffect:soundId", value: e2 };
            let r2, s2;
            if (g.isExistOptions(i2).result && g.checkValidInteger(i2), this.audio.mixAudioConf.sounds[e2] || (s2 = "stopEffect() soundId找不到对应的音效文件", r2 = u.default.AUDIO_EFFECT_FILE_LOST_ERROR), r2) throw new h.default({ code: r2, message: s2 });
            null === (t2 = this.audio.webAudio) || void 0 === t2 || t2.stopAudioEffectMix(this.audio.mixAudioConf.sounds[e2]), this.audio.mixAudioConf.sounds[e2].state = "STOPED", this._audioFilePlaybackCompletedEvent(), this.stream.client.apiFrequencyControl({ name: "stopEffect", code: 0, param: JSON.stringify(e2, null, " ") });
          }
          async pauseEffect(e2) {
            const t2 = { tag: "Stream.pauseEffect:soundId", value: e2 };
            let i2, r2;
            if (g.isExistOptions(t2).result && g.checkValidInteger(t2), this.audio.mixAudioConf.sounds[e2]) {
              if ("PAUSED" === this.audio.mixAudioConf.sounds[e2].state) return void this.logger.log("pauseEffect: 已经暂停");
              "PLAYED" !== this.audio.mixAudioConf.sounds[e2].state && (this.logger.log("pauseEffect: 当前没有开启该音效"), r2 = "pauseEffect() 当前没有开启该音效", i2 = u.default.AUDIO_EFFECT_NOT_STATE_ERROR);
            } else r2 = "pauseEffect() soundId找不到对应的音效文件", i2 = u.default.AUDIO_EFFECT_FILE_LOST_ERROR;
            if (i2) throw new h.default({ code: i2, message: r2 });
            if (!this.audio.webAudio) return;
            this.audio.webAudio.stopAudioEffectMix(this.audio.mixAudioConf.sounds[e2]), this.audio.mixAudioConf.sounds[e2].pauseTime = Date.now(), this.audio.mixAudioConf.sounds[e2].state = "PAUSED";
            let s2 = (this.audio.mixAudioConf.sounds[e2].pauseTime - this.audio.mixAudioConf.sounds[e2].startTime) / 1e3 + this.audio.mixAudioConf.sounds[e2].playStartTime;
            this.logger.log("pauseEffect 已经播放的时间: ", s2), s2 > this.audio.mixAudioConf.sounds[e2].totalTime && (s2 %= this.audio.mixAudioConf.sounds[e2].totalTime), this.logger.log("pauseEffect 暂停位置: ", s2), this.stream.client.apiFrequencyControl({ name: "pauseEffect", code: 0, param: JSON.stringify(e2, null, " ") });
          }
          async resumeEffect(e2) {
            const t2 = { tag: "Stream.resumeEffect:soundId", value: e2 };
            let i2, r2;
            if (g.isExistOptions(t2).result && g.checkValidInteger(t2), this.audio.mixAudioConf.sounds[e2] ? "PAUSED" !== this.audio.mixAudioConf.sounds[e2].state && (r2 = "resumeEffect() 当前没有暂停该音效文件", i2 = u.default.AUDIO_EFFECT_NOT_PAUSE) : (r2 = "resumeEffect() soundId找不到对应的音效文件", i2 = u.default.AUDIO_EFFECT_FILE_LOST_ERROR), i2) throw new h.default({ code: i2, message: r2 });
            if (!this.audio.webAudio) return;
            let s2 = (this.audio.mixAudioConf.sounds[e2].pauseTime - this.audio.mixAudioConf.sounds[e2].startTime) / 1e3 + this.audio.mixAudioConf.sounds[e2].playStartTime;
            if (this.logger.log("resumeEffect 已经播放的时间: ", s2), s2 > this.audio.mixAudioConf.sounds[e2].totalTime) {
              const t3 = Math.floor(s2 / this.audio.mixAudioConf.sounds[e2].totalTime);
              this.logger.log("播放过的圈数 playedCycle: ", t3), s2 %= this.audio.mixAudioConf.sounds[e2].totalTime, this.audio.mixAudioConf.sounds[e2].cycle = this.audio.mixAudioConf.sounds[e2].cycle - t3;
            }
            this.audio.mixAudioConf.sounds[e2].playOverTime = this.audio.mixAudioConf.sounds[e2].totalTime, this.audio.mixAudioConf.sounds[e2].cycle > 1 && (this.audio.mixAudioConf.sounds[e2].playOverTime = this.audio.mixAudioConf.sounds[e2].cycle * this.audio.mixAudioConf.sounds[e2].totalTime - this.audio.mixAudioConf.sounds[e2].playStartTime), s2 > this.audio.mixAudioConf.sounds[e2].totalTime && (s2 %= this.audio.mixAudioConf.sounds[e2].totalTime), this.audio.mixAudioConf.sounds[e2].playStartTime = s2, this.logger.log("resumeEffect 回复重置的时间点：", s2), this.playEffect({ soundId: e2, filePath: this.audio.mixAudioConf.sounds[e2].filePath, cycle: this.audio.mixAudioConf.sounds[e2].cycle }, s2), this.audio.mixAudioConf.sounds[e2].state = "PLAYED", this.audio.mixAudioConf.sounds[e2].startTime = Date.now(), this.stream.client.apiFrequencyControl({ name: "resumeEffect", code: 0, param: JSON.stringify(e2, null, " ") });
          }
          async setVolumeOfEffect(e2, t2) {
            var i2;
            const r2 = { tag: "Stream.setVolumeOfEffect:soundId", value: e2, min: 1 };
            if (g.isExistOptions(r2).result && g.checkValidInteger(r2), !this.audio.mixAudioConf.sounds[e2]) throw new h.default({ code: u.default.AUDIO_EFFECT_FILE_LOST_ERROR, message: "resumeEffect() soundId找不到对应的音效文件" });
            const s2 = { tag: "Stream.setVolumeOfEffect:volume", value: t2, min: 0, max: 100 };
            g.isExistOptions(s2).result && g.checkValidInteger(s2), this.logger.log(`setVolumeOfEffect 设置 ${e2} 音效文件的音量: ${t2}`), this._initSoundIfNotExists(e2);
            const a2 = null === (i2 = this.audio.mixAudioConf.sounds[e2]) || void 0 === i2 ? void 0 : i2.gainNode;
            a2 ? a2.gain.value = t2 / 100 : this.logger.log("setVolumeOfEffect: no gainNode"), this.audio.mixAudioConf.sounds[e2].volume = t2, this.stream.client.apiFrequencyControl({ name: "setVolumeOfEffect", code: 0, param: JSON.stringify({ soundId: e2, volume: t2 }, null, " ") });
          }
          async preloadEffect(e2, t2) {
            const i2 = { tag: "Stream.preloadEffect:filePath", value: t2 };
            g.checkExists(i2);
            const r2 = { tag: "Stream.preloadEffect:soundId", value: e2 };
            if (g.isExistOptions(r2).result && g.checkValidInteger(r2), this.logger.log(`preloadEffect 设置soundId: ${e2}, 音效文件的filePath: ${t2}`), this._initSoundIfNotExists(e2, t2), this.audio.audioRoutingEnabled || this.enableAudioRouting(), this.audio.mixAudioConf.audioBuffer[t2]) this.logger.log("preloadEffect: 已经 load 音效文件");
            else try {
              await this.loadAudioBuffer(t2), this.stream.client.apiFrequencyControl({ name: "preloadEffect", code: 0, param: JSON.stringify({ soundId: e2, filePath: t2 }, null, " ") });
            } catch (e3) {
              throw this.logger.error("preloadEffect 错误: ", e3.name, e3.message), this.stream.client.apiFrequencyControl({ name: "preloadEffect", code: -1, param: JSON.stringify({ reason: e3.message }, null, " ") }), e3;
            }
          }
          async unloadEffect(e2) {
            const t2 = { tag: "Stream.unloadEffect:soundId", value: e2, min: 1 };
            return g.isExistOptions(t2).result && g.checkValidInteger(t2), this.logger.log(`unloadEffect() ${e2} 音效文件`), this.audio.mixAudioConf.sounds[e2] ? "UNSTART" !== this.audio.mixAudioConf.sounds[e2].state && "STOPED" !== this.audio.mixAudioConf.sounds[e2].state ? (this.logger.log("unloadEffect() 该音效文件正在播放"), Promise.reject(new h.default({ code: u.default.AUDIO_EFFECT_PLAY_ALREADY, message: "unloadEffect() 该音效文件正在播放" }))) : (delete this.audio.mixAudioConf.audioBuffer[this.audio.mixAudioConf.sounds[e2].filePath], delete this.audio.mixAudioConf.sounds[e2], void this.stream.client.apiFrequencyControl({ name: "unloadEffect", code: 0, param: JSON.stringify({ soundId: e2 }, null, " ") })) : (this.logger.log("unloadEffect() 没有该音效文件"), Promise.reject(new h.default({ code: u.default.AUDIO_EFFECT_FILE_LOST_ERROR, message: "unloadEffect() soundId找不到对应的音效文件" })));
          }
          getEffectsVolume() {
            this.logger.log("getEffectsVolume()");
            const e2 = [];
            return Object.values(this.audio.mixAudioConf.sounds).forEach((t2) => {
              e2.push({ soundId: t2.soundId, volume: t2.volume });
            }), this.stream.client.apiFrequencyControl({ name: "getEffectsVolume", code: 0, param: JSON.stringify(e2, null, 2) }), e2;
          }
          setEffectsVolume(e2) {
            const t2 = { tag: "Stream.setEffectsVolume:volume", value: e2, min: 0, max: 100 };
            g.isExistOptions(t2).result && g.checkValidInteger(t2), this.logger.log("setEffectsVolume(), 设置音量: " + e2), Object.values(this.audio.mixAudioConf.sounds).forEach((t3) => {
              this.setVolumeOfEffect(t3.soundId, e2);
            }), this.stream.client.apiFrequencyControl({ name: "setEffectsVolume", code: 0, param: JSON.stringify({ volume: e2 }, null, 2) });
          }
          async stopAllEffects() {
            this.logger.log("stopAllEffects()"), Object.values(this.audio.mixAudioConf.sounds).forEach((e2) => {
              "PLAYED" !== e2.state && "PAUSED" !== e2.state || this.stopEffect(e2.soundId);
            }), this.stream.client.apiFrequencyControl({ name: "stopAllEffects", code: 0, param: JSON.stringify("stopAllEffects", null, 2) });
          }
          async pauseAllEffects() {
            this.logger.log("pauseAllEffects()"), Object.values(this.audio.mixAudioConf.sounds).forEach((e2) => {
              "PLAYED" === e2.state && this.pauseEffect(e2.soundId);
            }), this.stream.client.apiFrequencyControl({ name: "pauseAllEffects", code: 0, param: JSON.stringify("pauseAllEffects", null, 2) });
          }
          async resumeAllEffects() {
            this.logger.log("resumeAllEffects()"), Object.values(this.audio.mixAudioConf.sounds).forEach((e2) => {
              "PAUSED" === e2.state && this.resumeEffect(e2.soundId);
            }), this.stream.client.apiFrequencyControl({ name: "resumeAllEffects", code: 0, param: JSON.stringify("resumeAllEffects", null, 2) });
          }
          getAudioEffectsTotalTime(e2) {
            const { soundId: t2, filePath: i2, cycle: r2 = 1 } = e2;
            if (!this.audio.mixAudioConf || "{}" === JSON.stringify(this.audio.mixAudioConf.sounds)) return this.logger.log("getAudioEffectsDuration: 当前没有音效文件"), Promise.resolve();
            let s2;
            return this._initSoundIfNotExists(t2, i2), "PLAYED" === this.audio.mixAudioConf.sounds[t2].state && (s2 = this.audio.mixAudioConf.sounds[t2].totalTime), this.stream.client.apiFrequencyControl({ name: "getAudioEffectsDuration", code: 0, param: JSON.stringify({ totalTime: s2 }, null, " ") }), s2;
          }
          getAudioEffectsPlayedTime(e2) {
            const { soundId: t2, filePath: i2, cycle: r2 = 1 } = e2;
            if (!this.audio.mixAudioConf || "{}" === JSON.stringify(this.audio.mixAudioConf.sounds)) return this.logger.log("getAudioEffectsCurrentPosition() 当前没有音效文件"), Promise.resolve();
            this._initSoundIfNotExists(t2, i2);
            let s2 = Date.now();
            "PAUSED" == this.audio.mixAudioConf.sounds[t2].state && (this.logger.log("getAudioEffectsCurrentPosition() 当前是暂停状态"), s2 = this.audio.mixAudioConf.sounds[t2].pauseTime);
            let a2 = (s2 - this.audio.mixAudioConf.sounds[t2].startTime) / 1e3 + this.audio.mixAudioConf.sounds[t2].playStartTime;
            return a2 > this.audio.mixAudioConf.sounds[t2].totalTime && (a2 %= this.audio.mixAudioConf.sounds[t2].totalTime), this.stream.client.apiFrequencyControl({ name: "getAudioEffectsCurrentPosition", code: 0, param: JSON.stringify({ playTime: a2 }, null, " ") }), { playedTime: a2 };
          }
          loadAudioBuffer(e2) {
            return l.ajax({ url: e2, type: "GET", dataType: "arraybuffer" }).then((t2) => (this.logger.log("loadAudioBuffer 加载 audio file 成功"), new Promise((i2, r2) => {
              var s2, a2;
              null === (a2 = null === (s2 = this.audio.webAudio) || void 0 === s2 ? void 0 : s2.context) || void 0 === a2 || a2.decodeAudioData(t2, (t3) => {
                this.logger.log("loadAudioBuffer audio file 解码成功"), this.audio.mixAudioConf.audioBuffer[e2] = t3, i2(t3);
              }, (e3) => {
                this.logger.log("loadAudioBuffer 云端音乐解码失败：", e3.message), r2(new h.default({ code: u.default.AUDIO_EFFECT_FILE_ERROR, message: `loadAudioBuffer: 云端音乐解码失败: ${e3.name} ${e3.message}` }));
              });
            }))).catch((e3) => (this.logger.log("loadAudioBuffer 加载云端音乐失败: ", e3), Promise.reject(new h.default({ code: u.default.AUDIO_EFFECT_FILE_ERROR, message: `loadAudioBuffer: 加载云端音乐失败: ${e3.name} ${e3.message}` }))));
          }
          getAudioInputTracks() {
            var e2, t2;
            let i2 = [];
            return "live" === (null === (e2 = this.audio.audioSource) || void 0 === e2 ? void 0 : e2.readyState) && i2.push(this.audio.audioSource), "live" === (null === (t2 = this.audio.micTrack) || void 0 === t2 ? void 0 : t2.readyState) && i2.push(this.audio.micTrack), i2;
          }
          getAudioSlaveInputTracks() {
            var e2, t2;
            let i2 = [];
            return "live" === (null === (e2 = this.screenAudio.screenAudioTrack) || void 0 === e2 ? void 0 : e2.readyState) && i2.push(this.screenAudio.screenAudioTrack), "live" === (null === (t2 = this.screenAudio.screenAudioSource) || void 0 === t2 ? void 0 : t2.readyState) && i2.push(this.screenAudio.screenAudioSource), i2;
          }
          enableAudioRouting() {
            if (this.audio.webAudio && this.audio.webAudio.destination) {
              this.audio.audioRoutingEnabled = true;
              const e2 = this.audio.webAudio.destination.stream.getAudioTracks()[0];
              this.logger.log("enableAudioRouting: ", e2.label);
              const t2 = this.audio.audioStream.getAudioTracks()[0];
              if (t2 && (e2.enabled = t2.enabled, t2.enabled = true), m.emptyStreamWith(this.audio.audioStream, e2), this.stream.isRemote && this.audio.micTrack) {
                if (!this.audio.audioDom) {
                  const e3 = new MediaStream(), t3 = document.createElement("audio");
                  e3.addTrack(this.audio.micTrack), t3.srcObject = e3, this.audio.audioDom = t3;
                }
                this.audio.audioDom.volume = 1e-4, this.audio.audioDom.volume = 0, this.audio.audioDom.muted = true;
              }
              this.stream.audioLevelHelper && this.stream.audioLevelHelper.updateStream(this.audio.audioStream), this.updateAudioSender(e2);
            } else this.logger.log("enableAudioRouting: 已替换为Destination");
          }
          disableAudioRouting() {
            const e2 = this.getAudioInputTracks();
            if (e2.length) {
              1 === e2.length ? this.logger.log("disableAudioRouting: ", e2[0].label) : this.logger.warn("disableAudioRouting: 仍然有多于一个输入", ...e2);
              const t2 = this.audio.audioStream.getAudioTracks()[0];
              m.emptyStreamWith(this.audio.audioStream, e2[0]), e2[0].enabled = t2.enabled, t2.enabled = true, this.updateAudioSender(e2[0]);
            } else this.logger.log("disableAudioRouting quiet."), m.emptyStreamWith(this.audio.audioStream, null);
            this.audio.audioRoutingEnabled = false;
          }
          updateAudioSender(e2) {
            var t2, i2, r2, s2, a2, o2, n2, d2, c2, l2, u2, h2, p2, m2, g2, f2, v2;
            if (this.stream.isRemote) this.logger.warn("updateAudioSender only for localStream");
            else if (null === (i2 = null === (t2 = this.stream.getAdapterRef()) || void 0 === t2 ? void 0 : t2._mediasoup) || void 0 === i2 ? void 0 : i2._micProducer) {
              if (null === (a2 = null === (s2 = null === (r2 = this.stream.getAdapterRef()) || void 0 === r2 ? void 0 : r2._mediasoup) || void 0 === s2 ? void 0 : s2._micProducer) || void 0 === a2 ? void 0 : a2._rtpSender) this.logger.info("updateAudioSender: 替换当前_micProducer的track", e2.label), null === (c2 = null === (d2 = null === (n2 = null === (o2 = this.stream.getAdapterRef()) || void 0 === o2 ? void 0 : o2._mediasoup) || void 0 === n2 ? void 0 : n2._micProducer) || void 0 === d2 ? void 0 : d2._rtpSender) || void 0 === c2 || c2.replaceTrack(e2);
              else if (null === (p2 = null === (h2 = null === (u2 = null === (l2 = this.stream.getAdapterRef()) || void 0 === l2 ? void 0 : l2._mediasoup) || void 0 === u2 ? void 0 : u2._sendTransport) || void 0 === h2 ? void 0 : h2.handler) || void 0 === p2 ? void 0 : p2._pc) {
                const t3 = null === (f2 = null === (g2 = null === (m2 = this.stream.getAdapterRef()) || void 0 === m2 ? void 0 : m2._mediasoup) || void 0 === g2 ? void 0 : g2._sendTransport) || void 0 === f2 ? void 0 : f2.handler._pc.audioSender;
                t3 && (this.logger.info("updateAudioSender: 替换audioSender", null === (v2 = null == t3 ? void 0 : t3.track) || void 0 === v2 ? void 0 : v2.label), t3.replaceTrack(e2));
              }
            }
          }
          enablePreProcessing(e2, t2) {
            b.enablePreProcessing(this, e2, t2);
          }
          disablePreProcessing(e2, t2 = false) {
            b.disablePreProcessing(this, e2, t2);
          }
          canDisablePreProcessing(e2) {
            return b.canDisablePreProcessing(this, e2);
          }
          getPreprocessingStats(e2 = "video") {
            var t2;
            const i2 = null === (t2 = this[e2].preProcessing) || void 0 === t2 ? void 0 : t2.history;
            if (!(null == i2 ? void 0 : i2.length)) return null;
            const r2 = i2[i2.length - 1].endTs - i2[0].startTs, s2 = { total: 0 };
            for (let e3 = 0; e3 < i2.length; e3++) {
              s2.total += i2[e3].endTs - i2[e3].startTs;
              for (let t3 of i2[e3].handlerTs) t3.spent > 0 && (s2[t3.name] || (s2[t3.name] = 0), s2[t3.name] += t3.spent);
            }
            return { fps: 1e3 * i2.length / r2, load: s2.total / r2, delay: s2.total / i2.length, spent: s2 };
          }
          replaceConstraint(e2, t2) {
            var i2, r2, s2, a2, o2, n2;
            (null == e2 ? void 0 : e2.video) && ("safari16_screen" === R.getParameters().replaceIdealConstraint && v.IS_SAFARI && v.SAFARI_MAJOR_VERSION && v.SAFARI_MAJOR_VERSION >= 16 && "screen" === t2 || "all" === R.getParameters().replaceIdealConstraint) && ((null === (r2 = null === (i2 = null == e2 ? void 0 : e2.video) || void 0 === i2 ? void 0 : i2.width) || void 0 === r2 ? void 0 : r2.ideal) && (e2.video.width.max = e2.video.width.ideal, delete e2.video.width.ideal), (null === (a2 = null === (s2 = null == e2 ? void 0 : e2.video) || void 0 === s2 ? void 0 : s2.height) || void 0 === a2 ? void 0 : a2.ideal) && (e2.video.height.max = e2.video.height.ideal, delete e2.video.height.ideal), (null === (n2 = null === (o2 = null == e2 ? void 0 : e2.video) || void 0 === o2 ? void 0 : o2.frameRate) || void 0 === n2 ? void 0 : n2.ideal) && (e2.video.frameRate.max = e2.video.frameRate.ideal, delete e2.video.frameRate.ideal));
          }
          destroy() {
            this.logger.log("清除 meida"), this._reset();
          }
        }
        t.MediaHelper = I;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.StageBase = void 0;
        t.StageBase = class {
          constructor(e2) {
            this.enabled = false, this.node = null, this.state = "UNINIT", this.context = e2;
          }
          isTransparent() {
            return false;
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Play = void 0;
        const s = i(3), a = i(48), o = r(i(6)), n = r(i(8)), d = i(150), c = i(42), l = i(1), u = i(291), h = i(292), p = i(85), m = i(71), g = i(69);
        class f extends s.EventEmitter {
          constructor(e2) {
            super(), this.snapshotIndex = 0, this.sinkId = null, this.audio = { normalizedVolume: 1, dom: null }, this.audioSlave = { normalizedVolume: 1, dom: null }, this.mask = { enabled: false }, this.stream = e2.stream, this.logger = e2.stream.logger.getChild(() => {
              var e3, t2;
              let i2 = "player";
              return (null === (e3 = this.audio.dom) || void 0 === e3 ? void 0 : e3.paused) && (i2 += " audio_paused"), (null === (t2 = this.audioSlave.dom) || void 0 === t2 ? void 0 : t2.paused) && (i2 += " audioSlave_paused"), i2;
            }), this.video = { dom: null, containerDom: null, view: null, size: { width: 0, height: 0 }, canvasWatermark: u.createCanvasWatermarkControl(this.logger), encoderWatermark: h.createEncoderWatermarkControl(this.logger), frameData: { canvas: null, context: null }, renderMode: { width: 0, height: 0, cut: false } }, this.screen = { dom: null, containerDom: null, view: null, size: { width: 0, height: 0 }, canvasWatermark: u.createCanvasWatermarkControl(this.logger), encoderWatermark: h.createEncoderWatermarkControl(this.logger), frameData: { canvas: null, context: null }, renderMode: { width: 0, height: 0, cut: false } }, this.videoThird = { dom: null, containerDom: null, view: null, size: { width: 0, height: 0 }, canvasWatermark: u.createCanvasWatermarkControl(this.logger), encoderWatermark: h.createEncoderWatermarkControl(this.logger), frameData: { canvas: null, context: null }, renderMode: { width: 0, height: 0, cut: false } }, this.videoFourth = { dom: null, containerDom: null, view: null, size: { width: 0, height: 0 }, canvasWatermark: u.createCanvasWatermarkControl(this.logger), encoderWatermark: h.createEncoderWatermarkControl(this.logger), frameData: { canvas: null, context: null }, renderMode: { width: 0, height: 0, cut: false } };
          }
          _initDomAndView(e2) {
            const t2 = this[e2];
            if (t2.view) {
              if (!t2.containerDom) {
                const i2 = document.createElement("div");
                t2.containerDom = i2, t2.containerDom.className = `nertc-${e2}-container nertc-${e2}-container-${this.stream.isRemote ? "remote" : "local"}`, i2.style.overflow = "hidden", i2.style.position = "relative", i2.style.width = t2.view.clientWidth + "px", i2.style.height = t2.view.clientHeight + "px", i2.style.display = "inline-block";
              }
              if (!t2.dom) {
                const i2 = document.createElement("video");
                t2.dom = i2, i2.style.position = "absolute", i2.style.left = "50%", i2.style.top = "50%", i2.style.transform = "translate(-50%,-50%)", i2.setAttribute("x-webkit-airplay", "x-webkit-airplay"), i2.setAttribute("playsinline", "playsinline"), i2.setAttribute("webkit-playsinline", "webkit-playsinline"), i2.preload = "auto", i2.dataset.uid = "" + this.stream.getId(), i2.autoplay = true, i2.muted = true, t2.size.width = 0, t2.size.height = 0, l.getParameters().controlOnPaused && (i2.addEventListener("pause", this.showControlIfVideoPause.bind(this)), i2.addEventListener("canplay", this.handleVideoScreenPlay.bind(this)), i2.addEventListener("click", this.handleVideoScreenClick.bind(this))), i2.addEventListener("resize", (r2) => {
                  if (!this[e2].dom || this[e2].dom !== i2 || this[e2].dom !== r2.target) return;
                  const s2 = i2.videoWidth, a2 = i2.videoHeight;
                  s2 > 2 && a2 > 2 && this.stream.isRemote && this.stream.client.adapterRef.state.videoResizeTime < this.stream.client.adapterRef.state.signalJoinSuccessTime && (this.stream.client.adapterRef.state.videoResizeTime = Date.now()), s2 === t2.size.width && a2 === t2.size.height || (this.logger.log(`[Play] 视频分辨率发生变化：${e2} ${t2.size.width}x${t2.size.height} => ${s2}x${a2}。当前父节点：${c.getDomInfo(t2.view)}${t2.size.width < 4 ? " 首帧渲染" : ""}`), this.stream.safeEmit("video-resize", { uid: this.stream.getId(), mediaType: e2, width: s2, height: a2 }), s2 > a2 && t2.size.width > t2.size.height || s2 < a2 && t2.size.width < t2.size.height || this.setRender(e2), t2.size.width = s2, t2.size.height = a2);
                });
              }
              t2.containerDom == t2.dom.parentNode ? this.logger.log("[Play] initVideoNode: 节点已挂载，请勿重复挂载") : (t2.containerDom.appendChild(t2.dom), this.logger.log("[Play] initVideoNode " + e2)), t2.view == t2.containerDom.parentNode ? this.logger.log("[Play] mountVideoToDom: 节点已挂载，请勿重复挂载") : (this.logger.log("[Play] mountVideoToDom"), t2.view.appendChild(t2.containerDom), this.logger.log("[Play] 视频主流dom节点挂载成功。父节点：" + c.getDomInfo(t2.view)), t2.canvasWatermark.watermarks.length ? t2.canvasWatermark.start(t2.containerDom) : t2.canvasWatermark.div = t2.containerDom);
            }
          }
          showControlIfVideoPause() {
            a.MediaTypeList.forEach((e2) => {
              const t2 = this[e2].dom;
              (null == t2 ? void 0 : t2.paused) && (this.logger.log("[Play] 可能遇到了播放问题, 尝试主动恢复播放 " + e2), t2.play().then(() => {
                this.logger.log(`[Play] 主动恢复播放: ${e2} 成功`);
              }).catch((t3) => {
                this.logger.error(`[Play] 主动恢复播放 ${e2} 出现问题:`, t3.name, t3.message);
              }));
            });
          }
          handleVideoScreenClick() {
            a.MediaTypeList.forEach((e2) => {
              const t2 = this[e2].dom;
              (null == t2 ? void 0 : t2.paused) && (this.logger.log("[Play] 视频侦测到点击动作，尝试恢复播放:" + e2), t2.play());
            });
          }
          handleVideoScreenPlay() {
            a.MediaTypeList.forEach((e2) => {
              const t2 = this[e2].dom;
              t2 && false === (null == t2 ? void 0 : t2.paused) && this.logger.log(`[Play] 视频侦测到可以播放，当前 mediaType： ${e2}，当前播放状态 played: ${t2.played.length}, readyState: ${t2.readyState}, currentTime: ${t2.currentTime}`);
            });
          }
          isPlaying(e2) {
            let t2 = this[e2].dom;
            if (!t2) return false;
            if (!t2.srcObject) return false;
            if (t2.paused) return false;
            if (4 !== t2.readyState) return false;
            {
              let i2 = t2.srcObject.getTracks()[0];
              if (!i2) return false;
              if (!i2.enabled) return false;
              if (i2.muted) return false;
              if ("audio" === e2 || "audioSlave" === e2) {
                if (t2.muted) return false;
                if (0 === t2.volume) return false;
              }
            }
            return true;
          }
          canPlay(e2) {
            const t2 = { result: false, reason: "" }, i2 = this.stream.mediaHelper.getTrackByMediaType(e2), r2 = this[e2].dom;
            return i2 ? "ended" === i2.readyState ? t2.reason = "ENDED" : i2.muted || !i2.enabled ? t2.reason = "MUTED" : r2 && r2.srcObject ? r2.paused ? "audio" === i2.kind ? t2.result = true : t2.reason = "PAUSED" : t2.reason = "PLAYING" : t2.result = true : this.stream.isRemote ? this.stream.pubStatus[e2].producerId ? this.stream.pubStatus[e2].consumerId ? "end" !== this.stream.pubStatus[e2].consumerStatus ? t2.reason = "CONSUME_START" : t2.reason = "INVALID_STATE" : t2.reason = "NOT_SUBSCRIBED" : t2.reason = "NOT_PUBLISHED" : t2.reason = "NOT_OPENED", t2;
          }
          async resume() {
            const e2 = [];
            a.MediaTypeList.forEach((t2) => {
              const i2 = this[t2].dom;
              if (null == i2 ? void 0 : i2.paused) {
                const r2 = i2.play();
                e2.push(r2), r2.then(() => {
                  var e3;
                  this.logger.log(`[Resume] 恢复播放: ${t2} 成功`), this.stream.client.apiFrequencyControl({ name: "resume", code: 0, param: JSON.stringify({ streamID: this.stream.stringStreamID, isRemote: true, mediaType: t2, muted: i2.muted, active: null === (e3 = i2.srcObject) || void 0 === e3 ? void 0 : e3.active }) });
                }), r2.catch((e3) => {
                  if (this.logger.error(`[Resume] 恢复播放 ${t2} 出现问题:`, e3.name, e3.message), "notAllowedError" === e3.name || "NotAllowedError" === e3.name) throw new n.default({ code: o.default.AUTO_PLAY_NOT_ALLOWED, url: "https://doc.yunxin.163.com/docs/jcyOTA0ODM/jM3NDE0NTI?platformId=50082", message: "resume: 浏览器自动播放受限: " + e3.name });
                });
              }
            });
            try {
              await Promise.all(e2);
            } catch (e3) {
            }
          }
          updatePlaybackVolume() {
            a.MediaTypeListAudio.forEach((e2) => {
              const t2 = this[e2].dom;
              if (t2) {
                let i2;
                i2 = this.stream.isRemote ? this.stream.client.adapterRef.nomalizedPlaybackVolume * this[e2].normalizedVolume : this[e2].normalizedVolume, Math.abs(t2.volume - i2) > 0.01 && (this.logger.log(`updatePlaybackVolume ${e2} ${t2.volume} => ${i2} ( ${this.stream.client.adapterRef.nomalizedPlaybackVolume} * ${this[e2].normalizedVolume})`), t2.volume = i2);
              }
            });
          }
          async playAudioStream(e2, t2, i2) {
            var r2;
            const s2 = this[e2];
            s2.dom || (s2.dom = document.createElement("audio"), s2.dom.addEventListener("pause", (e3) => {
              this.logger.log(`[Play] 音频侦测到pause，当前播放状态 played: ${a2.played.length}, readyState: ${a2.readyState}, currentTime: ${a2.currentTime}`);
            }), s2.dom.addEventListener("canplay", (e3) => {
              this.logger.log(`[Play] 音频侦测到canplay，当前播放状态 played: ${a2.played.length}, readyState: ${a2.readyState}, currentTime: ${a2.currentTime}`);
            }));
            const a2 = s2.dom;
            if (a2.muted = "boolean" == typeof i2 && i2, a2.srcObject = t2, a2.autoplay = true, this.updatePlaybackVolume(), this.sinkId && void 0 !== a2.sinkId) {
              this.logger.log(`[Play ${e2}] 音频尝试使用输出设备`, this.sinkId);
              try {
                await a2.setSinkId(this.sinkId), this.logger.log(`[Play] ${e2} 音频使用输出设备成功`, this.sinkId);
              } catch (e3) {
                this.logger.error("[Play] 音频输出设备切换失败", e3.name, e3.message, e3);
              }
            }
            try {
              const i3 = t2.getTracks()[0];
              this.logger.log(`[Play] 音频播放开始, 当前音频track状态 enabled: ${i3.enabled}, muted: ${i3.muted}, name: ${i3.label}`), await this.playDomElement(a2, l.getParameters().playMediaTimeout, e2), this.logger.log(`[Play] 音频播放完成, 当前播放状态 played: ${a2.played.length}, readyState: ${a2.readyState}, currentTime: ${a2.currentTime}`), this.stream.client.updateRecordingAudioStream(), this.stream.client.apiEventReport("setFunction", { name: `set_${e2}_play`, oper: "1", value: JSON.stringify({ code: 0, reason: "", streamUid: this.stream.stringStreamID, isRemote: this.stream.isRemote, muted: a2.muted, active: null === (r2 = a2.srcObject) || void 0 === r2 ? void 0 : r2.active, played: a2.played.length, readyState: a2.readyState, currentTime: a2.currentTime, track: { enabled: i3.enabled, muted: i3.muted, label: i3.label } }, null, " ") });
            } catch (i3) {
              this.logger.warn(`[Play] 音频 ${e2} 播放出现问题: `, i3.name, i3.message);
              const r3 = this.canPlay(e2), s3 = "notAllowedError" === i3.name || "NotAllowedError" === i3.name ? 10347 : o.default[r3.reason];
              if (this.stream.client.apiEventReport("setFunction", { name: `set_${e2}_play`, oper: "1", value: JSON.stringify({ code: s3, reason: `${i3.name} + ${i3.message}`, streamUid: this.stream.stringStreamID, isRemote: this.stream.isRemote, muted: null == a2 ? void 0 : a2.muted, active: null == t2 ? void 0 : t2.active, readyState: null == a2 ? void 0 : a2.readyState }, null, " ") }), "notAllowedError" === i3.name || "NotAllowedError" === i3.name) throw new n.default({ code: o.default.AUTO_PLAY_NOT_ALLOWED, url: "https://doc.yunxin.163.com/docs/jcyOTA0ODM/jM3NDE0NTI?platformId=50082", message: `playStream ${e2}: 浏览器自动播放受限: ${i3.name}` });
            }
          }
          setPlayVolume(e2, t2) {
            this[e2].normalizedVolume = t2, this.updatePlaybackVolume();
          }
          async playVideoStream(e2, t2, i2) {
            var r2, s2, a2, d2;
            this.logger.log(`[Play ${e2}] playVideoStream`);
            const c2 = this[e2];
            if (c2.view && c2.containerDom && c2.view !== i2 && (this.logger.log(`[Play ${e2}] playVideoStream: 更换播放容器: ${c2.view.getAttribute("id")} -> ${i2.getAttribute("id")}`), c2.view = i2, c2.view.appendChild(c2.containerDom)), (null === (r2 = c2.dom) || void 0 === r2 ? void 0 : r2.srcObject) !== t2) {
              c2.view = i2, this._initDomAndView(e2), this.mask.enabled && this.enableMask();
              try {
                const i3 = t2.getVideoTracks()[0];
                if (!i3) return void this.logger.error(`[Play ${e2}] 加载播放视频源失败：没有视频源`);
                {
                  let t3 = "getSettings" in MediaStreamTrack.prototype ? i3.getSettings() : i3.getConstraints();
                  this.logger.log(`[Play] 视频播放${e2}开始, 当前视频track状态 enabled: ${i3.enabled}, muted: ${i3.muted}, name: ${i3.label}, videoSettings: ${JSON.stringify(t3, null, " ")}`);
                }
                const r3 = c2.dom;
                if (!r3) return;
                r3.srcObject = t2, this.stream.isRemote && this.stream.client.adapterRef.state.domVideoAppendTime < this.stream.client.adapterRef.state.signalJoinSuccessTime && (this.stream.client.adapterRef.state.domVideoAppendTime = Date.now()), await this.playDomElement(r3, l.getParameters().playMediaTimeout, e2), this.logger.log(`[Play] 视频播放${e2}完成, 当前播放状态 played: ${r3.played.length}, readyState: ${r3.readyState}, currentTime: ${r3.currentTime}, 分辨率: ${r3.videoWidth}x${r3.videoHeight}，显示宽高: ${r3.offsetWidth}x${r3.offsetHeight}`), this.stream.client.apiEventReport("setFunction", { name: `set_${e2}_play`, oper: "1", value: JSON.stringify({ code: 0, reason: "", streamUid: this.stream.stringStreamID, isRemote: this.stream.isRemote, muted: r3.muted, active: null === (s2 = r3.srcObject) || void 0 === s2 ? void 0 : s2.active, played: r3.played.length, readyState: r3.readyState, currentTime: r3.currentTime, videoWidth: r3.videoWidth, videoHeight: r3.videoHeight, track: { enabled: i3.enabled, muted: i3.muted, label: i3.label } }, null, " ") }), r3.paused && l.getParameters().controlOnPaused && this.showControlIfVideoPause();
              } catch (i3) {
                this.logger.warn(`[Play] 视频播放 ${e2} 出现问题: `, i3.name, i3.message);
                const r3 = this.canPlay(e2), s3 = "notAllowedError" === i3.name || "NotAllowedError" === i3.name ? 10347 : o.default[r3.reason];
                if (this.stream.client.apiEventReport("setFunction", { name: `set_${e2}_play`, oper: "1", value: JSON.stringify({ code: s3, reason: `${i3.name} + ${i3.message}`, streamUid: this.stream.stringStreamID, isRemote: this.stream.isRemote, muted: null === (a2 = null == c2 ? void 0 : c2.dom) || void 0 === a2 ? void 0 : a2.muted, active: null == t2 ? void 0 : t2.active, readyState: null === (d2 = null == c2 ? void 0 : c2.dom) || void 0 === d2 ? void 0 : d2.readyState }, null, " ") }), "notAllowedError" === i3.name || "NotAllowedError" === i3.name) throw new n.default({ code: o.default.AUTO_PLAY_NOT_ALLOWED, url: "https://doc.yunxin.163.com/docs/jcyOTA0ODM/jM3NDE0NTI?platformId=50082", message: "playVideoStream: 浏览器自动播放受限: " + i3.name });
              }
            } else this.logger.log(`[Play ${e2}] playVideoStream: 跳过重复的播放请求`);
          }
          async stopPlayStream(e2) {
            "audio" === e2 || "audioSlave" === e2 ? this._stopPlayAudioStream(e2) : "video" !== e2 && "screen" !== e2 && "videoThird" !== e2 && "videoFourth" !== e2 || this._stopPlayVideoStream(e2);
          }
          async _stopPlayAudioStream(e2) {
            const t2 = this[e2].dom;
            t2 && (t2.muted = true, t2.srcObject = null, this.stream.client.apiEventReport("setFunction", { name: `set_${e2}_play`, oper: "0", value: JSON.stringify({ code: 0, reason: "", streamUid: this.stream.stringStreamID, isRemote: this.stream.isRemote, muted: t2.muted }, null, " ") }));
          }
          async _stopPlayVideoStream(e2) {
            this.logger.log("stopPlayVideoStream 停止播放 " + e2);
            const t2 = this[e2].view, i2 = this[e2].containerDom, r2 = this[e2].dom;
            if (i2 && r2) {
              i2 === r2.parentNode ? (this.logger.log(`清除 ${e2} dom`), i2.removeChild(r2)) : i2.lastChild && (this.logger.log("videoContainerDom 删除子节点"), i2.removeChild(i2.lastChild));
              try {
                r2.remove(), r2.srcObject = null, this[e2].dom = null, this.stream.client.apiEventReport("setFunction", { name: `set_${e2}_play`, oper: "0", value: JSON.stringify({ code: 0, reason: "", streamUid: this.stream.stringStreamID, isRemote: this.stream.isRemote }, null, " ") });
              } catch (t3) {
                this.logger.log("stopPlayVideoStream e: ", t3), this.stream.client.apiEventReport("setFunction", { name: `set_${e2}_play`, oper: "0", value: JSON.stringify({ code: -1, uid: this.stream.stringStreamID, reason: `${t3.name} + ${t3.message}`, isRemote: this.stream.isRemote, streamUid: this.stream.stringStreamID }, null, " ") });
              }
            }
            t2 && i2 && (t2 == i2.parentNode ? (this.logger.log(`清除 ${e2} containerDom`), t2.removeChild(i2)) : t2.lastChild && (this.logger.log(e2 + " View 删除子节点"), t2.removeChild(t2.lastChild), t2.innerHTML = ""), this[e2].containerDom = null, this[e2].view = null);
          }
          setRender(e2, t2) {
            var i2, r2, s2, a2;
            const o2 = this[e2], n2 = o2.containerDom, d2 = o2.dom;
            if (t2 ? (this.logger.log(`[Play ${e2}] setRender() options: ${JSON.stringify(t2)}`), o2.renderMode = Object.assign({}, t2)) : (t2 = o2.renderMode, this.logger.log("[Play] setVideoRender() existing videoRenderMode: " + JSON.stringify(t2))), !n2 || !d2) return;
            if (n2.style.width = t2.width + "px", n2.style.height = t2.height + "px", !t2.cut) return d2.style.height = "100%", void (d2.style.width = "100%");
            d2.videoWidth / d2.videoHeight > t2.width / t2.height ? (d2.style.width = "auto", d2.style.height = "100%") : (d2.style.width = "100%", d2.style.height = "auto"), this.stream.client.apiEventReport("setFunction", { name: "set_render_" + e2, oper: "1", value: JSON.stringify({ result: "success", streamUid: this.stream.stringStreamID, played: d2.played.length, domStyleWidth: d2.style.width, domStyleHeight: d2.style.height, containerDomWidth: null === (r2 = null === (i2 = o2.containerDom) || void 0 === i2 ? void 0 : i2.style) || void 0 === r2 ? void 0 : r2.width, containerDomHeight: null === (a2 = null === (s2 = o2.containerDom) || void 0 === s2 ? void 0 : s2.style) || void 0 === a2 ? void 0 : a2.height }, null, " ") });
          }
          async setAudioOutput(e2) {
            this.logger.log("[Play] setAudioOutput() audioSinkId: ", e2), this.sinkId = e2, this.stream.client.outputDeviceId = e2;
            for (let t2 of a.MediaTypeListAudio) {
              const i2 = this[t2].dom;
              if (i2 && i2.srcObject && void 0 !== i2.sinkId) {
                i2.srcObject.getAudioTracks().length && (await i2.setSinkId(e2), this.logger.log("[Play] setAudioOutput() 设置通话音频输出设备成功"));
              } else this.logger.warn("[Play] setAudioOutput() Browser does not support output device selection.");
            }
          }
          async takeSnapshot(e2, t2, i2) {
            if (this.mask.enabled) return this.logger.warn("takeSnapshot: 目前在打码状态"), null;
            let r2 = new d.RTCCanvas("canvas"), s2 = r2._canvas, a2 = r2._ctx;
            if (!a2 || !s2) throw this.logger.error("takeSnapshot() 浏览器环境不支持"), new n.default({ code: o.default.STREAM_TAKE_SNAPSHOT_NO_CANVAS_ERROR, message: "takeSnapshot() 浏览器环境不支持" });
            const c2 = ["video", "screen", "videoThird", "videoFourth"];
            let l2 = "";
            for (let o2 of c2) {
              if (!e2.mediaType && this[o2].dom || e2.mediaType === o2) {
                const n2 = e2.name || (i2 || this.stream.getId()) + "-" + this.snapshotIndex++;
                a2.fillStyle = "#ffffff";
                const d2 = this[o2].dom;
                if (!d2) return;
                a2.fillRect(0, 0, d2.videoWidth, d2.videoHeight), r2.setSize(d2.videoWidth, d2.videoHeight), a2.drawImage(d2, 0, 0, d2.videoWidth, d2.videoHeight, 0, 0, d2.videoWidth, d2.videoHeight), "download" === t2 ? l2 = await new Promise((e3, t3) => {
                  s2.toBlob((t4) => {
                    this.logger.log("takeSnapshot() 获取到截图的blob: ", t4);
                    let i3 = URL.createObjectURL(t4), r3 = document.createElement("a");
                    document.body.appendChild(r3), r3.style.display = "none", r3.href = i3, r3.download = n2 + ".png", r3.click(), window.URL.revokeObjectURL(i3), e3(n2 + ".png");
                  });
                }) : "base64" === t2 && (l2 = this.getBase64Image(s2));
              }
            }
            return r2.destroy(), l2;
          }
          _initFrameDataCanvas(e2) {
            const t2 = this[e2].frameData;
            return t2.canvas || (this.logger.log("正在初始化 frameData.canvas " + e2), t2.canvas = document.createElement("canvas"), t2.context = p.get2DContext(t2.canvas, { willReadFrequently: true })), t2.context;
          }
          getCurrentFrameData(e2) {
            if ("audio" === e2.mediaType || "audioSlave" === e2.mediaType) return void this.logger.error("getCurrentFrameData: mediaType参数错误");
            if (this.mask.enabled) return this.logger.error("getCurrentFrameData: 当前在打码状态"), null;
            let t2, i2, r2;
            if (r2 = e2.mediaType && "video" !== e2.mediaType ? e2.mediaType : "video", i2 = this[r2].dom, t2 = this[r2].frameData, !i2) return this.logger.error("getCurrentFrameData: Playing Video is not found"), null;
            i2.paused && this.logger.warn("getCurrentFrameData: 目前数据源不在播放状态，截图结果可能不是最新。"), t2.canvas || this._initFrameDataCanvas(r2);
            const s2 = t2.canvas, a2 = t2.context;
            if (!a2 || !s2) throw new n.default({ code: o.default.STREAM_TAKE_SNAPSHOT_NO_CANVAS_ERROR, message: "getCurrentFrameData() 浏览器环境不支持" });
            const d2 = i2.videoWidth, c2 = i2.videoHeight;
            if (!d2 || !c2) return null;
            let l2, u2;
            e2.width && e2.width > 0 ? e2.height && e2.height > 0 ? (l2 = e2.width, u2 = e2.height) : (l2 = e2.width, u2 = Math.floor(e2.width / d2 * c2)) : e2.height && e2.height > 0 ? (u2 = e2.height, l2 = Math.floor(e2.height / c2 * d2)) : (l2 = d2, u2 = c2), s2.width !== l2 && (s2.width = l2), s2.height !== u2 && (s2.height = u2), a2.drawImage(i2, 0, 0, l2, u2);
            return a2.getImageData(0, 0, l2, u2);
          }
          getBase64Image(e2) {
            return e2.toDataURL("image/", 1);
          }
          async playDomElement(e2, t2, i2) {
            return new Promise((r2, s2) => {
              let a2 = setTimeout(() => {
                a2 && (a2 = null, r2());
              }, t2), d2 = setTimeout(() => {
                var t3, i3;
                if (d2 && (d2 = null, e2.readyState === g.MEDIA_READYSTATE.HAVE_ENOUGH_DATA || l.getParameters().moreNotAllowedError)) {
                  const e3 = new n.default({ code: o.default.AUTO_PLAY_NOT_ALLOWED, url: "https://doc.yunxin.163.com/docs/jcyOTA0ODM/jM3NDE0NTI?platformId=50082", message: "playDomElement: 浏览器自动播放受限，表现为Play既不成功也不失败。可尝试通过resume()恢复。" });
                  this.stream.safeEmit("notAllowedError", e3), null === (t3 = this.stream.getAdapterRef()) || void 0 === t3 || t3.instance.safeEmit("NotAllowedError", e3), null === (i3 = this.stream.getAdapterRef()) || void 0 === i3 || i3.instance.safeEmit("notAllowedError", e3);
                }
              }, l.getParameters().playMediaTimeoutForAutoplay);
              const c2 = e2.play();
              m.printVideoState(c2, e2, this.stream.stringStreamID, i2), c2.then(() => {
                a2 && (clearTimeout(a2), a2 = null, r2()), d2 && (clearTimeout(d2), d2 = null);
              }).catch((e3) => {
                a2 && (clearTimeout(a2), a2 = null, "AbortError" === (null == e3 ? void 0 : e3.name) ? r2() : s2(e3)), d2 && (clearTimeout(d2), d2 = null);
              });
            });
          }
          enableMask() {
            this.mask.enabled = true, this.video.dom && (this.video.dom.style.filter = "blur(20px)");
          }
          disableMask() {
            this.mask.enabled = false, this.video.dom && (this.video.dom.style.filter = ""), this.screen.dom && (this.screen.dom.style.filter = ""), this.videoThird.dom && (this.videoThird.dom.style.filter = ""), this.videoFourth.dom && (this.videoFourth.dom.style.filter = "");
          }
          destroy() {
            a.MediaTypeList.forEach((e2) => {
              this.stopPlayStream(e2);
            });
          }
        }
        t.Play = f;
      }, function(e, t, i) {
        var r;
        !function(s) {
          "use strict";
          var a, o, n, d = (a = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g, o = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, n = /[^-+\dA-Z]/g, function(e2, t2, i2, r2) {
            if (1 !== arguments.length || "string" !== h(e2) || /\d/.test(e2) || (t2 = e2, e2 = void 0), (e2 = e2 || /* @__PURE__ */ new Date()) instanceof Date || (e2 = new Date(e2)), isNaN(e2)) throw TypeError("Invalid date");
            var s2 = (t2 = String(d.masks[t2] || t2 || d.masks.default)).slice(0, 4);
            "UTC:" !== s2 && "GMT:" !== s2 || (t2 = t2.slice(4), i2 = true, "GMT:" === s2 && (r2 = true));
            var p = i2 ? "getUTC" : "get", m = e2[p + "Date"](), g = e2[p + "Day"](), f = e2[p + "Month"](), v = e2[p + "FullYear"](), S = e2[p + "Hours"](), y = e2[p + "Minutes"](), _ = e2[p + "Seconds"](), R = e2[p + "Milliseconds"](), b = i2 ? 0 : e2.getTimezoneOffset(), T = l(e2), E = u(e2), A = { d: m, dd: c(m), ddd: d.i18n.dayNames[g], dddd: d.i18n.dayNames[g + 7], m: f + 1, mm: c(f + 1), mmm: d.i18n.monthNames[f], mmmm: d.i18n.monthNames[f + 12], yy: String(v).slice(2), yyyy: v, h: S % 12 || 12, hh: c(S % 12 || 12), H: S, HH: c(S), M: y, MM: c(y), s: _, ss: c(_), l: c(R, 3), L: c(Math.round(R / 10)), t: S < 12 ? "a" : "p", tt: S < 12 ? "am" : "pm", T: S < 12 ? "A" : "P", TT: S < 12 ? "AM" : "PM", Z: r2 ? "GMT" : i2 ? "UTC" : (String(e2).match(o) || [""]).pop().replace(n, ""), o: (b > 0 ? "-" : "+") + c(100 * Math.floor(Math.abs(b) / 60) + Math.abs(b) % 60, 4), S: ["th", "st", "nd", "rd"][m % 10 > 3 ? 0 : (m % 100 - m % 10 != 10) * m % 10], W: T, N: E };
            return t2.replace(a, function(e3) {
              return e3 in A ? A[e3] : e3.slice(1, e3.length - 1);
            });
          });
          function c(e2, t2) {
            for (e2 = String(e2), t2 = t2 || 2; e2.length < t2; ) e2 = "0" + e2;
            return e2;
          }
          function l(e2) {
            var t2 = new Date(e2.getFullYear(), e2.getMonth(), e2.getDate());
            t2.setDate(t2.getDate() - (t2.getDay() + 6) % 7 + 3);
            var i2 = new Date(t2.getFullYear(), 0, 4);
            i2.setDate(i2.getDate() - (i2.getDay() + 6) % 7 + 3);
            var r2 = t2.getTimezoneOffset() - i2.getTimezoneOffset();
            t2.setHours(t2.getHours() - r2);
            var s2 = (t2 - i2) / 6048e5;
            return 1 + Math.floor(s2);
          }
          function u(e2) {
            var t2 = e2.getDay();
            return 0 === t2 && (t2 = 7), t2;
          }
          function h(e2) {
            return null === e2 ? "null" : void 0 === e2 ? "undefined" : "object" != typeof e2 ? typeof e2 : Array.isArray(e2) ? "array" : {}.toString.call(e2).slice(8, -1).toLowerCase();
          }
          d.masks = { default: "ddd mmm dd yyyy HH:MM:ss", shortDate: "m/d/yy", mediumDate: "mmm d, yyyy", longDate: "mmmm d, yyyy", fullDate: "dddd, mmmm d, yyyy", shortTime: "h:MM TT", mediumTime: "h:MM:ss TT", longTime: "h:MM:ss TT Z", isoDate: "yyyy-mm-dd", isoTime: "HH:MM:ss", isoDateTime: "yyyy-mm-dd'T'HH:MM:sso", isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'", expiresHeaderFormat: "ddd, dd mmm yyyy HH:MM:ss Z" }, d.i18n = { dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"] }, void 0 === (r = (function() {
            return d;
          }).call(t, i, t, e)) || (e.exports = r);
        }();
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.measureText = t.numberToRGBA = void 0, t.numberToRGBA = function(e2) {
          if (0 === e2) return "rgba(0,0,0,0)";
          let t2, i2, r, s;
          return r = e2 % 256, i2 = (e2 = Math.floor(e2 / 256)) % 256, t2 = (e2 = Math.floor(e2 / 256)) % 256, s = (e2 = Math.floor(e2 / 256)) > 0 ? (e2 % 256 / 256).toFixed(2) : 1, `rgba(${t2}, ${i2}, ${r}, ${s})`;
        }, t.measureText = function(e2, t2, i2) {
          if (!e2) return { width: 0, height: 0 };
          let r = document.createElement("div"), s = document.createElement("span");
          s.innerText = e2, s.style.fontSize = t2, s.style.fontFamily = i2, r.style.opacity = "0", r.style.position = "absolute", r.style.height = t2, document.body.appendChild(r), r.appendChild(s);
          const a = r.clientHeight, o = s.offsetWidth;
          return r.remove(), { width: o, height: a };
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.StageAIProcessing = void 0;
        const s = r(i(293)), a = r(i(294)), o = i(3);
        class n extends o.EventEmitter {
          constructor(e2, t2) {
            super(), this.node = null, this.howlingNode = null, this.enabled = false, this._audioAffectsProcessor = null, this._howlingProcessor = null, this.pluginModules = { AIAudioEffects: null, AIhowling: null }, this.pluginConfig = { AIAudioEffects: null, AIhowling: null }, this.context = e2, this.logger = t2.getChild(() => "StageAIProcessing"), this.enabled = false;
          }
          registerPlugin(e2) {
            this.logger.log("registerPlugin ", e2.key), this.pluginConfig[e2.key] = e2;
          }
          getPlugin(e2) {
            return this.pluginModules[e2];
          }
          getPluginConfig(e2) {
            return this.pluginConfig[e2] ? this.pluginConfig[e2] : (this.logger.warn("pluginConfig is not found", e2), null);
          }
          hasWorkingPlugin() {
            const e2 = null !== this._audioAffectsProcessor || null !== this._howlingProcessor;
            return this.logger.log("hasWorkingPlugin", e2), e2;
          }
          async initProcessor(e2) {
            "AIAudioEffects" === e2 ? await this.initAudioEffects() : "AIhowling" === e2 ? await this.initHowling() : this.logger.warn("initProcessor ", e2, "not found");
          }
          getProcessor(e2) {
            return this.pluginModules[e2];
          }
          destroyProcessor(e2) {
            var t2, i2;
            this.logger.log("destroyProcessor ", e2), "AIAudioEffects" === e2 ? (null === (t2 = this.pluginModules[e2]) || void 0 === t2 || t2.destroy(), this.pluginModules[e2] = null, this._audioAffectsProcessor = null) : "AIhowling" === e2 ? (null === (i2 = this.pluginModules[e2]) || void 0 === i2 || i2.destroy(), this.pluginModules[e2] = null, this._howlingProcessor = null) : this.logger.warn("destroyProcessor ", e2, "not found");
          }
          async initAudioEffects() {
            this.logger.log("initAudioEffectsProcessor"), this._audioAffectsProcessor = new s.default(this, this.context), await this._audioAffectsProcessor.init(), this.pluginModules.AIAudioEffects = this._audioAffectsProcessor, this._audioAffectsProcessor.on("effects-load", () => {
              this.emit("effects-load");
            }), this._audioAffectsProcessor.on("error", (e2) => {
              this.emit("error", { key: "AIAudioEffects", msg: e2 });
            }), this._audioAffectsProcessor.on("plugin-process-unstable", (e2) => {
              this.emit("plugin-process-unstable", { key: "AIAudioEffects", msg: e2 });
            }), this.node = this._audioAffectsProcessor.getAudioNode();
          }
          async initHowling() {
            this.logger.log("initHowlingProcessor"), this._howlingProcessor = new a.default(this, this.context), await this._howlingProcessor.init(), this.pluginModules.AIhowling = this._howlingProcessor, this._howlingProcessor.on("aihowling-load", () => {
              this.emit("aihowling-load");
            }), this._howlingProcessor.on("error", (e2) => {
              this.emit("error", { key: "AIhowling", msg: e2 });
            }), this.howlingNode = this._howlingProcessor.getAudioNode();
          }
          unregisterPlugin(e2) {
            var t2, i2, r2, s2;
            this.logger.log("unregisterPlugin ", e2), "AIAudioEffects" === e2 ? (null === (t2 = this._audioAffectsProcessor) || void 0 === t2 || t2.removeAllListeners(), null === (i2 = this._audioAffectsProcessor) || void 0 === i2 || i2.destroy(), this._audioAffectsProcessor = null, this.removeListener("plugin-process-unstable")) : "AIhowling" === e2 && (null === (r2 = this._howlingProcessor) || void 0 === r2 || r2.removeAllListeners(), null === (s2 = this._howlingProcessor) || void 0 === s2 || s2.destroy(), this._howlingProcessor = null), this.pluginConfig[e2] = null, this.pluginModules[e2] = null;
          }
          destroy() {
            this.logger.log("destroy StageAIProcessing");
            for (const e2 in this.pluginModules) this.pluginModules[e2] && this.unregisterPlugin(e2);
            this.node = null, this.howlingNode = null, this.enabled = false;
          }
        }
        t.StageAIProcessing = n;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AudioWorkletAgent = void 0;
        const r = i(3), s = i(72);
        let a = { AIAudioEffects: "NOTREADY", AIhowling: "NOTREADY" }, o = { AIAudioEffects: null, AIhowling: null };
        class n extends r.EventEmitter {
          constructor(e2) {
            super(), this.outputCnt = 0, this.inputCnt = 0, this.node = new s.NeAudioNodeNullable("AudioWorkletAgent", null), this.processCallback = null, this.pluginType = e2.pluginType, this.logger = e2.logger.getChild(() => {
              let t3 = "AudioWorkletAgent";
              return "READY" !== a[e2.pluginType] && (t3 += " " + a[e2.pluginType]), t3;
            });
            const t2 = e2.context;
            this.support = { context: t2, audioWorkletNode: null };
          }
          async init(e2) {
            var t2;
            if (this.logger.log("AudioWorkletAgent init ", e2.key), this.support.audioWorkletNode) return void this.logger.error("Already Inited");
            if (!this.support.context.audioWorklet) return void this.logger.error("该环境不支持音频处理");
            const i2 = "AIAudioEffects" === e2.key ? "audioEffectsWorkletAgentProcessor" : "aiHowlingWorkletAgentProcessor";
            o[this.pluginType] ? "LOADING" === a[this.pluginType] && await o[this.pluginType] : (a[this.pluginType] = "LOADING", this.logger.log(`正在载入 ${i2} 模块`), o[this.pluginType] = this.support.context.audioWorklet.addModule(e2.blobUrl), await o[this.pluginType], a[this.pluginType] = "READY", this.logger.log(`载入 ${i2} 模块成功`)), this.support.audioWorkletNode = new AudioWorkletNode(this.support.context, i2), this.node.updateNode(this.support.audioWorkletNode), this.bindProcessorEvents(), e2.wasmBinary ? null === (t2 = this.support.audioWorkletNode) || void 0 === t2 || t2.port.postMessage({ type: "init", wasmBinary: e2.wasmBinary }) : (this.logger.log("wasmBinary 为空，正在加载 " + e2.wasmUrl), fetch(e2.wasmUrl).then((t3) => {
              if (200 == t3.status) return t3.arrayBuffer();
              this.logger.error(`加载 ${e2.wasmUrl} 失败, 无法初始化音频处理程序`);
            }).then((e3) => {
              var t3;
              if (e3) {
                const i3 = new Uint8Array(e3);
                null === (t3 = this.support.audioWorkletNode) || void 0 === t3 || t3.port.postMessage({ type: "init", wasmBinary: i3 });
              }
            }));
          }
          bindProcessorEvents() {
            this.removeAllListeners("rawinputs"), this.support.audioWorkletNode.port.onmessage = (e2) => {
              this.emit("processor-message", e2);
              const { type: t2 } = e2.data;
              switch (t2) {
                case "rawinputs":
                  this.handleTypeRawInputs(e2);
                  break;
                case "bufferDrop":
                  this.logger.warn(`音频处理程序刚刚丢弃了${e2.data.cnt}个包的数据`);
                  break;
                case "created":
                  const { value: t3 } = e2.data;
                  this.logger.log("音频处理程序已创建 " + t3), "AIAudioEffects" === t3 ? this.emit("effects-load") : "AIhowling" === t3 && this.emit("aihowling-load");
                  break;
                case "howlingState":
                  "function" == typeof this.processCallback && this.processCallback(!!e2.data.result);
                  break;
                case "error":
                  const i2 = e2.data.message;
                  this.logger.error("音频处理程序错误 " + i2), this.emit("error", i2);
                  break;
                case "plugin-process-unstable":
                  const { startTime: r2, duration: s2 } = e2.data;
                  this.logger.log(`音频处理程序处理时长不稳定, start: ${r2}, duration: ${s2}`), this.emit("plugin-process-unstable", "音频处理程序处理时长不稳定, 可能发生卡顿问题, start: " + r2);
                  break;
                default:
                  this.logger.error("Unknown message", e2);
              }
            };
          }
          handleTypeRawInputs(e2) {
            this.outputCnt++, this.emit("rawinputs", e2.data);
          }
          outputData(e2) {
            if (!this.support.audioWorkletNode) throw new Error("Destroyed");
            this.inputCnt++, this.support.audioWorkletNode.port.postMessage({ type: "outputData", data: e2 });
          }
          postMessage(e2) {
            if (!this.support.audioWorkletNode) throw new Error("Destroyed");
            this.support.audioWorkletNode.port.postMessage(e2);
          }
          setHowlingCallback(e2) {
            this.logger.log("setHowlingCallback"), this.processCallback = e2;
          }
          destroy() {
            this.logger.log("destroy AudioWorkletAgent"), this.support.audioWorkletNode && (this.support.audioWorkletNode.disconnect(), this.support.audioWorkletNode = null);
          }
        }
        t.AudioWorkletAgent = n;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.loadPlugin = void 0;
        const s = r(i(155));
        t.loadPlugin = function(e2, t2) {
          return new Promise((i2, r2) => {
            -1 == s.default.indexOf(e2) && r2("unsupport plugin " + e2);
            const a = document.createElement("script");
            a.defer = true, a.src = t2, document.body.appendChild(a), a.onload = function() {
              i2();
            }, a.onerror = function(e3) {
              r2(`Load plugin ${t2} error`);
            };
          });
        };
      }, function(e, t, i) {
        "use strict";
        var r = a(i(73)), s = a(i(74));
        function a(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var o = i(169).EventEmitter;
        e.exports = class extends o {
          constructor(e2) {
            super(), this.setMaxListeners(1 / 0), this._logger = e2 || console;
          }
          safeEmit(e2) {
            try {
              for (var t2 = arguments.length, i2 = Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) i2[r2 - 1] = arguments[r2];
              this.emit.apply(this, [e2].concat(i2));
            } catch (t3) {
              this._logger.error("safeEmit() | event listener threw an error [event:%s]:%o", e2, t3);
            }
          }
          safeEmitAsPromise(e2) {
            for (var t2 = this, i2 = arguments.length, a2 = Array(i2 > 1 ? i2 - 1 : 0), o2 = 1; o2 < i2; o2++) a2[o2 - 1] = arguments[o2];
            return (0, s.default)(r.default.mark(function i3() {
              return r.default.wrap(function(i4) {
                for (; ; ) switch (i4.prev = i4.next) {
                  case 0:
                    return i4.abrupt("return", new Promise(function(i5, r2) {
                      t2.safeEmit.apply(t2, [e2].concat(a2, [i5, r2]));
                    }));
                  case 1:
                  case "end":
                    return i4.stop();
                }
              }, i3, t2);
            }))();
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r, s = i(121), a = (r = s) && r.__esModule ? r : { default: r }, o = i(28);
        var n = i(299).generateRandomNumber, d = i(81).JSONBigParse, c = new o.Logger({ tagGen: function() {
          return "Message";
        } });
        e.exports = class {
          static parse(e2) {
            var t2 = void 0, i2 = {};
            try {
              t2 = d(e2);
            } catch (e3) {
              return void c.error("parse() | invalid JSONbig: %s", e3);
            }
            if ("object" === (void 0 === t2 ? "undefined" : (0, a.default)(t2)) && !Array.isArray(t2)) {
              if (t2.request) {
                if (i2.request = true, "string" != typeof t2.method) return void c.error("parse() | missing/invalid method field");
                if ("number" != typeof t2.id) return void c.error("parse() | missing/invalid id field");
                i2.id = t2.id, i2.method = t2.method, i2.data = t2.data || {};
              } else if (t2.response) {
                if (i2.response = true, "number" != typeof t2.id) return void c.error("parse() | missing/invalid id field");
                i2.id = t2.id, t2.ok ? (i2.ok = true, i2.data = t2.data || {}) : (i2.ok = false, i2.errorCode = t2.errorCode, i2.errorReason = t2.errorReason);
              } else {
                if (!t2.notification) return void c.error("parse() | missing request/response field");
                if (i2.notification = true, "string" != typeof t2.method) return void c.error("parse() | missing/invalid method field");
                i2.id = t2.id, i2.method = t2.method, i2.data = t2.data || {};
              }
              return i2;
            }
            c.error("parse() | not an object");
          }
          static createRequest(e2, t2) {
            return { request: true, id: n(), method: e2, data: t2 || {} };
          }
          static createSuccessResponse(e2, t2) {
            return { response: true, id: e2.id, ok: true, data: t2 || {} };
          }
          static createErrorResponse(e2, t2, i2) {
            return { response: true, id: e2.id, ok: false, errorCode: t2, errorReason: i2 };
          }
          static createNotification(e2, t2) {
            return { notification: true, method: e2, data: t2 || {} };
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = i(1), s = i(84), a = i(28);
        window;
        const o = { setLogLevel(e2) {
          r.getParameters().logLevel !== e2 && (a.getDefaultLogger().info(`NERTC LogLevel was changed: ${s.loglevelMap[r.getParameters().logLevel]} => ${s.loglevelMap[e2]}`), r.getParameters().logLevel = e2);
        }, enableLogUpload() {
          r.getParameters().logUpload = true;
        }, disableLogUpload() {
          r.getParameters().logUpload = false;
        } };
        "on" === r.getParameters().forceLogUpload ? o.enableLogUpload() : o.disableLogUpload(), t.default = o;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.geofenceArea = void 0;
        const r = i(26), s = i(28), a = i(1);
        t.geofenceArea = new class {
          constructor() {
            this.areaCode = "GLOBAL", this.regions = r.LBS_REGION_CONFIG, this.logger = s.getDefaultLogger().getChild(() => "GeofenceArea " + this.areaCode);
          }
          setAreaById(e2) {
            if (this.regions[e2]) {
              const t2 = this.areaCode;
              this.areaCode = e2, this.logger.log(`setArea: ${t2} -> ${e2}`);
            } else this.logger.error(`setAreaById: 不存在该区域：${e2}。可用区域：${this.getAvailableAreas().join(",")}`);
            for (let e3 in a.getParameters().clients) {
              const t2 = a.getParameters().clients[e3];
              t2.destroyed || "DISCONNECTED" !== t2.adapterRef.connectState.curState || t2.adapterRef.lbsManager.loadBuiltinConfig("setArea");
            }
          }
          getAvailableAreas() {
            const e2 = [];
            for (let t2 in this.regions) this.regions[t2] && this.regions[t2].nrtc && e2.push(t2);
            return e2;
          }
          getBuiltinConfig() {
            return "NONE" !== a.getParameters().forceGeofenceArea ? this.regions[a.getParameters().forceGeofenceArea] : this.regions[this.areaCode];
          }
        }();
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AdvBeautyFilter = t.resSet = void 0;
        const r = i(156), s = i(134), a = i(135), o = i(75), n = i(317), d = i(318), c = i(319), l = i(320), u = i(136), h = i(321), p = i(137);
        t.resSet = { faceMask: "https://yx-web-nosdn.netease.im/common/6947be5d3e5604368401950ca0cf094d/facemask-01.png", eyeTeethMask: "https://yx-web-nosdn.netease.im/common/655421269305cac5c1e48d62f0fac8de/eye-teeth-mask-02.png", teethWhiten: "https://yx-web-nosdn.netease.im/common/ca8a6b0be3427ead9b19bcf9ae1245a8/teath.png" };
        const m = { genTopFace(e2) {
          const t2 = h.Vector2.getVec(e2, 49), i2 = h.Vector2.getVec(e2, 43);
          let r2 = h.Vector2.sub(i2, t2), s2 = 1.5 * r2.length;
          r2 = h.Vector2.normalize(r2);
          const a2 = h.Vector2.sub(h.Vector2.getVec(e2, 0), i2);
          let o2 = a2.length;
          const n2 = h.Vector2.sub(h.Vector2.getVec(e2, 32), i2);
          let d2 = n2.length;
          const c2 = Math.max(o2, d2);
          let l2 = o2 / c2, u2 = d2 / c2;
          h.Vector2.setPoint(e2, 116, h.Vector2.add(i2, h.Vector2.scale(r2, s2)));
          let p2 = h.Vector2.angle(a2, r2), m2 = h.Matrix3x3.rotate(p2 / -6, 0, 0), g2 = r2;
          [110, 109, 108, 107, 106].forEach((t3, r3) => {
            g2 = m2.multiplyVector(g2);
            const a3 = (r3 + 1) / 7, n3 = 1 * (1 - a3) + l2 * a3;
            h.Vector2.setPoint(e2, t3, h.Vector2.add(i2, h.Vector2.scale(g2, s2 * n3 * (1 - a3) + o2 * a3)));
          }), p2 = h.Vector2.angle(n2, r2), m2 = h.Matrix3x3.rotate(p2 / 6, 0, 0), g2 = r2, [115, 114, 113, 112, 111].forEach((t3, r3) => {
            g2 = m2.multiplyVector(g2);
            const a3 = (r3 + 1) / 7, o3 = 1 * (1 - a3) + u2 * a3;
            h.Vector2.setPoint(e2, t3, h.Vector2.add(i2, h.Vector2.scale(g2, s2 * o3 * (1 - a3) + d2 * a3)));
          });
        }, genFaceOutline(e2) {
          const t2 = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116], i2 = h.Vector2.getVec(e2, 43);
          for (let r2 = 0; r2 < t2.length; r2++) {
            const s2 = t2[r2], a2 = h.Vector2.getVec(e2, s2), o2 = h.Vector2.add(i2, h.Vector2.scale(h.Vector2.sub(a2, i2), 1.3)), n2 = 2 * (117 + r2);
            e2[n2] = o2.value[0] >> 0, e2[n2 + 1] = o2.value[1] >> 0;
          }
        } }, g = /* @__PURE__ */ new Set();
        let f = null, v = null, S = null;
        class y extends p.Filter {
          constructor(e2, t2, i2, s2, a2, n2, d2, c2, l2, u2, h2, p2) {
            super(e2, t2, i2, null), this.isShowWire = false, this.advData = null, this.wirePosBuffer = null, this.targetPosBuffer = null, this.zIndexBuffer = null, this.indicesBuffer = null, this.faceMaskUVBuffer = null, this.planePosBuffer = null, this.planeUVBuffer = null, this.advEyeTeethPosBuffer = null, this.advEyeTeethIndicesBuffer = null, this.advEyeTeethZindexBuffer = null, this.advEyeTeethUVBuffer = null, this.defParams = { enlargeEye: 0, roundedEye: 0, openCanthus: 0, eyeDistance: 0.5, eyeAngle: 0.5, shrinkNose: 0, lengthenNose: 0.5, shrinkMouth: 0.5, widenMouth: 0.5, mouthCorners: 0.5, adjustPhiltrum: 0.5, shrinkUnderjaw: 0, shrinkCheekbone: 0, lengthenJaw: 0.5, narrowedFace: 0, shrinkFace: 0, vShapedFace: 0, minifyFace: 0, shortenFace: 0, whitenTeeth: 0, brightenEye: 0, fadeHeadWrinkle: 0, fadeEyeRim: 0, fadeNoseLine: 0 }, g.add(this), this.faceMaskMap = o.createTexture(this.renderer.gl, f), this.eyeTeethMaskMap = o.createTexture(this.renderer.gl, v), this.whiteTeethLutMap = o.createTexture(this.renderer.gl, S, { flipY: false }), this.params = Object.assign({}, this.defParams), m.genTopFace(this.posBuffer.typedArray), m.genFaceOutline(this.posBuffer.typedArray), this.targetPosBuffer = r.createAttributeBuffer(this.renderer.gl, "tPosition", this.posBuffer.typedArray.slice(0), 2), this.zIndexBuffer = s2, this.indicesBuffer = a2, this.faceMaskUVBuffer = n2, this.planePosBuffer = d2, this.planeUVBuffer = c2, this.advEyeTeethPosBuffer = l2, this.advEyeTeethIndicesBuffer = u2, this.advEyeTeethZindexBuffer = h2, this.advEyeTeethUVBuffer = p2, this.setWirePosBuffer(), this.initProgramBuffer();
          }
          setWirePosBuffer() {
            if (!this.isShowWire) return;
            const e2 = /* @__PURE__ */ new Set(), t2 = [], i2 = this.indicesBuffer.typedArray, s2 = this.posBuffer.typedArray, a2 = (i3, r2) => {
              if (!e2.has(i3 + "-" + r2) && !e2.has(r2 + "-" + i3)) {
                e2.add(i3 + "-" + r2);
                const a3 = 2 * i3, o2 = 2 * r2;
                t2.push(s2[a3], s2[a3 + 1], s2[o2], s2[o2 + 1]);
              }
            };
            for (let e3 = 0; e3 < (i2.length - 2) / 3; e3++) {
              const t3 = 3 * e3, r2 = i2[t3], s3 = i2[t3 + 1], o2 = i2[t3 + 2];
              a2(r2, s3), a2(s3, o2), a2(o2, r2);
            }
            this.wirePosBuffer ? this.programs.wire.updateAttribute("position", (e3) => {
              e3.set(t2, 0);
            }) : this.wirePosBuffer = r.createAttributeBuffer(this.renderer.gl, "position", new Int16Array(t2), 2);
          }
          initProgramBuffer() {
            const e2 = this.renderer.gl, t2 = this.renderer.getSize(), i2 = { width: t2.width >> 2, height: t2.height >> 2 };
            let r2 = null;
            if (this.isShowWire) {
              const i3 = new a.Program(e2, () => {
                var t3;
                e2.drawArrays(e2.LINES, 0, (null === (t3 = this.wirePosBuffer) || void 0 === t3 ? void 0 : t3.count) || 0);
              });
              i3.setShader(c.advBeautyWireShader.vShader, "VERTEX"), i3.setShader(c.advBeautyWireShader.fShader, "FRAGMENT"), i3.setAttributeBuffer(this.wirePosBuffer), r2 = s.createFrameBuffer(e2, t2.width, t2.height), i3.setUniform("size", [t2.width, t2.height]), this.programs.wire = i3, this.framebuffers.wire = r2;
            }
            const o2 = new a.Program(e2, () => {
              e2.drawElements(e2.TRIANGLES, this.indicesBuffer.count, e2.UNSIGNED_SHORT, 0);
            });
            o2.setShader(d.advBeautyShader.vShader, "VERTEX"), o2.setShader(d.advBeautyShader.fShader, "FRAGMENT"), o2.setAttributeBuffer(this.posBuffer), o2.setAttributeBuffer(this.targetPosBuffer), o2.setAttributeBuffer(this.zIndexBuffer);
            const h2 = s.createFrameBuffer(e2, t2.width, t2.height);
            o2.setUniform("size", [t2.width, t2.height]), this.isShowWire && o2.setUniform("wireMap", r2.targetTexture), o2.setUniform("showWire", this.isShowWire ? 1 : 0), o2.setUniform("map", this.map), o2.setUniform("teethLut", this.whiteTeethLutMap), o2.setUniform("teethIntensity", 0), o2.setUniform("eyeIntensity", 0), o2.setIndices(this.indicesBuffer), this.programs.morph = o2, this.framebuffers.morph = h2;
            const p2 = new a.Program(e2, () => {
              e2.drawElements(e2.TRIANGLES, this.indicesBuffer.count, e2.UNSIGNED_SHORT, 0);
            });
            p2.setShader(l.advFaceMaskShader.vShader, "VERTEX"), p2.setShader(u.baseTextureShader.fShader, "FRAGMENT"), p2.setAttributeBuffer(this.targetPosBuffer), p2.setAttributeBuffer(this.zIndexBuffer), p2.setAttributeBuffer(this.faceMaskUVBuffer);
            const m2 = s.createFrameBuffer(e2, i2.width, i2.height);
            p2.setUniform("size", [t2.width, t2.height]), p2.setUniform("map", this.faceMaskMap), p2.setIndices(this.indicesBuffer), this.programs.faceMask = p2, this.framebuffers.faceMask = m2;
            const g2 = new a.Program(e2, () => {
              e2.drawElements(e2.TRIANGLES, this.advEyeTeethIndicesBuffer.count, e2.UNSIGNED_SHORT, 0);
            });
            g2.setShader(l.advFaceMaskShader.vShader, "VERTEX"), g2.setShader(u.baseTextureShader.fShader, "FRAGMENT"), g2.setAttributeBuffer(this.advEyeTeethPosBuffer), g2.setAttributeBuffer(this.advEyeTeethZindexBuffer), g2.setAttributeBuffer(this.advEyeTeethUVBuffer);
            const f2 = s.createFrameBuffer(e2, i2.width, i2.height);
            g2.setUniform("size", [t2.width, t2.height]), g2.setUniform("map", this.eyeTeethMaskMap), g2.setIndices(this.advEyeTeethIndicesBuffer), this.programs.eyeTeeth = g2, this.framebuffers.eyeTeeth = f2, o2.setUniform("eyeTeethMaskMap", f2.targetTexture);
            for (let r3 = 0; r3 < 2; r3++) {
              const o3 = new a.Program(e2);
              o3.setShader(u.baseTextureShader.vShader, "VERTEX"), o3.setShader(n.advBeautyEyeShader.fShader, "FRAGMENT"), o3.setAttributeBuffer(this.planePosBuffer), o3.setAttributeBuffer(this.planeUVBuffer);
              const d2 = s.createFrameBuffer(e2, t2.width, t2.height);
              o3.setUniform("map", 0 === r3 ? h2.targetTexture : this.framebuffers.lEye.targetTexture), o3.setUniform("eyeCenter", [0, 0]), o3.setUniform("rdIntensity", 0), o3.setUniform("lgIntensity", 0), o3.setUniform("intensRatio", 0), o3.setUniform("range", 0), o3.setUniform("rdDir", [0, 0]);
              const c2 = ["lEye", "rEye"][r3];
              this.programs[c2] = o3, this.framebuffers[c2] = d2;
              const p3 = new a.Program(e2);
              p3.setShader(u.baseTextureShader.vShader, "VERTEX"), p3.setShader(l.advFaceMaskShader.fShader, "FRAGMENT"), p3.setAttributeBuffer(this.planePosBuffer), p3.setAttributeBuffer(this.planeUVBuffer);
              const g3 = s.createFrameBuffer(e2, i2.width, i2.height);
              p3.setUniform("map", null), p3.setUniform("maskMap", m2.targetTexture), p3.setUniform("index", r3), this.programs["faceMaskMerge" + r3] = p3, this.framebuffers["faceMaskMerge" + r3] = g3;
            }
          }
          get output() {
            return this.advData ? this.framebuffers.rEye.targetTexture : super.output;
          }
          get faceMask() {
            if (this.advData) {
              const e2 = this.advData.length / 212 >> 0;
              return this.framebuffers["faceMaskMerge" + (e2 - 1) % 2].targetTexture;
            }
            return null;
          }
          updateSize() {
            const e2 = this.renderer.getSize(), t2 = { width: e2.width >> 2, height: e2.height >> 2 };
            ["wire", "morph", "lEye", "rEye", "faceMask", "faceMaskMerge0", "faceMaskMerge1", "eyeTeeth"].forEach((i2) => {
              var r2;
              -1 === ["faceMaskMerge0", "faceMaskMerge1", "lEye", "rEye"].indexOf(i2) && (null === (r2 = this.programs[i2]) || void 0 === r2 || r2.setUniform("size", [e2.width, e2.height]));
              const s2 = this.framebuffers[i2];
              if (s2) {
                const r3 = -1 === ["faceMask", "faceMaskMerge0", "faceMaskMerge1", "eyeTeeth"].indexOf(i2) ? e2 : t2;
                s2.targetTexture.opts.width = r3.width, s2.targetTexture.opts.height = r3.height, s2.targetTexture.refresh();
              }
            });
          }
          setAdvData(e2) {
            this.advData = e2.length ? e2 : null;
          }
          setAdvEffect(e2, t2) {
            if (e2 in this.params && "number" == typeof t2) this.params[e2] = Math.min(1, Math.max(0, t2)), "whitenTeeth" === e2 && 0 === this.params[e2] ? this.programs.morph.setUniform("teethIntensity", 0) : "brightenEye" === e2 ? this.programs.morph.setUniform("eyeIntensity", t2) : "roundedEye" === e2 ? (this.programs.lEye.setUniform("rdIntensity", t2), this.programs.rEye.setUniform("rdIntensity", t2)) : "enlargeEye" === e2 && (this.programs.lEye.setUniform("lgIntensity", t2), this.programs.rEye.setUniform("lgIntensity", t2));
            else for (const e3 in this.defParams) this.setAdvEffect(e3, this.defParams[e3]);
          }
          presetAdvEffect(e2) {
            for (const t2 in this.defParams) t2 in e2 ? this.setAdvEffect(t2, e2[t2]) : this.setAdvEffect(t2, this.defParams[t2]);
          }
          get featureParas() {
            return this.advData ? { forehead: this.params.fadeHeadWrinkle, eyeRim: this.params.fadeEyeRim, noseLine: this.params.fadeNoseLine } : { forehead: 0, eyeRim: 0, noseLine: 0 };
          }
          posToUV(e2, t2, i2) {
            return new h.Vector2(e2.x / t2, 1 - e2.y / i2);
          }
          render() {
            const e2 = this.advData;
            if (e2) {
              const t2 = this.renderer, i2 = t2.gl, r2 = t2.getSize(), s2 = { width: r2.width >> 2, height: r2.height >> 2 }, a2 = e2.length / 212 >> 0;
              for (let o2 = 0; o2 < a2; o2++) {
                const a3 = e2.slice(212 * o2, 212 * (o2 + 1)), n2 = o2 % 2, d2 = this.programs.morph, c2 = this.programs["faceMaskMerge" + n2];
                d2.setUniform("map", 0 === o2 ? this.map : this.framebuffers.rEye.targetTexture), d2.updateAttribute("position", (e3) => {
                  e3.set(a3, 0), m.genTopFace(e3), m.genFaceOutline(e3);
                });
                let l2 = null;
                if (d2.updateAttribute("tPosition", (e3) => {
                  var t3;
                  const i3 = e3;
                  i3.set(this.posBuffer.typedArray, 0), h.preHandle(i3);
                  for (const e4 in h.handlers) {
                    const r3 = this.params[e4];
                    if (r3 !== this.defParams[e4]) {
                      const s3 = null === (t3 = h.handlers[e4]) || void 0 === t3 ? void 0 : t3.call(h.handlers, i3, r3);
                      "whitenTeeth" === e4 ? d2.setUniform("teethIntensity", s3) : "roundedEye" !== e4 && "enlargeEye" !== e4 || (l2 = Object.assign(Object.assign({}, s3), { posData: i3 }));
                    }
                  }
                }), this.setWirePosBuffer(), this.isShowWire && (this.framebuffers.wire.bind(), i2.clear(i2.COLOR_BUFFER_BIT | i2.DEPTH_BUFFER_BIT), this.renderer.render(this.programs.wire)), t2.setViewport(0, 0, s2.width, s2.height), this.framebuffers.faceMask.bind(), this.renderer.render(this.programs.faceMask), c2.setUniform("index", o2), c2.setUniform("map", this.framebuffers["faceMaskMerge" + (0 === n2 ? 1 : 0)].targetTexture), this.framebuffers["faceMaskMerge" + n2].bind(), this.renderer.render(c2), this.programs.eyeTeeth.updateAttribute("tPosition", (e3) => {
                  const t3 = e3, i3 = this.targetPosBuffer.typedArray;
                  [52, 53, 72, 54, 55, 56, 73, 57, 61, 60, 75, 59, 58, 63, 76, 62, 96, 97, 98, 99, 100, 101, 102, 103].forEach((e4, r3) => {
                    let s3 = 2 * r3, a4 = 2 * e4;
                    t3[s3] = i3[a4], t3[s3 + 1] = i3[a4 + 1];
                  });
                }), this.framebuffers.eyeTeeth.bind(), i2.clear(i2.COLOR_BUFFER_BIT | i2.DEPTH_BUFFER_BIT), this.renderer.render(this.programs.eyeTeeth), t2.setViewport(0, 0, r2.width, r2.height), this.framebuffers.morph.bind(), this.renderer.render(d2), l2) {
                  const e3 = this.posToUV(l2.lEyeCenter, r2.width, r2.height), t3 = this.posToUV(l2.rEyeCenter, r2.width, r2.height), i3 = this.posToUV(h.Vector2.getVec(l2.posData, 52), r2.width, r2.height), s3 = this.posToUV(h.Vector2.getVec(l2.posData, 55), r2.width, r2.height);
                  let a4 = h.Vector2.getVec(l2.posData, 72), o3 = h.Vector2.getVec(l2.posData, 73);
                  const n3 = this.posToUV(h.Vector2.getVec(l2.posData, 58), r2.width, r2.height), d3 = this.posToUV(h.Vector2.getVec(l2.posData, 61), r2.width, r2.height);
                  let c3 = h.Vector2.getVec(l2.posData, 75), u2 = h.Vector2.getVec(l2.posData, 76);
                  const p2 = Math.min(1, Math.max(0, (h.Vector2.disPow2(a4, o3) - 4) / 4)), m2 = Math.min(1, Math.max(0, (h.Vector2.disPow2(c3, u2) - 4) / 4));
                  a4 = this.posToUV(a4, r2.width, r2.height), o3 = this.posToUV(o3, r2.width, r2.height), c3 = this.posToUV(c3, r2.width, r2.height), u2 = this.posToUV(u2, r2.width, r2.height), this.programs.lEye.setUniform("eyeCenter", e3.value), this.programs.lEye.setUniform("range", Math.max(h.Vector2.dis(e3, i3), h.Vector2.dis(e3, s3))), this.programs.lEye.setUniform("rdDir", h.Vector2.normalize(h.Vector2.sub(a4, o3)).value), this.programs.lEye.setUniform("intensRatio", p2), this.programs.rEye.setUniform("eyeCenter", t3.value), this.programs.rEye.setUniform("range", Math.max(h.Vector2.dis(t3, n3), h.Vector2.dis(t3, d3))), this.programs.rEye.setUniform("rdDir", h.Vector2.normalize(h.Vector2.sub(c3, u2)).value), this.programs.rEye.setUniform("intensRatio", m2);
                }
                this.framebuffers.lEye.bind(), this.renderer.render(this.programs.lEye), this.framebuffers.rEye.bind(), this.renderer.render(this.programs.rEye);
              }
            }
          }
          static configStaticRes(e2, i2) {
            const r2 = [];
            let s2 = 1;
            const a2 = () => {
              s2 -= 1, s2 <= 0 && (i2 ? i2.emit("advBeautyResComplete", r2) : g.forEach((e3) => {
                try {
                  e3.emit("advBeautyResComplete", r2);
                } catch (e4) {
                }
              }));
            };
            e2.faceMask && !f && (s2 += 1, t.resSet.faceMask = e2.faceMask, o.retryLoadImage(e2.faceMask, 3, (e3) => {
              f = e3, g.forEach((t2) => {
                try {
                  t2.faceMaskMap.source = e3, t2.faceMaskMap.refresh();
                } catch (e4) {
                }
              }), a2();
            }, () => {
              r2.push(e2.faceMask), a2();
            })), e2.eyeTeethMask && !v && (s2 += 1, t.resSet.eyeTeethMask = e2.eyeTeethMask, o.retryLoadImage(t.resSet.eyeTeethMask, 3, (e3) => {
              v = e3, g.forEach((t2) => {
                try {
                  t2.eyeTeethMaskMap.source = e3, t2.eyeTeethMaskMap.refresh();
                } catch (e4) {
                }
              }), a2();
            }, () => {
              r2.push(e2.eyeTeethMask), a2();
            })), e2.teethWhiten && !S && (s2 += 1, t.resSet.teethWhiten = e2.teethWhiten, o.retryLoadImage(t.resSet.teethWhiten, 3, (e3) => {
              S = e3, g.forEach((t2) => {
                try {
                  t2.whiteTeethLutMap.source = e3, t2.whiteTeethLutMap.refresh();
                } catch (e4) {
                }
              }), a2();
            }, () => {
              r2.push(e2.teethWhiten), a2();
            })), a2();
          }
          destroy() {
            var e2, t2, i2;
            super.destroy(), null === (e2 = this.renderer.gl) || void 0 === e2 || e2.deleteTexture(this.faceMaskMap.glTexture), null === (t2 = this.renderer.gl) || void 0 === t2 || t2.deleteTexture(this.eyeTeethMaskMap.glTexture), null === (i2 = this.renderer.gl) || void 0 === i2 || i2.deleteTexture(this.whiteTeethLutMap.glTexture), g.delete(this);
          }
          remove() {
            g.delete(this);
          }
        }
        t.AdvBeautyFilter = y;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.lutShader = void 0, t.lutShader = { fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    uniform sampler2D lut;\n\n    // lut强度\n    uniform float intensity;\n\n    varying vec2 vuv;\n\n    void main() {\n        vec3 color = texture2D(map, vuv).rgb;\n\n        if(intensity > 0.0){\n            float blue = color.b * 63.0;\n\n            vec2 q1;\n            float fb = floor(blue);\n            q1.y = floor(fb * 0.125);\n            q1.x = fb - (q1.y * 8.0);\n\n            vec2 q2;\n            float cb = ceil(blue);\n            q2.y = floor(cb * 0.125);\n            q2.x = cb - (q2.y * 8.0);\n\n            vec2 t = 0.123 * color.rg + vec2(0.000976563);\n            vec2 t1 = q1 * 0.125 + t;\n            vec3 p1 = texture2D(lut, t1).rgb;\n\n            vec2 t2 = q2 * 0.125 + t;\n            vec3 p2 = texture2D(lut, t2).rgb;\n\n            vec3 filter = mix(p1, p2, fract(blue));\n            color = mix(color, filter, intensity);\n        }\n        gl_FragColor = vec4(color, 1.0);\n    }" };
      }, , , function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.NERTC = void 0;
        const s = i(210), a = i(309), o = i(26), n = i(339), d = i(340), c = i(341), l = i(69), u = i(167), h = i(76), p = i(1), m = i(48), g = i(164), f = r(i(6)), v = r(i(8)), S = r(i(203)), y = i(84), _ = i(49), R = i(43), b = i(143), T = i(204);
        let E, A = window;
        t.NERTC = { Logger: { DEBUG: 0, INFO: 1, WARNING: 2, ERROR: 3, NONE: 4, setLogLevel(e2) {
          const t2 = p.getParameters().forceLogLevel;
          -1 !== t2 ? null == E || E.logger.error("setLogLevel: 本页面的日志级别固定为 " + y.loglevelMap[t2]) : (E && E.apiFrequencyControl({ name: "setLogLevel", code: 0, param: { clientUid: E.adapterRef.channelInfo.uid || "", level: e2 } }), S.default.setLogLevel(e2));
        }, enableLogUpload() {
          "off" === p.getParameters().forceLogUpload ? null == E || E.logger.error("enableLogUpload: 禁止开启日志上传") : (E && E.apiFrequencyControl({ name: "enableLogUpload", code: 0, param: { clientUid: E.adapterRef.channelInfo.uid || "" } }), S.default.enableLogUpload());
        }, disableLogUpload() {
          "on" === p.getParameters().forceLogUpload ? null == E || E.logger.error("disableLogUpload: 禁止关闭日志上传") : (E && E.apiFrequencyControl({ name: "disableLogUpload", code: 0, param: { clientUid: E.adapterRef.channelInfo.uid || "" } }), S.default.disableLogUpload());
        } }, setArea(e2) {
          const t2 = p.getParameters().forceGeofenceArea;
          if ("NONE" !== t2) null == E || E.logger.error("setArea: 本页面的日志级别固定为 " + t2);
          else {
            _.checkValidObject({ tag: "NERTC.setArea:area", value: e2 }), _.checkValidEnum({ tag: "NERTC.setArea:area.areaCode", value: e2.areaCode, enums: T.geofenceArea.getAvailableAreas() });
            let t3 = null;
            for (let e3 in p.getParameters().clients) if (t3 = p.getParameters().clients[e3], !t3.destroyed && "DISCONNECTED" !== t3.adapterRef.connectState.curState) throw new v.default({ code: f.default.CLIENT_ALREADY_IN_CHANNEL_ERROR, message: "用户已在频道中，不支持调用setArea" });
            T.geofenceArea.setAreaById(e2.areaCode), t3 && t3.apiFrequencyControl({ name: "setArea", code: 0, param: { clientUid: t3.adapterRef.channelInfo.uid || "", area: e2, config: T.geofenceArea.getBuiltinConfig() } });
          }
        }, createClient(e2) {
          if (!g.checkSystemRequirements()) throw console.error("浏览器环境不支持"), new v.default({ code: f.default.NOT_SUPPORT_ERROR, message: "云信sdk不支持，请使用最新版本的chrome浏览器" });
          _.checkExists({ tag: "createClient:ClientOptions", value: e2 }), _.checkExists({ tag: "createClient:ClientOptions.appkey", value: e2.appkey });
          const i2 = new s.Client(Object.assign(e2, { apiList: [], ref: t.NERTC }));
          return p.getParameters().clients.push(i2), E || (E = i2), i2;
        }, createStream(e2) {
          if (_.checkExists({ tag: "createStream:options", value: e2 }), b.isHttpProtocol() && !p.getParameters().passEnvCheck) throw null == E || E.adapterRef.logger.warn("The current protocol is HTTP"), new v.default({ code: f.default.NOT_SUPPORT_ERROR, message: "请使用https环境或者localhost环境" });
          if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) && !p.getParameters().passEnvCheck) throw null == E || E.adapterRef.logger.warn("没有 getUserMedia 方法。请使用最新版本的chrome浏览器"), new v.default({ code: f.default.NOT_SUPPORT_ERROR, message: "浏览器不支持开启媒体设备，请使用最新版本的chrome浏览器" });
          if (e2.screenAudio && !e2.screen && !e2.screenAudioSource) throw new v.default({ code: f.default.INVALID_OPERATION_ERROR, message: "createStream: screenAudio 要与 screen 一起开启" });
          if (!e2.client && E && E.adapterRef.logger.warn("createStream: 未传入client参数。使用默认client。"), E || e2.client) {
            const t2 = new a.LocalStream(Object.assign(e2, { isRemote: false, client: e2.client || E }));
            return p.getParameters().localStreams.push(t2), t2;
          }
          return n.clientNotYetUninitialized;
        }, Device: h.Device, getDevices: (e2 = false) => h.Device.getDevices({ audioinput: true, audiooutput: true, videoinput: true, requestPerm: e2 }), getCameras: (e2 = false) => h.Device.getCameras(e2), getMicrophones: (e2 = false) => h.Device.getMicrophones(e2), getSpeakers: (e2 = false) => h.Device.getSpeakers(e2), checkSystemRequirements: g.checkSystemRequirements, getSupportedCodec: async () => await R.getSupportedCodecs(), checkBrowserCompatibility: async () => await b.checkBrowserCompatibility(), getHandler: () => u.detectDevice(), _geofenceArea: T.geofenceArea, getParameters: p.getParameters, destroy(e2) {
          let t2 = e2 || E;
          t2 && t2.destroy(), e2 || (E = null);
        }, PlatformTypeMap: m.PlatformTypeMap, CHAT_VIDEO_FRAME_RATE_NORMAL: l.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_NORMAL, CHAT_VIDEO_FRAME_RATE_5: l.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_5, CHAT_VIDEO_FRAME_RATE_10: l.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_10, CHAT_VIDEO_FRAME_RATE_15: l.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_15, CHAT_VIDEO_FRAME_RATE_20: l.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_20, CHAT_VIDEO_FRAME_RATE_25: l.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_25, CHAT_VIDEO_FRAME_RATE_30: l.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_30, VIDEO_QUALITY_180p: l.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_180p, VIDEO_QUALITY_480p: l.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_480p, VIDEO_QUALITY_720p: l.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_720p, VIDEO_QUALITY_1080p: l.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_1080p, RECORD_VIDEO_QUALITY_360p: l.NERTC_RECORD_VIDEO_QUALITY.RECORD_VIDEO_QUALITY_360p, RECORD_VIDEO_QUALITY_480p: l.NERTC_RECORD_VIDEO_QUALITY.RECORD_VIDEO_QUALITY_480p, RECORD_VIDEO_QUALITY_720p: l.NERTC_RECORD_VIDEO_QUALITY.RECORD_VIDEO_QUALITY_720p, RECORD_VIDEO_FRAME_RATE_15: l.NERTC_RECORD_VIDEO_FRAME_RATE.RECORD_VIDEO_FRAME_RATE_15, RECORD_VIDEO_FRAME_RATE_30: l.NERTC_RECORD_VIDEO_FRAME_RATE.RECORD_VIDEO_FRAME_RATE_30, LIVE_STREAM_AUDIO_CODEC_PROFILE: d.LIVE_STREAM_AUDIO_CODEC_PROFILE, LIVE_STREAM_AUDIO_SAMPLE_RATE: d.LIVE_STREAM_AUDIO_SAMPLE_RATE, VIDEO_FRAME_RATE: l.VIDEO_FRAME_RATE, VIDEO_QUALITY: l.NERTC_VIDEO_QUALITY, NETWORK_STATUS: c.NETWORK_STATUS, STREAM_TYPE: l.STREAM_TYPE, VERSION: o.SDK_VERSION, BUILD: o.BUILD, ENV: o.ENV }, t.default = t.NERTC, e.exports = A.WebRTC2 = t.NERTC;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Client = void 0;
        const n = i(26), d = i(69), c = i(76), l = i(145), u = i(215), h = i(1), p = i(147), m = i(47), g = i(48), f = o(i(6)), v = o(i(8)), S = i(216), y = i(49), _ = i(217), R = i(308), b = i(43), T = i(149), E = a(i(7));
        class A extends _.Base {
          constructor(e2) {
            super(e2), this.destroyed = false, this.outOfConnect = false, this.onJoinFinish = null, this.spatialManager = null, this.outputDeviceId = "default", this.__v_skip = h.getParameters().enableVSkip, this.apiFrequencyControl({ name: "createClient", code: 0, param: { clientUid: "", debug: e2.debug } }), this.operationQueue = new S.OperationQueue(this.logger), this.handlePageUnload = (e3) => {
              "join" !== this.adapterRef.channelStatus && "connectioning" !== this.adapterRef.channelStatus || (this.logger.warn(`收到 ${null == e3 ? void 0 : e3.type} 事件，当前状态：${this.adapterRef.channelStatus}，即将离开房间`), this.leave(f.default.PAGE_UNLOAD));
            }, this.handleOnOnline = (e3) => {
              var t2;
              const i2 = { cmd: "onOnline", data: { type: e3.type } };
              null === (t2 = this.adapterRef.signalProbeManager.worker) || void 0 === t2 || t2.postMessage(i2);
            }, this.handleOnOffline = (e3) => {
            }, this.handleUnhandledRejection = (e3) => {
              this.logger.warn(`Exception caught => type: ${e3.type}, reason: ${e3.reason}`), this.apiFrequencyControl({ name: "exception", code: 0, param: { clientUid: "", type: e3.type, reason: e3.reason } });
            }, h.getParameters().leaveOnUnload && (window.addEventListener("pagehide", this.handlePageUnload), window.addEventListener("beforeunload", this.handlePageUnload)), h.getParameters().trustOnOnline && window.addEventListener("online", this.handleOnOnline), h.getParameters().trustOnOffline && window.addEventListener("offline", this.handleOnOffline), h.getParameters().trustUnhandledrejection && window.addEventListener("unhandledrejection", this.handleUnhandledRejection), this._roleInfo = { userRole: 0, audienceList: {} }, this._init(e2), this.logger.info(`NERTC ${n.SDK_VERSION} ${n.BUILD}: 客户端创建成功。`), this.on("@connection-state-change", (e3) => {
              var t2, i2, r2;
              "CONNECTED" === e3.prevState && (null === (t2 = this.recordManager.record) || void 0 === t2 ? void 0 : t2._status.isRecording) && "started" === (null === (i2 = this.recordManager.record) || void 0 === i2 ? void 0 : i2._status.state) && (this.logger.log("自动停止客户端录制功能"), this.recordManager.record.download()), "CONNECTED" === e3.curState && "CONNECTING" === e3.prevState && (e3.reconnect && this.adapterRef.lbsManager.startUpdate("reconnect"), (null === (r2 = this.adapterRef.datareportCache) || void 0 === r2 ? void 0 : r2.length) && (this.logger.log(`上报进频道前事件：${this.adapterRef.datareportCache.length}条: ${this.adapterRef.datareportCache.map((e4) => e4.func).join()}`), this.adapterRef.datareportCache.forEach((e4) => {
                const t3 = e4.datareport[e4.func];
                t3 && (t3.cid = t3.cid || this.adapterRef.channelInfo.cid, t3.uid = t3.uid || this.adapterRef.channelInfo.uid), e4.datareport.send();
              }), this.adapterRef.datareportCache = []));
            }), this.on("@media-stats-change", (e3) => {
              let t2 = false, i2 = { profile: b.getCurrentProfileLevel() };
              e3.data.forEach((e4) => {
                var r2;
                "video" !== e4.mediaType && "screen" !== e4.mediaType || (null === (r2 = e4.new) || void 0 === r2 ? void 0 : r2.CodecImplementationName) && (i2[`${e4.mediaType}_${e4.streamType}`] = e4.new.CodecImplementationName, "unknown" !== e4.new.CodecImplementationName && (e4.old && e4.old.CodecImplementationName === e4.new.CodecImplementationName || (this.logger.log(`CodecImplementationName ${e4.streamType} ${e4.mediaType} ${e4.new.CodecImplementationName}`), t2 = true)));
              }), t2 && this.apiFrequencyControl({ name: "CodecImplementationName", code: 0, param: i2 });
            });
          }
          _init(e2) {
            const { appkey: t2 = "", token: i2 } = e2;
            this._params.appkey = t2, this.adapterRef.lbsManager.loadBuiltinConfig("oninit"), this._params.token = i2, this._roleInfo = { userRole: 0, audienceList: {} }, c.Device.deviceInited || c.Device.startDeviceChangeDetection(), c.Device.on("recording-device-changed", (e3) => {
              this.destroyed || (this.safeEmit("recording-device-changed", e3), this.adapterRef.instance.apiEventReport("setUserCustomEvent", { name: "recording-device-changed", customIdentify: "client", param: JSON.stringify(e3, null, " ") }));
            }), c.Device.on("camera-changed", (e3) => {
              this.destroyed || (this.safeEmit("camera-changed", e3), this.adapterRef.instance.apiEventReport("setUserCustomEvent", { name: "camera-changed", customIdentify: "client", param: JSON.stringify(e3, null, " ") }));
            }), c.Device.on("playout-device-changed", (e3) => {
              this.destroyed || (this.safeEmit("playout-device-changed", e3), this.adapterRef.instance.apiEventReport("setUserCustomEvent", { name: "playout-device-changed", customIdentify: "client", param: JSON.stringify(e3, null, " ") }));
            }), c.Device.on("device-open-fail", (e3) => {
              this.destroyed || this.safeEmit("device-open-fail", e3);
            }), c.Device.on("unknown-display-surface", (e3) => {
              this.destroyed || this.safeEmit("displaySurfaceUnknown", e3);
            });
            const r2 = () => {
              this.onJoinFinish ? (this.onJoinFinish(), this.onJoinFinish = null) : this.logger.debug("孤立的join完成回调");
            };
            this.addListener("@pairing-join-success", r2), this.addListener("@pairing-join-error", r2), "never" !== h.getParameters().enableAlerter && c.alerter.watchClient(this.adapterRef.instance), document.addEventListener("visibilitychange", this._onVisibilityChange.bind(this)), this.eventCacheReport();
          }
          getUid() {
            return this.adapterRef.channelInfo && this.adapterRef.channelInfo.uid;
          }
          getParameter(e2 = "getChannelInfo") {
            if (this.apiFrequencyControl({ name: "getParameter", code: 0, param: { type: e2 } }), "getChannelInfo" === e2) {
              const e3 = `appkey=${this._params.appkey}&osType=4&mode=2&netType=0&version=${n.SDK_VERSION + ".0"}&webrtc=1&nrtcg2=1&t1=${Date.now()}`, t2 = { "Content-Type": "application/x-www-form-urlencoded" };
              return JSON.stringify({ postData: e3, header: t2 });
            }
          }
          getChannelInfo() {
            return this.apiFrequencyControl({ name: "getChannelInfo", code: 0, param: { clientUid: this.adapterRef.channelInfo.uid || "" } }), this.adapterRef.channelInfo || {};
          }
          startProxyServer(e2) {
            let t2 = null;
            if (this.adapterRef.logger.log("startProxyServer()"), "join" !== this.adapterRef.channelStatus && "connectioning" !== this.adapterRef.channelStatus || (this.adapterRef.logger.warn("startProxyServer() 请在加入房间前调用"), t2 = "startProxyServer() 请在加入房间前调用"), this.apiFrequencyControl({ name: "startProxyServer", code: t2 ? -1 : 0, param: { clientUid: this.adapterRef.channelInfo.uid || "", reason: t2 } }), t2) throw new v.default({ code: f.default.API_CALL_SEQUENCE_BEFORE_ERROR, message: "startProxyServer() 请在加入房间前调用" });
            this.adapterRef.proxyServer.enable = true, e2 && (this.adapterRef.proxyServer.type = e2);
          }
          stopProxyServer() {
            this.adapterRef.logger.log("stopProxyServer()"), this.adapterRef.proxyServer && (this.adapterRef.proxyServer.enable = false, this.adapterRef.proxyServer.wsProxyArray = null), this.apiFrequencyControl({ name: "stopProxyServer", code: 0, param: { clientUid: this.adapterRef.channelInfo.uid || "", reason: "" } });
          }
          setLocalMediaPriority(e2) {
            this.logger.log("setLocalMediaPriority() options: ", JSON.stringify(e2));
            let t2 = 0, i2 = "";
            "join" !== this.adapterRef.channelStatus && "connectioning" !== this.adapterRef.channelStatus || (i2 = "setLocalMediaPriority() 请在加入房间前调用", t2 = f.default.API_CALL_SEQUENCE_BEFORE_ERROR), 100 !== e2.priority && 50 !== e2.priority && (i2 = "setLocalMediaPriority: options.priority应该是100或者50", t2 = f.default.SET_LOCAL_MEDIA_PRIORITY_ARGUMENT_ERROR);
            const { priority: r2 = 100, preemtiveMode: s2 = false } = e2;
            if (this.apiFrequencyControl({ name: "setLocalMediaPriority", code: t2 ? -1 : 0, param: { clientUid: this.adapterRef.channelInfo.uid || "", priority: r2, preemtiveMode: s2, reason: t2, message: i2 } }), t2) throw this.logger.error(i2), new v.default({ code: t2, message: i2 });
            this.adapterRef.userPriority = e2;
          }
          async join(e2) {
            this.logger.log("join() 加入频道, options: ", JSON.stringify(e2, null, " ")), this.adapterRef.instance.outOfConnect = false;
            let t2 = null;
            try {
              if (!e2.channelName || "" === e2.channelName) throw this.logger.log("join() 请填写房间名称"), new v.default({ code: f.default.JOIN_WITHOUT_CHANNEL_NAME, message: "join() 请填写房间名称" });
              if (e2.joinChannelRecordConfig && (y.checkValidBoolean({ tag: "joinOptions.joinChannelRecordConfig.recordAudio should be boolean", value: e2.joinChannelRecordConfig.recordAudio }), y.checkValidBoolean({ tag: "joinOptions.joinChannelRecordConfig.recordVideo should be boolean", value: e2.joinChannelRecordConfig.recordVideo })), "string" == typeof e2.uid) {
                if (this.logger.log("join() uid 是 string 类型"), !/^[1-9]\d*$/.test(e2.uid)) throw this.logger.log("join() uid 不是数字字符串格式"), new v.default({ code: f.default.JOIN_UID_TYPE_ERROR, message: "join() uid 不是数字字符串格式" });
                this.adapterRef.channelInfo.uidType = "string";
              } else {
                if ("number" != typeof e2.uid) return this.logger.error("join() uid 参数格式非法"), Promise.reject(new v.default({ code: f.default.JOIN_UID_TYPE_ERROR, message: "join() uid 参数格式非法" }));
                if (this.logger.log("join() uid 是 number类型"), this.adapterRef.channelInfo.uidType = "number", e2.uid > Number.MAX_SAFE_INTEGER) throw this.logger.error("join() uid 参数越界, 会导致精度缺失"), new v.default({ code: f.default.JOIN_UID_TYPE_ERROR, message: "join() Number 类型的 uid 最大值是 2^53 - 1, 请输入正确的参数" });
              }
              if (e2.mixRemoteAudioStream && (this.logger.log("join() 开启远端音频流混流"), this.adapterRef.enableMixAudio = true), this.onJoinFinish = await this.operationQueue.enqueue({ caller: this, method: "join", options: e2 }), this.safeEmit("@pairing-join-start"), "join" === this.adapterRef.channelStatus || "connectioning" === this.adapterRef.channelStatus) return this.safeEmit("@pairing-join-error"), Promise.reject(new v.default({ code: f.default.REPEAT_JOIN_ERROR, message: "join() 重复加入房间" }));
              if (this.adapterRef.connectState.curState = "CONNECTING", this.adapterRef.connectState.prevState = "DISCONNECTED", this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), e2.spatial && this.initSpatialManager(e2.spatial), e2.token && (this._params.token = e2.token), e2.customData && (this.adapterRef.channelInfo.customData = e2.customData), E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION >= 58 && E.ANY_CHROME_MAJOR_VERSION < 69 || T.detectRtcCapabilities().catch((e3) => {
                this.logger.warn("join() detectRtcCapabilities", e3.name, e3.message);
              }), this._params.JoinChannelRequestParam4WebRTC2 = { startJoinTime: Date.now(), appkey: this._params.appkey, userRole: this._roleInfo.userRole, channelName: e2.channelName, wssArr: e2.wssArr, uid: e2.uid, permKey: e2.permKey || "", token: this._params.token, joinChannelLiveConfig: e2.joinChannelLiveConfig || { liveEnable: false }, joinChannelRecordConfig: e2.joinChannelRecordConfig || { recordAudio: false, recordVideo: false, recordType: 0, isHostSpeaker: false }, getChanneInfoResponse: e2.getChanneInfoResponse }, e2.neRtcServerAddresses && (h.getParameters().signalProbeEnabled = false, this._params.neRtcServerAddresses = { channelServer: e2.neRtcServerAddresses.channelServer || "", statisticsServer: e2.neRtcServerAddresses.statisticsServer || "", statisticsWebSocketServer: e2.neRtcServerAddresses.statisticsWebSocketServer || "", roomServer: e2.neRtcServerAddresses.roomServer || "", webSocketProxyServer: e2.neRtcServerAddresses.webSocketProxyServer || "", mediaProxyServer: e2.neRtcServerAddresses.mediaProxyServer || "", lbsServer: e2.neRtcServerAddresses.lbsServer || "" }), !h.getParameters().disableLBSService && !h.getParameters().lbsUseBuiltinOnly && (t2 = this.adapterRef.lbsManager.loadLocalConfig("onjoin"), t2.config)) {
                const e3 = t2.config.ts + 1e3 * t2.config.config.ttl - Date.now();
                e3 < 1e3 * t2.config.config.preloadTimeSec && (this.logger.log(`join() LBS在 ${Math.floor(e3 / 1e3)} 秒后过期。preloadTimeSec: ${t2.config.config.preloadTimeSec}。发起异步刷新请求`), this.adapterRef.lbsManager.startUpdate("renew"));
              }
              if (this.setStartSessionTime(), this.initMode(), !this.adapterRef.mediaCapability.supportedCodecRecv || !this.adapterRef.mediaCapability.supportedCodecSend) try {
                await this.adapterRef.mediaCapability.detect();
              } catch (e3) {
                this.logger.warn("join() Failed to detect mediaCapability: ", e3.name, e3.message);
              }
              if (!this.adapterRef._meetings) throw this.logger.error("join() meeting 模块缺失"), this.safeEmit("@pairing-join-error"), new v.default({ code: f.default.UNKNOWN_TYPE_ERROR, message: "join() meeting 模块缺失" });
              const i2 = await this.adapterRef._meetings.joinChannel(this._params.JoinChannelRequestParam4WebRTC2);
              return this.safeEmit("@pairing-join-success"), t2 && !t2.config && this.adapterRef.lbsManager.startUpdate(t2.reason), this.apiFrequencyControl({ name: "join", code: 0, param: Object.assign({}, e2) }), i2;
            } catch (i2) {
              throw this.logger.error("join() 加入房间失败: ", i2.message), this.safeEmit("@pairing-join-error"), t2 && !t2.config && this.adapterRef.lbsManager.startUpdate(t2.reason), this.apiFrequencyControl({ name: "join", code: -1, param: Object.assign(Object.assign({}, e2), { reason: i2 && i2.message }) }), this.stopSession(), i2.getCode ? i2 : new v.default({ code: f.default.JOIN_FAILED, message: `join() 内部错误: ${i2.name}, ${i2.message}` });
            }
          }
          async leave(e2 = 0) {
            const t2 = await this.operationQueue.enqueue({ caller: this, method: "leave", options: null });
            this.logger.log("leave() 离开频道: ", e2), this.adapterRef.instance.apiEventReport("setLogout", { reason: e2 }), this.apiFrequencyControl({ name: "leave", code: 0, param: { clientUid: this.getUid() } }), this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "DISCONNECTING", this.adapterRef.connectState.reconnect = false, this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: g.ConStateChange_state.ChannelLeave, reason: g.ConStateChange_reason.Leave }), this.setEndSessionTime(), this.adapterRef.asrCaptionConfig.enable && (await this.stopAsrCaptions(), this.adapterRef.asrCaptionConfig = { enable: false, source: "CH", target: "CH" }), this.adapterRef._meetings ? await this.adapterRef._meetings.leaveChannel() : this.adapterRef.connectState = { prevState: "DISCONNECTED", curState: "DISCONNECTED", reconnect: false }, this.adapterRef.audioMixer && this.adapterRef.audioMixer.destroy(), document.removeEventListener("visibilitychange", this._onVisibilityChange.bind(this)), setTimeout(() => {
              this.eventCacheReport();
            }, 500), t2();
          }
          setEncryptionMode(e2) {
            if (y.checkValidInteger({ tag: "Valid encryptionModes are: " + Object.keys(l.EncryptionModes).join(","), value: l.encryptionModeToInt(e2) }), this.adapterRef.encryption.encodedInsertableStreams) {
              const e3 = "setEncryptionMode() 自定义加密功能与国密加密功能不兼容";
              throw this.logger.error(e3), new v.default({ code: f.default.SET_ENCRYPTION_MODE_ERROR, message: e3 });
            }
            this.logger.log("setEncryptionMode() 设置加密模式：", e2), this.adapterRef.encryption.setEncryptionMode(e2);
            const t2 = { enable: "none" !== e2, mode: l.encryptionModeToInt(e2) };
            this.apiFrequencyControl({ name: "setEncryptionMode", code: 0, param: JSON.stringify(t2, null, " ") });
          }
          setEncryptionSecret(e2) {
            switch (this.adapterRef.encryption.encryptionMode) {
              case "none":
                throw new v.default({ code: f.default.SET_ENCRYPTION_SECRET_INVALID_OPERATION_ERROR, message: "setEncryptionSecret() 请先设置加密模式" });
              case "sm4-128-ecb":
                y.checkValidString({ tag: "client.setEncryptionSecret:encryptionSecret", value: e2, min: 1, max: 128 });
            }
            this.logger.log("设置加密密钥"), this.adapterRef.encryption.setEncryptionSecret(e2), this.apiFrequencyControl({ name: "setEncryptionSecret", code: 0, param: JSON.stringify({ encryptionSecret: e2 }, null, " ") });
          }
          enableCustomTransform(e2) {
            var t2;
            let i2, r2;
            if ("DISCONNECTED" !== this.adapterRef.connectState.curState ? (i2 = "enableCustomTransform() 必须在加入频道前调用", r2 = f.default.API_CALL_SEQUENCE_BEFORE_ERROR) : "function" != typeof window.TransformStream ? (i2 = "enableCustomTransform() 浏览器不支持自定义加密, TransformStream 未找到", r2 = f.default.CUSTOM_TRANSFOR_NOT_SUPPORT_ERROR) : "function" != typeof (null === (t2 = window.RTCRtpReceiver) || void 0 === t2 ? void 0 : t2.prototype.createEncodedStreams) ? (i2 = "enableCustomTransform() 浏览器不支持自定义加解密，未找到createEncodedStreams", r2 = f.default.CUSTOM_TRANSFOR_NOT_SUPPORT_ERROR) : "none" !== this.adapterRef.encryption.encryptionMode && (i2 = "enableCustomTransform() 自定义加密功能与国密加密功能不兼容", r2 = f.default.SET_ENCRYPTION_MODE_ERROR), this.apiFrequencyControl({ name: "enableCustomTransform", code: i2 ? -1 : 0, param: JSON.stringify({ enable: e2, message: i2 }) }), i2) throw this.logger.error(i2), new v.default({ code: r2, message: i2 });
            false === e2 ? (this.adapterRef.encryption.encodedInsertableStreams = false, this.logger.log("enableCustomTransform() 已关闭自定义加解密")) : (this.adapterRef.encryption.encodedInsertableStreams = true, this.logger.log("enableCustomTransform() 已开启自定义加解密"));
          }
          async publish(e2, t2 = "all") {
            y.checkExists({ tag: "client.publish:stream", value: e2 }), await this.doPublish(e2, t2);
          }
          async doPublish(e2, t2) {
            const i2 = await this.operationQueue.enqueue({ caller: this, method: "publish", options: e2 });
            let r2 = 0, s2 = "";
            const a2 = () => {
              var t3, a3;
              i2();
              const o2 = { reason: r2, message: s2, profileLevel: b.getCurrentProfileLevel(), pubStatus: e2.pubStatus };
              (e2.mediaHelper.video.cameraTrack || e2.mediaHelper.video.videoSource) && (o2.webcamProducerCodec = null === (t3 = this.adapterRef._mediasoup) || void 0 === t3 ? void 0 : t3._webcamProducerCodec), (e2.mediaHelper.screen.screenVideoTrack || e2.mediaHelper.screen.screenVideoSource) && (o2.screenProducerCodec = null === (a3 = this.adapterRef._mediasoup) || void 0 === a3 ? void 0 : a3._screenProducerCodec), this.apiFrequencyControl({ name: "publish", code: r2 ? -1 : 0, param: JSON.stringify(o2) });
              const n2 = JSON.stringify(e2.mediaHelper.getTrackSettings());
              this.apiFrequencyControl({ name: "_trackSettings", code: 0, param: n2 }), this.adapterRef.instance.apiEventReport("setUserCustomEvent", { name: "media_track_Settings", customIdentify: "publish", param: n2 });
            };
            if (e2 && (e2.audio || e2.video || e2.screen || e2.screenAudio) ? 1 === this._roleInfo.userRole ? (s2 = "publish() 观众禁止Publish, 请先使用setClientRole设为主播", this.logger.error(s2), r2 = f.default.PUBLISH_ROLE_ERROR) : "CONNECTING" === this.adapterRef.connectState.curState ? (s2 = "publish() 当前正在连接, 将在连接成功后发布媒体流", this.bindLocalStream(e2), r2 = f.default.RECONNECTING) : "CONNECTED" !== this.adapterRef.connectState.curState && (s2 = "publish() 当前不在频道中, 可能是没有加入频道或者是网络波动导致暂时断开连接", this.logger.error(s2), r2 = f.default.API_CALL_SEQUENCE_BEFORE_ERROR) : e2 && h.getParameters().allowEmptyMedia ? this.logger.log("publish() 当前模式允许发布没有媒体流的localStream") : (s2 = "publish() 传入的 stream 格式非法，没有媒体数据", this.logger.error(s2), r2 = f.default.PUBLISH_NO_STREAM), r2) return s2 ? (a2(), Promise.reject(new v.default({ code: r2, message: s2 }))) : void a2();
            try {
              if (!this.adapterRef._mediasoup) throw s2 = "publish() 媒体mediasoup模块缺失", r2 = f.default.UNKNOWN_TYPE_ERROR, this.logger.error(s2), a2(), new v.default({ code: r2, message: s2 });
              this.bindLocalStream(e2);
              try {
                e2.logger.log("publish() 发布音视频: ", e2.getId(), t2), await this.adapterRef._mediasoup.createProduce(e2, t2);
              } catch (e3) {
                this.logger.error("publish() createProduce error: ", e3);
              }
              a2();
            } catch (e3) {
              throw this.logger.error("publish() 内部错误: ", e3.name, e3.message), r2 = f.default.UNKNOWN_TYPE_ERROR, s2 = e3.message, a2(), e3.getCode ? e3 : new v.default({ code: r2, message: `publish() 内部错误: ${e3.name}, ${e3.message}` });
            }
          }
          async unpublish(e2, t2) {
            y.checkExists({ tag: "client.unpublish:stream", value: e2 });
            const i2 = await this.operationQueue.enqueue({ caller: this, method: "unpublish", options: null }), r2 = () => {
              i2();
              JSON.stringify({ pubStatus: e2 && e2.pubStatus, reason: s2, message: a2 }, null, " ");
              this.apiFrequencyControl({ name: "unpublish", code: s2 ? -1 : 0, param: { clientUid: this.getUid(), pubStatus: e2 && e2.pubStatus, reason: s2, mediaType: t2 } });
            };
            let s2 = 0, a2 = "";
            if ("CONNECTING" === this.adapterRef.connectState.curState ? (this.adapterRef.localStream = null, a2 = "unpublish() 当前正在连接, 连接成功后将不再发送媒体流", s2 = f.default.RECONNECTING) : "CONNECTED" !== this.adapterRef.connectState.curState && (a2 = "unpublish() 当前不在频道中, 可能是没有加入频道或者是网络波动导致暂时断开连接", this.logger.error(a2), s2 = f.default.API_CALL_SEQUENCE_BEFORE_ERROR), s2) return r2(), a2 ? (this.logger.error(a2), Promise.reject(new v.default({ code: s2, message: a2 }))) : void 0;
            this.logger.log("unpublish(): 开始取消发布本地流", t2);
            try {
              if (!this.adapterRef._mediasoup) throw a2 = "unpublish() 媒体mediasoup模块缺失", s2 = f.default.UNKNOWN_TYPE_ERROR, this.logger.error(a2), r2(), new v.default({ code: s2, message: a2 });
              t2 && "all" !== t2 ? await this.adapterRef._mediasoup.destroyProduce(t2) : (await this.adapterRef._mediasoup.destroyProduce("audio"), await this.adapterRef._mediasoup.destroyProduce("audioSlave"), await this.adapterRef._mediasoup.destroyProduce("video"), await this.adapterRef._mediasoup.destroyProduce("screen"), this.adapterRef.localStream = null), r2();
            } catch (e3) {
              throw this.logger.error("unpublish() 内部错误: ", e3.name, e3.message), s2 = f.default.UNKNOWN_TYPE_ERROR, a2 = e3.message, r2(), e3.getCode ? e3 : new v.default({ code: s2, message: `unpublish() 内部错误: ${e3.name}, ${e3.message}` });
            }
          }
          getSubStatus(e2, t2) {
            let i2 = { status: "unsubscribed", subscribable: false };
            if ("all" === t2) {
              const t3 = [this.getSubStatus(e2, "audio"), this.getSubStatus(e2, "audioSlave"), this.getSubStatus(e2, "video"), this.getSubStatus(e2, "screen")];
              t3.find((e3) => "unsubscribing" === e3.status) ? i2.status = "unsubscribing" : t3.find((e3) => "subscribing" === e3.status) && (i2.status = "subscribing"), t3.find((e3) => "subscribed" === e3.status) && (i2.status = "subscribed"), "subscribed" !== i2.status && "unsubscribed" !== i2.status || t3.find((e3) => e3.subscribable) && (i2.subscribable = true);
            } else "start" === e2.pubStatus[t2].stopconsumerStatus ? i2.status = "unsubscribing" : "start" === e2.pubStatus[t2].consumerStatus ? i2.status = "subscribing" : e2.pubStatus[t2].consumerId ? i2.status = "subscribed" : "unsubscribed" === i2.status && e2.pubStatus[t2].producerId && e2.subConf[t2] && (i2.subscribable = true);
            return i2;
          }
          async subscribe(e2, t2) {
            if (!this.spatialManager) return y.checkExists({ tag: "client.subscribe:stream", value: e2 }), t2 ? (this.logger.log(`subscribe [订阅远端: ${e2.stringStreamID}] ${JSON.stringify(t2)}`), e2.doSetSubscribeConfig(t2), this.doSubscribe(e2)) : (this.logger.log(`subscribe() [订阅远端: ${e2.stringStreamID}]`), this.doSubscribe(e2));
            this.logger.warn("subscribe() 已开启空间音频，跳过用户订阅步骤");
          }
          async doSubscribe(e2) {
            var t2, i2, r2, s2, a2, o2, n2, c2, l2, u2;
            const h2 = e2.getId();
            if (!this.adapterRef._mediasoup) {
              const e3 = "subscribe() 媒体mediasoup模块缺失";
              throw this.logger.error(e3), new v.default({ code: f.default.UNKNOWN_TYPE_ERROR, message: e3 });
            }
            let p2 = { audio: e2.subConf.audio, audioSlave: e2.subConf.audioSlave, video: e2.subConf.video, screen: e2.subConf.screen };
            try {
              if (e2.subConf.audio) false === (null === (t2 = this.adapterRef.permKeyInfo) || void 0 === t2 ? void 0 : t2.subAudioRight) ? (this.logger.error("subscribe() permKey权限控制，没有权限订阅audio"), this.adapterRef.instance.emit("error", "no-subscribe-audio-permission")) : e2.pubStatus.audio.audio && !e2.pubStatus.audio.consumerId && (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69 ? this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 音频流`) : (this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 音频流`), e2.pubStatus.audio.consumerStatus = "start", await this.adapterRef._mediasoup.createConsumer(h2, "audio", "audio", e2.pubStatus.audio.producerId), e2.pubStatus.audio.consumerStatus = "end", this.logger.log(`subscribe() 订阅 ${e2.getId()} 音频流完成`)));
              else if (e2.pubStatus.audio.consumerId && "start" !== e2.pubStatus.audio.stopconsumerStatus) if (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69) this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 音频流`);
              else {
                this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 音频流`), e2.pubStatus.audio.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.audio.consumerId, e2, "audio"), this.adapterRef.instance.removeSsrc(e2.getId(), "audio"), e2.mediaHelper.updateStream("audio", null), e2.pubStatus.audio.consumerId = "", e2.stop("audio"), e2.pubStatus.audio.stopconsumerStatus = "end", e2.subStatus.audio = false;
                const t3 = e2.getId();
                t3 && delete this.adapterRef.remoteAudioStats[t3], this.logger.log(`subscribe() 取消订阅 ${e2.getId()} 音频流完成`);
              }
              else this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} audio流, consumerId: ${e2.pubStatus.audio.consumerId}, stopconsumerStatus: {stream.pubStatus.audio.stopconsumerStatus}`);
              if (e2.subConf.audioSlave) false === (null === (i2 = this.adapterRef.permKeyInfo) || void 0 === i2 ? void 0 : i2.subAudioRight) ? (this.logger.error("subscribe() permKey权限控制，没有权限订阅audio slave"), this.adapterRef.instance.emit("error", "no-subscribe-audio-slave-permission")) : e2.pubStatus.audioSlave.audioSlave && !e2.pubStatus.audioSlave.consumerId && (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69 ? this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 音频辅流`) : (this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 音频辅流`), e2.pubStatus.audioSlave.consumerStatus = "start", await this.adapterRef._mediasoup.createConsumer(h2, "audio", "audioSlave", e2.pubStatus.audioSlave.producerId), e2.pubStatus.audioSlave.consumerStatus = "end", this.logger.log(`subscribe() 订阅 ${e2.getId()} 音频辅流完成`)));
              else if (e2.pubStatus.audioSlave.consumerId && "start" !== e2.pubStatus.audioSlave.stopconsumerStatus) if (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69) this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 音频辅流`);
              else {
                this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 音频辅流`), e2.pubStatus.audioSlave.stopconsumerStatus = "start", await (null === (r2 = this.adapterRef._mediasoup) || void 0 === r2 ? void 0 : r2.destroyConsumer(e2.pubStatus.audioSlave.consumerId, e2, "audioSlave")), this.adapterRef.instance.removeSsrc(e2.getId(), "audioSlave"), e2.mediaHelper.updateStream("audioSlave", null), e2.pubStatus.audioSlave.consumerId = "", e2.stop("audioSlave"), e2.pubStatus.audioSlave.stopconsumerStatus = "end", e2.subStatus.audioSlave = false;
                const t3 = e2.getId();
                t3 && delete this.adapterRef.remoteAudioSlaveStats[t3], this.logger.log("subscribe() 取消订阅 ${stream.getId()} 音频辅流完成");
              }
              else this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} audioSlave流, consumerId: ${e2.pubStatus.audioSlave.consumerId}, stopconsumerStatus: {stream.pubStatus.audioSlave.stopconsumerStatus}`);
              if (e2.subConf.video) if (false === (null === (s2 = this.adapterRef.permKeyInfo) || void 0 === s2 ? void 0 : s2.subVideoRight)) this.logger.error("subscribe() permKey权限控制，没有权限订阅video"), this.adapterRef.instance.emit("error", "no-subscribe-video-permission");
              else if (e2.pubStatus.video.video && !e2.pubStatus.video.consumerId) if (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69) this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 视频流`);
              else {
                let t3;
                this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 视频流`), t3 = e2.subConf.highOrLow.video === d.STREAM_TYPE.LOW ? 0 : 1, await this.adapterRef._mediasoup.createConsumer(h2, "video", "video", e2.pubStatus.video.producerId, t3), this.logger.log(`subscribe() 订阅 ${e2.getId()} 视频流完成`);
              }
              else this.logger.log("subscribe() stream.pubStatus.video: ", JSON.stringify(e2.pubStatus.video));
              else e2.pubStatus.video.consumerId && "start" !== e2.pubStatus.video.stopconsumerStatus ? E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69 ? this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 视频流`) : (this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 视频流`), e2.pubStatus.video.stopconsumerStatus = "start", await (null === (a2 = this.adapterRef._mediasoup) || void 0 === a2 ? void 0 : a2.destroyConsumer(e2.pubStatus.video.consumerId, e2, "video")), this.adapterRef.instance.removeSsrc(e2.getId(), "video"), e2.mediaHelper.updateStream("video", null), e2.pubStatus.video.consumerId = "", e2.stop("video"), e2.pubStatus.video.stopconsumerStatus = "end", e2.subStatus.video = false, this.logger.log(`subscribe() 取消订阅 ${e2.getId()} 视频流完成`)) : this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} video流, consumerId: ${e2.pubStatus.video.consumerId}, stopconsumerStatus: {stream.pubStatus.video.stopconsumerStatus}`);
              if (e2.subConf.screen) {
                if (false === (null === (o2 = this.adapterRef.permKeyInfo) || void 0 === o2 ? void 0 : o2.subVideoRight)) this.logger.error("subscribe() permKey权限控制，没有权利订阅screen"), this.adapterRef.instance.emit("error", "no-subscribe-screen-permission");
                else if (e2.pubStatus.screen.screen && !e2.pubStatus.screen.consumerId) if (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69) this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 辅流`);
                else {
                  let t3;
                  this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 辅流`), t3 = e2.subConf.highOrLow.screen === d.STREAM_TYPE.LOW ? 0 : 1, await this.adapterRef._mediasoup.createConsumer(h2, "video", "screenShare", e2.pubStatus.screen.producerId, t3), this.logger.log(`subscribe() 订阅 ${e2.getId()} 辅流完成`);
                }
              } else if (e2.pubStatus.screen.consumerId && "start" !== e2.pubStatus.screen.stopconsumerStatus) if (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69) this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 辅流`);
              else {
                this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 辅流`), e2.pubStatus.screen.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.screen.consumerId, e2, "screen"), this.adapterRef.instance.removeSsrc(e2.getId(), "screen"), e2.mediaHelper.updateStream("screen", null), e2.pubStatus.screen.consumerId = "", e2.stop("screen"), e2.pubStatus.screen.stopconsumerStatus = "end", e2.subStatus.screen = false;
                const t3 = e2.getId();
                t3 && delete this.adapterRef.remoteScreenStats[t3], this.logger.log(`subscribe() 取消订阅 ${e2.getId()} 辅流完成`);
              }
              else this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} screen流, consumerId: ${e2.pubStatus.screen.consumerId}, stopconsumerStatus: {stream.pubStatus.screen.stopconsumerStatus}`);
              if (e2.subConf.videoThird) if (false === (null === (n2 = this.adapterRef.permKeyInfo) || void 0 === n2 ? void 0 : n2.subVideoRight)) this.logger.error("subscribe() permKey权限控制，没有权限订阅videoThird"), this.adapterRef.instance.emit("error", "no-subscribe-video-permission");
              else if (e2.pubStatus.videoThird.videoThird && !e2.pubStatus.videoThird.consumerId) if (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69) this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 第三路视频流`);
              else {
                let t3;
                this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 第三路视频流`), t3 = e2.subConf.highOrLow.videoThird === d.STREAM_TYPE.LOW ? 0 : 1, await this.adapterRef._mediasoup.createConsumer(h2, "video", "videoThird", e2.pubStatus.videoThird.producerId, t3), this.logger.log(`subscribe() 订阅 ${e2.getId()} 第三路视频流完成`);
              }
              else this.logger.log("subscribe() stream.pubStatus.videoThird: ", JSON.stringify(e2.pubStatus.video));
              else e2.pubStatus.videoThird.consumerId && "start" !== e2.pubStatus.videoThird.stopconsumerStatus ? E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69 ? this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 第三路视频流`) : (this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 第三路视频流`), e2.pubStatus.videoThird.stopconsumerStatus = "start", await (null === (c2 = this.adapterRef._mediasoup) || void 0 === c2 ? void 0 : c2.destroyConsumer(e2.pubStatus.videoThird.consumerId, e2, "videoThird")), this.adapterRef.instance.removeSsrc(e2.getId(), "videoThird"), e2.mediaHelper.updateStream("videoThird", null), e2.pubStatus.videoThird.consumerId = "", e2.stop("videoThird"), e2.pubStatus.videoThird.stopconsumerStatus = "end", e2.subStatus.videoThird = false, this.logger.log(`subscribe() 取消订阅 ${e2.getId()} 第三路视频流完成`)) : this.logger.log(`subscribe() 开始取消第三路订阅 ${e2.getId()} 视频流, consumerId: ${e2.pubStatus.videoThird.consumerId}, stopconsumerStatus: {stream.pubStatus.videoThird.stopconsumerStatus}`);
              if (e2.subConf.videoFourth) if (false === (null === (l2 = this.adapterRef.permKeyInfo) || void 0 === l2 ? void 0 : l2.subVideoRight)) this.logger.error("subscribe() permKey权限控制，没有权限订阅videoFourth"), this.adapterRef.instance.emit("error", "no-subscribe-video-permission");
              else if (e2.pubStatus.videoFourth.videoFourth && !e2.pubStatus.videoFourth.consumerId) if (E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69) this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 第四路视频流`);
              else {
                let t3;
                this.logger.log(`subscribe() 开始订阅 ${e2.getId()} 第四路视频流`), t3 = e2.subConf.highOrLow.videoFourth === d.STREAM_TYPE.LOW ? 0 : 1, await this.adapterRef._mediasoup.createConsumer(h2, "video", "videoFourth", e2.pubStatus.videoFourth.producerId, t3), this.logger.log(`subscribe() 订阅 ${e2.getId()} 第四路视频流完成`);
              }
              else this.logger.log("subscribe() stream.pubStatus.videoFourth: ", JSON.stringify(e2.pubStatus.video));
              else e2.pubStatus.videoFourth.consumerId && "start" !== e2.pubStatus.videoFourth.stopconsumerStatus ? E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69 ? this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 第四路视频流`) : (this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 第四路视频流`), e2.pubStatus.videoFourth.stopconsumerStatus = "start", await (null === (u2 = this.adapterRef._mediasoup) || void 0 === u2 ? void 0 : u2.destroyConsumer(e2.pubStatus.videoFourth.consumerId, e2, "videoFourth")), this.adapterRef.instance.removeSsrc(e2.getId(), "videoFourth"), e2.mediaHelper.updateStream("videoFourth", null), e2.pubStatus.videoFourth.consumerId = "", e2.stop("videoFourth"), e2.pubStatus.videoFourth.stopconsumerStatus = "end", e2.subStatus.videoFourth = false, this.logger.log(`subscribe() 取消订阅 ${e2.getId()} 第四路视频流完成`)) : this.logger.log(`subscribe() 开始取消订阅 ${e2.getId()} 第四路视频流, consumerId: ${e2.pubStatus.videoFourth.consumerId}, stopconsumerStatus: {stream.pubStatus.videoFourth.stopconsumerStatus}`);
              E.ANY_CHROME_MAJOR_VERSION && E.ANY_CHROME_MAJOR_VERSION < 69 && await this.adapterRef._mediasoup.createConsumer69(h2, e2, p2, e2.pubStatus), this.apiFrequencyControl({ name: "subscribe", code: 0, param: JSON.stringify({ reason: "", subStatus: e2.subStatus, subConf: e2.subConf, pubStatus: e2.pubStatus }, null, " ") });
            } catch (t3) {
              if ("resetConsumeRequestStatus" === t3) return void this.logger.warn("subscribe() API调用被打断");
              throw this.logger.error("subscribe() 内部错误: ", t3.message), this.apiFrequencyControl({ name: "subscribe", code: -1, param: JSON.stringify({ reason: t3.message, subStatus: e2.subStatus, subConf: e2.subConf, pubStatus: e2.pubStatus }, null, " ") }), t3.getCode ? t3 : new v.default({ code: f.default.UNKNOWN_TYPE_ERROR, message: `subscribe() 内部错误: ${t3.name}, ${t3.message}` });
            }
          }
          async unsubscribe(e2, t2) {
            if (y.checkExists({ tag: "client.unsubscribe:stream", value: e2 }), !t2) return this.logger.log(`unsubscribe() [取消订阅远端: ${e2.getId()}]`), this.doUnsubscribe(e2);
            {
              y.checkValidObject({ tag: "client.unsubscribe:unsubscribeOptions", value: t2 }), this.logger.log(`unsubscribe ${e2.getId()} ${JSON.stringify(t2)}`);
              const i2 = { audio: e2.subConf.audio, audioSlave: e2.subConf.audioSlave, video: e2.subConf.video, screen: e2.subConf.screen, videoThird: e2.subConf.videoThird, videoFourth: e2.subConf.videoFourth };
              g.MediaTypeList.forEach((e3) => {
                true === t2[e3] && (i2[e3] = false);
              }), e2.doSetSubscribeConfig(i2), this.doSubscribe(e2);
            }
          }
          async doUnsubscribe(e2, t2) {
            if (!this.adapterRef._mediasoup) {
              const e3 = "unsubscribe() 媒体mediasoup模块缺失";
              throw this.logger.error(e3), new v.default({ code: f.default.UNKNOWN_TYPE_ERROR, message: e3 });
            }
            try {
              if ((void 0 === t2 || "audio" === t2) && e2.pubStatus.audio.consumerId && "start" !== e2.pubStatus.audio.stopconsumerStatus) {
                this.logger.log(`unsubscribe() [开始取消订阅 ${e2.getId()}] 的音频流`), e2.pubStatus.audio.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.audio.consumerId, e2, "audio"), this.adapterRef.instance.removeSsrc(e2.getId(), "audio"), e2.mediaHelper.updateStream("audio", null), e2.pubStatus.audio.consumerId = "", e2.stop("audio"), e2.pubStatus.audio.stopconsumerStatus = "end", e2.subStatus.audio = false;
                const t3 = e2.getId();
                t3 && delete this.adapterRef.remoteAudioStats[t3], this.logger.log(`unsubscribe() [取消订阅 ${e2.getId()}] 的音频流完成`);
              }
              if ((void 0 === t2 || "audioSlave" === t2) && e2.pubStatus.audioSlave.consumerId && "start" !== e2.pubStatus.audioSlave.stopconsumerStatus) {
                this.logger.log(`unsubscribe() [开始取消订阅 ${e2.getId()}] 的音频辅流`), e2.pubStatus.audioSlave.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.audioSlave.consumerId, e2, "audioSlave"), this.adapterRef.instance.removeSsrc(e2.getId(), "audioSlave"), e2.mediaHelper.updateStream("audioSlave", null), e2.pubStatus.audioSlave.consumerId = "", e2.stop("audioSlave"), e2.pubStatus.audioSlave.stopconsumerStatus = "end", e2.subStatus.audioSlave = false;
                const t3 = e2.getId();
                t3 && delete this.adapterRef.remoteAudioSlaveStats[t3], this.logger.log(`unsubscribe() [取消订阅 ${e2.getId()}] 的音频辅流完成`);
              }
              if ((void 0 === t2 || "video" === t2) && e2.pubStatus.video.consumerId && "start" !== e2.pubStatus.video.stopconsumerStatus) {
                this.logger.log(`unsubscribe() [开始取消订阅 ${e2.getId()}] 的视频流`), e2.pubStatus.video.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.video.consumerId, e2, "video"), this.adapterRef.instance.removeSsrc(e2.getId(), "video"), e2.mediaHelper.updateStream("video", null), e2.pubStatus.video.consumerId = "", e2.stop("video"), e2.pubStatus.video.stopconsumerStatus = "end", e2.subStatus.video = false;
                e2.getId();
                this.logger.log(`unsubscribe() [取消订阅 ${e2.getId()}] 的视频流完成`);
              }
              if ((void 0 === t2 || "screen" === t2) && e2.pubStatus.screen.consumerId && "start" !== e2.pubStatus.screen.stopconsumerStatus) {
                this.logger.log(`unsubscribe() [开始取消订阅 ${e2.getId()}] 的视频辅流`), e2.pubStatus.screen.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.screen.consumerId, e2, "screen"), this.adapterRef.instance.removeSsrc(e2.getId(), "screen"), e2.mediaHelper.updateStream("screen", null), e2.pubStatus.screen.consumerId = "", e2.stop("screen"), e2.pubStatus.screen.stopconsumerStatus = "end", e2.subStatus.screen = false;
                const t3 = e2.getId();
                t3 && delete this.adapterRef.remoteScreenStats[t3], this.logger.log(`unsubscribe() [取消订阅 ${e2.getId()}] 的视频辅流完成`);
              }
              if ((void 0 === t2 || "videoThird" === t2) && e2.pubStatus.videoThird.consumerId && "start" !== e2.pubStatus.videoThird.stopconsumerStatus) {
                this.logger.log(`unsubscribe() [开始取消订阅 ${e2.getId()}] 的第三路视频流`), e2.pubStatus.videoThird.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.videoThird.consumerId, e2, "videoThird"), this.adapterRef.instance.removeSsrc(e2.getId(), "videoThird"), e2.mediaHelper.updateStream("videoThird", null), e2.pubStatus.videoThird.consumerId = "", e2.stop("videoThird"), e2.pubStatus.videoThird.stopconsumerStatus = "end", e2.subStatus.videoThird = false;
                e2.getId();
                this.logger.log(`unsubscribe() [取消订阅 ${e2.getId()}] 的第三路视频流完成`);
              }
              if ((void 0 === t2 || "videoFourth" === t2) && e2.pubStatus.videoFourth.consumerId && "start" !== e2.pubStatus.videoFourth.stopconsumerStatus) {
                this.logger.log(`unsubscribe() [开始取消订阅 ${e2.getId()}] 的第四路视频流`), e2.pubStatus.videoFourth.stopconsumerStatus = "start", await this.adapterRef._mediasoup.destroyConsumer(e2.pubStatus.videoFourth.consumerId, e2, "videoFourth"), this.adapterRef.instance.removeSsrc(e2.getId(), "videoFourth"), e2.mediaHelper.updateStream("videoFourth", null), e2.pubStatus.videoFourth.consumerId = "", e2.stop("videoFourth"), e2.pubStatus.videoFourth.stopconsumerStatus = "end", e2.subStatus.videoFourth = false;
                e2.getId();
                this.logger.log(`unsubscribe() [取消订阅 ${e2.getId()}] 的第四路视频流完成`);
              }
              this.apiFrequencyControl({ name: "unsubscribe", code: 0, param: JSON.stringify({ clientUid: this.getUid(), streamId: e2.stringStreamID, reason: "", subStatus: e2.subStatus, subConf: e2.subConf }, null, " ") });
            } catch (t3) {
              throw this.logger.error("unsubscribe() 内部错误:", t3, t3.name, t3.message), this.apiFrequencyControl({ name: "unsubscribe", code: -1, param: JSON.stringify({ clientUid: this.getUid(), streamId: e2.stringStreamID, reason: t3.message, subStatus: e2.subStatus, subConf: e2.subConf }, null, " ") }), t3.getCode ? t3 : new v.default({ code: f.default.UNKNOWN_TYPE_ERROR, message: `unsubscribe() 内部错误: ${t3.name}, ${t3.message}` });
            }
          }
          async setRemoteVideoStreamType(e2, t2) {
            var i2;
            this.logger.log(`setRemoteVideoStreamType() uid ${e2.getId()} 订阅成员的${t2 ? "小" : "大"}流`, t2);
            try {
              await (null === (i2 = this.adapterRef._mediasoup) || void 0 === i2 ? void 0 : i2.setConsumerPreferredLayer(e2, t2 ? 0 : 1, "video")), e2.subConf.highOrLow.video = t2, this.apiFrequencyControl({ name: "setRemoteVideoStreamType", code: 0, param: JSON.stringify({ clientUid: this.getUid(), streamId: e2.stringStreamID, highOrLow: t2 }, null, " ") });
            } catch (i3) {
              throw this.logger.error("setRemoteVideoStreamType() 内部错误: ", i3.message), this.apiFrequencyControl({ name: "setRemoteVideoStreamType", code: -1, param: JSON.stringify({ clientUid: this.getUid(), streamId: e2.stringStreamID, reason: i3.message, highOrLow: t2 }, null, " ") }), i3.getCode ? i3 : new v.default({ code: f.default.UNKNOWN_TYPE_ERROR, message: `setRemoteVideoStreamType() 内部错误: ${i3.name}, ${i3.message}` });
            }
          }
          async setRemoteStreamType(e2, t2, i2) {
            var r2;
            this.logger.log(`setRemoteStreamType() 订阅${e2.getId()}成员${t2}媒体的${t2 ? "小" : "大"}流`);
            try {
              await (null === (r2 = this.adapterRef._mediasoup) || void 0 === r2 ? void 0 : r2.setConsumerPreferredLayer(e2, t2 ? 0 : 1, i2)), e2.subConf.highOrLow[i2] = t2, this.apiFrequencyControl({ name: "setRemoteStreamType", code: 0, param: { highOrLow: t2, mediaType: i2, clientUid: this.getUid(), streamID: e2.stringStreamID } });
            } catch (r3) {
              throw this.logger.error("setRemoteStreamType() 内部错误: ", r3.message), this.apiFrequencyControl({ name: "setRemoteVideoStreamType", code: -1, param: JSON.stringify({ reason: r3.message, highOrLow: t2, mediaType: i2, streamID: e2.stringStreamID }, null, " ") }), r3.getCode ? r3 : new v.default({ code: f.default.UNKNOWN_TYPE_ERROR, message: "setRemoteStreamType() 内部错误: " + r3.message });
            }
          }
          enableAudioVolumeIndicator() {
            this.logger.log("开启音量提醒");
          }
          enableDualStream(e2 = { video: true, screen: false }) {
            this.adapterRef.channelInfo.videoLow = e2.video, this.adapterRef.channelInfo.screenLow = e2.screen, this.logger.log("enableDualStream() 开启双流模式"), this.apiFrequencyControl({ name: "enableDualStream", code: 0, param: { clientUid: this.adapterRef.channelInfo.uid || "", video: e2.video, screen: e2.screen, reason: "" } });
          }
          disableDualStream(e2 = { video: false, screen: false }) {
            this.logger.log("disableDualStream() 关闭双流模式"), this.adapterRef.channelInfo.videoLow = false, this.adapterRef.channelInfo.screenLow = false, this.apiFrequencyControl({ name: "disableDualStream", code: 0, param: { clientUid: this.adapterRef.channelInfo.uid || "", video: e2.video, screen: e2.screen, reason: "" } });
          }
          setPlaybackVolume(e2) {
            let t2, i2;
            if (!Number.isInteger(e2) || e2 < 0 || e2 > 100) t2 = f.default.SET_AUDIO_VOLUME_ARGUMENTS_ERROR, i2 = "setPlaybackVolume() volume 应该为 0 - 100 的整数";
            else {
              const t3 = e2 / 100;
              this.logger.log(`setPlaybackVolume: ${this.adapterRef.nomalizedPlaybackVolume} => ${t3} normalized`), this.adapterRef.nomalizedPlaybackVolume = t3;
            }
            if (this.apiFrequencyControl({ name: "setPlaybackVolume", code: t2 ? -1 : 0, param: { volume: e2 } }), t2) throw this.logger.error(i2), new v.default({ code: t2, message: i2 });
            for (let e3 in this.adapterRef.remoteStreamMap) {
              const t3 = this.adapterRef.remoteStreamMap[e3];
              t3.active && t3._play.updatePlaybackVolume();
            }
          }
          async setClientRole(e2) {
            var t2;
            let i2, r2 = 0, s2 = "";
            if ("host" === e2 || "broadcaster" === e2 ? i2 = 0 : "audience" === e2 ? i2 = 1 : (s2 = "setClientRole() 无法识别的角色：" + e2, this.logger.error(s2), r2 = f.default.ROLE_TYPE_ERROR, i2 = -1), !r2) {
              const a3 = this.adapterRef.channelInfo && this.adapterRef.channelInfo.uid || "";
              if (i2 === this._roleInfo.userRole) this.logger.warn(`setClientRole() 用户${a3}的角色已经是${e2}了`);
              else switch (this.adapterRef.connectState.curState) {
                case "CONNECTED":
                  1 === i2 && this.adapterRef.localStream && this.isPublished(this.adapterRef.localStream) && (this.logger.info(`setClientRole() 主播 ${a3}将设为观众，自动unPublish中`), await this.unpublish(this.adapterRef.localStream));
                  const o2 = await (null === (t2 = this.adapterRef._mediasoup) || void 0 === t2 ? void 0 : t2.updateUserRole(i2));
                  200 !== o2.code ? (r2 = o2.code, s2 = o2.errMsg) : this._roleInfo.userRole !== i2 && (this._roleInfo.userRole = i2, this.logger.info(`setClientRole() 本地用户${a3} 设置角色为 ${e2}`), this.safeEmit("client-role-changed", { role: e2 }));
                  break;
                case "DISCONNECTED":
                  this._roleInfo.userRole !== i2 && (this._roleInfo.userRole = i2, this.logger.info(`setClientRole() 本地用户${a3}设置角色为 ${e2}`), this.safeEmit("client-role-changed", { role: e2 }));
                  break;
                default:
                  s2 = `setClientRole() 本地用户${a3}当前不在频道中，可能是网络波动导致暂时断开连接`, this.logger.error(s2), r2 = f.default.USER_NOT_IN_CHANNEL_ERROR;
              }
            }
            const a2 = { code: r2, message: s2, role: i2 };
            if (this.apiFrequencyControl({ name: "setClientRole", code: r2 ? -1 : 0, param: a2 }), r2) throw new v.default({ code: r2, message: s2 });
          }
          bindLocalStream(e2) {
            this.adapterRef.localStream = e2, e2.client = this, e2.logger.parent = this.logger;
            const t2 = this.getUid();
            t2 && e2.streamID !== t2 && (this.logger.warn("localStream更换streamID", e2.streamID, "=>", t2), e2.streamID = t2, e2.stringStreamID = t2.toString());
          }
          getConnectionState() {
            return this.apiFrequencyControl({ name: "getConnectionState", code: 0, param: JSON.stringify({}, null, " ") }), this.adapterRef.connectState.curState;
          }
          getSystemStats() {
            return navigator.getBattery ? new Promise((e2, t2) => {
              navigator.getBattery().then(function(t3) {
                e2(100 * t3.level);
              });
            }) : Promise.reject(new v.default({ code: f.default.GET_SYSTEM_STATS_NOT_SUPPORT_ERROR, message: "getSystemStats() 浏览器不支持, 建议使用最新版的 Chrome 浏览器" }));
          }
          getSessionStats() {
            return new Promise((e2, t2) => {
              this.adapterRef.sessionStats.Duration = (Date.now() - this.adapterRef.state.startSessionTime) / 1e3, this.adapterRef.sessionStats.UserCount = Object.keys(this.adapterRef.memberMap).length + 1, e2(this.adapterRef.sessionStats);
            });
          }
          getTransportStats() {
            return new Promise((e2, t2) => {
              e2(this.adapterRef.transportStats);
            });
          }
          getLocalAudioStats() {
            var e2, t2;
            let i2 = [];
            return (null === (t2 = null === (e2 = this.adapterRef.localStream) || void 0 === e2 ? void 0 : e2.getSender("audio", "high")) || void 0 === t2 ? void 0 : t2.track) && (i2 = i2.concat(this.adapterRef.localAudioStats)), Promise.resolve(i2);
          }
          getLocalAudioSlaveStats() {
            var e2, t2;
            let i2 = [];
            return (null === (t2 = null === (e2 = this.adapterRef.localStream) || void 0 === e2 ? void 0 : e2.getSender("audioSlave", "high")) || void 0 === t2 ? void 0 : t2.track) && (i2 = i2.concat(this.adapterRef.localAudioSlaveStats)), Promise.resolve(i2);
          }
          getLocalVideoStats(e2) {
            var t2, i2, r2, s2;
            let a2 = [];
            return e2 && "video" !== e2 || (null === (i2 = null === (t2 = this.adapterRef.localStream) || void 0 === t2 ? void 0 : t2.getSender("video", "high")) || void 0 === i2 ? void 0 : i2.track) && (a2 = a2.concat(this.adapterRef.localVideoStats)), e2 && "screen" !== e2 || (null === (s2 = null === (r2 = this.adapterRef.localStream) || void 0 === r2 ? void 0 : r2.getSender("screen", "high")) || void 0 === s2 ? void 0 : s2.track) && (a2 = a2.concat(this.adapterRef.localScreenStats)), Promise.resolve(a2);
          }
          getRemoteAudioStats() {
            return new Promise((e2, t2) => {
              e2(this.adapterRef.remoteAudioStats);
            });
          }
          getRemoteAudioSlaveStats() {
            return new Promise((e2, t2) => {
              e2(this.adapterRef.remoteAudioSlaveStats);
            });
          }
          getRemoteVideoStats(e2) {
            let t2 = {};
            return e2 && "screen" !== e2 || (t2 = Object.assign(t2, this.adapterRef.remoteScreenStats)), e2 && "video" !== e2 || (t2 = Object.assign(t2, this.adapterRef.remoteVideoStats)), Promise.resolve(t2);
          }
          setChannelProfile(e2) {
            const t2 = (null == e2 ? void 0 : e2.mode) || null;
            let i2, r2;
            if (this.logger.log("setChannelProfile, options: ", JSON.stringify(e2, null, " ")), "rtc" !== t2 && "live" !== t2 && (r2 = "setChannelProfile: 参数格式错误", i2 = f.default.SET_CHANNEL_PROFILE_INVALID_PARAMETER_ERROR, this.logger.warn(r2)), "DISCONNECTED" !== this.adapterRef.connectState.curState ? (r2 = "setChannelProfile() 请在加入房间之前调用", i2 = f.default.API_CALL_SEQUENCE_BEFORE_ERROR, this.logger.warn(r2)) : (this.adapterRef.localStream && ("live" === t2 ? this.adapterRef.localStream.audioProfile = "music_standard" : "rtc" === t2 && (this.adapterRef.localStream.audioProfile = "speech_low_quality")), this._params.mode = t2), this.apiFrequencyControl({ name: "setChannelProfile", code: i2 ? -1 : 0, param: { mode: JSON.stringify(e2, null, " "), reason: i2, message: r2 } }), i2) throw new v.default({ code: i2, message: r2 });
          }
          async updatePermKey(e2) {
            var t2;
            try {
              this.logger.log("updatePermKey() permKey: " + e2), this.adapterRef.channelInfo.permKey = e2, await (null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2.updatePermKey(e2)), this.adapterRef.instance.apiFrequencyControl({ name: "updatePermKey", code: 0, param: { permKey: e2 } });
            } catch (t3) {
              throw this.adapterRef.instance.apiFrequencyControl({ name: "updatePermKey", code: t3.code, param: { permKey: e2, reason: t3.message } }), t3;
            }
          }
          async addTasks(e2) {
            var t2;
            const { rtmpTasks: i2 = [] } = e2;
            let r2, s2;
            if (this.logger.log("addTasks() 增加互动直播推流任务, options: ", JSON.stringify(e2)), i2 && Array.isArray(i2) && i2.length ? 1 === this._roleInfo.userRole ? (s2 = "addTasks() 观众角色不允许进行添加推流任务", r2 = f.default.TASKS_ROLE_ERROR) : this.adapterRef._meetings || (s2 = "addTasks() 加入房间后进行添加推流任务", r2 = f.default.API_CALL_SEQUENCE_AFTER_ERROR) : (s2 = "addTasks() 参数格式错误, rtmpTasks为空, 或者该数组长度为空", r2 = f.default.ADD_TASK_PARAMETER_ERROR), r2) throw this.logger.error(s2), this.adapterRef.instance.apiFrequencyControl({ name: "addTasks", code: -1, param: { clientUid: this.getUid(), reason: r2, message: s2 } }), new v.default({ code: r2, message: s2 });
            try {
              await (null === (t2 = this.adapterRef._meetings) || void 0 === t2 ? void 0 : t2.addTasks(e2)), this.adapterRef.instance.apiFrequencyControl({ name: "addTasks", code: 0, param: { lbsAddrs: this.adapterRef.lbsManager.getReportField("call"), clientUid: this.getUid() } });
            } catch (e3) {
              throw this.adapterRef.instance.apiFrequencyControl({ name: "addTasks", code: -1, param: { clientUid: this.getUid(), lbsAddrs: this.adapterRef.lbsManager.getReportField("call"), message: e3.message } }), e3;
            }
          }
          async deleteTasks(e2) {
            var t2;
            const { taskIds: i2 = [] } = e2;
            let r2, s2;
            if (this.logger.log("deleteTasks() 删除互动直播推流任务, options: ", e2), i2 && Array.isArray(i2) && i2.length ? 1 === this._roleInfo.userRole ? (s2 = "deleteTasks() 观众角色不允许删除推流任务", r2 = f.default.TASKS_ROLE_ERROR) : this.adapterRef._meetings || (s2 = "deleteTasks() 加入房间后才能删除推流任务", r2 = f.default.API_CALL_SEQUENCE_AFTER_ERROR) : (s2 = "deleteTasks() 参数格式错误, taskIds为空, 或者该数组长度为空", r2 = f.default.DELETE_TASK_PARAMETER_ERROR), r2) throw this.logger.error(s2), this.adapterRef.instance.apiFrequencyControl({ name: "deleteTasks", code: -1, param: { clientUid: this.getUid(), reason: r2, message: s2 } }), new v.default({ code: r2, message: s2 });
            try {
              await (null === (t2 = this.adapterRef._meetings) || void 0 === t2 ? void 0 : t2.deleteTasks(e2)), this.adapterRef.instance.apiFrequencyControl({ name: "deleteTasks", code: 0, param: { lbsAddrs: this.adapterRef.lbsManager.getReportField("call"), clientUid: this.getUid() } });
            } catch (e3) {
              throw this.adapterRef.instance.apiFrequencyControl({ name: "deleteTasks", code: -1, param: { clientUid: this.getUid(), lbsAddrs: this.adapterRef.lbsManager.getReportField("call"), reason: e3.message } }), e3;
            }
          }
          async updateTasks(e2) {
            var t2;
            const { rtmpTasks: i2 = [] } = e2;
            let r2, s2;
            if (this.logger.log("updateTasks() 更新互动直播推流任务, options: ", e2), i2 && Array.isArray(i2) && i2.length ? 1 === this._roleInfo.userRole ? (s2 = "updateTasks() 观众角色不允许进行添加推流任务", r2 = f.default.TASKS_ROLE_ERROR) : this.adapterRef._meetings || (s2 = "updateTasks() 加入房间后进行添加推流任务", r2 = f.default.API_CALL_SEQUENCE_AFTER_ERROR) : (s2 = "updateTasks() 参数格式错误, rtmpTasks为空, 或者该数组长度为空", r2 = f.default.UPDATE_TASK_PARAMETER_ERROR), r2) throw this.logger.error(s2), this.adapterRef.instance.apiFrequencyControl({ name: "updateTasks", code: -1, param: { clientUid: this.getUid(), reason: r2, message: s2 } }), new v.default({ code: r2, message: s2 });
            try {
              await (null === (t2 = this.adapterRef._meetings) || void 0 === t2 ? void 0 : t2.updateTasks(e2)), this.adapterRef.instance.apiFrequencyControl({ name: "onUpdateTasks", code: 0, param: { clientUid: this.getUid(), lbsAddrs: this.adapterRef.lbsManager.getReportField("call") } });
            } catch (e3) {
              throw this.adapterRef.instance.apiFrequencyControl({ name: "onUpdateTasks", code: -1, param: { clientUid: this.getUid(), lbsAddrs: this.adapterRef.lbsManager.getReportField("call"), reason: e3.message } }), e3;
            }
          }
          refreshRemoteEvents() {
            for (let e2 in this.adapterRef.remoteStreamMap) {
              const t2 = this.adapterRef.remoteStreamMap[e2];
              this.logger.warn("refreshRemoteEvents peer-online", e2), this.safeEmit("peer-online", { uid: e2 }), g.MediaTypeList.forEach((i2) => {
                t2.pubStatus[i2].producerId && (this.logger.warn("refreshRemoteEvents stream-added", e2, i2), this.safeEmit("stream-added", { stream: t2, mediaType: i2 }), t2.muteStatus[i2].send && (this.logger.warn("refreshRemoteEvents mute-" + i2, e2, i2), this.safeEmit("mute-" + i2, { uid: t2.getId() })));
              });
            }
          }
          initSpatialManager(e2) {
            if (!this.spatialManager) {
              const t2 = m.getAudioContext();
              if (!t2) return void this.logger.error("当前环境不支持WebAudio");
              this.spatialManager = new R.SpatialManager({ client: this, options: e2, context: t2 });
            }
            this.spatialManager.init(), this.spatialManager.play();
          }
          syncUserList() {
            return this.adapterRef.memberMap;
          }
          updateRecordingAudioStream() {
            if (!this.recordManager || !this.recordManager.formatMedia || !this.recordManager.formatMedia.destination) return;
            this.logger.log("updateRecordingAudioStream() [更新录制的音频]");
            const e2 = [];
            if (this.adapterRef.remoteStreamMap) for (var t2 in this.adapterRef.remoteStreamMap) {
              const i2 = this.adapterRef.remoteStreamMap[t2];
              e2.push(i2.mediaHelper.audio.audioStream);
            }
            this.adapterRef.localStream && e2.push(this.adapterRef.localStream.mediaHelper.audio.audioStream), this.recordManager.formatMedia.updateStream(e2);
          }
          async startMediaRecording(e2) {
            var t2;
            const { recorder: i2, recordConfig: r2 } = e2;
            this.recordManager.record || (this.recordManager.record = new p.Record({ logger: this.logger, client: this.adapterRef.instance }), this.recordManager.record.on("media-recording-stopped", (e3) => {
              this.safeEmit("@media-recording-stopped");
            })), this.recordManager.formatMedia || (this.recordManager.formatMedia = new u.FormatMedia({ adapterRef: this.adapterRef }));
            const s2 = [];
            if ((null === (t2 = this.adapterRef.localStream) || void 0 === t2 ? void 0 : t2.mediaHelper.audio.audioStream.active) && s2.push(this.adapterRef.localStream.mediaHelper.audio.audioStream), "all" === i2 && this.adapterRef.remoteStreamMap) for (var a2 in this.adapterRef.remoteStreamMap) {
              const e3 = this.adapterRef.remoteStreamMap[a2];
              e3.mediaHelper.audio.audioStream.active && s2.push(e3.mediaHelper.audio.audioStream);
            }
            const o2 = await this.recordManager.formatMedia.formatAudio(s2), n2 = await this.recordManager.formatMedia.formatVideo(i2, r2), d2 = [];
            if (d2.push(n2), s2.length > 0 && d2.push(o2), 0 !== d2.length) return this.recordManager.record.start({ uid: "", type: (null == r2 ? void 0 : r2.recordType) || "video", recordName: null == r2 ? void 0 : r2.recordName, reset: true, stream: d2 });
            this.logger.log("没有没发现要录制的媒体流");
          }
          stopMediaRecording(e2) {
            if (!this.recordManager.record) throw new v.default({ code: f.default.RECORDING_NOT_START_ERROR, message: "stopMediaRecording() 录制未开始" });
            return this.recordManager.record.stop({});
          }
          cleanMediaRecording() {
            if (!this.recordManager.record) throw new v.default({ code: f.default.RECORDING_NOT_START_ERROR, message: "stopMediaRecording() 录制未开始" });
            return this.recordManager.record.clean();
          }
          downloadMediaRecording() {
            if (!this.recordManager.record) throw new v.default({ code: f.default.RECORDING_NOT_START_ERROR, message: "stopMediaRecording() 录制未开始" });
            return this.recordManager.record.download();
          }
          async startAsrCaptions(e2 = "AUTO", t2 = "") {
            var i2;
            const r2 = this.getUid();
            if (!r2) return this.logger.error("startAsrCaptions() 开启实时字幕失败: uid为空"), false;
            this.logger.log("startAsrCaptions() 开启实时字幕: ", r2, t2);
            try {
              const s2 = await (null === (i2 = this.adapterRef._mediasoup) || void 0 === i2 ? void 0 : i2.startAsrCaptions(e2, t2));
              return s2 && (this.logger.log("startAsrCaptions() 开启字幕成功: ", r2, t2), this.adapterRef.asrCaptionConfig = { enable: true, source: "AUTO", target: t2 }), this.apiFrequencyControl({ name: "startAsrCaptions", code: 0, param: { uid: r2, result: s2, sourceLang: "AUTO", targetLang: t2 } }), s2;
            } catch (e3) {
              return this.logger.error("startAsrCaptions() 异常: ", e3.name, e3.message), this.apiFrequencyControl({ name: "startAsrCaptions", code: -1, param: { uid: r2, reason: e3.message } }), false;
            }
          }
          async stopAsrCaptions() {
            var e2;
            const t2 = this.getUid();
            if (!t2) return this.logger.warn("stopAsrCaptions() 关闭实时字幕失败: uid为空"), false;
            this.logger.log("stopAsrCaptions() 关闭实时字幕: ", t2);
            try {
              const i2 = await (null === (e2 = this.adapterRef._mediasoup) || void 0 === e2 ? void 0 : e2.stopAsrCaptions());
              return i2 && (this.logger.log("stopAsrCaptions() 关闭实时字幕: ", t2), this.adapterRef.asrCaptionConfig.enable = false), this.apiFrequencyControl({ name: "stopAsrCaptions", code: 0, param: { uid: t2 } }), i2;
            } catch (e3) {
              return this.logger.error("stopAsrCaptions() 异常: ", e3.name, e3.message), this.apiFrequencyControl({ name: "stopAsrCaptions", code: -1, param: { uid: t2, reason: e3.message } }), false;
            }
          }
          getAudioOutputDevice() {
            return this.outputDeviceId;
          }
          setCodecType(e2) {
            if (this.logger.log("setCodecType() 设置编解码格式: ", e2), !e2) return this.logger.log("setCodecType() codecType为空，自动选择编解码格式"), void (this.adapterRef.mediaCapability.forceCodec = false);
            "VP8" === e2 || "H264" === e2 ? this.adapterRef.mediaCapability.forceCodec = e2 : this.logger.error("setCodecType() 参数错误: ", e2);
          }
          async aiManualInterrupt(e2) {
            var t2;
            if (this.logger.log("aiManualInterrupt() 开始  dstUid: ", e2), e2 && 0 !== e2 && "0" !== e2) {
              if (!this.adapterRef.remoteStreamMap[e2]) return this.logger.warn("aiManualInterrupt() 无法获取到远端流: ", e2), false;
            } else {
              const t3 = this.adapterRef.remoteStreamMap[Object.keys(this.adapterRef.remoteStreamMap)[0]];
              if (!t3) return this.logger.warn("aiManualInterrupt() 无法获取到远端流"), false;
              e2 = t3.getId();
            }
            this.logger.log("aiManualInterrupt() dstUid: ", e2);
            try {
              const i2 = await (null === (t2 = this.adapterRef._mediasoup) || void 0 === t2 ? void 0 : t2.setMpsNotify(1, { dstUid: e2 }));
              i2 && this.logger.log("aiManualInterrupt() 成功: ", e2), this.apiFrequencyControl({ name: "aiManualInterrupt", code: 0, param: { dstUid: e2, result: i2 } });
            } catch (t3) {
              this.logger.error("aiManualInterrupt() 异常: ", t3.name, t3.message), this.apiFrequencyControl({ name: "aiManualInterrupt", code: -1, param: { dstUid: e2, reason: t3.message } });
            }
          }
          _onVisibilityChange() {
            var e2, t2, i2, r2, s2, a2, o2, n2;
            if ("hidden" === document.visibilityState) this.logger.warn("document.visibilityState: hidden");
            else {
              this.logger.log("document.visibilityState: visible");
              const d2 = { video: { muted: null === (t2 = null === (e2 = this.adapterRef.localStream) || void 0 === e2 ? void 0 : e2.getVideoTrack()) || void 0 === t2 ? void 0 : t2.muted }, audio: { muted: null === (r2 = null === (i2 = this.adapterRef.localStream) || void 0 === i2 ? void 0 : i2.getAudioTrack()) || void 0 === r2 ? void 0 : r2.muted }, screen: { muted: null === (a2 = null === (s2 = this.adapterRef.localStream) || void 0 === s2 ? void 0 : s2.getScreenTrack()) || void 0 === a2 ? void 0 : a2.muted }, screenAudio: { muted: null === (n2 = null === (o2 = this.adapterRef.localStream) || void 0 === o2 ? void 0 : o2.getAudioSlaveTrack()) || void 0 === n2 ? void 0 : n2.muted } };
              this.safeEmit("local-track-state", d2);
            }
            this.apiEventReport("setFunction", { name: "visibilitychange", oper: "1", value: document.visibilityState });
          }
          async destroy() {
            this.logger && this.logger.warn("清除 Client 实例中"), this.leave(0);
            const e2 = await this.operationQueue.enqueue({ caller: this, method: "destroy", options: null });
            this.operationQueue.destroy(), this._reset(), this.destroyed = true, e2();
          }
        }
        t.Client = A;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.ENV = t.TAGS_TO_MAIN_DOMAIN = t.LBS_REGION_CONFIG = t.Config = void 0, t.Config = { lbsUrl: "https://wecan-lbs.netease.im/api/v1/web_domains", checkSumUrl: "https://nrtc.netease.im/demo/getChecksum.action", createChannelUrl: "https://nrtc.netease.im/nrtc/createChannel.action", getChannelInfoUrl: "https://nrtc.netease.im/nrtc/getChannelInfos.action", roomsTaskUrl: "https://roomserver.netease.im/v2/sdk/rooms/", getCloudProxyInfoUrl: "https://ap-prd-jd.netease.im/v1/g2/getCloudProxyInfo" }, t.LBS_REGION_CONFIG = { GLOBAL: { cloudProxy: ["ap-prd-jd.netease.im"], lbs: ["wecan-lbs.netease.im", "wecan-lbs.yunxinvcloud.com"], nrtc: ["nrtc.netease.im", "wecan-gw.yunxinvcloud.com"], call: ["roomserver.netease.im", "wecan-sdk.yunxinvcloud.com"], tracking: ["statistic.live.126.net", "apm.yunxinhi.com"] }, OVERSEAS: { cloudProxy: ["supervisor-overseas.yunxinvcloud.com"], lbs: ["lbs-overseas.yunxinvcloud.com"], nrtc: ["nrtc-overseas.yunxinvcloud.com"], call: ["call-overseas.yunxinvcloud.com"], tracking: ["statistic-overseas.yunxinfw.com"] } }, t.TAGS_TO_MAIN_DOMAIN = { cloudProxy: "ap-prd-jd.netease.im", lbs: "wecan-lbs.netease.im", nrtc: "nrtc.netease.im", call: "roomserver.netease.im", tracking: "statistic.live.126.net" }, t.ENV = "production";
      }, function(e, t, i) {
        "use strict";
        function r(e2, t2, i2, r2) {
          for (var s = t2 * e2.sampleRate, a = s + (t2 - 2 * i2) * e2.sampleRate, o = e2.createBuffer(1, a, e2.sampleRate), n = o.getChannelData(0), d = 0; d < s; ++d) n[d] = r2 ? (s - d) / a : d / s;
          for (d = s; d < a; ++d) n[d] = 0;
          return o;
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.crossfade = t.Jungle = void 0;
        t.Jungle = class {
          constructor(e2) {
            this.connected = false, this.context = e2;
            var t2 = e2.createGain(), i2 = e2.createGain();
            this.input = t2, this.output = i2;
            var s = e2.createBufferSource(), a = e2.createBufferSource(), o = e2.createBufferSource(), n = e2.createBufferSource();
            this.shiftDownBuffer = r(e2, 0.1, 0.05, false), this.shiftUpBuffer = r(e2, 0.1, 0.05, true), s.buffer = this.shiftDownBuffer, a.buffer = this.shiftDownBuffer, o.buffer = this.shiftUpBuffer, n.buffer = this.shiftUpBuffer, s.loop = true, a.loop = true, o.loop = true, n.loop = true;
            var d = e2.createGain(), c = e2.createGain(), l = e2.createGain();
            l.gain.value = 0;
            var u = e2.createGain();
            u.gain.value = 0, s.connect(d), a.connect(c), o.connect(l), n.connect(u);
            var h = e2.createGain(), p = e2.createGain(), m = e2.createDelay(), g = e2.createDelay();
            d.connect(h), c.connect(p), l.connect(h), u.connect(p), h.connect(m.delayTime), p.connect(g.delayTime);
            var f = e2.createBufferSource(), v = e2.createBufferSource(), S = function(e3, t3, i3) {
              for (var r2 = t3 * e3.sampleRate, s2 = r2 + (t3 - 2 * i3) * e3.sampleRate, a2 = e3.createBuffer(1, s2, e3.sampleRate), o2 = a2.getChannelData(0), n2 = i3 * e3.sampleRate, d2 = n2, c2 = r2 - n2, l2 = 0; l2 < r2; ++l2) {
                var u2;
                u2 = l2 < d2 ? Math.sqrt(l2 / n2) : l2 >= c2 ? Math.sqrt(1 - (l2 - c2) / n2) : 1, o2[l2] = u2;
              }
              for (l2 = r2; l2 < s2; ++l2) o2[l2] = 0;
              return a2;
            }(e2, 0.1, 0.05);
            f.buffer = S, v.buffer = S, f.loop = true, v.loop = true;
            var y = e2.createGain(), _ = e2.createGain();
            y.gain.value = 0, _.gain.value = 0, f.connect(y.gain), v.connect(_.gain), t2.connect(m), t2.connect(g), m.connect(y), g.connect(_), y.connect(i2), _.connect(i2);
            var R = e2.currentTime + 0.05, b = R + 0.1 - 0.05;
            s.start(R), a.start(b), o.start(R), n.start(b), f.start(R), v.start(b), this.mod1 = s, this.mod2 = a, this.mod1Gain = d, this.mod2Gain = c, this.mod3Gain = l, this.mod4Gain = u, this.modGain1 = h, this.modGain2 = p, this.fade1 = f, this.fade2 = v, this.mix1 = y, this.mix2 = _, this.delay1 = m, this.delay2 = g, this.setDelay(0.1);
          }
          setDelay(e2) {
            this.modGain1.gain.setTargetAtTime(0.5 * e2, 0, 0.01), this.modGain2.gain.setTargetAtTime(0.5 * e2, 0, 0.01);
          }
          setPitchOffset(e2) {
            e2 > 0 ? (this.mod1Gain.gain.value = 0, this.mod2Gain.gain.value = 0, this.mod3Gain.gain.value = 1, this.mod4Gain.gain.value = 1) : (this.mod1Gain.gain.value = 1, this.mod2Gain.gain.value = 1, this.mod3Gain.gain.value = 0, this.mod4Gain.gain.value = 0), this.setDelay(0.1 * Math.abs(e2));
          }
        }, t.crossfade = function(e2, t2, i2) {
          var r2 = Math.cos(0.5 * e2 * Math.PI), s = Math.cos(0.5 * (1 - e2) * Math.PI);
          t2 && (t2.gain.value = r2), i2 && (i2.gain.value = s);
        };
      }, function(e, t) {
        var i, r;
        i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", r = { rotl: function(e2, t2) {
          return e2 << t2 | e2 >>> 32 - t2;
        }, rotr: function(e2, t2) {
          return e2 << 32 - t2 | e2 >>> t2;
        }, endian: function(e2) {
          if (e2.constructor == Number) return 16711935 & r.rotl(e2, 8) | 4278255360 & r.rotl(e2, 24);
          for (var t2 = 0; t2 < e2.length; t2++) e2[t2] = r.endian(e2[t2]);
          return e2;
        }, randomBytes: function(e2) {
          for (var t2 = []; e2 > 0; e2--) t2.push(Math.floor(256 * Math.random()));
          return t2;
        }, bytesToWords: function(e2) {
          for (var t2 = [], i2 = 0, r2 = 0; i2 < e2.length; i2++, r2 += 8) t2[r2 >>> 5] |= e2[i2] << 24 - r2 % 32;
          return t2;
        }, wordsToBytes: function(e2) {
          for (var t2 = [], i2 = 0; i2 < 32 * e2.length; i2 += 8) t2.push(e2[i2 >>> 5] >>> 24 - i2 % 32 & 255);
          return t2;
        }, bytesToHex: function(e2) {
          for (var t2 = [], i2 = 0; i2 < e2.length; i2++) t2.push((e2[i2] >>> 4).toString(16)), t2.push((15 & e2[i2]).toString(16));
          return t2.join("");
        }, hexToBytes: function(e2) {
          for (var t2 = [], i2 = 0; i2 < e2.length; i2 += 2) t2.push(parseInt(e2.substr(i2, 2), 16));
          return t2;
        }, bytesToBase64: function(e2) {
          for (var t2 = [], r2 = 0; r2 < e2.length; r2 += 3) for (var s = e2[r2] << 16 | e2[r2 + 1] << 8 | e2[r2 + 2], a = 0; a < 4; a++) 8 * r2 + 6 * a <= 8 * e2.length ? t2.push(i.charAt(s >>> 6 * (3 - a) & 63)) : t2.push("=");
          return t2.join("");
        }, base64ToBytes: function(e2) {
          e2 = e2.replace(/[^A-Z0-9+\/]/gi, "");
          for (var t2 = [], r2 = 0, s = 0; r2 < e2.length; s = ++r2 % 4) 0 != s && t2.push((i.indexOf(e2.charAt(r2 - 1)) & Math.pow(2, -2 * s + 8) - 1) << 2 * s | i.indexOf(e2.charAt(r2)) >>> 6 - 2 * s);
          return t2;
        } }, e.exports = r;
      }, function(e, t) {
        function i(e2) {
          return !!e2.constructor && "function" == typeof e2.constructor.isBuffer && e2.constructor.isBuffer(e2);
        }
        e.exports = function(e2) {
          return null != e2 && (i(e2) || function(e3) {
            return "function" == typeof e3.readFloatLE && "function" == typeof e3.slice && i(e3.slice(0, 0));
          }(e2) || !!e2._isBuffer);
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.FormatMedia = void 0;
        const s = i(3), a = r(i(6)), o = r(i(8)), n = i(85);
        class d extends s.EventEmitter {
          constructor(e2) {
            super(), this.adapterRef = e2.adapterRef, this.logger = e2.adapterRef.logger, this.audioContext = null, this.destination = null, this.audioStreams = [], this.canvas = null, this.canvasContext = null, this.canvasTimer = null;
          }
          async formatAudio(e2) {
            this.logger.log("formatAudio() [混音: ]", e2);
            try {
              return this.audioContext || (this.audioContext = new window.AudioContext()), this.destination = this.audioContext.createMediaStreamDestination(), await this.initAudioIn(e2), this.destination.stream;
            } catch (e3) {
              return this.logger.error("formatAudio() 异常: ", e3.name, e3.message), Promise.reject(new o.default({ code: a.default.RECORDING_NOT_SUPPORT, message: e3.message || "formatAudio() 浏览器不支持" }));
            }
          }
          initAudioIn(e2) {
            if (this.audioContext && this.destination) {
              for (var t2 = 0; t2 < e2.length; t2++) {
                const i2 = e2[t2].getAudioTracks()[0];
                if ("live" !== (null == i2 ? void 0 : i2.readyState)) continue;
                const r2 = this.audioContext.createMediaStreamSource(e2[t2]);
                r2.connect(this.destination), this.audioStreams.push(r2);
              }
              this.logger.log(`initAudioIn() [初始化音频 state: ${this.audioContext.state}]`), "running" !== this.audioContext.state && this.audioContext.resume().then(() => {
                this.audioContext && this.logger.log(`initAudioIn(): [audioContext 状态变更成功 state: ${this.audioContext.state}]`);
              }).catch((e3) => {
                this.logger.warn(`initAudioIn(): [audioContext 状态变更发生错误, errorName: ${e3.name}, erroMessage: ${e3.message}]`), this.audioContext && this.audioContext.resume();
              });
            } else this.logger.error("initAudioIn:参数不够");
          }
          async updateStream(e2) {
            this.logger.log("updateStream() [更新混频的音频数据: ]", e2), this.audioStreams.forEach((e3) => {
              e3.disconnect(0);
            }), this.audioStreams.length = 0, this.initAudioIn(e2);
          }
          stopFormatAudio() {
            this.logger.log("stopFormatAudio() [结束混音]"), this.audioStreams.forEach((e2) => {
              e2.disconnect(0);
            }), this.audioContext && this.audioContext.close(), this.audioContext = null, this.destination = null;
          }
          async formatVideo(e2, t2) {
            this.logger.log("formatVideo() 混频 recorder: ", e2, "recordConfig: ", t2);
            let i2 = 640, r2 = 360;
            const s2 = (null == t2 ? void 0 : t2.recordVideoFrame) || 15;
            switch (null == t2 ? void 0 : t2.recordVideoQuality) {
              case 360:
                i2 = 640, r2 = 360;
                break;
              case 480:
                i2 = 640, r2 = 480;
                break;
              case 720:
                i2 = 1280, r2 = 720;
            }
            this.canvas || (this.canvas = document.createElement("canvas"), this.canvasContext = n.get2DContext(this.canvas)), this.canvas.width = i2, this.canvas.height = r2, this.canvasTimer && (clearInterval(this.canvasTimer), this.canvasTimer = null);
            const a2 = Math.floor(i2 / 2), o2 = Math.floor(r2 / 2), d2 = Math.floor(i2 / 3), c = Math.floor(r2 / 3);
            return this.canvasContext && (this.canvasContext.fillStyle = "black", this.canvasContext.fillRect(0, 0, i2, r2)), this.canvasTimer && clearInterval(this.canvasTimer), this.canvasTimer = setInterval(() => {
              var s3, n2, l;
              this.canvasContext && (this.canvasContext.fillStyle = "black", this.canvasContext.fillRect(0, 0, i2, r2));
              let u = [];
              if ("video" === (null == t2 ? void 0 : t2.recordType) && ((null === (s3 = this.adapterRef.localStream) || void 0 === s3 ? void 0 : s3._play.video.dom) && u.push(this.adapterRef.localStream._play.video.dom), (null === (n2 = this.adapterRef.localStream) || void 0 === n2 ? void 0 : n2._play.screen.dom) && u.push(null === (l = this.adapterRef.localStream) || void 0 === l ? void 0 : l._play.screen.dom), "all" === e2 && this.adapterRef.remoteStreamMap)) for (var h in this.adapterRef.remoteStreamMap) {
                const e3 = this.adapterRef.remoteStreamMap[h];
                e3._play.video.dom && u.push(e3._play.video.dom), e3._play.screen.dom && u.push(e3._play.screen.dom);
              }
              switch (u.length > 9 && (u = u.filter((e3) => 4 === e3.readyState)), u.length) {
                case 0:
                  break;
                case 1:
                  this.drawSingleVideo(u[0], 0, 0, i2, r2);
                  break;
                case 2:
                  this.drawSingleVideo(u[0], 0, 0, a2, r2), this.drawSingleVideo(u[1], a2, 0, a2, r2);
                  break;
                case 3:
                case 4:
                  this.drawSingleVideo(u[0], 0, 0, a2, o2), this.drawSingleVideo(u[1], a2, 0, a2, o2), this.drawSingleVideo(u[2], 0, o2, a2, o2), this.drawSingleVideo(u[3], a2, o2, a2, o2);
                  break;
                default:
                  this.drawSingleVideo(u[0], 0, 0, d2, c), this.drawSingleVideo(u[1], d2, 0, d2, c), this.drawSingleVideo(u[2], 2 * d2, 0, d2, c), this.drawSingleVideo(u[3], 0, c, d2, c), this.drawSingleVideo(u[4], d2, c, d2, c), this.drawSingleVideo(u[5], 2 * d2, c, d2, c), this.drawSingleVideo(u[6], 0, 2 * c, d2, c), this.drawSingleVideo(u[7], d2, 2 * c, d2, c), this.drawSingleVideo(u[8], 2 * d2, 2 * c, d2, c);
              }
            }, Math.floor(1e3 / s2)), this.canvas.captureStream();
          }
          drawSingleVideo(e2, t2, i2, r2, s2) {
            var a2;
            if (!e2) return;
            const o2 = Math.min(r2 / e2.videoWidth, s2 / e2.videoHeight);
            let n2 = e2.videoWidth * o2, d2 = e2.videoHeight * o2, c = t2 + (r2 - n2) / 2, l = i2 + (s2 - d2) / 2;
            null === (a2 = this.canvasContext) || void 0 === a2 || a2.drawImage(e2, c, l, n2, d2);
          }
          async stopFormatVideo() {
            this.logger.log("stopFormatAudio() [结束混频]"), this.canvasTimer && (clearInterval(this.canvasTimer), this.canvasTimer = null), this.canvasContext = this.canvas = null;
          }
          destroy() {
            this.logger.log("destroy()"), this.stopFormatAudio(), this.stopFormatVideo();
          }
        }
        t.FormatMedia = d;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.OperationQueue = void 0;
        let r = false;
        t.OperationQueue = class {
          constructor(e2) {
            this.cnt = 0, this.current = null, this.history = null, this.queue = [], this.logger = e2.getChild(() => {
              let e3 = "oper";
              return this.current ? e3 += ` ${this.current.args.method}#${this.current.id}` : this.history && (e3 += ` ${this.history.args.method}#${this.history.id} FINISHED`), this.queue.forEach((t2) => {
                e3 += `|${t2.args.method}#${t2.id}`;
              }), e3;
            }), this.operationQueueTimer = setInterval(() => {
              if (this.current && Date.now() - this.current.enqueueTs > 5e3) {
                if (this.queue.length) {
                  const e3 = this.queue[0];
                  this.logger.error(`当前操作已执行了${Date.now() - this.current.enqueueTs}ms，放开锁限制：${this.current.args.method}#${this.current.id}。即将进行下一个操作：${e3.args.method}#${e3.id}`);
                } else this.logger.log(`当前操作已执行了${Date.now() - this.current.enqueueTs}ms，放开锁限制：${this.current.args.method}#${this.current.id}`);
                this.current.status = "timeout", this.history = this.current, this.current = null, this.fire("timer");
              }
            }, 5e3);
          }
          enqueue(e2) {
            var t2, i2;
            if (!r) {
              const s = e2.caller;
              s.clientId > -1 && s.clientId == (null === (i2 = null === (t2 = s.adapterRef) || void 0 === t2 ? void 0 : t2.instance) || void 0 === i2 ? void 0 : i2.clientId) && s !== s.adapterRef.instance && (s.logger.warn("侦测到该次调用的this不指向原生Client对象。请避免使用Proxy或bind等方式篡改SDK调用主体 Client:" + e2.method), r = true);
            }
            return new Promise((t3, i3) => {
              this.queue.push({ id: ++this.cnt, enqueueTs: Date.now(), args: e2, resolve: t3, reject: i3, status: "pending" }), this.current ? this.logger.log(`操作等位中，目前有其他操作。前面还有${this.queue.length}位：${e2.method}#${this.cnt}。`) : this.fire("instant");
            });
          }
          fire(e2) {
            var t2;
            if (!this.current) {
              const i2 = this.queue.shift();
              if (i2) {
                if (null === (t2 = i2.args.caller) || void 0 === t2 ? void 0 : t2.destroyed) return this.logger.error(`无法执行操作：${i2.args.method}: 对象已被销毁，请重新创建对象`), void this.fire("functionEnd");
                this.history = this.current, this.current = i2, this.current.status = "live", "instant" === e2 ? this.logger.log("开始执行操作：" + i2.args.method) : this.logger.log(`开始执行队列中的操作：${i2.args.method}#${i2.id}，等待时间：${Date.now() - i2.enqueueTs}ms。`), i2.startTs = Date.now(), i2.resolve(() => {
                  this.current === i2 ? (this.current.status = "finished", this.history = this.current, this.current = null, this.logger.log(`执行操作结束：${i2.args.method}。花费 ${i2.startTs ? Date.now() - i2.startTs : null}ms`), this.fire("functionEnd")) : "timeout" === i2.status ? this.logger.log(`执行操作结束：${i2.args.method}。花费 ${i2.startTs ? Date.now() - i2.startTs : null}ms。该操作超时，但未阻塞执行队列。`) : this.logger.error(`操作收到多次返回：${i2.args.method}#${i2.id}。花费 ${i2.startTs ? Date.now() - i2.startTs : null}ms`);
                });
              }
            }
          }
          destroy() {
            clearInterval(this.operationQueueTimer), this.queue = [], this.current = null, this.history = null;
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Base = void 0;
        const s = i(145), a = i(218), o = i(220), n = i(256), d = i(1), c = i(177), l = i(258), u = i(281), h = i(48), p = r(i(6)), m = r(i(8)), g = i(304), f = r(i(203)), v = i(43), S = i(28), y = i(146), _ = i(305), R = i(46), b = i(84), T = i(42), E = i(306), A = i(307);
        let I = 0;
        class w extends R.RTCEventEmitter {
          constructor(e2) {
            super(), this.transportRebuildCnt = 0, this.timeLast = Date.now(), this._params = { appkey: "", mode: "rtc" }, this.isReport = "boolean" != typeof e2.report || e2.report, this.clientId = I++, this.adapterRef = { datareportCache: [], channelInfo: { customData: "", sessionConfig: {} }, apiEvent: {}, apiEvents: {}, requestId: {}, instance: this, preferRemb: false, deviceId: "", asrCaptionConfig: { enable: false, source: "CH", target: "CH" } };
            const t2 = d.getParameters().forceLogLevel;
            -1 !== t2 ? f.default.setLogLevel(t2) : true === e2.debug ? f.default.setLogLevel(b.loglevels.DEBUG) : false === e2.debug && d.getParameters().logLevel <= b.loglevels.WARNING && f.default.setLogLevel(b.loglevels.WARNING), this.logger = new S.Logger({ tagGen: () => {
              let e3 = "client" + (this.clientId || "");
              const t3 = this.getUid();
              return t3 && (e3 += "#" + t3), "CONNECTED" !== this.adapterRef.connectState.curState && (e3 += " " + this.adapterRef.connectState.curState), this.destroyed && (e3 += " DESTROYED"), e3;
            } }), this.adapterRef.logger = this.logger, this.recordManager = { record: null, formatMedia: null }, this._reset(), this.adapterRef.encryption = new s.Encryption(this.adapterRef), this.adapterRef.audioMixer = new A.AudioMixer(this.adapterRef), e2.debug && (d.getParameters().debugG2 = true), this.sdkRef = e2.ref;
          }
          _reset() {
            this.sdkRef = null, this.adapterRef = { datareportCache: [], audioAsl: { enabled: "unknown", aslActiveNum: -1 }, uid2SscrList: {}, netStatusTimer: null, networkQuality: {}, _statsReport: null, _meetings: null, state: void 0, mediaCapability: void 0, instance: this, lbsManager: void 0, channelInfo: { customData: "", sessionConfig: {} }, apiEvent: {}, memberMap: {}, apiEvents: {}, transportStats: { txRtt: -1, rxRtt: -1, NetworkType: "unknown", OutgoingAvailableBandwidth: -1 }, sessionStats: void 0, remoteAudioStats: {}, remoteAudioSlaveStats: {}, remoteVideoStats: {}, remoteScreenStats: {}, remoteStreamMap: {}, localStream: null, localAudioStats: {}, localAudioSlaveStats: {}, localVideoStats: [], localScreenStats: [], logger: this.logger, logStorage: void 0, channelStatus: "init", _signalling: null, connectState: { prevState: "DISCONNECTED", curState: "DISCONNECTED", reconnect: false }, _mediasoup: null, mediaHelpers: {}, netStatusList: [], requestId: {}, deviceId: "", preferRemb: false, nomalizedPlaybackVolume: 1, userPriority: { priority: 100, preemtiveMode: false }, proxyServer: { enable: false, type: 3 }, encryption: void 0, signalProbeManager: void 0, isAudioBanned: false, isVideoBanned: false, permKeyInfo: void 0, asrCaptionConfig: { enable: false, source: "CH", target: "CH" }, audioMixer: null, enableMixAudio: false }, this.adapterRef.mediaCapability = new a.MediaCapability(this.adapterRef), this.adapterRef.encryption = new s.Encryption(this.adapterRef), this.adapterRef.signalProbeManager = new E.SignalProbeManager(this.adapterRef), this._resetState(), this.adapterRef.lbsManager = new _.LBSManager(this), this._destroyModule();
          }
          _getSupportedCodecs() {
            return v.getSupportedCodecs(...arguments);
          }
          initMode() {
            this.adapterRef._meetings || (this.adapterRef._meetings = new n.Meeting({ sdkRef: this.sdkRef, adapterRef: this.adapterRef })), this.adapterRef._signalling || (this.adapterRef._signalling = new u.Signalling({ adapterRef: this.adapterRef, logger: this.logger })), this.adapterRef._mediasoup || (this.adapterRef._mediasoup = new o.Mediasoup({ adapterRef: this.adapterRef, logger: this.logger })), this.adapterRef._statsReport || (this.adapterRef._statsReport = new l.StatsReport({ sdkRef: this.sdkRef, adapterRef: this.adapterRef, isReport: this.isReport }));
          }
          _destroyModule() {
            this.adapterRef._meetings && (this.adapterRef._meetings.destroy(), this.adapterRef._meetings = null), this.adapterRef._signalling && (this.adapterRef._signalling.destroy(), this.adapterRef._signalling = null), this.adapterRef._mediasoup && (this.adapterRef._mediasoup.destroy(), this.adapterRef._mediasoup = null), this.recordManager.formatMedia && (this.recordManager.formatMedia.destroy(), this.recordManager.formatMedia = null), this.recordManager.record && (this.recordManager.record.destroy(), this.recordManager.record = null), this.adapterRef.signalProbeManager.stop();
          }
          _resetState() {
            this._params.neRtcServerAddresses = {}, this.adapterRef.channelStatus = "init", this.adapterRef.connectState = { prevState: "DISCONNECTED", curState: "DISCONNECTED", reconnect: false }, this.adapterRef.networkQuality = {}, this.adapterRef.localStream = null, this.adapterRef.memberMap = {}, this.adapterRef.remoteStreamMap = {}, this.adapterRef.netStatusList = [], this.adapterRef.netStatusTimer && (clearInterval(this.adapterRef.netStatusTimer), this.adapterRef.netStatusTimer = null), this.adapterRef.uid2SscrList = {}, this.adapterRef.proxyServer = { enable: false, type: 3 }, this.adapterRef.state = { lastDeviceStatus: { audio: { type: null, device: null }, video: { type: null, device: null } }, audioDeviceHasOpened: false, videoDeviceHasOpened: false, chromeScreenShareOpened: false, startSessionTime: 0, endSessionTime: 0, startPubVideoTime: 0, startPubScreenTime: 0, getChannelInfoTime: 0, signalEstablishTime: 0, signalOpenTime: 0, signalJoinResTime: 0, signalJoinSuccessTime: 0, getChannelInfoRtt: 0, signalWebsocketOpenRtt: 0, signalJoinMsgRtt: 0, signalAudioAddedTime: 0, signalAudioSubscribedTime: 0, signalVideoAddedTime: 0, signalVideoSubscribedTime: 0, iceRecvConnectedTime: 0, domVideoAppendTime: 0, videoFirstIframeTime: 0, videoResizeTime: 0 }, Object.assign(this.adapterRef, { transportStats: { NetworkType: "unknown", OutgoingAvailableBandwidth: 0, txRtt: 0, rxRtt: 0 }, sessionStats: { Duration: 0, RecvBitrate: 0, RecvBytes: 0, SendBitrate: 0, SendBytes: 0, UserCount: 0 }, localAudioStats: [], localAudioSlaveStats: [], localVideoStats: [], localScreenStats: [], remoteAudioStats: {}, remoteAudioSlaveStats: {}, remoteVideoStats: {}, remoteScreenStats: {} });
          }
          setSessionConfig(e2 = {}) {
            this.adapterRef.channelInfo || (this.adapterRef.channelInfo = {}), this.adapterRef.channelInfo.sessionConfig || (this.adapterRef.channelInfo.sessionConfig = {}), this.adapterRef.channelInfo.sessionConfig = Object.assign(this.adapterRef.channelInfo.sessionConfig, e2);
          }
          resetChannel() {
            this.adapterRef.networkQuality = {}, this.adapterRef.netStatusList = [];
            for (let e2 in this.adapterRef.remoteStreamMap) {
              const t2 = this.adapterRef.remoteStreamMap[e2];
              t2.active && (t2.active = false, t2.stop(), t2.clearRemotePubStatus(), d.getParameters().peerLeaveEventOnReconnect && this.adapterRef.instance.safeEmit("peer-leave", { uid: e2, reason: g.peerLeaveReasonCode.LEAVE_FOR_RECONNECT }));
            }
            this.adapterRef.memberMap = {}, this.adapterRef.uid2SscrList = {}, this.adapterRef._mediasoup && this.adapterRef._mediasoup.destroy();
          }
          async startSession(e2 = 0) {
            0 === e2 ? this.logger.log("join() 开始音视频会话") : this.logger.log(`join() 开始音视频会话：第${e2}次`);
            let { wssArr: t2, cid: i2 } = this.adapterRef.channelInfo;
            if (!t2 || 0 === t2.length) throw this.logger.error("join() 没有找到服务器地址 : " + JSON.stringify(this.adapterRef.channelInfo)), this.adapterRef.channelStatus = "leave", new m.default({ code: p.default.JOIN_FAILED, message: "join() 没有找到媒体服务器地址" });
            if (!i2) throw this.logger.error("join() 服务器没有分配cid"), new m.default({ code: p.default.JOIN_FAILED, message: "join() 服务器没有分配cid" });
            if (this.logger.log(`join() 开始连接服务器: ${this.adapterRef.channelInfo.wssArrIndex}, url: ${t2[this.adapterRef.channelInfo.wssArrIndex]}`), this.adapterRef.channelInfo.wssArrIndex >= t2.length) throw this.logger.error("join() 所有的服务器地址都连接失败"), new m.default({ code: p.default.NETWORK_ERROR, message: "所有的服务器地址都连接失败" });
            if (!this.adapterRef._signalling) throw new m.default({ code: p.default.UNKNOWN_TYPE_ERROR, message: "startSession: 信令模块缺失" });
            try {
              await this.adapterRef._signalling.init(false, false);
            } catch (e3) {
              throw this.adapterRef.channelStatus = "leave", e3;
            }
            const r2 = t2[this.adapterRef.channelInfo.wssArrIndex];
            t2.splice(this.adapterRef.channelInfo.wssArrIndex, 1), t2.unshift(r2), this.adapterRef.channelInfo.wssArrIndex = 0, this.adapterRef._statsReport && this.adapterRef._statsReport.start();
          }
          stopSession() {
            this.logger.log("开始清除音视频会话"), this._destroyModule();
            const e2 = d.getParameters().localStreams.filter((e3) => e3.client.clientId === this.clientId && !e3.destroyed);
            e2.length && (d.getParameters().keepLocalstreamOnLeave ? this.logger.log("当前模式下离开频道不会销毁localStream") : (this.logger.log(`即将销毁${e2.length}个localStream`), e2.forEach((e3) => {
              e3.destroy();
            }))), Object.values(this.adapterRef.remoteStreamMap).forEach((e3) => {
              e3.destroy();
            }), this.adapterRef.remoteStreamMap = {}, this.adapterRef.memberMap = {}, this.adapterRef.uid2SscrList = {}, this._resetState(), this.adapterRef._statsReport && (this.adapterRef._statsReport.destroy(), this.adapterRef._statsReport = null);
          }
          async clearMember(e2, t2) {
            var i2;
            this.logger.log(`${e2}离开房间, reason: ${t2}`);
            const r2 = this.adapterRef.remoteStreamMap[e2];
            if (null == r2 ? void 0 : r2.active) {
              for (let e3 of h.MediaTypeList) r2.pubStatus[e3].producerId && this.adapterRef.instance.safeEmit("stream-removed", { stream: r2, mediaType: e3, reason: "onPeerLeave" });
              delete this.adapterRef.remoteStreamMap[e2], delete this.adapterRef.memberMap[e2], delete this.adapterRef.remoteAudioStats[e2], delete this.adapterRef.remoteAudioSlaveStats[e2], delete this.adapterRef.remoteVideoStats[e2], delete this.adapterRef.remoteScreenStats[e2];
              for (let e3 of h.MediaTypeList) r2.pubStatus[e3].consumerId && await (null === (i2 = this.adapterRef._mediasoup) || void 0 === i2 ? void 0 : i2.destroyConsumer(r2.pubStatus[e3].consumerId, r2, e3));
              r2.active = false, r2.destroy();
            }
            this.adapterRef.netStatusList = this.adapterRef.netStatusList.filter((t3, i3, r3) => t3.uid !== e2), this.logger.log(e2 + " 离开房间 通知用户"), this.adapterRef.instance.safeEmit("peer-leave", { uid: e2, reason: t2 });
          }
          setStartSessionTime() {
            this.adapterRef.state.startSessionTime = Date.now();
            const e2 = T.generateUUID(), t2 = this.adapterRef.channelInfo.channelName || "", i2 = this.adapterRef.channelInfo.uid || 0, r2 = Date.now(), s2 = y(e2 + t2 + i2 + r2 + "");
            this.adapterRef.deviceId = T.randomString(s2, 16);
          }
          setEndSessionTime() {
            if (!this.adapterRef.state.startSessionTime) return void this.logger.log("AbstractAdapter: setEndSessionTime: startSessionTime为空");
            this.adapterRef.state.endSessionTime = Date.now();
            const e2 = this.adapterRef.state.endSessionTime - this.adapterRef.state.startSessionTime;
            this.adapterRef.instance.safeEmit("@sessionDuration", e2), this.adapterRef.state.startSessionTime = 0, this.adapterRef.state.endSessionTime = 0;
          }
          async reBuildRecvTransport() {
            if (this.transportRebuildCnt++, this.transportRebuildCnt >= d.getParameters().maxTransportRebuildCnt) return void this.logger.error("reBuildRecvTransport 达到最大重连次数：" + this.transportRebuildCnt);
            if (this.logger.warn("下行通道异常，重新建立 #" + this.transportRebuildCnt), !this.adapterRef._mediasoup) return;
            this.adapterRef.instance.safeEmit("@pairing-reBuildRecvTransport-start"), this.adapterRef._mediasoup._recvTransport && (this.adapterRef._mediasoup._recvTransport.close(), this.adapterRef._mediasoup._recvTransport = null), this.adapterRef._mediasoup.init(), this.logger.log("下行通道异常, remoteStreamMap", Object.keys(this.adapterRef.remoteStreamMap)), this.logger.log("this._eventQueue: ", this.adapterRef._mediasoup._eventQueue);
            let e2 = false;
            for (const t2 in this.adapterRef.remoteStreamMap) {
              const i2 = this.adapterRef.remoteStreamMap[t2];
              if (i2) {
                i2.pubStatus.audio.consumerStatus = "init", i2.pubStatus.video.consumerStatus = "init", i2.pubStatus.screen.consumerStatus = "init", i2.pubStatus.audio.consumerId = "", i2.pubStatus.video.consumerId = "", i2.pubStatus.screen.consumerId = "", this.logger.log("重连逻辑订阅 start：", i2.stringStreamID);
                try {
                  await this.doSubscribe(i2);
                } catch (t3) {
                  this.logger.error("重连逻辑订阅 error: ", t3, t3.name, t3.message), e2 = true, this.adapterRef.instance.safeEmit("@pairing-reBuildRecvTransport-error");
                  break;
                }
                this.logger.log("重连逻辑订阅 over: ", i2.stringStreamID);
              }
            }
            e2 || this.adapterRef.instance.safeEmit("@pairing-reBuildRecvTransport-success");
          }
          apiFrequencyControl(e2) {
            if (d.getParameters().disableAllReports) return;
            const { name: t2, code: i2, param: r2 } = e2;
            if (!t2) return;
            this.adapterRef.apiEvent[t2] || (this.adapterRef.apiEvent[t2] = [], this.adapterRef.apiEvents[t2] = [], this.adapterRef.requestId[t2] = 0);
            let s2 = this.adapterRef.channelInfo.clientNtpTime - this.adapterRef.channelInfo.T4;
            s2 > 0 || (s2 = 0);
            let a2 = Date.now() + s2;
            if (a2 <= this.timeLast && (a2 = this.timeLast + 1), this.timeLast = a2, this.adapterRef.apiEvent[t2].length < 10) this.adapterRef.apiEvent[t2].push({ cid: this.adapterRef.channelInfo && this.adapterRef.channelInfo.cid, uid: this.adapterRef.channelInfo && this.adapterRef.channelInfo.uid, code: i2, name: t2, time: a2, param: r2, request_id: this.adapterRef.requestId[t2]++ });
            else {
              if (!this.adapterRef.apiEvent || !this.adapterRef.apiEvent[t2] || !this.adapterRef.apiEvent[t2].length) return;
              this.adapterRef.apiEvent[t2][0].time, Date.now() - this.adapterRef.apiEvent[t2][0].time < 1e4 ? this.adapterRef.requestId[t2]++ : (this.adapterRef.apiEvents[t2] = this.adapterRef.apiEvents[t2].concat(this.adapterRef.apiEvent[t2]), this.adapterRef.apiEvent[t2] = []);
            }
          }
          apiEventReport(e2, t2) {
            if (!e2) return;
            if (d.getParameters().disableAllReports) return;
            let i2 = new c.DataReport({ adapterRef: this.adapterRef, sdkRef: this.sdkRef });
            i2[e2](Object.assign({ uid: "" + this.adapterRef.channelInfo.uid, cid: "" + this.adapterRef.channelInfo.cid, time: Date.now() }, t2)), this.adapterRef.channelInfo.cid && this.adapterRef.channelInfo.uid ? i2.send() : (this.adapterRef.datareportCache.push({ func: e2, datareport: i2 }), this.adapterRef.datareportCache.length > 20 && this.adapterRef.datareportCache.shift());
          }
          eventCacheReport() {
            new c.DataReport({ adapterRef: this.adapterRef, sdkRef: this.sdkRef }).sendCacheEvent();
          }
          getUidAndKindBySsrc(e2) {
            var t2, i2;
            const r2 = ["high", "low"];
            for (let s2 of h.MediaTypeList) for (let a2 of r2) if ((null === (i2 = null === (t2 = this.adapterRef._mediasoup) || void 0 === t2 ? void 0 : t2.senderEncodingParameter[s2][a2]) || void 0 === i2 ? void 0 : i2.ssrc) === e2) return { uid: 0, kind: s2, streamType: a2 };
            for (let t3 in this.adapterRef.uid2SscrList) {
              if (this.adapterRef.uid2SscrList[t3].audio.ssrc == e2) return { uid: t3, kind: "audio", streamType: "high" };
              if (this.adapterRef.uid2SscrList[t3].audioSlave.ssrc == e2) return { uid: t3, kind: "audioSlave", streamType: "high" };
              if (this.adapterRef.uid2SscrList[t3].video && this.adapterRef.uid2SscrList[t3].video.ssrc == e2) return { uid: t3, kind: "video", streamType: "high" };
              if (this.adapterRef.uid2SscrList[t3].screen && this.adapterRef.uid2SscrList[t3].screen.ssrc == e2) return { uid: t3, kind: "screen", streamType: "high" };
              if (this.adapterRef.uid2SscrList[t3].videoThird && this.adapterRef.uid2SscrList[t3].videoThird.ssrc == e2) return { uid: t3, kind: "videoThird", streamType: "high" };
              if (this.adapterRef.uid2SscrList[t3].videoFourth && this.adapterRef.uid2SscrList[t3].videoFourth.ssrc == e2) return { uid: t3, kind: "videoFourth", streamType: "high" };
            }
            return { uid: 0, kind: "", streamType: "high" };
          }
          getSsrcByUidAndKind(e2, t2) {
            return this.adapterRef.uid2SscrList[e2] && this.adapterRef.uid2SscrList[e2][t2];
          }
          addSsrc(e2, t2, i2) {
            this.adapterRef.uid2SscrList[e2] || (this.adapterRef.uid2SscrList[e2] = { audio: { ssrc: 0 }, audioSlave: { ssrc: 0 }, video: { ssrc: 0 }, screen: { ssrc: 0 }, videoThird: { ssrc: 0 }, videoFourth: { ssrc: 0 } }), this.adapterRef.uid2SscrList[e2][t2] ? this.adapterRef.uid2SscrList[e2][t2].ssrc = i2 : this.adapterRef.uid2SscrList[e2][t2] = { ssrc: i2 };
          }
          removeSsrc(e2, t2) {
            this.adapterRef.uid2SscrList[e2] && (t2 ? this.adapterRef.uid2SscrList[e2][t2] && (this.adapterRef.uid2SscrList[e2][t2].ssrc = 0) : delete this.adapterRef.uid2SscrList[e2]);
          }
          isPublished(e2) {
            var t2;
            return e2 && (null === (t2 = this.adapterRef.localStream) || void 0 === t2 ? void 0 : t2.localStreamId) === e2.localStreamId && (e2.audio && e2.pubStatus.audio.audio || e2.video && e2.pubStatus.video.video || e2.screen && e2.pubStatus.screen.screen);
          }
          getPeer(e2) {
            return this.adapterRef._mediasoup ? "send" == e2 ? this.adapterRef._mediasoup._sendTransport && this.adapterRef._mediasoup._sendTransport.handler._pc : "recv" == e2 ? this.adapterRef._mediasoup._recvTransport && this.adapterRef._mediasoup._recvTransport.handler._pc : null : null;
          }
          destroy() {
            this.logger.log("base: destroy!"), this._reset();
          }
        }
        t.Base = w;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.MediaCapability = void 0;
        const r = i(219), s = i(43), a = i(1);
        t.MediaCapability = class {
          constructor(e2) {
            this.logger = e2.logger.getChild(() => {
              let e3 = "codec" + this.room.videoCodecType.join(",");
              return this.supportedCodecSend && 2 === this.supportedCodecSend.length && this.supportedCodecRecv && 2 === this.supportedCodecRecv.length || (e3 += `/${this.supportedCodecSend}/${this.supportedCodecRecv}`), e3;
            }), this.supportedCodecRecv = null, this.supportedCodecSend = null, this.preferredCodecSend = { video: ["H264", "VP8"], screen: ["H264", "VP8"] }, this.forceCodec = false, this.room = { videoCodecType: [] };
          }
          async detect() {
            const e2 = Date.now();
            let t2 = await s.getSupportedCodecs("recv") || { video: [], audio: ["OPUS"] }, i2 = await s.getSupportedCodecs("send") || { video: [], audio: ["OPUS"] };
            if (a.getParameters().h264Wait) {
              if (-1 === t2.video.indexOf("H264")) for (this.logger.warn(`当前浏览器不支持H264解码。这可能会触发频道内编码协商。最多等待 ${a.getParameters().h264Wait} 毫秒以避免编码器尚未加载。`); Date.now() - e2 < a.getParameters().h264Wait; ) {
                if (t2 = await s.getSupportedCodecs("recv") || { video: [], audio: ["OPUS"] }, -1 !== t2.video.indexOf("H264")) {
                  this.logger.log(`H264解码器加载完成！用时 ${Date.now() - e2} 毫秒`);
                  break;
                }
                await new Promise((e3) => {
                  setTimeout(e3, 100);
                });
              }
              -1 === t2.video.indexOf("H264") && this.logger.warn("H264解码器加载失败！");
            }
            if (this.supportedCodecRecv = t2.video, this.supportedCodecSend = i2.video, a.getParameters().disableH264Send) {
              let e3 = this.supportedCodecSend.indexOf("H264");
              -1 !== e3 && (this.logger.log("根据私有化参数设置，忽略H264发送支持"), this.supportedCodecSend.splice(e3, 1));
            }
            if (a.getParameters().disableVP8Send) {
              let e3 = this.supportedCodecSend.indexOf("VP8");
              -1 !== e3 && (this.logger.log("根据私有化参数设置，忽略VP8发送支持"), this.supportedCodecSend.splice(e3, 1));
            }
            this.logger.log("detect supportedCodecRecv", JSON.stringify(this.supportedCodecRecv), "supportedCodecSend", JSON.stringify(this.supportedCodecSend), "Preferred codec:", JSON.stringify(this.preferredCodecSend));
          }
          getCodecCapability() {
            if ("H264" === this.forceCodec || "VP8" === this.forceCodec) return this.logger.log("getCodecCapability: forceCodec ", this.forceCodec), [this.forceCodec];
            if (this.supportedCodecRecv && this.supportedCodecSend) {
              const e2 = [];
              for (let t2 of s.VideoCodecList) this.supportedCodecRecv.indexOf(t2) > -1 && this.supportedCodecSend.indexOf(t2) > -1 && e2.push(t2);
              return e2;
            }
            return this.logger.error("getCodecCapability: call detect first"), [];
          }
          stringify() {
            let e2 = { 256: [] };
            for (let t2 of this.getCodecCapability()) r.VideoCodecStr2Int[t2] > -1 ? e2[256].push(r.VideoCodecStr2Int[t2]) : this.logger.error("MediaCapability:Unknown VideoCodecStr2Int", t2);
            0 === e2[256].length && this.logger.warn("MediaCapability:No Local Suitable codec available");
            return JSON.stringify(e2);
          }
          getCodecSend(e2, t2) {
            var i2, r2;
            let s2 = { codecName: null }, o = { codecName: null };
            for (let n = 0; n < this.preferredCodecSend[e2].length; n++) {
              const d = this.preferredCodecSend[e2][n];
              if (t2.codecs || !t2.codecs.length) for (let e3 = 0; e3 < t2.codecs.length; e3++) {
                const n2 = t2.codecs[e3];
                a.getParameters().disableH264Send && (null === (i2 = n2.mimeType) || void 0 === i2 ? void 0 : i2.toLowerCase().indexOf("h264")) > -1 || (a.getParameters().disableVP8Send && (null === (r2 = n2.mimeType) || void 0 === r2 ? void 0 : r2.toLowerCase().indexOf("vp8")) > -1 || n2.mimeType && n2.mimeType.toLowerCase().indexOf(d.toLowerCase()) > -1 && (this.room.videoCodecType.indexOf(d) > -1 ? s2.codecName || (s2 = { codecParam: n2, codecName: d }) : o.codecName || (o = { codecParam: n2, codecName: d })));
              }
            }
            return s2.codecName ? (this.logger.log("MediaCapability：发送的Codec为:", s2.codecName, JSON.stringify(s2.codecParam)), s2) : (this.logger.warn("MediaCapability：未找到合适的发送Codec。发送的Codec使用:", o.codecName, o.codecParam), o);
          }
          parseRoom(e2) {
            if (!e2.mediaCapabilitySet) return;
            const t2 = JSON.parse(e2.mediaCapabilitySet);
            if (t2[256]) {
              const i2 = this.room.videoCodecType;
              this.room.videoCodecType = [];
              for (const i3 of t2[256]) {
                let t3 = r.VideoCodecInt2Str[i3];
                t3 ? this.room.videoCodecType.push(t3) : this.logger.error("Unknown Video Codec Type", i3, e2);
              }
              i2.length ? this.logger.log("Room videoCodecType发生变更。new:", this.room.videoCodecType, "old:", i2) : this.logger.log("Room videoCodecType:", JSON.stringify(this.room.videoCodecType));
            }
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.VideoCodecStr2Int = t.VideoCodecInt2Str = t.SignalChannelMode = void 0, function(e2) {
          e2[e2.CHANNEL_MODE_P2P = 1] = "CHANNEL_MODE_P2P", e2[e2.CHANNEL_MODE_MEETING = 2] = "CHANNEL_MODE_MEETING", e2[e2.CHANNEL_MODE_1V1 = 3] = "CHANNEL_MODE_1V1";
        }(t.SignalChannelMode || (t.SignalChannelMode = {}));
        t.VideoCodecStr2Int = { H264: 0, H265: 1, VP8: 2, NEVC: 3 };
        t.VideoCodecInt2Str = { 0: "H264", 1: "H265", 2: "VP8", 3: "NEVC" };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Mediasoup = void 0;
        const n = i(3), d = i(48), c = o(i(6)), l = o(i(8)), u = a(i(7)), h = i(221), p = a(i(167)), m = i(1), g = i(244), f = i(7), v = i(81), S = i(140), y = i(89);
        let _ = 0;
        const R = /* @__PURE__ */ new Map([["audio", ["_recvTransportMainAudio", "_recvTransportMainAudioTimeoutTimer"]], ["video", ["_recvTransportMainVideo", "_recvTransportMainVideoTimeoutTimer"]], ["audioSlave", ["_recvTransportSubAudioSlave", "_recvTransportSubAudioSlaveTimeoutTimer"]], ["screen", ["_recvTransportSubScreen", "_recvTransportSubScreenTimeoutTimer"]]]);
        class b extends n.EventEmitter {
          constructor(e2) {
            super(), this._consumers = {}, this._timeout = 6e4, this._edgeRtpCapabilities = null, this._mediasoupDevice = null, this._audioSlaveProducer = null, this._audioSlaveProducerId = null, this._micProducer = null, this._micProducerId = null, this._webcamProducer = null, this._webcamProducerId = null, this._screenProducer = null, this._screenProducerId = null, this._webcamProducerCodec = null, this._screenProducerCodec = null, this._sendTransport = null, this._recvTransport = null, this._sendTransportTimeoutTimer = null, this._recvTransportTimeoutTimer = null, this._eventQueue = [], this._eventQueueData = [], this._protoo = null, this.mediasoupId = _++, this._usedUidMediaTypes = {}, this.consumerMap = /* @__PURE__ */ new Map(), this.remoteRecvParams = {}, this.senderEncodingParameter = { ssrcList: [], audio: { high: null, low: null }, audioSlave: { high: null, low: null }, video: { high: null, low: null }, screen: { high: null, low: null }, videoThird: { high: null, low: null }, videoFourth: { high: null, low: null } }, this.unsupportedProducers = {}, this.iceStatusHistory = { send: { promises: [], status: { ts: 0, info: "" } }, recv: { promises: [], status: { ts: 0, info: "" } } }, this.adapterRef = e2.adapterRef, this.logger = e2.logger, this.loggerSend = e2.logger.getChild(() => {
              var e3, t2;
              let i2 = "MediaSend";
              if (this._sendTransport) if (null === (e3 = this._sendTransport._handler) || void 0 === e3 ? void 0 : e3._pc) {
                const e4 = this._sendTransport._handler._pc;
                e4.connectionState && "connected" !== e4.connectionState && (i2 += " " + e4.connectionState), "stable" !== e4.signalingState && (i2 += " " + e4.signalingState);
              } else i2 += " NOTRANSPORT";
              else i2 += " UNINIT";
              return (null === (t2 = this.adapterRef._mediasoup) || void 0 === t2 ? void 0 : t2.mediasoupId) !== this.mediasoupId && (i2 += " DETACHED"), i2;
            }), this.loggerRecv = e2.logger.getChild(() => {
              var e3, t2;
              let i2 = "MediaRecv";
              if (this._recvTransport) if (null === (e3 = this._recvTransport._handler) || void 0 === e3 ? void 0 : e3._pc) {
                const e4 = this._recvTransport._handler._pc;
                e4.connectionState && "connected" !== e4.connectionState && (i2 += " " + e4.connectionState), "stable" !== e4.signalingState && (i2 += " " + e4.signalingState);
              } else i2 += " NOTRANSPORT";
              else i2 += " UNINIT";
              return (null === (t2 = this.adapterRef._mediasoup) || void 0 === t2 ? void 0 : t2.mediasoupId) !== this.mediasoupId && (i2 += " DETACHED"), i2;
            }), this._reset();
          }
          get consumers() {
            return this._consumers;
          }
          _reset() {
            this._edgeRtpCapabilities = null, this._mediasoupDevice = null, this._micProducer = null, this._audioSlaveProducer = null, this._micProducerId = null, this._webcamProducer = null, this._webcamProducerId = null, this._screenProducer = null, this._screenProducerId = null, this._consumers = {}, this._sendTransportTimeoutTimer && clearTimeout(this._sendTransportTimeoutTimer), this._sendTransportTimeoutTimer = null, this._recvTransportTimeoutTimer && clearTimeout(this._recvTransportTimeoutTimer), this._recvTransportTimeoutTimer = null, this._sendTransport && this._sendTransport.close(), this._sendTransport = null, this._recvTransport && this._recvTransport.close(), this._recvTransport = null, this.resetConsumeRequestStatus();
          }
          async resetRecvTransport() {
            this.logger.log("[Subscribe] resetRecvTransport() 重新创建下行传输通道"), this._consumers = {}, this._recvTransportTimeoutTimer && clearTimeout(this._recvTransportTimeoutTimer), this._recvTransportTimeoutTimer = null, this._recvTransport && this._recvTransport.close(), this._recvTransport = null;
            let e2 = [], t2 = "all";
            if (this.adapterRef.channelInfo.relaytoken && this.adapterRef.channelInfo.relayaddrs && (this.adapterRef.channelInfo.relayaddrs.forEach((t3) => {
              e2.push({ urls: "turn:" + t3 + "?transport=udp", credential: this.adapterRef.proxyServer.credential || this.adapterRef.channelInfo.uid + "/" + this.adapterRef.channelInfo.cid, username: this.adapterRef.channelInfo.relaytoken }, { urls: "turn:" + t3 + "?transport=tcp", credential: this.adapterRef.proxyServer.credential || this.adapterRef.channelInfo.uid + "/" + this.adapterRef.channelInfo.cid, username: this.adapterRef.channelInfo.relaytoken });
            }), u.IS_FIREFOX || (t2 = "relay")), !this._recvTransport && this._mediasoupDevice) {
              const i2 = this._mediasoupDevice.createRecvTransport({ id: this.adapterRef.channelInfo.uid, iceParameters: void 0, iceCandidates: void 0, dtlsParameters: void 0, sctpParameters: void 0, iceServers: e2, iceTransportPolicy: t2, appData: { cid: this.adapterRef.channelInfo.cid, uid: this.adapterRef.channelInfo.uid, encodedInsertableStreams: this.adapterRef.encryption.encodedInsertableStreams } });
              this._recvTransport = i2, i2.on("connectionstatechange", this._recvTransportConnectionstatechange.bind(this, i2)), i2.handler._pc.addEventListener("iceconnectionstatechange", () => {
                this.getIceStatus("recv");
              });
            }
          }
          async init(e2 = []) {
            this.logger.log("init() 初始化 devices、transport"), this._mediasoupDevice || (this._mediasoupDevice = new p.Device(), this._mediasoupDevice && await this._mediasoupDevice.load({ routerRtpCapabilities: this._edgeRtpCapabilities }));
            let t2 = [], i2 = "all";
            if (this.adapterRef.channelInfo.relaytoken && this.adapterRef.channelInfo.relayaddrs ? (this.adapterRef.channelInfo.relayaddrs.forEach((e3) => {
              t2.push({ urls: "turn:" + e3 + "?transport=udp", credential: this.adapterRef.proxyServer.credential || this.adapterRef.channelInfo.uid + "/" + this.adapterRef.channelInfo.cid, username: this.adapterRef.channelInfo.relaytoken }, { urls: "turn:" + e3 + "?transport=tcp", credential: this.adapterRef.proxyServer.credential || this.adapterRef.channelInfo.uid + "/" + this.adapterRef.channelInfo.cid, username: this.adapterRef.channelInfo.relaytoken });
            }), u.IS_FIREFOX || (i2 = "relay")) : e2.length && (this.logger.log("init() 初始化 stunServers: ", e2), t2 = e2), t2.length && this.logger.log("iceTransportPolicy ", i2, " iceServers ", v.JSONBigStringify(t2)), !this._sendTransport && this._mediasoupDevice && (this._sendTransport = this._mediasoupDevice.createSendTransport({ id: this.adapterRef.channelInfo.uid, iceParameters: void 0, iceCandidates: void 0, dtlsParameters: void 0, sctpParameters: void 0, iceServers: t2, iceTransportPolicy: i2, appData: { cid: this.adapterRef.channelInfo.cid, uid: this.adapterRef.channelInfo.uid, encodedInsertableStreams: this.adapterRef.encryption.encodedInsertableStreams } }), this.senderEncodingParameter = { ssrcList: [], audioSlave: { high: null, low: null }, audio: { high: null, low: null }, video: { high: null, low: null }, screen: { high: null, low: null }, videoThird: { high: null, low: null }, videoFourth: { high: null, low: null } }, this._sendTransport.on("connectionstatechange", this._sendTransportConnectionstatechange.bind(this, this._sendTransport)), this._sendTransport.handler._pc.addEventListener("iceconnectionstatechange", () => {
              this.getIceStatus("send");
            })), !(u.ANY_CHROME_MAJOR_VERSION && u.ANY_CHROME_MAJOR_VERSION < 69) && !this._recvTransport && this._mediasoupDevice) {
              const e3 = this._mediasoupDevice.createRecvTransport({ id: this.adapterRef.channelInfo.uid, iceParameters: void 0, iceCandidates: void 0, dtlsParameters: void 0, sctpParameters: void 0, iceServers: t2, iceTransportPolicy: i2, appData: { cid: this.adapterRef.channelInfo.cid, uid: this.adapterRef.channelInfo.uid, encodedInsertableStreams: this.adapterRef.encryption.encodedInsertableStreams } });
              this._recvTransport = e3, e3.on("connectionstatechange", this._recvTransportConnectionstatechange.bind(this, e3)), e3.handler._pc.addEventListener("iceconnectionstatechange", () => {
                this.getIceStatus("recv");
              });
            }
            this.emit("transportReady");
          }
          async _sendTransportConnectionstatechange(e2, t2) {
            if (this._sendTransport && !this._sendTransport.closed) if (this._sendTransport.idx === e2.idx) if (this.loggerSend.log(`send connection #${e2._handler._pc.pcid} state  changed to ${t2}`), this.emit("upstream-state-change", { connectionState: t2 }), "failed" === t2) try {
              this._sendTransport && (this._sendTransportTimeoutTimer || (this._sendTransportTimeoutTimer = setTimeout(() => {
                this._reconnectTransportConnectTimeout();
              }, this._timeout))), this._sendTransportConnectTimeout();
            } catch (e3) {
              this.loggerSend.error("reconnectSendTransportConnect() | failed:", e3.name, e3.message);
            }
            else "connected" === t2 && this._sendTransportTimeoutTimer && (clearTimeout(this._sendTransportTimeoutTimer), this._sendTransportTimeoutTimer = null);
            else this.loggerSend.warn(`_sendTransportConnectionstatechange：出现了_sendTransport绑定不一致的状况:${e2.id}/${e2.idx}=>${this._sendTransport.id}/${this._sendTransport.idx}`);
          }
          async _recvTransportConnectionstatechange(e2, t2) {
            if (this._recvTransport && !this._recvTransport.closed) if (this._recvTransport.idx === e2.idx) if (this.loggerRecv.log(`recv connection ${e2._handler._pc.pcid} state changed to ${t2}`), this.emit("downstream-state-change", { connectionState: t2 }), "failed" === t2) {
              try {
                this._recvTransport && (this._recvTransportTimeoutTimer || (this._recvTransportTimeoutTimer = setTimeout(() => {
                  this._reconnectTransportConnectTimeout();
                }, this._timeout)));
              } catch (e3) {
                this.loggerRecv.error("reconnectRecvTransportConnect() | failed:", e3.name, e3.message);
              }
              this._recvTransportConnectTimeout();
            } else "connected" === t2 && this._recvTransportTimeoutTimer && (clearTimeout(this._recvTransportTimeoutTimer), this._recvTransportTimeoutTimer = null);
            else this.loggerRecv.warn(`_recvTransportConnectionstatechange：出现了_recvTransport绑定不一致的状况:${e2.id}/${e2.idx}=>${this._recvTransport.id}/${this._recvTransport.idx}`);
          }
          async _recvTransportConnectionstatechange69(e2, t2, i2) {
            let r2 = i2.target.iceConnectionState;
            if (this.loggerRecv.log(`recv69 connection ${e2._handler._pc.pcid} state changed to ${r2}`), this.emit("downstream-state-change", { connectionState: r2 }), "failed" === r2) {
              try {
                e2 && (t2 || (t2 = setTimeout(() => {
                  this._reconnectTransportConnectTimeout();
                }, this._timeout)));
              } catch (e3) {
                this.loggerRecv.error("reconnectRecvTransportConnect() | failed:", e3.name, e3.message);
              }
              this._recvTransportConnectTimeout();
            } else "connected" === r2 && t2 && (clearTimeout(t2), t2 = null);
          }
          async _sendTransportConnectTimeout() {
            this.loggerSend.warn("媒体上行传输通道连接失败"), this.adapterRef._signalling && ("CONNECTED" === this.adapterRef.connectState.curState ? (this.loggerSend.log("媒体上行传输通道连接失败，尝试整体重连"), this.adapterRef.channelStatus = "connectioning", this.adapterRef._signalling.reconnectionControl.next = this.adapterRef._signalling.reconnectionControl.copynext, this.adapterRef._signalling.reconnectionReason = d.ReconnectReason.SendPeerIceFailed, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "sendPeerIceFailed", ext: "" }), this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this.adapterRef._signalling._reconnection()) : (this.loggerRecv.warn("媒体上行传输通道建立失败, 此时sdk正在重连, 不用特殊处理"), this.adapterRef.instance.apiEventReport("setStreamException", { name: "pushStreamException", value: "send transport connection failed" })));
          }
          async _recvTransportConnectTimeout() {
            this.loggerRecv.warn("媒体下行传输通道建立失败"), this.adapterRef._signalling && ("CONNECTED" === this.adapterRef.connectState.curState ? (this.loggerRecv.error("媒体下行传输通道连接失败，尝试整体重连"), this.adapterRef.channelStatus = "connectioning", this.adapterRef._signalling.reconnectionControl.next = this.adapterRef._signalling.reconnectionControl.copynext, this.adapterRef._signalling.reconnectionReason = d.ReconnectReason.RecvPeerIceFailed, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "recvPeerIceFailed", ext: "" }), this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this.adapterRef._signalling._reconnection()) : (this.loggerRecv.warn("媒体下行传输通道建立失败，此时sdk正在重连，不用特殊处理"), this.adapterRef.instance.apiEventReport("setStreamException", { name: "pullStreamException", value: "receive transport connection failed" })));
          }
          async _reconnectTransportConnectTimeout() {
            this.loggerRecv.error("媒体传输通道一直重连失败，主动退出房间"), this.adapterRef.instance.safeEmit("error", "MEDIA_TRANSPORT_DISCONNECT"), this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: d.ConStateChange_state.ChannelLeave, reason: d.ConStateChange_reason.MediaDisconnected }), this.adapterRef.instance.leave(c.default.MEDIA_CONNECTION_DISCONNECTED);
          }
          async createProduce(e2, t2) {
            var i2, r2, s2, a2, o2;
            if (e2.logger.log("publish() 发布音视频, mediaType: ", t2), !this._sendTransport) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "createProduce: 发送端 transport 未找到 1" });
            if (0 === this._sendTransport.listenerCount("produce") && this._sendTransport.on("produce", async ({ kind: t3, rtpParameters: i3, appData: r3, localDtlsParameters: s3, offer: a3 }, o3, n2) => {
              if (this.loggerSend.log(`publish() produce 反馈 [kind= ${t3}, appData= ${v.JSONBigStringify(r3)}]`), !this._sendTransport) return;
              const d2 = "screenShare" == r3.mediaType ? "screen" : r3.mediaType;
              let h2 = false;
              ("video" === d2 && this.adapterRef.channelInfo.videoLow || "screen" === d2 && this.adapterRef.channelInfo.screenLow) && (h2 = true);
              const p2 = a3.sdp.match(/a=ice-ufrag:([0-9a-zA-Z#=+-_\/\\\\]+)/);
              p2 || this.adapterRef.logger.error("publish() 找不到 iceUfragRegLocal: ", a3.sdp);
              try {
                this.adapterRef.preferRemb && (this.logger.log("publish() 使用REMB作为带宽估计方式"), y.filterTransportCCFromRtpParameters(i3));
                let n3, g2, f2, S2, _2 = Object.assign({ requestId: "" + Math.ceil(1e9 * Math.random()), kind: t3, rtpParameters: i3, iceUfrag: p2[1], externData: { producerInfo: { mediaType: "audioSlave" === r3.mediaType ? "subAudio" : r3.mediaType, subStream: "screenShare" === r3.mediaType || "audioSlave" === r3.mediaType, simulcastEnable: h2, spatialLayerCount: h2 ? 2 : 1, mute: e2.muteStatus[d2].send || false } }, appData: { enableTcpCandidate: true } }, r3);
                if ("screen" === d2 ? _2.deviceId = "screen-share-default" : "video" === d2 && (e2.mediaHelper.video.videoSource ? _2.deviceId = "video-external-default" : _2.deviceId = "video-default"), m.getParameters().revertSubstreamProduceType) switch (_2.externData.producerInfo.mediaType) {
                  case "screenShare":
                    _2.externData.producerInfo.mediaType = "video", _2.externData.producerInfo.subStream = false;
                    break;
                  case "video":
                    _2.externData.producerInfo.mediaType = "screenShare", _2.externData.producerInfo.subStream = true;
                    break;
                  case "audio":
                    _2.externData.producerInfo.mediaType = "subAudio", _2.externData.producerInfo.subStream = true;
                    break;
                  case "subAudio":
                    _2.externData.producerInfo.mediaType = "audio", _2.externData.producerInfo.subStream = false;
                }
                if (u.ANY_CHROME_MAJOR_VERSION && u.ANY_CHROME_MAJOR_VERSION >= 58 && u.ANY_CHROME_MAJOR_VERSION < 69) n3 = i3.encodings[0];
                else {
                  if (n3 = this.senderEncodingParameter[d2].high, g2 = this.senderEncodingParameter[d2].low, f2 = a3.sdp.indexOf(r3.deviceId), S2 = a3.sdp.indexOf(r3.deviceIdLow), !n3) {
                    if (i3.encodings && (n3 = i3.encodings[0], n3 && this.senderEncodingParameter.ssrcList.indexOf(n3.ssrc) > -1 && (n3 = null), i3.encodings[1] && (g2 = i3.encodings[1], g2 && this.senderEncodingParameter.ssrcList.indexOf(g2.ssrc) > -1 && (n3 = null))), !n3 && r3.deviceId && f2 > -1) {
                      const e3 = a3.sdp.substring(f2).match(/a=ssrc-group:FID (\d+) (\d+)/);
                      if (e3 && (n3 = { ssrc: parseInt(e3[1]), rtx: { ssrc: parseInt(e3[2]) } }), n3 && this.senderEncodingParameter.ssrcList.indexOf(n3.ssrc) > -1 && (n3 = null), !g2 && r3.deviceIdLow && S2 > -1) {
                        const e4 = a3.sdp.substring(S2).match(/a=ssrc-group:FID (\d+) (\d+)/);
                        e4 && (g2 = { ssrc: parseInt(e4[1]), rtx: { ssrc: parseInt(e4[2]) } }), g2 && this.senderEncodingParameter.ssrcList.indexOf(g2.ssrc) > -1 && (g2 = null);
                      }
                    }
                    n3 || (this.loggerSend.log("publish() 使用sdp中第一个ssrc"), n3 = { ssrc: parseInt(a3.sdp.match(/a=ssrc:(\d+)/)[1]), dtx: false }), this.senderEncodingParameter[d2].high = n3, this.senderEncodingParameter.ssrcList.push(n3.ssrc), g2 ? (this.senderEncodingParameter[d2].low = g2, this.senderEncodingParameter.ssrcList.push(g2.ssrc)) : this.senderEncodingParameter[d2].low = null;
                  }
                  i3.encodings = [this.senderEncodingParameter[d2].high], this.senderEncodingParameter[d2].low && i3.encodings.unshift(this.senderEncodingParameter[d2].low);
                }
                if ("video" === r3.mediaType || "screenShare" === r3.mediaType) {
                  const t4 = "video" === r3.mediaType ? "video" : "screen", i4 = e2.mediaHelper[t4];
                  console.log("mediaConfig: ", i4), _2.mediaProfile = [], g2 && _2.mediaProfile.push({ ssrc: g2.ssrc, res: "240*180", fps: "1", spatialLayer: 0, maxBitrate: i4.encoderConfig.low.maxBitrate / 1e3 || 800 }), console.log("captureConfig: ", i4.captureConfig), _2.mediaProfile.push({ ssrc: n3.ssrc, res: `${i4.captureConfig.high.width || 640}*${i4.captureConfig.high.height || 480}`, fps: "" + (i4.captureConfig.high.frameRate || 15), spatialLayer: _2.mediaProfile.length, maxBitrate: i4.encoderConfig.high.maxBitrate / 1e3 || 800 });
                } else if ("audio" === r3.mediaType) {
                  _2.mediaProfile = [];
                  let t4 = 32;
                  switch (e2.audioProfile) {
                    case "speech_standard":
                      t4 = 36;
                      break;
                    case "music_standard":
                      t4 = 40;
                      break;
                    case "standard_stereo":
                      t4 = 64;
                      break;
                    case "high_quality":
                      t4 = 128;
                      break;
                    case "high_quality_stereo":
                      t4 = 192;
                  }
                  _2.mediaProfile.push({ ssrc: n3.ssrc, maxBitrate: t4 });
                }
                for (let e3 = _2.rtpParameters.codecs.length - 1; e3 >= 0; e3--) "audio/red" === _2.rtpParameters.codecs[e3].mimeType && _2.rtpParameters.codecs.splice(e3, 1);
                if (void 0 === s3 ? _2.transportId = this._sendTransport.id : _2.dtlsParameters = s3, !this.adapterRef._signalling || !this.adapterRef._signalling._protoo) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "createProduce: _protoo 未找到" });
                let R2 = _2.rtpParameters;
                const b2 = R2.codecs[0];
                m.getParameters().h264ProfileLevel && m.getParameters().h264ProfileLevelSignal && "video/H264" === b2.mimeType && b2.parameters && b2.parameters["profile-level-id"] !== m.getParameters().h264ProfileLevelSignal && (R2 = JSON.parse(JSON.stringify(R2)), this.logger.log(`信令消息修改profile-level-id, ${R2.codecs[0].parameters["profile-level-id"]} => ${m.getParameters().h264ProfileLevelSignal}`), R2.codecs[0].parameters["profile-level-id"] = m.getParameters().h264ProfileLevelSignal, _2.rtpParameters = R2);
                let T = await this.adapterRef._signalling._protoo.request("Produce", _2);
                const { code: E, transportId: A, iceParameters: I, iceCandidates: w, turnParameters: C, dtlsParameters: O, producerId: k, errMsg: P } = T;
                if (void 0 !== A && (this._sendTransport._id = A), 200 === E ? this.loggerSend.log(`publish() produce请求反馈结果, code: ${E}, kind: ${t3}, producerId: ${k}`) : this.loggerSend.error(`publish() produce请求反馈错误, code: ${E}, kind: ${t3}, producerId: ${k},  errMsg: ${P}, 请求：${v.JSONBigStringify(_2)}, 返回：${v.JSONBigStringify(_2)}`), C) {
                  let e3 = [];
                  e3.push({ urls: "turn:" + C.ip + ":" + C.port + "?transport=udp", credential: C.password, username: C.username }, { urls: "turn:" + C.ip + ":" + C.port + "?transport=tcp", credential: C.password, username: C.username }), await this._sendTransport.updateIceServers({ iceServers: e3 });
                }
                let x = { codecParam: null, codecName: null };
                if ("audio" === r3.mediaType ? this._micProducerId = k : "audioSlave" === r3.mediaType ? this._audioSlaveProducerId = k : "video" === r3.mediaType ? (this._webcamProducerId = k, x = this.adapterRef.mediaCapability.getCodecSend("video", this._sendTransport.handler._sendingRtpParametersByKind.video), this._webcamProducerCodec = x.codecName) : "screenShare" === r3.mediaType && (this._screenProducerId = k, x = this.adapterRef.mediaCapability.getCodecSend("screen", this._sendTransport.handler._sendingRtpParametersByKind.video), this._screenProducerCodec = x.codecName), !this.adapterRef.localStream) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "createProduce: 未找到 localStream" });
                let M = [];
                if ("audio" === r3.mediaType || "audioSlave" === r3.mediaType) M.push(Object.assign({}, m.getParameters().codecOptions.audio));
                else if ("video" === r3.mediaType) {
                  if (i3.encodings.length >= 2) {
                    const e4 = {};
                    m.getParameters().videoLowStartBitrate && (e4.videoGoogleStartBitrate = m.getParameters().videoLowStartBitrate), m.getParameters().videoLowMinBitrate && (e4.videoGoogleMinBitrate = m.getParameters().videoLowMinBitrate), M.push(e4);
                  }
                  const e3 = {};
                  m.getParameters().videoHighStartBitrate && (e3.videoGoogleStartBitrate = m.getParameters().videoHighStartBitrate), m.getParameters().videoHighMinBitrate && (e3.videoGoogleMinBitrate = m.getParameters().videoHighMinBitrate), M.push(e3);
                } else if ("screenShare" === r3.mediaType) {
                  if (i3.encodings.length >= 2) {
                    const e4 = {};
                    m.getParameters().screenLowStartBitrate && (e4.videoGoogleStartBitrate = m.getParameters().screenLowStartBitrate), m.getParameters().screenLowMinBitrate && (e4.videoGoogleMinBitrate = m.getParameters().screenLowMinBitrate), M.push(e4);
                  }
                  const e3 = {};
                  m.getParameters().screenHighStartBitrate && (e3.videoGoogleStartBitrate = m.getParameters().screenHighStartBitrate), m.getParameters().screenHighMinBitrate && (e3.videoGoogleMinBitrate = m.getParameters().screenHighMinBitrate), M.push(e3);
                }
                this.logger.log(`codecOptions for producer ${r3.mediaType}: ${v.JSONBigStringify(M)}`);
                let D = w;
                this.adapterRef.channelInfo.iceProtocol && w && (this.logger.warn("Produce iceProtocol: ", this.adapterRef.channelInfo.iceProtocol), D = w.filter((e3) => e3.protocol == this.adapterRef.channelInfo.iceProtocol)), r3.mediaType && (this.remoteRecvParams[r3.mediaType] = { kind: t3, appData: r3, iceParameters: I, iceCandidates: D, dtlsParameters: O, sctpParameters: void 0, sendingRtpParameters: i3, codecOptions: M, offer: a3, codec: x.codecParam, audioProfile: this.adapterRef.localStream.audioProfile }), await this._sendTransport.fillRemoteRecvSdp({ kind: t3, appData: r3, iceParameters: I, iceCandidates: D, dtlsParameters: O, sctpParameters: void 0, sendingRtpParameters: i3, codecOptions: M, offer: a3, codec: x.codecParam, audioProfile: this.adapterRef.localStream.audioProfile }), u.ANY_CHROME_MAJOR_VERSION && u.ANY_CHROME_MAJOR_VERSION >= 58 && u.ANY_CHROME_MAJOR_VERSION < 69 || "video" !== d2 && "screen" !== d2 || (this.adapterRef.localStream.applyEncoderConfig(d2, "high"), i3.encodings.length >= 2 && this.adapterRef.localStream.applyEncoderConfig(d2, "low")), o3({ id: k });
              } catch (e3) {
                n2(e3);
              }
            }), "audio" === t2 || "all" === t2) if (this._micProducer) this.loggerSend.log("publish() 音频已经发布, 忽略");
            else {
              const t3 = e2.mediaHelper.audio.audioStream.getAudioTracks()[0];
              if (t3) if (false === (null === (i2 = this.adapterRef.permKeyInfo) || void 0 === i2 ? void 0 : i2.pubAudioRight)) this.loggerSend.error("publish() permKey权限控制, 不能发布音频"), this.adapterRef.instance.safeEmit("error", "no-publish-audio-permission");
              else if ("ended" === t3.readyState) this.loggerSend.error("publish() 音频轨道已关闭，请检查输入设备:audio", t3);
              else {
                this.loggerSend.log("publish() 发布音频 audioTrack: ", t3.id, t3.label), e2.pubStatus.audio.audio = true;
                try {
                  this._micProducer = await this._sendTransport.produce({ track: t3, trackLow: null, codecOptions: { opusStereo: true, opusDtx: true }, appData: { preferRemb: this.adapterRef.preferRemb, deviceId: t3.id, deviceIdLow: null, mediaType: "audio" } });
                } catch (e3) {
                  this.loggerSend.error("produce audio error: ", e3);
                }
                this.watchProducerState(this._micProducer, "_micProducer"), this.adapterRef.encryption.encodedInsertableStreams && this._micProducer._rtpSender && this.enableSendTransform(this._micProducer._rtpSender, "audio", "high");
              }
            }
            if ("audioSlave" === t2 || "all" === t2) if (this._audioSlaveProducer) this.loggerSend.log("publish() 音频辅流已经发布, 忽略");
            else {
              const t3 = e2.mediaHelper.screenAudio.screenAudioStream.getAudioTracks()[0];
              t3 && (false === (null === (r2 = this.adapterRef.permKeyInfo) || void 0 === r2 ? void 0 : r2.pubAudioRight) ? (this.loggerSend.error("publish() permKey权限控制, 不能发布音频辅流"), this.adapterRef.instance.safeEmit("error", "no-publish-audio-slave-permission")) : "ended" === t3.readyState ? this.loggerSend.error("publish() 音频辅流轨道已关闭，请检查输入设备:audioSlave", t3) : (this.loggerSend.log("publish() 发布音频辅流 audioSlaveTrack: ", t3.id, t3.label), e2.pubStatus.audioSlave.audio = true, this._audioSlaveProducer = await this._sendTransport.produce({ track: t3, trackLow: null, codecOptions: { opusStereo: true, opusDtx: true }, appData: { preferRemb: this.adapterRef.preferRemb, deviceId: t3.id, deviceIdLow: null, mediaType: "audioSlave" } }), this.watchProducerState(this._audioSlaveProducer, "_audioSlaveProducer")));
            }
            if ("video" === t2 || "all" === t2) {
              if (this._webcamProducer) this.loggerSend.log("publish() 视频已经发布，忽略");
              else if (e2.mediaHelper.video.videoStream.getVideoTracks().length) {
                const t3 = e2.mediaHelper.video.videoStream.getVideoTracks()[0];
                if (false === (null === (s2 = this.adapterRef.permKeyInfo) || void 0 === s2 ? void 0 : s2.pubVideoRight)) this.loggerSend.error("publish() permKey权限控制, 不能发布视频"), this.adapterRef.instance.safeEmit("error", "no-publish-video-permission");
                else if ("ended" === t3.readyState) this.loggerSend.error("publish() 视频轨道已关闭, 请检查输入设备: video", t3);
                else {
                  let i3 = null;
                  this.adapterRef.channelInfo.videoLow ? (e2.mediaHelper.video.low || (e2.mediaHelper.video.low = new g.VideoTrackLow({ logger: this.logger, mediaType: "video" })), e2.mediaHelper.video.low.track ? (i3 = e2.mediaHelper.video.low.track, this.adapterRef.instance.safeEmit("track-low-init-success", { mediaType: "video" })) : this.adapterRef.instance.safeEmit("track-low-init-fail", { mediaType: "video" })) : (e2.mediaHelper.video.low && e2.mediaHelper.video.low.bindSender(null, null), this.senderEncodingParameter.video.low = null), this.loggerSend.log("publish() 发布视频 videoTrack: ", t3.id, t3.label), e2.pubStatus.video.video = true;
                  const r3 = this.adapterRef.mediaCapability.getCodecSend("video", this._sendTransport.handler._sendingRtpParametersByKind.video);
                  this._webcamProducer = await this._sendTransport.produce({ track: t3, trackLow: i3, codec: r3.codecParam, codecOptions: { videoGoogleStartBitrate: 1e3 }, appData: { preferRemb: this.adapterRef.preferRemb, deviceId: t3.id, deviceIdLow: (null == i3 ? void 0 : i3.id) || null, mediaType: "video" } }), this._webcamProducer._rtpSender && e2.mediaHelper.video.low && (e2.mediaHelper.video.low.bindSender(this._webcamProducer._rtpSender, this._webcamProducer._rtpSenderLow || null), f.IS_SAFARI && f.SAFARI_MAJOR_VERSION && f.SAFARI_MAJOR_VERSION < 14 && (null === (a2 = e2._play.video.dom) || void 0 === a2 ? void 0 : a2.srcObject) && (this.logger.log("publish() 尝试重置本地视图的SrcObject"), e2._play.video.dom.srcObject = e2._play.video.dom.srcObject)), this.watchProducerState(this._webcamProducer, "_webcamProducer"), this.adapterRef.encryption.encodedInsertableStreams && (this._webcamProducer._rtpSender && this.enableSendTransform(this._webcamProducer._rtpSender, "video", "high"), this._webcamProducer._rtpSenderLow && this.enableSendTransform(this._webcamProducer._rtpSenderLow, "video", "low")), this.adapterRef.state.startPubVideoTime || (this.adapterRef.state.startPubVideoTime = Date.now());
                }
              }
            }
            if ("screen" === t2 || "all" === t2) {
              if (this._screenProducer) this.loggerSend.log("publish() 屏幕共享已经发布, 忽略");
              else if (e2.mediaHelper.screen.screenVideoStream.getVideoTracks().length) {
                const t3 = e2.mediaHelper.screen.screenVideoStream.getVideoTracks()[0];
                if (false === (null === (o2 = this.adapterRef.permKeyInfo) || void 0 === o2 ? void 0 : o2.pubVideoRight)) this.loggerSend.error("publish() permKey权限控制, 不能发布屏幕共享"), this.adapterRef.instance.safeEmit("error", "no-publish-screen-permission");
                else if ("ended" === t3.readyState) this.loggerSend.error("publish()，屏幕共享轨道已关闭，请检查输入设备:screen", t3);
                else {
                  let i3 = null;
                  this.adapterRef.channelInfo.screenLow ? (e2.mediaHelper.screen.low || (e2.mediaHelper.screen.low = new g.VideoTrackLow({ logger: e2.logger, mediaType: "screen" })), e2.mediaHelper.screen.low.track ? (i3 = e2.mediaHelper.screen.low.track, this.adapterRef.instance.safeEmit("track-low-init-success", { mediaType: "screen" })) : this.adapterRef.instance.safeEmit("track-low-init-fail", { mediaType: "screen" })) : (e2.mediaHelper.screen.low && e2.mediaHelper.screen.low.bindSender(null, null), this.senderEncodingParameter.screen.low = null), this.loggerSend.log("publish() 发布屏幕共享 screenTrack: ", t3.id, t3.label), e2.pubStatus.screen.screen = true;
                  const r3 = this.adapterRef.mediaCapability.getCodecSend("screen", this._sendTransport.handler._sendingRtpParametersByKind.video);
                  this._screenProducer = await this._sendTransport.produce({ track: t3, trackLow: i3, codec: r3.codecParam, codecOptions: { videoGoogleStartBitrate: 1e3 }, appData: { preferRemb: this.adapterRef.preferRemb, deviceId: t3.id, deviceIdLow: (null == i3 ? void 0 : i3.id) || null, mediaType: "screenShare" } }), this._screenProducer._rtpSender && e2.mediaHelper.screen.low && e2.mediaHelper.screen.low.bindSender(this._screenProducer._rtpSender, this._screenProducer._rtpSenderLow || null), this.watchProducerState(this._screenProducer, "_screenProducer"), this.adapterRef.encryption.encodedInsertableStreams && (this._screenProducer._rtpSender && this.enableSendTransform(this._screenProducer._rtpSender, "screen", "high"), this._screenProducer._rtpSenderLow && this.enableSendTransform(this._screenProducer._rtpSenderLow, "screen", "low")), this.adapterRef.state.startPubScreenTime || (this.adapterRef.state.startPubScreenTime = Date.now());
                }
              }
            }
          }
          async setRemoteRecvSdp(e2, t2) {
            var i2, r2, s2;
            if (!this._sendTransport) return void this.logger.warn("setRemoteRecvSdp _sendTransport 不存在");
            if (!this.remoteRecvParams[t2]) return void this.logger.warn("setRemoteRecvSdp remoteRecvParams 不存在, mediaType: " + t2);
            if (!this.adapterRef.localStream) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "未找到 localStream" });
            const { kind: a2, appData: o2, iceParameters: n2, iceCandidates: d2, dtlsParameters: u2, codecOptions: h2, sendingRtpParameters: p2 } = this.remoteRecvParams[t2], m2 = await this._sendTransport._handler._pc.createOffer();
            let g2 = null, f2 = (null === (r2 = null === (i2 = this._sendTransport) || void 0 === i2 ? void 0 : i2.handler._sendingRtpParametersByKind.video) || void 0 === r2 ? void 0 : r2.codecs) || [];
            for (let t3 in f2) if (f2[t3].mimeType.indexOf(e2) > -1) {
              g2 = { codecParam: f2[t3], codecName: e2 };
              break;
            }
            g2 ? await (null === (s2 = this._sendTransport) || void 0 === s2 ? void 0 : s2.fillRemoteRecvSdp({ kind: a2, appData: o2, iceParameters: n2, iceCandidates: d2, dtlsParameters: u2, sctpParameters: void 0, sendingRtpParameters: p2, codecOptions: h2, offer: m2, codec: g2.codecParam, audioProfile: this.adapterRef.localStream.audioProfile, resetVideoSdp: "video" === t2 || "screenShare" === t2 })) : this.logger.error("setRemoteRecvSdp codecInfo 不存在", e2);
          }
          enableSendTransform(e2, t2, i2) {
            var r2;
            const s2 = null === (r2 = this._sendTransport) || void 0 === r2 ? void 0 : r2.send.find((t3) => t3.sender === e2);
            if (s2) if (s2.encodedStreams) this.loggerRecv.log(`发送端自定义加密，复用之前的通道。 ${s2.mediaType} ${s2.streamType}`);
            else {
              const t3 = e2.createEncodedStreams(), i3 = new TransformStream({ transform: this.adapterRef.encryption.handleUpstreamTransform.bind(this.adapterRef.encryption, s2) });
              t3.readable.pipeThrough(i3).pipeTo(t3.writable), s2.encodedStreams = t3, s2.transformStream = i3, this.loggerRecv.log(`发送端自定义加密，成功启动。 ${s2.mediaType} ${s2.streamType}`);
            }
            else this.loggerRecv.error("enableSendTransform() 未找到匹配的Sender", t2, i2);
          }
          enableRecvTransform(e2, t2, i2) {
            var r2;
            const s2 = null === (r2 = this._recvTransport) || void 0 === r2 ? void 0 : r2.recv.find((t3) => t3.receiver === e2);
            if (s2) if (s2.encodedStreams) this.loggerRecv.log(`接收端自定义解密，复用之前的通道。uid:${s2.uid}, mediaType: ${s2.mediaType}`);
            else {
              const t3 = e2.createEncodedStreams(), i3 = new TransformStream({ transform: this.adapterRef.encryption.handleDownstreamTransform.bind(this.adapterRef.encryption, s2) });
              t3.readable.pipeThrough(i3).pipeTo(t3.writable), s2.encodedStreams = t3, s2.transformStream = i3, this.loggerRecv.log(`接收端自定义解密，成功启动。uid:${s2.uid}, mediaType: ${s2.mediaType}`);
            }
            else this.loggerRecv.error("enableRecvTransform() 未找到匹配的Receiver", t2, i2);
          }
          watchProducerState(e2, t2) {
            var i2;
            if (null === (i2 = e2.rtpSender) || void 0 === i2 ? void 0 : i2.transport) {
              const i3 = e2.rtpSender.transport;
              switch (i3.state) {
                case "failed":
                  this.logger.error(`publish() Producer state ${t2} ${i3.state}`);
                  break;
                case "connected":
                case "new":
                case "connecting":
                default:
                  this.logger.log(`publish() Producer state ${t2} ${i3.state}`), e2.rtpSender.transport.addEventListener("statechange", () => {
                    switch (i3.state) {
                      case "failed":
                        this.logger.error(`publish() Producer state changed: ${t2} ${i3.state}`);
                        break;
                      case "connected":
                      case "new":
                      case "connecting":
                        this.logger.log(`publish() Producer state changed: ${t2} ${i3.state}`);
                    }
                  });
              }
            } else this.logger.log("publish() Producer state: transport is null");
          }
          async destroyProduce(e2) {
            var t2;
            let i2 = null, r2 = null;
            if (!this.adapterRef.localStream) throw new l.default({ code: c.default.LOCALSTREAM_NOT_FOUND_ERROR, message: `destroyProduce.${e2}: 未找到 localStream` });
            "audio" === e2 ? (i2 = this._micProducer, r2 = this._micProducerId, this._micProducer = this._micProducerId = null, this.adapterRef.localStream.pubStatus.audio.audio = false) : "audioSlave" === e2 ? (i2 = this._audioSlaveProducer, r2 = this._audioSlaveProducerId, this._audioSlaveProducer = this._audioSlaveProducerId = null, this.adapterRef.localStream.pubStatus.audioSlave.audio = false) : "video" === e2 ? (i2 = this._webcamProducer, r2 = this._webcamProducerId, this._webcamProducer = this._webcamProducerId = null, this.adapterRef.localStream.pubStatus.video.video = false) : "screen" === e2 && (i2 = this._screenProducer, r2 = this._screenProducerId, this._screenProducer = this._screenProducerId = null, this.adapterRef.localStream.pubStatus.screen.screen = false);
            try {
              if (this.loggerSend.log(`停止发布 destroyProduce ${e2} producerId=`, r2), !i2) return;
              i2.close(), (null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) ? this.adapterRef._signalling._protoo.request("CloseProducer", { requestId: "" + Math.ceil(1e9 * Math.random()), producerId: r2 }).catch((e3) => {
                this.logger.error("CloseProducer Failed: ", e3.name, e3.message);
              }) : this.logger.warn("destroyProduce: 当前信令中断, 不发信令包", e2, r2);
            } catch (e3) {
              this.loggerSend.error("destroyProduce failed: ", e3.name, e3.message);
            }
          }
          async createConsumer(e2, t2, i2, r2, s2 = 0) {
            this.adapterRef.instance.safeEmit("@pairing-createConsumer-start");
            let a2 = false;
            if (this._eventQueue.forEach((t3) => {
              if (t3.id === r2) return this.loggerRecv.log(`[subscribe] 已经在订阅任务队列中，忽略该次请求, uid: ${e2}, mediaType: ${i2}, producerId: ${r2}`), void (a2 = true);
            }), !a2) return new Promise((a3, o2) => {
              if (this._eventQueue.push({ uid: e2, kind: t2, id: r2, mediaType: i2, preferredSpatialLayer: s2, resolve: a3, reject: o2 }), this._eventQueue.length > 1) return this._eventQueueData = Object.assign([], this._eventQueue), void this.loggerRecv.log(`[subscribe] 订阅任务队列中有多个任务，当前任务队列长度: ${this._eventQueue.length},第一个任务: ${JSON.stringify(this._eventQueue[0])}`);
              this._createConsumer(this._eventQueue[0]);
            });
          }
          async createConsumer69(e2, t2, i2, r2) {
            if (this.consumerMap.has(e2)) {
              if (i2.audio == this.consumerMap.get(e2).subStatus.audio && i2.video == this.consumerMap.get(e2).subStatus.video && i2.audioSlave == this.consumerMap.get(e2).subStatus.audioSlave && i2.screen == this.consumerMap.get(e2).subStatus.screen) return void this.logger.info("createConsumer69() uid 已经存在");
              this.logger.info("createConsumer69() 只需替换pubStatus: ", r2), this.logger.info("createConsumer69() 只需替换stream.pubStatus: ", t2.pubStatus), this.consumerMap.get(e2).subStatus = i2, this.consumerMap.get(e2).pubStatus = t2.pubStatus;
            } else this.logger.info("createConsumer69() 设置consumerMap: ", r2), this.consumerMap.set(e2, { stream: t2, subStatus: i2, pubStatus: r2 });
            let s2 = [], a2 = "all";
            this.adapterRef.channelInfo.relaytoken && this.adapterRef.channelInfo.relayaddrs && (this.adapterRef.channelInfo.relayaddrs.forEach((e3) => {
              s2.push({ urls: "turn:" + e3 + "?transport=udp", credential: this.adapterRef.proxyServer.credential || this.adapterRef.channelInfo.uid + "/" + this.adapterRef.channelInfo.cid, username: this.adapterRef.channelInfo.relaytoken }, { urls: "turn:" + e3 + "?transport=tcp", credential: this.adapterRef.proxyServer.credential || this.adapterRef.channelInfo.uid + "/" + this.adapterRef.channelInfo.cid, username: this.adapterRef.channelInfo.relaytoken });
            }), u.IS_FIREFOX || (a2 = "relay")), s2.length && this.logger.log("iceTransportPolicy ", a2, " iceServers ", v.JSONBigStringify(s2)), this.consumerMap.size && this.consumerMap.forEach((e3, t3) => {
              this._mediasoupDevice && (e3.subStatus.audio && !e3._recvTransportMainAudio && (e3._recvTransportMainAudio = this._mediasoupDevice.createRecvTransport({ id: t3 + "_main_audio", iceParameters: void 0, iceCandidates: void 0, dtlsParameters: void 0, sctpParameters: void 0, iceServers: s2, iceTransportPolicy: a2, appData: { cid: this.adapterRef.channelInfo.cid, uid: t3.toString(), encodedInsertableStreams: this.adapterRef.encryption.encodedInsertableStreams } }), e3._recvTransportMainAudioTimeoutTimer = null, e3._recvTransportMainAudio._handler._pc.addEventListener("iceconnectionstatechange", this._recvTransportConnectionstatechange69.bind(this, e3._recvTransportMainAudio, e3._recvTransportMainAudioTimeoutTimer)), this._createConsumer69(t3, "audio", "audio", e3.pubStatus.audio.producerId, e3._recvTransportMainAudio)), e3.subStatus.video && !e3._recvTransportMainVideo && (e3._recvTransportMainVideo = this._mediasoupDevice.createRecvTransport({ id: t3 + "_main_video", iceParameters: void 0, iceCandidates: void 0, dtlsParameters: void 0, sctpParameters: void 0, iceServers: s2, iceTransportPolicy: a2, appData: { cid: this.adapterRef.channelInfo.cid, uid: t3.toString(), encodedInsertableStreams: this.adapterRef.encryption.encodedInsertableStreams } }), e3._recvTransportMainVideoTimeoutTimer = null, e3._recvTransportMainVideo._handler._pc.addEventListener("iceconnectionstatechange", this._recvTransportConnectionstatechange69.bind(this, e3._recvTransportMainVideo, e3._recvTransportMainVideoTimeoutTimer)), this._createConsumer69(t3, "video", "video", e3.pubStatus.video.producerId, e3._recvTransportMainVideo)), e3.subStatus.audioSlave && !e3._recvTransportSubAudioSlave && (e3._recvTransportSubAudioSlave = this._mediasoupDevice.createRecvTransport({ id: t3 + "_sub_audioSlave", iceParameters: void 0, iceCandidates: void 0, dtlsParameters: void 0, sctpParameters: void 0, iceServers: s2, iceTransportPolicy: a2, appData: { cid: this.adapterRef.channelInfo.cid, uid: t3.toString(), encodedInsertableStreams: this.adapterRef.encryption.encodedInsertableStreams } }), e3._recvTransportSubAudioSlaveTimeoutTimer = null, e3._recvTransportSubAudioSlave._handler._pc.addEventListener("iceconnectionstatechange", this._recvTransportConnectionstatechange69.bind(this, e3._recvTransportSubAudioSlave, e3._recvTransportSubAudioSlaveTimeoutTimer)), this._createConsumer69(t3, "audio", "audioSlave", e3.pubStatus.audioSlave.producerId, e3._recvTransportSubAudioSlave)), e3.subStatus.screen && !e3._recvTransportSubScreen && (e3._recvTransportSubScreen = this._mediasoupDevice.createRecvTransport({ id: t3 + "_sub_screen", iceParameters: void 0, iceCandidates: void 0, dtlsParameters: void 0, sctpParameters: void 0, iceServers: s2, iceTransportPolicy: a2, appData: { cid: this.adapterRef.channelInfo.cid, uid: t3.toString(), encodedInsertableStreams: this.adapterRef.encryption.encodedInsertableStreams } }), e3._recvTransportSubScreenTimeoutTimer = null, e3._recvTransportSubScreen._handler._pc.addEventListener("iceconnectionstatechange", this._recvTransportConnectionstatechange69.bind(this, e3._recvTransportSubScreen, e3._recvTransportSubScreenTimeoutTimer)), this._createConsumer69(t3, "video", "screen", e3.pubStatus.screen.producerId, e3._recvTransportSubScreen)));
            });
          }
          async setConsumerPreferredLayer(e2, t2, i2) {
            if (!this.adapterRef._signalling || !this.adapterRef._signalling._protoo) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "setConsumerPreferredLayer: _protoo 未找到" });
            this.loggerSend.log("setConsumerPreferredLayer() [切换大小流]layer: ", t2, 1 === t2 ? "大流" : "小流", i2);
            return await this.adapterRef._signalling._protoo.request("SetConsumerPreferredLayer", { requestId: "" + Math.ceil(1e9 * Math.random()), uid: new S.SimpleBig(e2.streamID), producerId: e2.pubStatus[i2].producerId, consumerId: e2.pubStatus[i2].consumerId, spatialLayer: t2 });
          }
          async resetConsumeRequestStatus() {
            const e2 = this._eventQueue;
            this._eventQueue = [];
            for (let t2 = 0; t2 < e2.length; t2++) {
              const i2 = e2[t2];
              this.loggerRecv.log(`resetConsumeRequestStatus：uid ${i2.uid}, uid ${i2.uid}, kind ${i2.kind}, id ${i2.id}`), i2.reject("resetConsumeRequestStatus");
            }
          }
          removeUselessConsumeRequest(e2, t2) {
            if (e2) for (let i2 = this._eventQueue.length - 1; i2 >= 1; i2--) {
              const r2 = this._eventQueue[i2];
              r2.uid.toString() !== e2.toString() || r2.mediaType !== t2 && "all" !== t2 || (this.loggerRecv.warn(`removeUselessConsumeRequest：uid ${r2.uid}, mediaType ${r2.mediaType}, id ${r2.id}, i ${i2}`), r2.resolve(null), this._eventQueue.splice(i2, 1));
            }
          }
          checkConsumerList(e2) {
            return this._eventQueue.shift(), e2.resolve(null), this.loggerRecv.log("查看事件队列, _eventQueue: ", this._eventQueue.length), this._eventQueue.forEach((e3) => {
              this.loggerRecv.log(`consumerList, uid: ${e3.uid}, kind: ${e3.kind}, mediaType: ${e3.mediaType}, id: ${e3.id}`);
            }), this._eventQueue.length > 0 && this._createConsumer(this._eventQueue[0]), "checkConsumerList";
          }
          async _createConsumer(e2) {
            var t2, i2, r2, s2, a2, o2, n2, u2;
            const p2 = (null === (r2 = null === (i2 = null === (t2 = this.adapterRef) || void 0 === t2 ? void 0 : t2._mediasoup) || void 0 === i2 ? void 0 : i2._recvTransport) || void 0 === r2 ? void 0 : r2._handler._pc.getTransceivers()) || [];
            if (p2.length) {
              const t3 = [...p2].reverse().find((t4) => t4.remoteUid === e2.uid && t4.receiver.track.kind === e2.kind);
              "ended" === (null == t3 ? void 0 : t3.receiver.track.readyState) && (this.loggerRecv.log("[Subscribe] Track readyState ended. RemoteUid: " + e2.uid), t3.isUseless = false);
            }
            const { uid: g2, kind: f2, mediaType: y2, id: _2, preferredSpatialLayer: R2 = 0 } = e2, b2 = "screenShare" === y2 ? "screen" : y2;
            if ("audio" === b2 ? this.loggerRecv.log(`[Subscribe] 开始订阅 ${g2} 的 ${b2} 媒体: ${_2}`) : this.loggerRecv.log(`[Subscribe] 开始订阅 ${g2} 的 ${b2} 媒体: ${_2} preferredSpatialLayer: ${R2} 大小流: `, 1 === R2 ? "大流" : "小流"), !_2) return this.adapterRef.instance.safeEmit("@pairing-createConsumer-error"), this.checkConsumerList(e2);
            if (this.unsupportedProducers[_2]) return this.loggerRecv.warn("[Subscribe] createConsumer: 跳过不支持的Producer", _2, v.JSONBigStringify(this.unsupportedProducers[_2])), this.checkConsumerList(e2);
            const T = this.adapterRef.remoteStreamMap[g2];
            if (!T || !T.pubStatus[b2][b2] || !T.pubStatus[b2].producerId) return this.adapterRef.instance.safeEmit("@pairing-createConsumer-skip"), this.checkConsumerList(e2);
            if (T.pubStatus[b2].consumerId) {
              this.loggerRecv.log("[Subscribe] 已经订阅过: ", b2);
              let t3 = true;
              if (T.Play && (t3 = T._play.isPlaying(b2)), t3) return this.loggerRecv.log(`[Subscribe] 当前 ${b2} 播放正常，直接返回`), this.adapterRef.instance.safeEmit("@pairing-createConsumer-skip"), this.checkConsumerList(e2);
              if ("start" !== T.pubStatus[b2].stopconsumerStatus) {
                this.loggerRecv.log("[Subscribe] 先停止之前的订阅: ", b2);
                try {
                  if (T.pubStatus[b2].stopconsumerStatus = "start", !this.adapterRef._mediasoup) return this.checkConsumerList(e2);
                  await this.destroyConsumer(T.pubStatus.audio.consumerId, null, null), this.adapterRef.instance.removeSsrc(T.getId(), b2), T.pubStatus[b2].consumerId = "", T.stop(b2), T.pubStatus[b2].stopconsumerStatus = "end";
                } catch (e3) {
                  this.loggerRecv.error("[Subscribe] 停止之前的订阅出现错误: ", e3.name, e3.message);
                }
              }
            }
            let E = null;
            if ("audio" !== b2 && "audioSlave" !== b2 || (E = { opusStereo: 1 }), this._mediasoupDevice && this._mediasoupDevice.loaded || (this.loggerRecv.warn(`[Subscribe] ${b2} createConsumer: Waiting for Transport Ready`), await h.waitForEvent(this, "transportReady", 3e3)), !this._recvTransport) throw this.adapterRef.instance.safeEmit("@pairing-createConsumer-error"), e2.resolve(null), new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "createConsumer: 接收端 transport 未找到" });
            this.loggerRecv.log(`[Subscribe] prepareLocalSdp [kind: ${f2}, mediaTypeShort: ${b2}, uid: ${g2}]`), this._recvTransport.id === this.adapterRef.channelInfo.uid && (this.loggerRecv.log("[Subscribe] transporth还没有协商, 需要dtls消息"), this._recvTransport._handler._transportReady = false);
            const A = await this._recvTransport.prepareLocalSdp(f2, this._edgeRtpCapabilities, g2);
            this.adapterRef && "DISCONNECTING" != this.adapterRef.connectState.curState && "DISCONNECTED" != this.adapterRef.connectState.curState || this.checkConsumerList(e2), this.loggerRecv.log("[Subscribe] 获取本地sdp, mid =", A.mid);
            let { rtpCapabilities: I, offer: w } = A, C = A.mid;
            const O = A.dtlsParameters;
            C = "number" == typeof C && C < 0 ? void 0 : "" + C;
            const k = w.sdp.match(/a=ice-ufrag:([0-9a-zA-Z=#+-_\/\\\\]+)/);
            if (!k) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "_createConsumer: iceUfragRegRemote 为空" });
            let P = { requestId: "" + Math.ceil(1e9 * Math.random()), kind: f2, rtpCapabilities: I, uid: new S.SimpleBig(g2), producerId: _2, preferredSpatialLayer: R2, mid: C, pause: false, iceUfrag: k[1], audioAslFlag: "yes" === this.adapterRef.audioAsl.enabled && m.getParameters().audioAslFlag, appData: { enableTcpCandidate: true } };
            if (void 0 === O ? P.transportId = this._recvTransport.id : P.dtlsParameters = O, this.loggerRecv.log(`[Subscribe] 发送consume请求, uid: ${g2}, kind: ${f2}, mediaTypeShort: ${b2}, producerId: ${P.producerId}, transportId: ${P.transportId}, requestId: ${P.requestId}`), !this.adapterRef._signalling || !this.adapterRef._signalling._protoo) throw e2.resolve(null), new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "_createConsumer: _protoo 未找到" });
            const x = this.adapterRef._signalling._protoo;
            let M = null;
            try {
              M = await this.adapterRef._signalling._protoo.request("Consume", P);
            } catch (e3) {
              throw "request timeout" === e3.message && this.adapterRef._signalling._protoo.id === x.id ? (this.logger.error(`[Subscribe] Consume消息Timeout, 尝试信令重连: ${e3.name}/${e3.message}, 当前的连接状态: ${this.adapterRef.connectState.curState}, 原始请求: `, v.JSONBigStringify(P)), this.adapterRef.channelStatus = "connectioning", this.adapterRef._signalling.reconnectionReason = d.ReconnectReason.ConsumeRequestTimeout, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "consumeRequestTimeout", ext: "" }), this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this.adapterRef._signalling._reconnection()) : this.logger.error(`[Subscribe] Consume消息错误: ${e3.name}/${e3.message}, 当前的连接状态：${this.adapterRef.connectState.curState}, 原始请求：`, v.JSONBigStringify(P)), new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "_createConsumer: Consume 消息错误:" + e3.message });
            }
            let { transportId: D, iceParameters: N, iceCandidates: L, dtlsParameters: F, probeSSrc: V, rtpParameters: H, turnParameters: j, producerId: U, consumerId: B, code: $, errMsg: W } = M;
            if (this.loggerRecv.log(`[Subscribe] consume反馈结果 code: ${$} uid: ${g2},  kind: ${f2}, mediaTypeShort: ${b2}, mid: ${H && H.mid}, kind: ${f2}, producerId: ${U}, consumerId: ${B}, transportId: ${D}, requestId: ${M.requestId}, errMsg: ${W}`), !this._recvTransport) return this.loggerRecv.error("[Subscribe] transport undefined, 直接返回"), this.checkConsumerList(e2);
            if (200 !== $ && !(null === (a2 = null === (s2 = this._recvTransport) || void 0 === s2 ? void 0 : s2._handler) || void 0 === a2 ? void 0 : a2.remoteSdp)) return this._recvTransport.recoverLocalSdp(g2, "0", f2), this.loggerRecv.log("[Subscribe] consume, 此外没有remoteSdp, 忽略改次失败的consume"), (null === (n2 = null === (o2 = this._recvTransport) || void 0 === o2 ? void 0 : o2._handler) || void 0 === n2 ? void 0 : n2._pc.localDescription) || 1 !== (null === (u2 = this._recvTransport._handler) || void 0 === u2 ? void 0 : u2._pc.getTransceivers().length) || this.resetRecvTransport(), this.checkConsumerList(e2);
            if (j) {
              let e3 = [];
              e3.push({ urls: "turn:" + j.ip + ":" + j.port + "?transport=udp", credential: j.password, username: j.username }, { urls: "turn:" + j.ip + ":" + j.port + "?transport=tcp", credential: j.password, username: j.username }), await this._recvTransport.updateIceServers({ iceServers: e3 });
            }
            const G = M.uid;
            H && H.encodings && H.encodings.length && H.encodings[0].ssrc && this.adapterRef.instance.addSsrc(g2, b2, H.encodings[0].ssrc), void 0 !== D && (this._recvTransport._id = D), void 0 !== V && (this._probeSSrc = V), H && null != H.mid && (H.mid = H.mid + "");
            let J = L;
            this.adapterRef.channelInfo.iceProtocol && L && (this.logger.warn("Consume iceProtocol: ", this.adapterRef.channelInfo.iceProtocol), J = L.filter((e3) => e3.protocol == this.adapterRef.channelInfo.iceProtocol));
            const q = await this._recvTransport.consume({ id: B || U || _2, producerId: U || _2, kind: f2, mediaType: b2, uid: g2 || G, rtpParameters: H, codecOptions: E, appData: { peerId: G, remoteUid: g2, mid: C }, offer: w, iceParameters: N, iceCandidates: J, dtlsParameters: F, sctpParameters: void 0, probeSSrc: this._probeSSrc });
            if (this.adapterRef.encryption.encodedInsertableStreams && q.rtpReceiver && this.enableRecvTransform(q.rtpReceiver, g2, b2), this._consumers[q.id] = q, q.on("transportclose", () => {
              this._consumers && delete this._consumers[q.id];
            }), this.loggerRecv.log(`[Subscribe] 订阅consume完成  uid: ${g2},  kind: ${f2}, mediaTypeShort: ${b2}, peerId: ${G}`), this.adapterRef.instance.apiEventReport("setFunction", { name: `set_${b2}_sub`, oper: "1", value: v.JSONBigStringify({ remoteUid: g2, code: $, reason: W || "", preferredSpatialLayer: R2, consumerId: B || "", producerId: U || _2 }, null, " ") }), T && T.pubStatus[b2].producerId) {
              if (T.subStatus[b2] = true, T.pubStatus[b2][b2] = true, T.pubStatus[b2].consumerId = B, T.pubStatus[b2].producerId = U, T.getMuteStatus(b2).muted) {
                this.loggerRecv.log(`[Subscribe] 远端流处于mute状态 uid: ${T.getId()}, mediaTypeShort: ${b2}, muteStatus: ${v.JSONBigStringify(T.getMuteStatus(b2))}`);
                const e3 = T.getMuteStatus(b2);
                e3.send && this.loggerRecv.log(`[Subscribe] 远端流把自己mute了：uid ${T.getId()}, ${b2}, ${v.JSONBigStringify(e3)}`), e3.recv && (this.loggerRecv.log(`[Subscribe] 本端把远端流mute了：uid ${T.getId()}, ${b2}, ${v.JSONBigStringify(e3)}`), q.track.enabled = false);
              } else q.track.enabled = true;
              this.loggerRecv.log(`[Subscribe] updateStream uid: ${T.getId()}, mediaTypeShort: ${b2}, track状态 enabled: ${q.track.enabled}, muted: ${q.track.muted}, name: ${q.track.label}}`), T.mediaHelper.updateStream(b2, q.track), this.adapterRef.instance.safeEmit("@pairing-createConsumer-success"), "audio" === b2 ? this.adapterRef.state.signalAudioSubscribedTime < this.adapterRef.state.signalOpenTime && (this.adapterRef.state.signalAudioSubscribedTime = Date.now()) : "video" === b2 && this.adapterRef.state.signalVideoSubscribedTime < this.adapterRef.state.signalOpenTime && (this.adapterRef.state.signalVideoSubscribedTime = Date.now()), this.adapterRef.instance.safeEmit("stream-subscribed", { stream: T, mediaType: b2 });
            } else this.adapterRef.instance.safeEmit("@pairing-createConsumer-error"), this.loggerRecv.log("[Subscribe] 该次consume状态错误: ", v.JSONBigStringify(T.pubStatus, null, ""));
            return this.checkConsumerList(e2);
          }
          async _createConsumer69(e2, t2, i2, r2, s2) {
            let a2 = `${e2}_${i2}`;
            if (this._usedUidMediaTypes[a2]) return void this.logger.info("_createConsumer69 去重: ", a2);
            this._usedUidMediaTypes[a2] = true;
            const o2 = this.adapterRef.remoteStreamMap[e2];
            let n2 = await s2.prepareLocalSdp(t2, this._edgeRtpCapabilities, e2);
            this.loggerRecv.warn("[Subscribe] 获取本地sdp, mid =", n2.mid, "id = ", r2);
            let { rtpCapabilities: u2, offer: h2 } = n2, p2 = n2.mid;
            const g2 = n2.dtlsParameters;
            p2 = "number" == typeof p2 && p2 < 0 ? void 0 : "" + p2;
            const f2 = h2.sdp.match(/a=ice-ufrag:([0-9a-zA-Z=#+-_\/\\\\]+)/);
            if (!f2) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "_createConsumer: iceUfragRegRemote 为空" });
            let y2 = { requestId: "" + Math.ceil(1e9 * Math.random()), kind: t2, rtpCapabilities: u2, uid: new S.SimpleBig(e2), producerId: r2, preferredSpatialLayer: 0, mid: p2, pause: false, iceUfrag: f2[1], audioAslFlag: "yes" === this.adapterRef.audioAsl.enabled && m.getParameters().audioAslFlag, appData: { enableTcpCandidate: true } };
            if (void 0 === g2 ? y2.transportId = s2.id : y2.dtlsParameters = g2, this.loggerRecv.log(`[Subscribe] 发送consume请求, uid: ${e2}, kind: ${t2}, mediaTypeShort: ${i2}, producerId: ${y2.producerId}, transportId: ${y2.transportId}, requestId: ${y2.requestId}`), !this.adapterRef._signalling || !this.adapterRef._signalling._protoo) throw new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "[Subscribe] createConsumer: _protoo 未找到" });
            const _2 = this.adapterRef._signalling._protoo;
            let R2 = null;
            try {
              R2 = await this.adapterRef._signalling._protoo.request("Consume", y2);
            } catch (e3) {
              throw "request timeout" === e3.message && this.adapterRef._signalling._protoo.id === _2.id ? (this.logger.error(`[Subscribe] Consume消息Timeout, 尝试信令重连: ${e3.name}/${e3.message}, 当前的连接状态: ${this.adapterRef.connectState.curState}, 原始请求: `, v.JSONBigStringify(y2)), this.adapterRef.channelStatus = "connectioning", this.adapterRef._signalling.reconnectionReason = d.ReconnectReason.ConsumeRequestTimeout, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "consumeRequestTimeout", ext: "" }), this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this.adapterRef._signalling._reconnection()) : this.logger.error(`[Subscribe] Consume消息错误: ${e3.name}/${e3.message}, 当前的连接状态：${this.adapterRef.connectState.curState}, 原始请求：`, v.JSONBigStringify(y2)), new l.default({ code: c.default.UNKNOWN_TYPE_ERROR, message: "[Subscribe] createConsumer: Consume 消息错误:" + e3.message });
            }
            let { transportId: b2, iceParameters: T, iceCandidates: E, dtlsParameters: A, probeSSrc: I, rtpParameters: w, turnParameters: C, producerId: O, consumerId: k, code: P, errMsg: x } = R2;
            if (this.loggerRecv.log(`[Subscribe] consume反馈结果 code: ${P} uid: ${e2}, mid: ${w && w.mid}, kind: ${t2}, producerId: ${O}, consumerId: ${k}, transportId: ${b2}, requestId: ${R2.requestId}, errMsg: ${x}`), C) {
              let e3 = [];
              e3.push({ urls: "turn:" + C.ip + ":" + C.port + "?transport=udp", credential: C.password, username: C.username }, { urls: "turn:" + C.ip + ":" + C.port + "?transport=tcp", credential: C.password, username: C.username }), await s2.updateIceServers({ iceServers: e3 });
            }
            const M = R2.uid;
            w && w.encodings && w.encodings.length && w.encodings[0].ssrc && this.adapterRef.instance.addSsrc(e2, i2, w.encodings[0].ssrc), void 0 !== b2 && (s2._id = b2), void 0 !== I && (this._probeSSrc = I), w && null != w.mid && (w.mid = w.mid + "");
            let D = E;
            this.adapterRef.channelInfo.iceProtocol && E && (this.logger.warn("[Subscribe] Consume iceProtocol: ", this.adapterRef.channelInfo.iceProtocol), D = E.filter((e3) => e3.protocol == this.adapterRef.channelInfo.iceProtocol));
            let N = null;
            "audio" !== i2 && "audioSlave" !== i2 || (N = { opusStereo: 1 });
            const L = await s2.consume({ id: k || O || r2, producerId: O || r2, kind: t2, mediaType: i2, uid: e2 || M, rtpParameters: w, codecOptions: N, appData: { peerId: M, remoteUid: e2, mid: p2 }, offer: h2, iceParameters: T, iceCandidates: D, dtlsParameters: A, sctpParameters: void 0, probeSSrc: this._probeSSrc });
            if (this._consumers[L.id] = L, L.on("transportclose", () => {
              this._consumers && delete this._consumers[L.id];
            }), this.loggerRecv.log("[Subscribe] 订阅consume完成 peerId =", M), this.adapterRef.instance.apiEventReport("setFunction", { name: `set_${i2}_sub`, oper: "1", value: v.JSONBigStringify({ remoteUid: e2, code: P, reason: x || "", preferredSpatialLayer: 0, consumerId: k || "", producerId: O || r2 }, null, " ") }), o2 && o2.pubStatus[i2].producerId) {
              if (o2.subStatus[i2] = true, o2.pubStatus[i2][i2] = true, o2.pubStatus[i2].consumerId = k, o2.pubStatus[i2].producerId = O, o2.getMuteStatus(i2).muted) {
                this.loggerRecv.log(`[Subscribe] 远端流处于mute状态：uid ${o2.getId()}, ${i2}, ${v.JSONBigStringify(o2.getMuteStatus(i2))}`);
                const e3 = o2.getMuteStatus(i2);
                e3.send && this.loggerRecv.log(`[Subscribe] 远端流把自己mute了：uid ${o2.getId()}, ${i2}, ${v.JSONBigStringify(e3)}`), e3.recv && (this.loggerRecv.log(`[Subscribe] 本端把远端流mute了：uid ${o2.getId()}, ${i2}, ${v.JSONBigStringify(e3)}`), L.track.enabled = false);
              } else L.track.enabled = true;
              o2.mediaHelper.updateStream(i2, L.track), this.adapterRef.instance.safeEmit("@pairing-createConsumer-success"), "audio" === i2 ? this.adapterRef.state.signalAudioSubscribedTime < this.adapterRef.state.signalOpenTime && (this.adapterRef.state.signalAudioSubscribedTime = Date.now()) : "video" === i2 && this.adapterRef.state.signalVideoSubscribedTime < this.adapterRef.state.signalOpenTime && (this.adapterRef.state.signalVideoSubscribedTime = Date.now()), this.adapterRef.instance.safeEmit("stream-subscribed", { stream: o2, mediaType: i2 });
            } else this.adapterRef.instance.safeEmit("@pairing-createConsumer-error"), this.loggerRecv.log("[Subscribe] 该次consume状态错误: ", v.JSONBigStringify(o2.pubStatus, null, ""));
          }
          async destroyConsumer(e2, t2, i2) {
            var r2, s2;
            if (e2) try {
              const a2 = this._consumers[e2];
              if (!a2) return void this.loggerRecv.log("跳过停止订阅 destroyConsumer consumerId=", e2, null == t2 ? void 0 : t2.streamID);
              if (this.loggerRecv.log("停止订阅 destroyConsumer consumerId=", e2, null == t2 ? void 0 : t2.streamID), delete this._consumers[e2], u.ANY_CHROME_MAJOR_VERSION && u.ANY_CHROME_MAJOR_VERSION < 69) {
                let e3 = t2.streamID.toString();
                this.consumerMap.get(e3).subStatus[i2] = false, this.consumerMap.get(e3)[R.get(i2)[0]].close(), this.consumerMap.get(e3)[R.get(i2)[0]] = null;
                let r3 = this.consumerMap.get(e3)[R.get(i2)[1]];
                r3 && clearTimeout(r3), r3 = null;
                let s3 = `${e3}_${i2}`;
                this._usedUidMediaTypes[s3] = false;
              }
              try {
                await (null === (s2 = null === (r2 = this.adapterRef._signalling) || void 0 === r2 ? void 0 : r2._protoo) || void 0 === s2 ? void 0 : s2.request("CloseConsumer", { requestId: "" + Math.ceil(1e9 * Math.random()), consumerId: e2, producerId: a2.producerId })), await a2.close(), t2 && i2 && this.adapterRef.instance.safeEmit("@stream-unsubscribed", { stream: t2, mediaType: i2 }), this.adapterRef.instance.apiEventReport("setFunction", { name: `set_${i2}_sub`, oper: "0", value: v.JSONBigStringify({ code: 200, remoteUid: null == t2 ? void 0 : t2.stringStreamID, consumerId: e2 || "" }, null, " ") });
              } catch (e3) {
                this.logger.error("CloseConsumer失败", e3.name, e3.message, e3);
              }
            } catch (e3) {
              this.loggerRecv.error("destroyConsumer() | failed:", e3.name, e3.message, e3.stack);
            }
          }
          async closeTransport(e2) {
            var t2, i2;
            if (e2 && e2.id) try {
              this.logger.log(`closeTransport() [停止通道 transportId= ${e2.id}]`);
              const r2 = await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("CloseTransport", { requestId: "" + Math.ceil(1e9 * Math.random()), transportId: e2.id }));
              this.logger.log(`closeTransport() [停止通道反馈结果 result=${v.JSONBigStringify(r2, null, " ")}]`), e2.close();
            } catch (e3) {
              this.logger.error("closeTransport() | failed:", e3.name, e3.message);
            }
          }
          async muteAudio() {
            var e2, t2, i2, r2;
            this.loggerSend.log("mute音频"), null === (e2 = this._micProducer) || void 0 === e2 || e2.pause();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._micProducer) || void 0 === r2 ? void 0 : r2.id, mute: true } } }));
            } catch (e3) {
              this.loggerSend.error("muteAudio() | failed:", e3.name, e3.message, e3);
            }
          }
          async unmuteAudio() {
            var e2, t2, i2, r2;
            this.loggerSend.log("unmute音频"), null === (e2 = this._micProducer) || void 0 === e2 || e2.resume();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._micProducer) || void 0 === r2 ? void 0 : r2.id, mute: false } } }));
            } catch (e3) {
              return this.loggerSend.error("unmuteAudio() | failed: ", e3.name, e3.message), Promise.reject(e3);
            }
          }
          async muteAudioSlave() {
            var e2, t2, i2, r2;
            this.loggerSend.log("mute音频辅流"), null === (e2 = this._audioSlaveProducer) || void 0 === e2 || e2.pause();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._audioSlaveProducer) || void 0 === r2 ? void 0 : r2.id, mute: true } } }));
            } catch (e3) {
              this.loggerSend.error("muteAudioSlave() | failed:", e3.name, e3.message);
            }
          }
          async unmuteAudioSlave() {
            var e2, t2, i2, r2;
            this.loggerSend.log("unmute音频辅流"), null === (e2 = this._audioSlaveProducer) || void 0 === e2 || e2.resume();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._audioSlaveProducer) || void 0 === r2 ? void 0 : r2.id, mute: false } } }));
            } catch (e3) {
              return this.loggerSend.error("unmuteAudioSlave() | failed: ", e3.name, e3.message), Promise.reject(e3);
            }
          }
          async muteVideo() {
            var e2, t2, i2, r2;
            this.loggerSend.log("mute视频"), null === (e2 = this._webcamProducer) || void 0 === e2 || e2.pause();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._webcamProducer) || void 0 === r2 ? void 0 : r2.id, mute: true } } }));
            } catch (e3) {
              this.loggerSend.error("muteVideo() | failed:", e3.name, e3.message);
            }
          }
          async unmuteVideo() {
            var e2, t2, i2, r2;
            this.loggerSend.log("unmute视频"), null === (e2 = this._webcamProducer) || void 0 === e2 || e2.resume();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._webcamProducer) || void 0 === r2 ? void 0 : r2.id, mute: false } } }));
            } catch (e3) {
              this.loggerSend.error("unmuteVideo() | failed:", e3.name, e3.message);
            }
          }
          async muteScreen() {
            var e2, t2, i2, r2;
            this.loggerSend.log("mute屏幕共享"), null === (e2 = this._screenProducer) || void 0 === e2 || e2.pause();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._screenProducer) || void 0 === r2 ? void 0 : r2.id, mute: true } } }));
            } catch (e3) {
              this.loggerSend.error("muteScreen() | failed: ", e3.name, e3.message);
            }
          }
          async unmuteScreen() {
            var e2, t2, i2, r2;
            this.loggerSend.log("unmute屏幕共享"), null === (e2 = this._screenProducer) || void 0 === e2 || e2.resume();
            try {
              await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "Mute", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { producerId: null === (r2 = this._screenProducer) || void 0 === r2 ? void 0 : r2.id, mute: false } } }));
            } catch (e3) {
              this.loggerSend.error("unmuteScreen() | failed:", e3.name, e3.message);
            }
          }
          async startAsrCaptions(e2, t2) {
            var i2, r2;
            this.loggerSend.log("startAsrCaptions() 开启实时字幕信令");
            try {
              const s2 = await (null === (r2 = null === (i2 = this.adapterRef._signalling) || void 0 === i2 ? void 0 : i2._protoo) || void 0 === r2 ? void 0 : r2.request("StartAsrCaptions", { uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), requestId: "" + Math.ceil(1e9 * Math.random()), externData: { asrInfo: { srcLan: e2, dstLan: t2 } } }));
              if (200 !== (null == s2 ? void 0 : s2.code)) throw s2;
              return this.adapterRef.instance.apiEventReport("setAsrCaptions", { oper: "start", value: JSON.stringify({ code: 0, uid: this.adapterRef.channelInfo.uid, externData: { asrInfo: { srcLan: e2, dstLan: t2 } } }) }), !!s2;
            } catch (e3) {
              throw this.loggerSend.error("startAsrCaptions() | failed:", e3.code, e3.errMsg), new l.default({ code: c.default.ASR_CAPTIONS_ERROR, message: "实时字幕开启失败, code: " + e3.code + ", errMsg: " + e3.errMsg });
            }
          }
          async stopAsrCaptions() {
            var e2, t2, i2;
            this.loggerSend.log("stopAsrCaptions() 关闭实时字幕信令");
            try {
              const r2 = await (null === (t2 = null === (e2 = this.adapterRef._signalling) || void 0 === e2 ? void 0 : e2._protoo) || void 0 === t2 ? void 0 : t2.request("StopAsrCaptions", { uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), requestId: "" + Math.ceil(1e9 * Math.random()) }));
              if (200 !== (null == r2 ? void 0 : r2.code)) throw r2;
              return this.adapterRef.instance.apiEventReport("setAsrCaptions", { oper: "stop", value: JSON.stringify({ code: 0, uid: null === (i2 = this.adapterRef.localStream) || void 0 === i2 ? void 0 : i2.stringStreamID }) }), !!r2;
            } catch (e3) {
              throw this.loggerSend.error("stopAsrCaptions() | failed:", e3.code, e3.errMsg), new l.default({ code: c.default.ASR_CAPTIONS_ERROR, message: "关闭实时字幕失败, code: " + e3.code + ", errMsg: " + e3.errMsg });
            }
          }
          async setMpsNotify(e2, t2) {
            var i2, r2;
            this.loggerSend.log("setMpsNotify", e2, JSON.stringify(t2));
            try {
              const s2 = await (null === (r2 = null === (i2 = this.adapterRef._signalling) || void 0 === i2 ? void 0 : i2._protoo) || void 0 === r2 ? void 0 : r2.request("SendUserData", { externData: { type: "MpsNotify", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), dstUid: new S.SimpleBig(t2.dstUid), data: { action: e2, dstUid: new S.SimpleBig(t2.dstUid) } } }));
              if (200 !== s2.code) throw this.logger.error(`setMpsNotify: ${s2.errMsg}. Code: ${s2.code}`), s2;
              return true;
            } catch (e3) {
              throw this.loggerSend.error("setMpsNotify() | failed:", e3.name, e3.message), e3;
            }
          }
          async updateUserRole(e2) {
            var t2, i2;
            this.loggerSend.log("updateUserRole() 更新用户角色为" + e2);
            try {
              const r2 = await (null === (i2 = null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2._protoo) || void 0 === i2 ? void 0 : i2.request("SendUserData", { externData: { type: "UserRole", cid: this.adapterRef.channelInfo.cid, uid: new S.SimpleBig(this.adapterRef.channelInfo.uid), data: { userRole: e2 } } }));
              return 200 !== r2 && this.logger.error(`UpdateUserRole:${r2.errMsg}. Code: ${r2.code}`), r2;
            } catch (e3) {
              throw this.loggerSend.error("updateUserRole() failed:", e3.name, e3.message), e3;
            }
          }
          async getIceStatus(e2 = "send") {
            var t2, i2, r2, s2;
            const a2 = Date.now(), o2 = { ts: Date.now(), direction: e2, iceConnectionState: "uninit", info: "", stuckTime: -1, elapse: -1 };
            let n2;
            if (n2 = "send" === e2 ? null === (i2 = null === (t2 = this._sendTransport) || void 0 === t2 ? void 0 : t2._handler) || void 0 === i2 ? void 0 : i2._pc : null === (s2 = null === (r2 = this._recvTransport) || void 0 === r2 ? void 0 : r2._handler) || void 0 === s2 ? void 0 : s2._pc, n2) {
              if (o2.info += "#" + n2.pcid, o2.iceConnectionState = n2.iceConnectionState, o2.info += "|iceConnectoinState " + n2.iceConnectionState, n2.iceStartedAt && (o2.elapse = a2 - n2.iceStartedAt), this.iceStatusHistory[e2].promises[0] && (this.iceStatusHistory[e2].promises[0](null), this.iceStatusHistory[e2].promises = []), "checking" === n2.iceConnectionState) {
                if (n2.iceStartedAt || (n2.iceStartedAt = a2), await new Promise((t4) => {
                  this.iceStatusHistory[e2].promises = [t4], setTimeout(t4, 3e3);
                }), "checking" !== n2.iceConnectionState) return o2;
                o2.elapse = Date.now() - n2.iceStartedAt;
              }
              "connected" !== n2.iceConnectionState && "completed" !== n2.iceConnectionState || (n2.iceConnectedAt || (n2.iceConnectedAt = a2), await new Promise((t4) => {
                this.iceStatusHistory[e2].promises = [t4], setTimeout(t4, 100);
              }));
              let t3 = null;
              try {
                let i4 = Date.now(), r4 = null;
                if ("send" === e2) {
                  let e3 = n2.getSenders()[0];
                  (null == e3 ? void 0 : e3.track) && (r4 = e3.track);
                } else {
                  let e3 = n2.getReceivers()[0];
                  (null == e3 ? void 0 : e3.track) && (r4 = e3.track);
                }
                let s4 = n2.getStats(r4);
                o2.stuckTime = Date.now() - i4, t3 = await s4;
              } catch (e3) {
              }
              const i3 = [], r3 = [];
              let s3 = Date.now();
              t3 && t3.forEach((e3, t4) => {
                i3.push(e3), "transport" === e3.type && r3.push(e3);
              }), r3.length || (o2.info += "|no transport stats"), r3.forEach((e3) => {
                var t4, r4;
                const s4 = i3.find((t5) => t5.id === e3.selectedCandidatePairId);
                if (s4) {
                  const e4 = i3.find((e5) => e5.id === s4.localCandidateId);
                  e4 ? (o2.info += `|local:${e4.protocol} `, o2.info += `${e4.address || "NOADDRESS"}:${e4.port || "NOPORT"} ${e4.candidateType} ${e4.networkType || ""}`, o2.networkType = e4.networkType, o2.protocol = e4.protocol, o2.relayProtocol = e4.relayProtocol, o2.ip = e4.ip, o2.address = e4.address, "unsupported" === (null === (r4 = null === (t4 = this.adapterRef._statsReport) || void 0 === t4 ? void 0 : t4.stats) || void 0 === r4 ? void 0 : r4.chromeLegecy) && (this.adapterRef.transportStats.NetworkType = e4.networkType)) : o2.info += "|无法找到localCandidate " + s4.localCandidateId;
                  const a3 = i3.find((e5) => e5.id === s4.remoteCandidateId);
                  a3 ? (o2.info += `|remote:${a3.protocol} `, o2.info += `${a3.address || "NOADDRESS"}:${a3.port || "NOPORT"} ${a3.candidateType}`) : o2.info += "|无法找到remoteCandidate " + s4.remoteCandidateId;
                } else o2.info += "无法找到candidatePair " + e3.selectedCandidatePairId;
              }), o2.stuckTime += Date.now() - s3;
            } else o2.info = "no_pc_" + e2;
            if (this.iceStatusHistory[e2].status.info !== o2.info && "new" !== o2.iceConnectionState && this._mediasoupDevice) {
              const t3 = { new: 1, checking: 2, connected: 3, completed: 4, failed: -1, disconnected: -2, closed: -3 }, i3 = t3[o2.iceConnectionState || 0] || 0;
              i3 > 0 ? (this.adapterRef.logger.log("iceConnectionStateChanged", e2, o2.info), i3 === t3.connected && "recv" === e2 && this.adapterRef.state.iceRecvConnectedTime < this.adapterRef.state.signalJoinResTime && (this.adapterRef.state.iceRecvConnectedTime = Date.now())) : this.adapterRef.logger.warn("iceConnectionStateChanged", e2, o2.info), this.adapterRef.instance.apiFrequencyControl({ name: "_iceStateChange_" + e2, code: i3, param: v.JSONBigStringify(o2) }), this.adapterRef.instance.safeEmit("@ice-change", o2);
            }
            return this.iceStatusHistory[e2].status = o2, o2;
          }
          getReceivers(e2 = {}) {
            const t2 = [];
            for (let i2 in this.adapterRef.remoteStreamMap) {
              const r2 = this.adapterRef.remoteStreamMap[i2];
              e2.uid && e2.uid.toString() !== i2 || d.MediaTypeList.forEach((s2) => {
                if (e2.mediaType && e2.mediaType !== s2) return;
                if (!r2.active || !r2.pubStatus[s2].consumerId) return;
                const a2 = this._consumers[r2.pubStatus[s2].consumerId];
                a2 && t2.push({ uid: i2, mediaType: s2, remoteStream: r2, consumer: a2 });
              });
            }
            return t2;
          }
          clearConsumerMap() {
            this.consumerMap.forEach((e2, t2) => {
              e2._recvTransportMainAudio && e2._recvTransportMainAudio.close(), e2._recvTransportMainVideo && e2._recvTransportMainVideo.close(), e2._recvTransportSubAudioSlave && e2._recvTransportSubAudioSlave.close(), e2._recvTransportSubScreen && e2._recvTransportSubScreen.close(), e2._recvTransportMainAudioTimeoutTimer && (clearTimeout(e2._recvTransportMainAudioTimeoutTimer), e2._recvTransportMainAudioTimeoutTimer = null), e2._recvTransportMainVideoTimeoutTimer && clearTimeout(e2._recvTransportMainVideoTimeoutTimer), e2._recvTransportMainVideoTimeoutTimer = null, e2._recvTransportSubAudioSlaveTimeoutTimer && clearTimeout(e2._recvTransportSubAudioSlaveTimeoutTimer), e2._recvTransportSubAudioSlaveTimeoutTimer = null, e2._recvTransportSubScreenTimeoutTimer && clearTimeout(e2._recvTransportSubScreenTimeoutTimer), e2._recvTransportSubScreenTimeoutTimer = null;
            }), this.consumerMap.clear();
          }
          destroy() {
            this.logger.log("清除 meidasoup"), this._reset(), u.ANY_CHROME_MAJOR_VERSION && u.ANY_CHROME_MAJOR_VERSION < 69 && this.clearConsumerMap();
          }
        }
        t.Mediasoup = b;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.waitForEvent = void 0, t.waitForEvent = async function(e2, t2, i2) {
          return new Promise((r, s) => {
            let a;
            const o = (e3) => {
              a && clearTimeout(a), r(e3);
            };
            i2 && (a = setTimeout(() => {
              e2.removeListener(t2, o), s(`timed out after ${i2}ms:${t2}`);
            }, i2)), e2.once(t2, o);
          });
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Chrome74 = void 0;
        const n = a(i(50)), d = o(i(6)), c = o(i(8)), l = i(43), u = i(1), h = i(29), p = a(i(79)), m = a(i(27)), g = i(87), f = a(i(88)), v = i(138), S = a(i(148)), y = i(89), _ = i(139), R = i(149), { generateRandomNumber: b } = i(27), T = "Chrome_", E = { OS: 1024, MIS: 1024 };
        let A = 0;
        class I extends g.HandlerInterface {
          constructor() {
            super(), this._sendingRemoteRtpParametersByKind = {}, this._mapMidTransceiver = /* @__PURE__ */ new Map(), this._sendStream = new MediaStream(), this._transportReady = false, this._appData = {}, this.senderStream = { main: new MediaStream(), slave: new MediaStream() };
          }
          static createFactory() {
            return () => new I();
          }
          get name() {
            return "Chrome74";
          }
          get remoteSdp() {
            return this._remoteSdp;
          }
          close() {
            if (h.Logger.debug(T, "close()"), this._pc) try {
              this._pc.onconnectionstatechange = null, this._pc.close();
            } catch (e2) {
            }
          }
          async getNativeRtpCapabilities() {
            return R.getNativeRtpCapabilities();
          }
          async getNativeSctpCapabilities() {
            return h.Logger.debug(T, "getNativeSctpCapabilities()"), { numStreams: E };
          }
          run({ direction: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: n2, proprietaryConstraints: d2, extendedRtpCapabilities: c2, appData: l2 }) {
            h.Logger.debug(T, "run()"), this._appData = l2, this._direction = e2, this._sendingRtpParametersByKind = { audio: p.getSendingRtpParameters("audio", c2), video: p.getSendingRtpParameters("video", c2) }, this._sendingRemoteRtpParametersByKind = { audio: p.getSendingRemoteRtpParameters("audio", c2), video: p.getSendingRemoteRtpParameters("video", c2) }, h.Logger.debug(T, "iceServers: ", null == a2 ? void 0 : a2.length);
            const u2 = { iceServers: a2 || [], iceTransportPolicy: o2 || "all", rtcpMuxPolicy: "require", sdpSemantics: "unified-plan", iceCandidatePoolSize: 10 };
            l2.encodedInsertableStreams && (u2.encodedInsertableStreams = true), this._pc = new RTCPeerConnection(u2, d2), this._pc.pcid = A++, this._pc.onconnectionstatechange = (e3) => {
              switch (h.Logger.debug(T, "onconnectionstatechange connectionState: ", this._pc.connectionState), this._pc.connectionState) {
                case "checking":
                  this.emit("@connectionstatechange", "connecting");
                  break;
                case "connected":
                case "completed":
                  this.emit("@connectionstatechange", "connected");
                  break;
                case "failed":
                  this.emit("@connectionstatechange", "failed");
                  break;
                case "disconnected":
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                case "closed":
                  this.emit("@connectionstatechange", "closed");
              }
            }, this._pc.onicegatheringstatechange = (e3) => {
              h.Logger.debug(T, "icegatheringstatechange iceGatheringState: ", this._pc.iceGatheringState), this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
            }, this._pc.onicecandidate = (e3) => {
              e3.candidate && h.Logger.debug(T, "onicecandidate: ", JSON.stringify(e3.candidate, null, " "));
            }, this._pc.onicecandidateerror = (e3) => {
              h.Logger.warn(T, "onicecandidateerror: ", e3);
            };
          }
          async updateIceServers(e2) {
            h.Logger.debug(T, "updateIceServers(): ");
            const t2 = this._pc.getConfiguration();
            t2.iceServers = e2, this._pc.setConfiguration(t2);
          }
          async restartIce(e2) {
            if (h.Logger.debug(T, "restartIce()"), this._remoteSdp.updateIceParameters(e2), this._transportReady) if (this._direction) {
              const e3 = await this._pc.createOffer({ iceRestart: true });
              let t2 = n.parse(e3.sdp);
              t2.media.forEach((e4) => {
                "audio" === e4.type && "send" === this._direction && e4.ext && e4.rtcpFb && (e4.ext = e4.ext.filter((e5) => -1 == e5.uri.indexOf("transport-wide-cc") && -1 == e5.uri.indexOf("abs-send-time")), e4.rtcpFb.push({ payload: 111, type: "nack" }));
              }), e3.sdp = n.write(t2), h.Logger.debug(T, "restartIce() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(e3);
              const i2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
              h.Logger.debug(T, "restartIce() | calling pc.setRemoteDescription() [answer]"), await this._pc.setRemoteDescription(i2);
            } else {
              const e3 = { type: "offer", sdp: this._remoteSdp.getSdp() };
              h.Logger.debug(T, "restartIce() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(e3);
              const t2 = await this._pc.createAnswer();
              h.Logger.debug(T, "restartIce() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(t2);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track: e2, trackLow: t2, encodings: i2, codecOptions: r2, codec: s2, appData: a2 }) {
            this._assertSendDirection(), h.Logger.debug(T, `publish() send() [kind: ${e2.kind}, track.id: ${e2.id}, appData: ${JSON.stringify(a2)}]`), i2 && i2.length > 1 && i2.forEach((e3, t3) => {
              e3.rid = "r" + t3;
            });
            const o2 = m.clone(this._sendingRtpParametersByKind[e2.kind], {});
            let l2, u2 = {}, p2 = {};
            l2 = "audio" === a2.mediaType || "video" === a2.mediaType ? this.senderStream.main : this.senderStream.slave, "audio" === a2.mediaType && this._pc.audioSender ? (h.Logger.debug(T, "publish() audioSender 更新 track: ", this._pc.audioSender.track, "=>", e2), this._pc.audioSender.replaceTrack(e2)) : "audioSlave" === a2.mediaType && this._pc.audioSlaveSender ? (h.Logger.debug(T, "publish() audioSlaveSender 更新 track: ", this._pc.audioSlaveSender.track, "=>", e2), this._pc.audioSlaveSender.replaceTrack(e2)) : "video" === a2.mediaType && this._pc.videoSender ? (h.Logger.debug(T, "publish() videoSender 更新 track: ", this._pc.videoSender.track, "=>", e2), this._pc.videoSender.replaceTrack(e2), this._pc.videoSenderLow && this._pc.videoSenderLow.track !== t2 && (h.Logger.debug(T, "publish() videoSenderLow 更新 track: ", this._pc.videoSenderLow), this._pc.videoSenderLow.replaceTrack(t2))) : "screenShare" === a2.mediaType && this._pc.screenSender ? (h.Logger.debug(T, "publish() screenSender 更新 track: ", this._pc.screenSender.track, "=>", e2), this._pc.screenSender.replaceTrack(e2), this._pc.screenSenderLow && this._pc.screenSenderLow.track !== t2 && (h.Logger.debug(T, "publish() screenSenderLow 更新 track: ", this._pc.screenSenderLow), this._pc.screenSenderLow.replaceTrack(t2))) : (l2.addTrack(e2), u2 = this._pc.addTransceiver(e2, { direction: "sendonly", streams: [l2] }), t2 && (p2 = this._pc.addTransceiver(t2, { direction: "sendonly", streams: [this._sendStream] })), "audio" !== a2.mediaType || this._pc.audioSender ? "audioSlave" !== a2.mediaType || this._pc.audioSlaveSender ? "video" !== a2.mediaType || this._pc.videoSender ? "screenShare" !== a2.mediaType || this._pc.screenSender || (this._pc.screenSender = u2.sender, this._pc.screenSenderLow = p2.sender) : (this._pc.videoSender = u2.sender, this._pc.videoSenderLow = p2.sender) : this._pc.audioSlaveSender = u2.sender : this._pc.audioSender = u2.sender), h.Logger.debug(T, `publish() [transceivers: ${this._pc.getTransceivers().length}]`);
            let g2 = await this._pc.createOffer(), v2 = n.parse(g2.sdp);
            a2.preferRemb && y.filterTransportCCFromSdp(v2);
            let _2, R2, b2 = void 0;
            const E2 = v2.media.filter((i3) => {
              const r3 = this._mapMidTransceiver.get("" + i3.mid);
              return i3.type === e2.kind && (!(r3 && r3.sender && r3.sender.track) || (r3.sender.track.id === e2.id ? (_2 = i3, false) : !t2 || r3.sender.track.id !== t2.id || (R2 = i3, false)));
            });
            _2 || (_2 = E2.pop()), t2 && !R2 && (R2 = E2.pop()), this._transportReady || (b2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: v2 }));
            let A2 = null == _2 ? void 0 : _2.mid;
            if ("number" == typeof A2 && (A2 = "" + A2), !A2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "publish() Chrome.send: localId 未找到" });
            let I2 = null;
            if (R2 && (I2 = "" + R2.mid), o2.mid = A2, o2.rtcp.cname = f.getCname({ offerMediaObject: _2 }), i2) if (1 === i2.length) {
              let e3 = S.getRtpEncodings({ offerMediaObject: _2 });
              Object.assign(e3[0], i2[0]), o2.encodings = e3;
            } else o2.encodings = i2;
            else o2.encodings = [], R2 && (o2.encodings = o2.encodings.concat(S.getRtpEncodings({ offerMediaObject: R2 }))), o2.encodings = o2.encodings.concat(S.getRtpEncodings({ offerMediaObject: _2 }));
            return o2.encodings.length > 1 && ("video/vp8" === o2.codecs[0].mimeType.toLowerCase() || "video/h264" === o2.codecs[0].mimeType.toLowerCase()) && v2.media.forEach((e3) => {
              "audio" === e3.type && e3.ext && e3.rtcpFb && (e3.ext = e3.ext.filter((e4) => -1 == e4.uri.indexOf("transport-wide-cc") && -1 == e4.uri.indexOf("abs-send-time")), e3.rtcpFb.push({ payload: 111, type: "nack" }));
            }), g2.sdp = n.write(v2), this._mapMidTransceiver.set(A2, u2), I2 && this._mapMidTransceiver.set(I2, p2), { localId: A2, localIdLow: I2, rtpParameters: o2, rtpSender: u2.sender, rtpSenderLow: p2.sender || null, dtlsParameters: b2, offer: g2 };
          }
          async fillRemoteRecvSdp({ kind: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, sendingRtpParameters: a2, codecOptions: o2, offer: d2, audioProfile: c2, codec: p2, resetVideoSdp: g2, appData: f2 }) {
            h.Logger.debug(T, "publish() fillRemoteRecvSdp() | calling pc.setLocalDescription(), appData: ", JSON.stringify(f2)), await this._pc.setLocalDescription(d2), this._remoteSdp || (this._remoteSdp = new v.RemoteSdp({ iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2 }), this._remoteSdp.updateDtlsRole("client"));
            const S2 = m.clone(this._sendingRemoteRtpParametersByKind[e2]);
            f2.preferRemb ? (h.Logger.debug(T, "publish() fillRemoteRecvSdp() |  使用REMB作为带宽估计方式"), y.filterTransportCCFromRtpParameters(S2)) : (h.Logger.debug(T, "publish() fillRemoteRecvSdp() |  使用transport-cc作为带宽估计方式"), y.filterRembFromRtpParameters(S2)), S2.codecs = l.reduceCodecs(S2.codecs, p2);
            let _2 = n.parse(this._pc.localDescription.sdp), R2 = this._remoteSdp.getNextMediaSectionIdx();
            g2 && (a2.mid ? a2.encodings && a2.encodings.length > 1 ? R2.idx = Number(a2.mid) - (a2.encodings.length - 1) : R2.idx = Number(a2.mid) : h.Logger.warn(T, "publish() fillRemoteRecvSdp() | mid 未找到"), R2.reuseMid = true);
            let b2 = _2.media[R2.idx], E2 = null;
            a2.encodings && a2.encodings.length > 1 && (E2 = _2.media[R2.idx + 1]), this._remoteSdp.send({ offerMediaObjectArr: [b2, E2], reuseMid: R2.reuseMid, offerRtpParameters: a2, answerRtpParameters: S2, codecOptions: o2, extmapAllowMixed: true });
            const A2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            if (h.Logger.debug(T, "publish() audioProfile设置为: ", c2), c2) {
              let e3 = null;
              switch (c2) {
                case "speech_low_quality":
                  e3 = "maxplaybackrate=16000;sprop-maxcapturerate=16000;maxaveragebitrate=32000";
                  break;
                case "speech_standard":
                  e3 = "maxplaybackrate=32000;sprop-maxcapturerate=32000;maxaveragebitrate=36000";
                  break;
                case "music_standard":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;";
                  break;
                case "standard_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=56000";
                  break;
                case "high_quality":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=128000";
                  break;
                case "high_quality_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=192000";
              }
              A2.sdp.indexOf("a=fmtp:111") && (A2.sdp = A2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;useinbandfec=1;" + e3)), A2.sdp = A2.sdp.replace(/a=rtcp-fb:111 transport-cc/g, "a=maxptime:60");
            }
            h.Logger.debug(T, "publish() fillRemoteRecvSdp() | calling pc.setRemoteDescription()"), u.getParameters().enableUdpCandidate || (A2.sdp = A2.sdp.replace(/\r\na=candidate:udpcandidate[^\r]+/g, "")), u.getParameters().enableTcpCandidate || (A2.sdp = A2.sdp.replace(/\r\na=candidate:tcpcandidate[^\r]+/g, "")), await this._pc.setRemoteDescription(A2);
          }
          async stopSending(e2, t2) {
            this._assertSendDirection(), h.Logger.debug(T, `[unpublish] stopSending() [kind: ${t2}, localId: ${e2}]`);
            const i2 = this._mapMidTransceiver.get(e2);
            "audio" === t2 ? this._pc.audioSender.replaceTrack(null) : "audioSlave" === t2 ? this._pc.audioSlaveSender.replaceTrack(null) : "video" === t2 ? (this._pc.videoSender.replaceTrack(null), this._pc.videoSenderLow && this._pc.videoSenderLow.replaceTrack(null)) : "screenShare" === t2 ? (this._pc.screenSender.replaceTrack(null), this._pc.screenSenderLow && this._pc.screenSenderLow.replaceTrack(null)) : null == i2 || i2.sender.replaceTrack(null);
            const r2 = await this._pc.createOffer();
            let s2 = n.parse(r2.sdp);
            s2.media.forEach((e3) => {
              "audio" === e3.type && e3.ext && e3.rtcpFb && (e3.ext = e3.ext.filter((e4) => -1 == e4.uri.indexOf("transport-wide-cc") && -1 == e4.uri.indexOf("abs-send-time")), e3.rtcpFb.push({ payload: 111, type: "nack" }));
            }), r2.sdp = n.write(s2), h.Logger.debug(T, "[unpublish]stopSending() | calling pc.setLocalDescription()");
            try {
              await this._pc.setLocalDescription(r2);
            } catch (e3) {
              h.Logger.debug(T, "setLocalDescription error: ", e3.message);
            }
            const a2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            h.Logger.debug(T, "[unpublish]stopSending() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(a2);
          }
          async replaceTrack(e2, t2) {
            this._assertSendDirection(), t2 ? h.Logger.debug(T, "replaceTrack() [localId:%s, track.id:%s]", e2, t2.id) : h.Logger.debug(T, "replaceTrack() [localId:%s, no track]", e2);
            const i2 = this._mapMidTransceiver.get(e2);
            await (null == i2 ? void 0 : i2.sender.replaceTrack(t2));
          }
          async setMaxSpatialLayer(e2, t2) {
            this._assertSendDirection(), h.Logger.debug(T, "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", e2, t2);
            const i2 = this._mapMidTransceiver.get(e2), r2 = null == i2 ? void 0 : i2.sender.getParameters();
            r2.encodings.forEach((e3, i3) => {
              e3.active = i3 <= t2;
            }), await (null == i2 ? void 0 : i2.sender.setParameters(r2));
          }
          async setRtpEncodingParameters(e2, t2) {
            this._assertSendDirection(), h.Logger.debug(T, "setRtpEncodingParameters() [localId:%s, params:%o]", e2, t2);
            const i2 = this._mapMidTransceiver.get(e2);
            if (!i2) return;
            const r2 = i2.sender.getParameters();
            r2.encodings.forEach((e3, i3) => {
              r2.encodings[i3] = Object.assign(Object.assign({}, e3), t2);
            }), await i2.sender.setParameters(r2);
          }
          async getSenderStats(e2) {
            this._assertSendDirection();
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Chrome.getSenderStats: RTCRtpTransceiver 未找到" });
            return t2.sender.getStats();
          }
          async recoverTransceiver(e2, t2, i2) {
            h.Logger.debug(T, "recoverTransceiver() [kind:%s, remoteUid:%s, mid: %s]", i2, e2, t2);
            const r2 = this._mapMidTransceiver.get(t2);
            r2 ? r2.isUseless = true : h.Logger.debug(T, "recoverTransceiver() transceiver undefined");
          }
          async prepareLocalSdp(e2, t2) {
            h.Logger.debug(T, `[Subscribe] prepareLocalSdp() [kind: ${e2}, remoteUid: ${t2}]`);
            let i2, r2 = -1;
            if (u.getParameters().reuseMid) for (const t3 of this._mapMidTransceiver.keys()) {
              const i3 = this._mapMidTransceiver.get(t3);
              if (!i3) continue;
              const s3 = i3.receiver && i3.receiver.track && i3.receiver.track.kind || e2;
              if (i3.isUseless && s3 === e2) {
                r2 = t3 - 0, i3.isUseless = false;
                break;
              }
            }
            let s2 = null;
            if (-1 === r2) {
              if (h.Logger.debug(T, "[Subscribe] prepareLocalSdp() 添加一个M行"), s2 = this._pc.addTransceiver(e2, { direction: "recvonly" }), s2.remoteUid = t2, i2 = await this._pc.createOffer(), !i2.sdp) throw h.Logger.error(T, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
              i2.sdp.indexOf("a=rtcp-fb:111") && -1 === i2.sdp.indexOf("a=rtcp-fb:111 nack") && (i2.sdp = i2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack")), i2.sdp.indexOf("a=fmtp:111") && (i2.sdp = i2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z-]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1"));
            } else if (this._pc.localDescription) i2 = { type: "offer", sdp: this._pc.localDescription.sdp };
            else {
              if (i2 = await this._pc.createOffer(), !i2.sdp) throw h.Logger.error(T, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
              i2.sdp.indexOf("a=rtcp-fb:111") && -1 === i2.sdp.indexOf("a=rtcp-fb:111 nack") && (i2.sdp = i2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack")), i2.sdp.indexOf("a=fmtp:111") && (i2.sdp = i2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z-]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1"));
              const e3 = n.parse(i2.sdp);
              r2 = e3.media[e3.media.length - 1].mid;
            }
            if (!i2.sdp) throw h.Logger.error(T, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
            const a2 = n.parse(i2.sdp);
            let o2 = void 0;
            this._transportReady || (o2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: a2 }));
            const d2 = f.extractRtpCapabilities({ sdpObject: a2 });
            return _.addNackSuppportForOpus(d2), -1 === r2 && (r2 = a2.media[a2.media.length - 1].mid, this._mapMidTransceiver.set("" + r2, s2)), { dtlsParameters: o2, rtpCapabilities: d2, offer: i2, mid: r2, iceUfragReg: "" };
          }
          async receive({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2, trackId: s2, kind: a2, rtpParameters: o2, offer: n2, probeSSrc: d2 = -1, remoteUid: c2, extendedRtpCapabilities: l2, appData: p2 }) {
            this._assertRecvDirection(), h.Logger.debug(T, `[Subscribe] receive() [trackId: ${s2}, kind: ${a2}, remoteUid: ${c2}]`), this._remoteSdp || (this._remoteSdp = new v.RemoteSdp({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2 }), this._remoteSdp.updateDtlsRole("client"));
            let m2 = o2 && o2.mid || p2.mid;
            if (h.Logger.debug(T, "[Subscribe] receive() mid: " + m2), null == o2 ? void 0 : o2.mid) this._remoteSdp.receive({ mid: m2, kind: a2, offerRtpParameters: o2, streamId: o2.rtcp.cname, trackId: s2 });
            else {
              const e3 = s2 + "_" + b();
              h.Logger.debug(T, "[Subscribe] receive() 容错流程 trackId: ", e3);
              const t3 = [];
              l2.codecs.forEach((e4) => {
                if (e4.kind === a2) {
                  const i4 = Object.assign({}, e4);
                  i4.parameters = i4.parameters || i4.localParameters, i4.payloadType = i4.payloadType || i4.localPayloadType, t3.push(i4);
                }
              });
              const i3 = { mid: m2, kind: a2, offerRtpParameters: { codecs: t3, encodings: [{ ssrc: 0 }], headerExtensions: [], rtcp: {}, mid: m2 }, streamId: a2, trackId: e3, reuseMediaSection: void 0 };
              this._remoteSdp.receive(i3), this._remoteSdp.disableMediaSection("" + m2);
            }
            if (!n2.sdp) throw h.Logger.error(T, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
            n2.sdp.indexOf("a=fmtp:111") && (n2.sdp = n2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1"));
            const g2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            g2.sdp.indexOf("a=fmtp:111") && (g2.sdp = g2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1")), "chrome" !== u.getParameters().enableSdpRrtr && "all" !== u.getParameters().enableSdpRrtr || (n2.sdp = n2.sdp.replace(/a=rtcp-fb:(\d+) rrtr ?\r\n/g, ""), n2.sdp = n2.sdp.replace(/a=rtcp-fb:(\d+) nack ?\r\n/g, "a=rtcp-fb:$1 rrtr\r\na=rtcp-fb:$1 nack\r\n"), g2.sdp = g2.sdp.replace(/a=rtcp-fb:(\d+) rrtr ?\r\n/g, ""), g2.sdp = g2.sdp.replace(/a=rtcp-fb:(\d+) nack ?\r\n/g, "a=rtcp-fb:$1 rrtr\r\na=rtcp-fb:$1 nack\r\n")), u.getParameters().enableUdpCandidate || (g2.sdp = g2.sdp.replace(/\r\na=candidate:udpcandidate[^\r]+/g, "")), u.getParameters().enableTcpCandidate || (g2.sdp = g2.sdp.replace(/\r\na=candidate:tcpcandidate[^\r]+/g, "")), h.Logger.debug(T, "[Subscribe] receive() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(n2), h.Logger.debug(T, "[Subscribe] receive() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(g2);
            const f2 = this._pc.getTransceivers().find((e3) => e3.mid === m2);
            return this._mapMidTransceiver.set(m2, f2), { localId: m2, track: f2.receiver.track, rtpReceiver: f2.receiver };
          }
          async stopReceiving(e2) {
            this._assertRecvDirection(), h.Logger.debug(T, "[unsubscribe] stopReceiving() [localId:%s]", e2);
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2 || !t2.mid) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Chrome.stopReceiving: RTCRtpTransceiver 未找到" });
            t2.receiver && t2.receiver.track && t2.receiver.track && "audio" === t2.receiver.track.kind || (t2.isUseless = true), this._remoteSdp.disableMediaSection(t2.mid);
            const i2 = this._pc.localDescription;
            h.Logger.debug(T, "[unsubscribe] stopReceiving() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(i2);
            const r2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            h.Logger.debug(T, "[unsubscribe] stopReceiving() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(r2);
          }
          async getReceiverStats(e2) {
            this._assertRecvDirection();
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Chrome.getReceiverStats: RTCRtpTransceiver 未找到" });
            return t2.receiver.getStats();
          }
          async _setupTransport({ localDtlsRole: e2, localSdpObject: t2 }) {
            t2 || (t2 = n.parse(this._pc.localDescription.sdp));
            const i2 = f.extractDtlsParameters({ sdpObject: t2 });
            return i2.role = e2, this._transportReady = true, i2;
          }
          _assertSendDirection() {
            if ("send" !== this._direction) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "_assertSendDirection: 操作异常" });
          }
          _assertRecvDirection() {
            if ("recv" !== this._direction) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "_assertRecvDirection: 操作异常" });
          }
        }
        t.Chrome74 = I;
      }, function(e, t, i) {
        var r = function(e2) {
          return String(Number(e2)) === e2 ? Number(e2) : e2;
        }, s = function(e2, t2, i2) {
          var s2 = e2.name && e2.names;
          e2.push && !t2[e2.push] ? t2[e2.push] = [] : s2 && !t2[e2.name] && (t2[e2.name] = {});
          var a2 = e2.push ? {} : s2 ? t2[e2.name] : t2;
          !function(e3, t3, i3, s3) {
            if (s3 && !i3) t3[s3] = r(e3[1]);
            else for (var a3 = 0; a3 < i3.length; a3 += 1) null != e3[a3 + 1] && (t3[i3[a3]] = r(e3[a3 + 1]));
          }(i2.match(e2.reg), a2, e2.names, e2.name), e2.push && t2[e2.push].push(a2);
        }, a = i(170), o = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
        t.parse = function(e2) {
          var t2 = {}, i2 = [], r2 = t2;
          return e2.split(/(\r\n|\r|\n)/).filter(o).forEach(function(e3) {
            var t3 = e3[0], o2 = e3.slice(2);
            "m" === t3 && (i2.push({ rtp: [], fmtp: [] }), r2 = i2[i2.length - 1]);
            for (var n2 = 0; n2 < (a[t3] || []).length; n2 += 1) {
              var d = a[t3][n2];
              if (d.reg.test(o2)) return s(d, r2, o2);
            }
          }), t2.media = i2, t2;
        };
        var n = function(e2, t2) {
          var i2 = t2.split(/=(.+)/, 2);
          return 2 === i2.length ? e2[i2[0]] = r(i2[1]) : 1 === i2.length && t2.length > 1 && (e2[i2[0]] = void 0), e2;
        };
        t.parseParams = function(e2) {
          return e2.split(/;\s?/).reduce(n, {});
        }, t.parseFmtpConfig = t.parseParams, t.parsePayloads = function(e2) {
          return e2.toString().split(" ").map(Number);
        }, t.parseRemoteCandidates = function(e2) {
          for (var t2 = [], i2 = e2.split(" ").map(r), s2 = 0; s2 < i2.length; s2 += 3) t2.push({ component: i2[s2], ip: i2[s2 + 1], port: i2[s2 + 2] });
          return t2;
        }, t.parseImageAttributes = function(e2) {
          return e2.split(" ").map(function(e3) {
            return e3.substring(1, e3.length - 1).split(",").reduce(n, {});
          });
        }, t.parseSimulcastStreamList = function(e2) {
          return e2.split(";").map(function(e3) {
            return e3.split(",").map(function(e4) {
              var t2, i2 = false;
              return "~" !== e4[0] ? t2 = r(e4) : (t2 = r(e4.substring(1, e4.length)), i2 = true), { scid: t2, paused: i2 };
            });
          });
        };
      }, function(e, t, i) {
        var r = i(170), s = /%[sdv%]/g, a = function(e2) {
          var t2 = 1, i2 = arguments, r2 = i2.length;
          return e2.replace(s, function(e3) {
            if (t2 >= r2) return e3;
            var s2 = i2[t2];
            switch (t2 += 1, e3) {
              case "%%":
                return "%";
              case "%s":
                return String(s2);
              case "%d":
                return Number(s2);
              case "%v":
                return "";
            }
          });
        }, o = function(e2, t2, i2) {
          var r2 = [e2 + "=" + (t2.format instanceof Function ? t2.format(t2.push ? i2 : i2[t2.name]) : t2.format)];
          if (t2.names) for (var s2 = 0; s2 < t2.names.length; s2 += 1) {
            var o2 = t2.names[s2];
            t2.name ? r2.push(i2[t2.name][o2]) : r2.push(i2[t2.names[s2]]);
          }
          else r2.push(i2[t2.name]);
          return a.apply(null, r2);
        }, n = ["v", "o", "s", "i", "u", "e", "p", "c", "b", "t", "r", "z", "a"], d = ["i", "c", "b", "a"];
        e.exports = function(e2, t2) {
          t2 = t2 || {}, null == e2.version && (e2.version = 0), null == e2.name && (e2.name = " "), e2.media.forEach(function(e3) {
            null == e3.payloads && (e3.payloads = "");
          });
          var i2 = t2.outerOrder || n, s2 = t2.innerOrder || d, a2 = [];
          return i2.forEach(function(t3) {
            r[t3].forEach(function(i3) {
              i3.name in e2 && null != e2[i3.name] ? a2.push(o(t3, i3, e2)) : i3.push in e2 && null != e2[i3.push] && e2[i3.push].forEach(function(e3) {
                a2.push(o(t3, i3, e3));
              });
            });
          }), e2.media.forEach(function(e3) {
            a2.push(o("m", r.m[0], e3)), s2.forEach(function(t3) {
              r[t3].forEach(function(i3) {
                i3.name in e3 && null != e3[i3.name] ? a2.push(o(t3, i3, e3)) : i3.push in e3 && null != e3[i3.push] && e3[i3.push].forEach(function(e4) {
                  a2.push(o(t3, i3, e4));
                });
              });
            });
          }), a2.join("\r\n") + "\r\n";
        };
      }, function(e, t, i) {
        const r = i(226)("h264-profile-level-id");
        r.log = console.info.bind(console);
        t.ProfileConstrainedBaseline = 1, t.ProfileBaseline = 2, t.ProfileMain = 3, t.ProfileConstrainedHigh = 4, t.ProfileHigh = 5;
        t.Level1_b = 0, t.Level1 = 10, t.Level1_1 = 11, t.Level1_2 = 12, t.Level1_3 = 13, t.Level2 = 20, t.Level2_1 = 21, t.Level2_2 = 22, t.Level3 = 30, t.Level3_1 = 31, t.Level3_2 = 32, t.Level4 = 40, t.Level4_1 = 41, t.Level4_2 = 42, t.Level5 = 50, t.Level5_1 = 51, t.Level5_2 = 52;
        class s {
          constructor(e2, t2) {
            this.profile = e2, this.level = t2;
          }
        }
        t.ProfileLevelId = s;
        const a = new s(1, 31);
        class o {
          constructor(e2) {
            this._mask = ~c("x", e2), this._maskedValue = c("1", e2);
          }
          isMatch(e2) {
            return this._maskedValue === (e2 & this._mask);
          }
        }
        class n {
          constructor(e2, t2, i2) {
            this.profile_idc = e2, this.profile_iop = t2, this.profile = i2;
          }
        }
        const d = [new n(66, new o("x1xx0000"), 1), new n(77, new o("1xxx0000"), 1), new n(88, new o("11xx0000"), 1), new n(66, new o("x0xx0000"), 2), new n(88, new o("10xx0000"), 2), new n(77, new o("0x0x0000"), 3), new n(100, new o("00000000"), 5), new n(100, new o("00001100"), 4)];
        function c(e2, t2) {
          return (t2[0] === e2) << 7 | (t2[1] === e2) << 6 | (t2[2] === e2) << 5 | (t2[3] === e2) << 4 | (t2[4] === e2) << 3 | (t2[5] === e2) << 2 | (t2[6] === e2) << 1 | (t2[7] === e2) << 0;
        }
        function l(e2 = {}) {
          const t2 = e2["level-asymmetry-allowed"];
          return 1 === t2 || "1" === t2;
        }
        t.parseProfileLevelId = function(e2) {
          if ("string" != typeof e2 || 6 !== e2.length) return null;
          const t2 = parseInt(e2, 16);
          if (0 === t2) return null;
          const i2 = 255 & t2, a2 = t2 >> 8 & 255, o2 = t2 >> 16 & 255;
          let n2;
          switch (i2) {
            case 11:
              n2 = 0 != (16 & a2) ? 0 : 11;
              break;
            case 10:
            case 12:
            case 13:
            case 20:
            case 21:
            case 22:
            case 30:
            case 31:
            case 32:
            case 40:
            case 41:
            case 42:
            case 50:
            case 51:
            case 52:
              n2 = i2;
              break;
            default:
              return r("parseProfileLevelId() | unrecognized level_idc:%s", i2), null;
          }
          for (const e3 of d) if (o2 === e3.profile_idc && e3.profile_iop.isMatch(a2)) return new s(e3.profile, n2);
          return r("parseProfileLevelId() | unrecognized profile_idc/profile_iop combination"), null;
        }, t.profileLevelIdToString = function(e2) {
          if (0 == e2.level) switch (e2.profile) {
            case 1:
              return "42f00b";
            case 2:
              return "42100b";
            case 3:
              return "4d100b";
            default:
              return r("profileLevelIdToString() | Level 1_b not is allowed for profile:%s", e2.profile), null;
          }
          let t2;
          switch (e2.profile) {
            case 1:
              t2 = "42e0";
              break;
            case 2:
              t2 = "4200";
              break;
            case 3:
              t2 = "4d00";
              break;
            case 4:
              t2 = "640c";
              break;
            case 5:
              t2 = "6400";
              break;
            default:
              return r("profileLevelIdToString() | unrecognized profile:%s", e2.profile), null;
          }
          let i2 = e2.level.toString(16);
          return 1 === i2.length && (i2 = "0" + i2), `${t2}${i2}`;
        }, t.parseSdpProfileLevelId = function(e2 = {}) {
          const i2 = e2["profile-level-id"];
          return i2 ? t.parseProfileLevelId(i2) : a;
        }, t.isSameProfile = function(e2 = {}, i2 = {}) {
          const r2 = t.parseSdpProfileLevelId(e2), s2 = t.parseSdpProfileLevelId(i2);
          return Boolean(r2 && s2 && r2.profile === s2.profile);
        }, t.generateProfileLevelIdForAnswer = function(e2 = {}, i2 = {}) {
          if (!e2["profile-level-id"] && !i2["profile-level-id"]) return r("generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params"), null;
          const a2 = t.parseSdpProfileLevelId(e2), o2 = t.parseSdpProfileLevelId(i2);
          if (!a2) throw new TypeError("invalid local_profile_level_id");
          if (!o2) throw new TypeError("invalid remote_profile_level_id");
          if (a2.profile !== o2.profile) throw new TypeError("H264 Profile mismatch");
          const n2 = l(e2) && l(i2), d2 = a2.level, c2 = o2.level, u = function(e3, t2) {
            return 0 === e3 ? 10 !== t2 && 0 !== t2 : 0 === t2 ? 10 !== e3 : e3 < t2;
          }(h = d2, p = c2) ? h : p;
          var h, p;
          const m = n2 ? d2 : u;
          return r("generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]", a2.profile, m), t.profileLevelIdToString(new s(a2.profile, m));
        };
      }, function(e, t, i) {
        (function(r) {
          t.formatArgs = function(t2) {
            if (t2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + t2[0] + (this.useColors ? "%c " : " ") + "+" + e.exports.humanize(this.diff), !this.useColors) return;
            const i2 = "color: " + this.color;
            t2.splice(1, 0, i2, "color: inherit");
            let r2 = 0, s2 = 0;
            t2[0].replace(/%[a-zA-Z%]/g, (e2) => {
              "%%" !== e2 && (r2++, "%c" === e2 && (s2 = r2));
            }), t2.splice(s2, 0, i2);
          }, t.save = function(e2) {
            try {
              e2 ? t.storage.setItem("debug", e2) : t.storage.removeItem("debug");
            } catch (e3) {
            }
          }, t.load = function() {
            let e2;
            try {
              e2 = t.storage.getItem("debug");
            } catch (e3) {
            }
            !e2 && void 0 !== r && "env" in r && (e2 = r.env.DEBUG);
            return e2;
          }, t.useColors = function() {
            if ("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return true;
            if ("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
            return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          }, t.storage = function() {
            try {
              return localStorage;
            } catch (e2) {
            }
          }(), t.destroy = /* @__PURE__ */ (() => {
            let e2 = false;
            return () => {
              e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
            };
          })(), t.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], t.log = console.debug || console.log || (() => {
          }), e.exports = i(227)(t);
          const { formatters: s } = e.exports;
          s.j = function(e2) {
            try {
              return JSON.stringify(e2);
            } catch (e3) {
              return "[UnexpectedJSONParseError]: " + e3.message;
            }
          };
        }).call(this, i(80));
      }, function(e, t, i) {
        e.exports = function(e2) {
          function t2(e3) {
            let i2, s2, a, o = null;
            function n(...e4) {
              if (!n.enabled) return;
              const r2 = n, s3 = Number(/* @__PURE__ */ new Date()), a2 = s3 - (i2 || s3);
              r2.diff = a2, r2.prev = i2, r2.curr = s3, i2 = s3, e4[0] = t2.coerce(e4[0]), "string" != typeof e4[0] && e4.unshift("%O");
              let o2 = 0;
              e4[0] = e4[0].replace(/%([a-zA-Z%])/g, (i3, s4) => {
                if ("%%" === i3) return "%";
                o2++;
                const a3 = t2.formatters[s4];
                if ("function" == typeof a3) {
                  const t3 = e4[o2];
                  i3 = a3.call(r2, t3), e4.splice(o2, 1), o2--;
                }
                return i3;
              }), t2.formatArgs.call(r2, e4);
              (r2.log || t2.log).apply(r2, e4);
            }
            return n.namespace = e3, n.useColors = t2.useColors(), n.color = t2.selectColor(e3), n.extend = r, n.destroy = t2.destroy, Object.defineProperty(n, "enabled", { enumerable: true, configurable: false, get: () => null !== o ? o : (s2 !== t2.namespaces && (s2 = t2.namespaces, a = t2.enabled(e3)), a), set: (e4) => {
              o = e4;
            } }), "function" == typeof t2.init && t2.init(n), n;
          }
          function r(e3, i2) {
            const r2 = t2(this.namespace + (void 0 === i2 ? ":" : i2) + e3);
            return r2.log = this.log, r2;
          }
          function s(e3) {
            return e3.toString().substring(2, e3.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return t2.debug = t2, t2.default = t2, t2.coerce = function(e3) {
            if (e3 instanceof Error) return e3.stack || e3.message;
            return e3;
          }, t2.disable = function() {
            const e3 = [...t2.names.map(s), ...t2.skips.map(s).map((e4) => "-" + e4)].join(",");
            return t2.enable(""), e3;
          }, t2.enable = function(e3) {
            let i2;
            t2.save(e3), t2.namespaces = e3, t2.names = [], t2.skips = [];
            const r2 = ("string" == typeof e3 ? e3 : "").split(/[\s,]+/), s2 = r2.length;
            for (i2 = 0; i2 < s2; i2++) r2[i2] && ("-" === (e3 = r2[i2].replace(/\*/g, ".*?"))[0] ? t2.skips.push(new RegExp("^" + e3.slice(1) + "$")) : t2.names.push(new RegExp("^" + e3 + "$")));
          }, t2.enabled = function(e3) {
            if ("*" === e3[e3.length - 1]) return true;
            let i2, r2;
            for (i2 = 0, r2 = t2.skips.length; i2 < r2; i2++) if (t2.skips[i2].test(e3)) return false;
            for (i2 = 0, r2 = t2.names.length; i2 < r2; i2++) if (t2.names[i2].test(e3)) return true;
            return false;
          }, t2.humanize = i(228), t2.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(e2).forEach((i2) => {
            t2[i2] = e2[i2];
          }), t2.names = [], t2.skips = [], t2.formatters = {}, t2.selectColor = function(e3) {
            let i2 = 0;
            for (let t3 = 0; t3 < e3.length; t3++) i2 = (i2 << 5) - i2 + e3.charCodeAt(t3), i2 |= 0;
            return t2.colors[Math.abs(i2) % t2.colors.length];
          }, t2.enable(t2.load()), t2;
        };
      }, function(e, t) {
        var i = 1e3, r = 6e4, s = 60 * r, a = 24 * s;
        function o(e2, t2, i2, r2) {
          var s2 = t2 >= 1.5 * i2;
          return Math.round(e2 / i2) + " " + r2 + (s2 ? "s" : "");
        }
        e.exports = function(e2, t2) {
          t2 = t2 || {};
          var n = typeof e2;
          if ("string" === n && e2.length > 0) return function(e3) {
            if ((e3 = String(e3)).length > 100) return;
            var t3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e3);
            if (!t3) return;
            var o2 = parseFloat(t3[1]);
            switch ((t3[2] || "ms").toLowerCase()) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return 315576e5 * o2;
              case "weeks":
              case "week":
              case "w":
                return 6048e5 * o2;
              case "days":
              case "day":
              case "d":
                return o2 * a;
              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return o2 * s;
              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return o2 * r;
              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return o2 * i;
              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return o2;
              default:
                return;
            }
          }(e2);
          if ("number" === n && isFinite(e2)) return t2.long ? function(e3) {
            var t3 = Math.abs(e3);
            if (t3 >= a) return o(e3, t3, a, "day");
            if (t3 >= s) return o(e3, t3, s, "hour");
            if (t3 >= r) return o(e3, t3, r, "minute");
            if (t3 >= i) return o(e3, t3, i, "second");
            return e3 + " ms";
          }(e2) : function(e3) {
            var t3 = Math.abs(e3);
            if (t3 >= a) return Math.round(e3 / a) + "d";
            if (t3 >= s) return Math.round(e3 / s) + "h";
            if (t3 >= r) return Math.round(e3 / r) + "m";
            if (t3 >= i) return Math.round(e3 / i) + "s";
            return e3 + "ms";
          }(e2);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.OfferMediaSection = t.AnswerMediaSection = t.MediaSection = void 0;
        const o = a(i(27));
        class n {
          constructor({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, planB: r2 = false }) {
            if (this._mediaObject = {}, this._planB = r2, e2 && this.setIceParameters(e2), t2) {
              this._mediaObject.candidates = [];
              for (const e3 of t2) {
                const t3 = { component: 1 };
                t3.foundation = e3.foundation, t3.ip = e3.ip, t3.port = e3.port, t3.priority = e3.priority, t3.transport = e3.protocol, t3.type = e3.type, e3.tcpType && (t3.tcptype = e3.tcpType), this._mediaObject.candidates.push(t3);
              }
              this._mediaObject.endOfCandidates = "end-of-candidates", this._mediaObject.iceOptions = "renomination";
            }
            i2 && this.setDtlsRole(i2.role);
          }
          get mid() {
            return String(this._mediaObject.mid);
          }
          get type() {
            return String(this._mediaObject.type);
          }
          get closed() {
            return 0 === this._mediaObject.port;
          }
          set mid(e2) {
            this._mediaObject.mid = e2;
          }
          getObject() {
            return this._mediaObject;
          }
          setIceParameters(e2) {
            this._mediaObject.iceUfrag = e2.usernameFragment, this._mediaObject.icePwd = e2.password;
          }
          disable() {
            delete this._mediaObject.ext, delete this._mediaObject.ssrcs, delete this._mediaObject.ssrcGroups, delete this._mediaObject.simulcast, delete this._mediaObject.simulcast_03, delete this._mediaObject.rids;
          }
          close() {
            this._mediaObject.direction = "inactive", this._mediaObject.port = 0, delete this._mediaObject.ext, delete this._mediaObject.ssrcs, delete this._mediaObject.ssrcGroups, delete this._mediaObject.simulcast, delete this._mediaObject.simulcast_03, delete this._mediaObject.rids, delete this._mediaObject.extmapAllowMixed;
          }
        }
        t.MediaSection = n;
        t.AnswerMediaSection = class extends n {
          constructor({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2, plainRtpParameters: s2, planB: a2 = false, offerMediaObject: n2, offerRtpParameters: c, answerRtpParameters: l, codecOptions: u, extmapAllowMixed: h = false }) {
            switch (super({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, planB: a2 }), this._mediaObject.mid = String(n2.mid), this._mediaObject.type = n2.type, this._mediaObject.protocol = n2.protocol, s2 ? (this._mediaObject.connection = { ip: s2.ip, version: s2.ipVersion }, this._mediaObject.port = s2.port) : (this._mediaObject.connection = { ip: "127.0.0.1", version: 4 }, this._mediaObject.port = 7), n2.type) {
              case "audio":
              case "video":
                this._mediaObject.direction = "recvonly", this._mediaObject.rtp = [], this._mediaObject.rtcpFb = [], this._mediaObject.fmtp = [];
                for (const e3 of l.codecs) {
                  const t3 = { payload: e3.payloadType, codec: d(e3), rate: e3.clockRate };
                  e3.channels > 1 && (t3.encoding = e3.channels), this._mediaObject.rtp.push(t3);
                  const i3 = o.clone(e3.parameters, {});
                  if (u) {
                    const { opusStereo: t4, opusFec: r4, opusDtx: s3, opusMaxPlaybackRate: a3, opusPtime: o2, videoGoogleStartBitrate: n3, videoGoogleMaxBitrate: d2, videoGoogleMinBitrate: l2 } = u, h2 = c.codecs.find((t5) => t5.payloadType === e3.payloadType);
                    switch (e3.mimeType.toLowerCase()) {
                      case "audio/opus":
                        void 0 !== t4 && (h2.parameters["sprop-stereo"] = t4 ? 1 : 0, i3.stereo = t4 ? 1 : 0), void 0 !== r4 && (h2.parameters.useinbandfec = r4 ? 1 : 0, i3.useinbandfec = r4 ? 1 : 0), void 0 !== s3 && (h2.parameters.usedtx = s3 ? 1 : 0, i3.usedtx = s3 ? 1 : 0), void 0 !== a3 && (i3.maxplaybackrate = a3), void 0 !== o2 && (h2.parameters.ptime = o2, i3.ptime = o2);
                        break;
                      case "video/vp8":
                      case "video/vp9":
                      case "video/h264":
                      case "video/h265":
                        void 0 !== n3 && (i3["x-google-start-bitrate"] = n3), void 0 !== d2 && (i3["x-google-max-bitrate"] = d2), void 0 !== l2 && (i3["x-google-min-bitrate"] = l2);
                    }
                  }
                  const r3 = { payload: e3.payloadType, config: "" };
                  for (const e4 of Object.keys(i3)) r3.config && (r3.config += ";"), r3.config += `${e4}=${i3[e4]}`;
                  r3.config && this._mediaObject.fmtp.push(r3);
                  for (const t4 of e3.rtcpFeedback) this._mediaObject.rtcpFb.push({ payload: e3.payloadType, type: t4.type, subtype: t4.parameter });
                }
                this._mediaObject.payloads = l.codecs.map((e3) => e3.payloadType).join(" "), this._mediaObject.ext = [];
                for (const e3 of l.headerExtensions) {
                  (n2.ext || []).some((t3) => t3.uri === e3.uri) && this._mediaObject.ext.push({ uri: e3.uri, value: e3.id });
                }
                if (h && "extmap-allow-mixed" === n2.extmapAllowMixed && (this._mediaObject.extmapAllowMixed = "extmap-allow-mixed"), n2.simulcast) {
                  this._mediaObject.simulcast = { dir1: "recv", list1: n2.simulcast.list1 }, this._mediaObject.rids = [];
                  for (const e3 of n2.rids || []) "send" === e3.direction && this._mediaObject.rids.push({ id: e3.id, direction: "recv" });
                } else if (n2.simulcast_03) {
                  this._mediaObject.simulcast_03 = { value: n2.simulcast_03.value.replace(/send/g, "recv") }, this._mediaObject.rids = [];
                  for (const e3 of n2.rids || []) "send" === e3.direction && this._mediaObject.rids.push({ id: e3.id, direction: "recv" });
                }
                this._mediaObject.rtcpMux = "rtcp-mux", this._mediaObject.rtcpRsize = "rtcp-rsize", this._planB && "video" === this._mediaObject.type && (this._mediaObject.xGoogleFlag = "conference");
                break;
              case "application":
                "number" == typeof n2.sctpPort ? (this._mediaObject.payloads = "webrtc-datachannel", this._mediaObject.sctpPort = r2.port, this._mediaObject.maxMessageSize = r2.maxMessageSize) : n2.sctpmap && (this._mediaObject.payloads = r2.port, this._mediaObject.sctpmap = { app: "webrtc-datachannel", sctpmapNumber: r2.port, maxMessageSize: r2.maxMessageSize });
            }
          }
          setDtlsRole(e2) {
            switch (e2) {
              case "client":
                this._mediaObject.setup = "active";
                break;
              case "server":
                this._mediaObject.setup = "passive";
                break;
              case "auto":
                this._mediaObject.setup = "actpass";
            }
          }
        };
        function d(e2) {
          const t2 = new RegExp("^(audio|video)/(.+)", "i").exec(e2.mimeType);
          if (!t2) throw new TypeError("invalid codec.mimeType");
          return t2[2];
        }
        t.OfferMediaSection = class extends n {
          constructor({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2, plainRtpParameters: s2, planB: a2 = false, mid: o2, kind: n2, offerRtpParameters: c, streamId: l, trackId: u, oldDataChannelSpec: h = false }) {
            switch (super({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, planB: a2 }), this._mediaObject.mid = String(o2), this._mediaObject.type = n2, s2 ? (this._mediaObject.connection = { ip: s2.ip, version: s2.ipVersion }, this._mediaObject.protocol = "RTP/AVP", this._mediaObject.port = s2.port) : (this._mediaObject.connection = { ip: "127.0.0.1", version: 4 }, this._mediaObject.protocol = r2 ? "UDP/DTLS/SCTP" : "UDP/TLS/RTP/SAVPF", this._mediaObject.port = 7), n2) {
              case "audio":
              case "video": {
                this._mediaObject.direction = "sendonly", this._mediaObject.rtp = [], this._mediaObject.rtcpFb = [], this._mediaObject.fmtp = [], this._planB || (this._mediaObject.msid = `${l || "-"} ${u}`);
                for (const e4 of c.codecs) {
                  const t4 = { payload: e4.payloadType || e4.localPayloadType || 125, codec: d(e4), rate: e4.clockRate };
                  e4.channels > 1 && (t4.encoding = e4.channels), this._mediaObject.rtp.push(t4);
                  const i4 = { payload: e4.payloadType || e4.localPayloadType || 125, config: "" }, r3 = e4.parameters || e4.localParameters || {};
                  for (const e5 of Object.keys(r3)) i4.config && (i4.config += ";"), i4.config += `${e5}=${r3[e5]}`;
                  i4.config && this._mediaObject.fmtp.push(i4);
                  for (const t5 of e4.rtcpFeedback) this._mediaObject.rtcpFb.push({ payload: e4.payloadType, type: t5.type, subtype: t5.parameter });
                }
                this._mediaObject.payloads = c.codecs.map((e4) => e4.payloadType || e4.localPayloadType || 125).join(" "), this._mediaObject.ext = [];
                for (const e4 of c.headerExtensions) this._mediaObject.ext.push({ uri: e4.uri, value: e4.id });
                this._mediaObject.rtcpMux = "rtcp-mux", this._mediaObject.rtcpRsize = "rtcp-rsize";
                const e3 = c.encodings[0], t3 = e3.ssrc, i3 = e3.rtx && e3.rtx.ssrc ? e3.rtx.ssrc : void 0;
                this._mediaObject.ssrcs = [], this._mediaObject.ssrcGroups = [], c.rtcp.cname && this._mediaObject.ssrcs.push({ id: t3, attribute: "cname", value: c.rtcp.cname }), this._planB && this._mediaObject.ssrcs.push({ id: t3, attribute: "msid", value: `${l || "-"} ${u}` }), i3 && (c.rtcp.cname && this._mediaObject.ssrcs.push({ id: i3, attribute: "cname", value: c.rtcp.cname }), this._planB && this._mediaObject.ssrcs.push({ id: i3, attribute: "msid", value: `${l || "-"} ${u}` }), this._mediaObject.ssrcGroups.push({ semantics: "FID", ssrcs: `${t3} ${i3}` }));
                break;
              }
              case "application":
                h ? (this._mediaObject.payloads = r2.port, this._mediaObject.sctpmap = { app: "webrtc-datachannel", sctpmapNumber: r2.port, maxMessageSize: r2.maxMessageSize }) : (this._mediaObject.payloads = "webrtc-datachannel", this._mediaObject.sctpPort = r2.port, this._mediaObject.maxMessageSize = r2.maxMessageSize);
            }
          }
          setDtlsRole(e2) {
            switch (e2) {
              case "client":
                this._mediaObject.setup = "active";
                break;
              case "server":
                this._mediaObject.setup = "passive";
                break;
              case "auto":
                this._mediaObject.setup = "actpass";
            }
          }
          planBReceive({ offerRtpParameters: e2, streamId: t2, trackId: i2 }) {
            const r2 = e2.encodings[0], s2 = r2.ssrc, a2 = r2.rtx && r2.rtx.ssrc ? r2.rtx.ssrc : void 0;
            e2.rtcp.cname && this._mediaObject.ssrcs.push({ id: s2, attribute: "cname", value: e2.rtcp.cname }), this._mediaObject.ssrcs.push({ id: s2, attribute: "msid", value: `${t2 || "-"} ${i2}` }), a2 && (e2.rtcp.cname && this._mediaObject.ssrcs.push({ id: a2, attribute: "cname", value: e2.rtcp.cname }), this._mediaObject.ssrcs.push({ id: a2, attribute: "msid", value: `${t2 || "-"} ${i2}` }), this._mediaObject.ssrcGroups.push({ semantics: "FID", ssrcs: `${s2} ${a2}` }));
          }
          planBStopReceiving({ offerRtpParameters: e2 }) {
            const t2 = e2.encodings[0], i2 = t2.ssrc, r2 = t2.rtx && t2.rtx.ssrc ? t2.rtx.ssrc : void 0;
            this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((e3) => e3.id !== i2 && e3.id !== r2), r2 && (this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((e3) => e3.ssrcs !== `${i2} ${r2}`));
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Chrome58 = void 0;
        const o = a(i(50)), n = i(29), d = i(78), c = a(i(27)), l = a(i(79)), u = a(i(88)), h = a(i(231)), p = i(43), m = i(1), g = i(87), f = i(138), v = i(89), S = i(232), y = a(i(7)), _ = "Chrome_", R = { OS: 1024, MIS: 1024 };
        class b extends g.HandlerInterface {
          constructor() {
            super(), this._sendStream = new MediaStream(), this._mapSendLocalIdTrack = /* @__PURE__ */ new Map(), this._nextSendLocalId = 0, this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map(), this._hasDataChannelMediaSection = false, this._nextSendSctpStreamId = 0, this._transportReady = false;
          }
          static createFactory() {
            return () => new b();
          }
          get name() {
            return "Chrome58";
          }
          close() {
            if (n.Logger.debug(_, "close()"), this._pc) try {
              this._pc.onconnectionstatechange = null, this._pc.close();
            } catch (e2) {
            }
          }
          async getNativeRtpCapabilities() {
            n.Logger.debug("getNativeRtpCapabilities()");
            const e2 = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require", sdpSemantics: "plan-b" });
            try {
              const t2 = await e2.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true });
              try {
                e2.close();
              } catch (e3) {
              }
              const i2 = o.parse(t2.sdp);
              return u.extractRtpCapabilities({ sdpObject: i2 });
            } catch (t2) {
              try {
                e2.close();
              } catch (e3) {
              }
              throw t2;
            }
          }
          async getNativeSctpCapabilities() {
            return n.Logger.debug("getNativeSctpCapabilities()"), { numStreams: R };
          }
          run({ direction: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: d2, proprietaryConstraints: c2, extendedRtpCapabilities: u2 }) {
            n.Logger.debug("run()"), this._direction = e2, this._sendingRtpParametersByKind = { audio: l.getSendingRtpParameters("audio", u2), video: l.getSendingRtpParameters("video", u2) }, this._sendingRemoteRtpParametersByKind = { audio: l.getSendingRemoteRtpParameters("audio", u2), video: l.getSendingRemoteRtpParameters("video", u2) }, (null == r2 ? void 0 : r2.role) && "auto" !== r2.role && (this._forcedLocalDtlsRole = "server" === r2.role ? "client" : "server"), this._pc = new RTCPeerConnection(Object.assign({ iceServers: a2 || [], iceTransportPolicy: o2 || "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require", sdpSemantics: "plan-b" }, d2), c2), this._pc.connectionState ? this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            }) : this._pc.addEventListener("iceconnectionstatechange", () => {
              switch (n.Logger.debug("run() | pc.connectionState not supported, using pc.iceConnectionState"), this._pc.iceConnectionState) {
                case "checking":
                  this.emit("@connectionstatechange", "connecting");
                  break;
                case "connected":
                case "completed":
                  this.emit("@connectionstatechange", "connected");
                  break;
                case "failed":
                  this.emit("@connectionstatechange", "failed");
                  break;
                case "disconnected":
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                case "closed":
                  this.emit("@connectionstatechange", "closed");
              }
            }), this._pc.onicecandidate = (e3) => {
            }, this._pc.onicecandidateerror = (e3) => {
              n.Logger.warn("onicecandidateerror: ", e3);
            };
          }
          async updateIceServers(e2) {
            n.Logger.debug("updateIceServers()");
            const t2 = this._pc.getConfiguration();
            t2.iceServers = e2, this._pc.setConfiguration(t2);
          }
          async restartIce(e2) {
            if (n.Logger.debug("restartIce()"), this._remoteSdp.updateIceParameters(e2), this._transportReady) if ("send" === this._direction) {
              const e3 = await this._pc.createOffer({ iceRestart: true });
              n.Logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", e3), await this._pc.setLocalDescription(e3);
              const t2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
              n.Logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", t2), await this._pc.setRemoteDescription(t2);
            } else {
              const e3 = { type: "offer", sdp: this._remoteSdp.getSdp() };
              n.Logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", e3), await this._pc.setRemoteDescription(e3);
              const t2 = await this._pc.createAnswer();
              n.Logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", t2), await this._pc.setLocalDescription(t2);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track: e2, encodings: t2, codecOptions: i2, codec: r2, appData: s2 }) {
            this.assertSendDirection(), n.Logger.debug("send() [kind:%s, track.id:%s]", e2.kind, e2.id), this._sendStream.addTrack(e2), this._pc.addStream(this._sendStream);
            let a2, d2 = await this._pc.createOffer(), p2 = o.parse(d2.sdp);
            s2.preferRemb && v.filterTransportCCFromSdp(p2);
            let m2 = void 0;
            const g2 = c.clone(this._sendingRtpParametersByKind[e2.kind]), f2 = c.clone(this._sendingRemoteRtpParametersByKind[e2.kind]);
            if (f2.codecs = l.reduceCodecs(f2.codecs), this._transportReady || (m2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: p2 })), "video" === e2.kind && t2 && t2.length > 1 && (n.Logger.debug("send() | enabling simulcast"), p2 = o.parse(d2.sdp), a2 = p2.media.find((e3) => "video" === e3.type), h.addLegacySimulcast({ offerMediaObject: a2, track: e2, numStreams: t2.length }), d2 = { type: "offer", sdp: o.write(p2) }), n.Logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", d2), a2 = p2.media.find((t3) => t3.type === e2.kind), g2.rtcp.cname = u.getCname({ offerMediaObject: a2 }), g2.encodings = h.getRtpEncodings({ offerMediaObject: a2, track: e2 }), t2) for (let e3 = 0; e3 < g2.encodings.length; ++e3) t2[e3] && Object.assign(g2.encodings[e3], t2[e3]);
            if (g2.encodings.length > 1 && "video/vp8" === g2.codecs[0].mimeType.toLowerCase()) for (const e3 of g2.encodings) e3.scalabilityMode = "S1T3";
            const S2 = String(this._nextSendLocalId);
            return this._nextSendLocalId++, this._mapSendLocalIdTrack.set(S2, e2), { localId: S2, rtpParameters: g2, dtlsParameters: m2, offer: d2 };
          }
          async fillRemoteRecvSdp({ kind: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, sendingRtpParameters: a2, codecOptions: d2, offer: l2, audioProfile: u2, codec: h2, resetVideoSdp: g2, appData: y2 }) {
            n.Logger.debug(_, "fillRemoteRecvSdp() | calling pc.setLocalDescription()"), l2 = new S.Interop().toUnifiedPlan(l2), await this._pc.setLocalDescription(l2), this._remoteSdp || (this._remoteSdp = new f.RemoteSdp({ iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2 }), this._remoteSdp.updateDtlsRole("client"));
            const R2 = c.clone(this._sendingRemoteRtpParametersByKind[e2]);
            y2.preferRemb ? (n.Logger.debug(_, "publish() fillRemoteRecvSdp() |  使用REMB作为带宽估计方式"), v.filterTransportCCFromRtpParameters(R2)) : (n.Logger.debug(_, "publish() fillRemoteRecvSdp() |  使用transport-cc作为带宽估计方式"), v.filterRembFromRtpParameters(R2)), R2.codecs = p.reduceCodecs(R2.codecs, h2);
            let b2 = o.parse(this._pc.localDescription.sdp), T = this._remoteSdp.getNextMediaSectionIdx();
            g2 && (a2.mid ? a2.encodings && a2.encodings.length > 1 ? T.idx = Number(a2.mid) - (a2.encodings.length - 1) : T.idx = Number(a2.mid) : n.Logger.warn(_, "fillRemoteRecvSdp() | mid 未找到"), T.reuseMid = true);
            let E = b2.media[T.idx], A = null;
            a2.encodings && a2.encodings.length > 1 && (A = b2.media[T.idx + 1]), this._remoteSdp.send({ offerMediaObjectArr: [E], reuseMid: T.reuseMid, offerRtpParameters: a2, answerRtpParameters: R2, codecOptions: d2, extmapAllowMixed: true });
            let I = { type: "answer", sdp: this._remoteSdp.getSdp() };
            if (n.Logger.debug(_, "audioProfile设置为: ", u2), u2) {
              let e3 = null;
              switch (u2) {
                case "speech_low_quality":
                  e3 = "maxplaybackrate=16000;sprop-maxcapturerate=16000;maxaveragebitrate=32000";
                  break;
                case "speech_standard":
                  e3 = "maxplaybackrate=32000;sprop-maxcapturerate=32000;maxaveragebitrate=36000";
                  break;
                case "music_standard":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;";
                  break;
                case "standard_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=56000";
                  break;
                case "high_quality":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=128000";
                  break;
                case "high_quality_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=192000";
              }
              I.sdp.indexOf("a=fmtp:111") && (I.sdp = I.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;useinbandfec=1;" + e3)), I.sdp = I.sdp.replace(/a=rtcp-fb:111 transport-cc/g, "a=maxptime:60");
            }
            n.Logger.debug(_, "fillRemoteRecvSdp() | calling pc.setRemoteDescription()"), m.getParameters().enableUdpCandidate || (I.sdp = I.sdp.replace(/\r\na=candidate:udpcandidate[^\r]+/g, "")), m.getParameters().enableTcpCandidate || (I.sdp = I.sdp.replace(/\r\na=candidate:tcpcandidate[^\r]+/g, "")), await this._pc.setRemoteDescription(I);
          }
          async stopSending(e2) {
            this.assertSendDirection(), n.Logger.debug("stopSending() [localId:%s]", e2);
            const t2 = this._mapSendLocalIdTrack.get(e2);
            if (!t2) throw new Error("track not found");
            this._mapSendLocalIdTrack.delete(e2), this._sendStream.removeTrack(t2), this._pc.addStream(this._sendStream);
            const i2 = await this._pc.createOffer();
            n.Logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", i2);
            try {
              await this._pc.setLocalDescription(i2);
            } catch (e3) {
              if (0 === this._sendStream.getTracks().length) return void n.Logger.warn("stopSending() | ignoring expected error due no sending tracks: %s", e3.toString());
              throw e3;
            }
            if ("stable" === this._pc.signalingState) return;
            const r2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            n.Logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", r2), await this._pc.setRemoteDescription(r2);
          }
          async pauseSending(e2) {
          }
          async resumeSending(e2) {
          }
          async replaceTrack(e2, t2) {
            throw new d.UnsupportedError("not implemented");
          }
          async setMaxSpatialLayer(e2, t2) {
            throw new d.UnsupportedError(" not implemented");
          }
          async setRtpEncodingParameters(e2, t2) {
            throw new d.UnsupportedError("not supported");
          }
          async getSenderStats(e2) {
            throw new d.UnsupportedError("not implemented");
          }
          async prepareLocalSdp(e2, t2) {
            n.Logger.debug("prepareLocalSdp() [kind:%s, remoteUid:%s]", e2, t2);
            let i2, r2, s2, a2 = -1;
            if (r2 = "audio" === e2 || this._pc.localDescription.sdp.indexOf("m=audio") > -1, s2 = "video" === e2 || this._pc.localDescription.sdp.indexOf("m=video") > -1, i2 = await this._pc.createOffer({ offerToReceiveAudio: r2, offerToReceiveVideo: s2 }), !i2.sdp) throw n.Logger.error(_, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
            if (i2.sdp.indexOf("a=rtcp-fb:111") && -1 === i2.sdp.indexOf("a=rtcp-fb:111 nack") && (i2.sdp = i2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack")), i2.sdp.indexOf("a=fmtp:111") && (i2.sdp = i2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z-]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1")), !i2.sdp) throw n.Logger.error(_, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
            i2.sdp.includes("a=inactive") && (i2.sdp = i2.sdp.replace(/a=inactive/g, "a=recvonly"));
            const d2 = o.parse(i2.sdp);
            a2 = d2.media[d2.media.length - 1].mid;
            let c2 = void 0;
            c2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: d2 });
            let l2 = await this._pc.createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true }), h2 = o.parse(l2.sdp), p2 = u.extractRtpCapabilities({ sdpObject: h2 });
            return -1 === a2 && (a2 = d2.media[d2.media.length - 1].mid), { dtlsParameters: c2, rtpCapabilities: p2, offer: i2, mid: a2, iceUfragReg: "" };
          }
          async receive({ trackId: e2, kind: t2, rtpParameters: i2, iceParameters: r2, iceCandidates: s2, dtlsParameters: a2, sctpParameters: o2, offer: d2, remoteUid: c2, extendedRtpCapabilities: l2, appData: u2 }) {
            this.assertRecvDirection(), n.Logger.debug("receive() [trackId:%s, kind:%s]", e2, t2);
            const h2 = t2, p2 = i2.rtcp.cname;
            this._remoteSdp || (this._remoteSdp = new f.RemoteSdp({ iceParameters: r2, iceCandidates: s2, dtlsParameters: a2, sctpParameters: o2, planB: true }), this._remoteSdp.updateDtlsRole("client"));
            let m2 = i2 && i2.mid || u2.mid;
            n.Logger.debug(_, "[Subscribe] receive() mid: " + m2), this._remoteSdp.receive({ mid: h2, kind: t2, offerRtpParameters: i2, streamId: p2, trackId: e2 }), y.ANY_CHROME_MAJOR_VERSION && y.ANY_CHROME_MAJOR_VERSION < 59 && this._remoteSdp.getSdp().indexOf("a=setup:actpass") > -1 && this._remoteSdp.updateDtlsRole("client");
            let g2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            n.Logger.debug(_, "[Subscribe] receive() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(d2), n.Logger.debug(_, "[Subscribe] receive() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(g2);
            return { localId: m2, track: this._pc.getRemoteStreams().find((e3) => e3.id === p2).getTrackById(e2), rtpReceiver: void 0 };
          }
          async stopReceiving(e2) {
            this.assertRecvDirection();
            for (const t3 of e2) {
              n.Logger.debug("stopReceiving() [localId:%s]", t3);
              const { mid: e3, rtpParameters: i3 } = this._mapRecvLocalIdInfo.get(t3) || {};
              this._mapRecvLocalIdInfo.delete(t3), y.ANY_CHROME_MAJOR_VERSION && y.ANY_CHROME_MAJOR_VERSION < 59 && this._remoteSdp.updateDtlsRole("auto"), this._remoteSdp.planBStopReceiving({ mid: e3, offerRtpParameters: i3 });
            }
            const t2 = { type: "offer", sdp: this._remoteSdp.getSdp() };
            n.Logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", t2), await this._pc.setRemoteDescription(t2);
            const i2 = await this._pc.createAnswer();
            n.Logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", i2), await this._pc.setLocalDescription(i2);
          }
          async pauseReceiving(e2) {
          }
          async resumeReceiving(e2) {
          }
          async getReceiverStats(e2) {
            throw new d.UnsupportedError("not implemented");
          }
          async _setupTransport({ localDtlsRole: e2, localSdpObject: t2 }) {
            t2 || (t2 = o.parse(this._pc.localDescription.sdp));
            const i2 = u.extractDtlsParameters({ sdpObject: t2 });
            return i2.role = e2, this._transportReady = true, i2;
          }
          assertSendDirection() {
            if ("send" !== this._direction) throw new Error('method can just be called for handlers with "send" direction');
          }
          assertRecvDirection() {
            if ("recv" !== this._direction) throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
        t.Chrome58 = b;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.addLegacySimulcast = t.getRtpEncodings = void 0, t.getRtpEncodings = function({ offerMediaObject: e2, track: t2 }) {
          let i2;
          const r = /* @__PURE__ */ new Set();
          for (const s2 of e2.ssrcs || []) {
            if ("msid" !== s2.attribute) continue;
            if (s2.value.split(" ")[1] === t2.id) {
              const e3 = s2.id;
              r.add(e3), i2 || (i2 = e3);
            }
          }
          if (0 === r.size) throw new Error(`a=ssrc line with msid information not found [track.id:${t2.id}]`);
          const s = /* @__PURE__ */ new Map();
          for (const t3 of e2.ssrcGroups || []) {
            if ("FID" !== t3.semantics) continue;
            let [e3, i3] = t3.ssrcs.split(/\s+/);
            e3 = Number(e3), i3 = Number(i3), r.has(e3) && (r.delete(e3), r.delete(i3), s.set(e3, i3));
          }
          for (const e3 of r) s.set(e3, null);
          const a = [];
          for (const [e3, t3] of s) {
            const i3 = { ssrc: e3 };
            t3 && (i3.rtx = { ssrc: t3 }), a.push(i3);
          }
          return a;
        }, t.addLegacySimulcast = function({ offerMediaObject: e2, track: t2, numStreams: i2 }) {
          if (i2 <= 1) throw new TypeError("numStreams must be greater than 1");
          let r, s, a;
          if (!(e2.ssrcs || []).find((e3) => {
            if ("msid" !== e3.attribute) return false;
            return e3.value.split(" ")[1] === t2.id && (r = e3.id, a = e3.value.split(" ")[0], true);
          })) throw new Error(`a=ssrc line with msid information not found [track.id:${t2.id}]`);
          (e2.ssrcGroups || []).some((e3) => {
            if ("FID" !== e3.semantics) return false;
            const t3 = e3.ssrcs.split(/\s+/);
            return Number(t3[0]) === r && (s = Number(t3[1]), true);
          });
          const o = e2.ssrcs.find((e3) => "cname" === e3.attribute && e3.id === r);
          if (!o) throw new Error(`a=ssrc line with cname information not found [track.id:${t2.id}]`);
          const n = o.value, d = [], c = [];
          for (let e3 = 0; e3 < i2; ++e3) d.push(r + e3), s && c.push(s + e3);
          e2.ssrcGroups = e2.ssrcGroups || [], e2.ssrcs = e2.ssrcs || [], e2.ssrcGroups.push({ semantics: "SIM", ssrcs: d.join(" ") });
          for (let i3 = 0; i3 < d.length; ++i3) {
            const r2 = d[i3];
            e2.ssrcs.push({ id: r2, attribute: "cname", value: n }), e2.ssrcs.push({ id: r2, attribute: "msid", value: `${a} ${t2.id}` });
          }
          for (let i3 = 0; i3 < c.length; ++i3) {
            const r2 = d[i3], s2 = c[i3];
            e2.ssrcs.push({ id: s2, attribute: "cname", value: n }), e2.ssrcs.push({ id: s2, attribute: "msid", value: `${a} ${t2.id}` }), e2.ssrcGroups.push({ semantics: "FID", ssrcs: `${r2} ${s2}` });
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Interop = void 0;
        const s = r(i(233)), a = r(i(234)), o = ["audio", "video", "data"], n = (e2) => e2.find((e3) => "SIM" === e3.semantics), d = (e2) => e2.find((e3) => "FID" === e3.semantics);
        function c(e2, t2, i2, r2) {
          if (!e2 || !t2) return;
          const s2 = (e3) => r2.find((t3) => t3.id.toString() === e3);
          t2.ssrcs.forEach((t3) => {
            e2.sources.push(s2(t3));
            const r3 = i2[parseInt(t3, 10)].find((e3) => "FID" === e3.semantics);
            if (r3) {
              const i3 = r3.ssrcs.find((e3) => e3 !== t3);
              e2.sources.push(s2(i3)), e2.ssrcGroups.push(r3);
            }
          }), e2.ssrcGroups.push(t2);
        }
        function l(e2, t2, i2, r2) {
          if (!e2 || !t2) return;
          if (e2.sources = [], e2.ssrcGroups = [], !i2[t2.id]) return e2.sources.push(t2), void (e2.msid = t2.msid);
          const s2 = n(i2[t2.id]), a2 = d(i2[t2.id]);
          if (s2) c(e2, s2, i2, r2);
          else if (a2) {
            const s3 = a2.ssrcs.find((e3) => e3 !== t2), o2 = n(i2[s3]);
            o2 ? c(e2, o2, i2, r2) : (a2.ssrcs.forEach((t3) => {
              e2.sources.push(((e3) => r2.find((t4) => t4.id.toString() === e3))(t3));
            }), e2.ssrcGroups.push(a2));
          }
          e2.msid = e2.sources[0].msid;
        }
        function u(e2, t2, i2) {
          if (!i2.find((t3) => !!t3.sources && t3.sources.some((t4) => t4.id === e2.id))) {
            if (!t2[e2.id]) return false;
            const r2 = n(t2[e2.id]), s2 = d(t2[e2.id]);
            if (r2) return i2.some((e3) => e3.sources && e3.sources.some((e4) => e4.id.toString() === r2.ssrcs[0]));
            if (s2 && e2.id.toString() !== s2.ssrcs[0]) {
              return u({ id: s2.ssrcs[0] }, t2, i2);
            }
            return false;
          }
          return true;
        }
        t.Interop = class {
          toPlanB(e2) {
            if (!e2 || "string" != typeof e2.sdp) return console.warn("An empty description was passed as an argument."), e2;
            const t2 = s.default.parse(e2.sdp);
            if (!t2.media || !t2.media.length) return console.warn("The description has no media."), e2;
            if (t2.media.every((e3) => -1 !== o.indexOf(e3.mid))) return console.warn("The description does not look like unified plan sdp"), e2;
            const i2 = {}, r2 = t2.media;
            t2.media = [], r2.forEach((e3) => {
              const t3 = e3.type;
              if ("application" === t3) return e3.mid = "data", void (i2[e3.mid] = e3);
              if (void 0 === i2[t3]) {
                const r3 = a.default(e3);
                r3.sources && Array.isArray(r3.sources) && r3.sources.forEach((t4) => {
                  e3.msid ? t4.msid = e3.msid : delete t4.msid;
                }), r3.ssrcGroups && e3.msid || (r3.ssrcGroups = []), delete r3.msid, r3.mid = t3, i2[t3] = r3;
              } else if (e3.msid) {
                const r3 = a.default(e3);
                r3.sources && Array.isArray(r3.sources) && (r3.sources.forEach((t4) => {
                  t4.msid = e3.msid;
                }), i2[t3].sources = (i2[t3].sources || []).concat(r3.sources)), void 0 !== r3.ssrcGroups && Array.isArray(r3.ssrcGroups) && (i2[t3].ssrcGroups = (i2[t3].ssrcGroups || []).concat(r3.ssrcGroups));
              }
            }), t2.media = Object.values(i2);
            const n2 = [];
            Object.values(i2).forEach((e3) => {
              "inactive" !== e3.direction && n2.push(e3.mid);
            }), t2.groups.forEach((e3) => {
              "BUNDLE" === e3.type && (e3.mids = n2.join(" "));
            }), t2.msidSemantic = { semantic: "WMS", token: "*" };
            const d2 = s.default.write(t2);
            return new RTCSessionDescription({ type: e2.type, sdp: d2 });
          }
          toUnifiedPlan(e2, t2 = null) {
            if (!e2 || "string" != typeof e2.sdp) return console.warn("An empty description was passed as an argument."), e2;
            const i2 = s.default.parse(e2.sdp);
            if (!i2.media || !i2.media.length) return console.warn("The description has no media."), e2;
            if (i2.media.length > 3 || i2.media.every((e3) => -1 === o.indexOf(e3.mid))) return console.warn("The description does not look like plan-b"), e2;
            const r2 = t2 ? s.default.parse(t2.sdp) : null, n2 = function(e3, t3) {
              if (!e3 || !t3 || 0 === e3.media.length || 0 === t3.media.length) return false;
              const i3 = e3.media[0], r3 = t3.media[0];
              return i3.iceUfrag !== r3.iceUfrag || i3.icePwd !== r3.icePwd;
            }(i2, r2), d2 = i2.media[0].iceUfrag, c2 = i2.media[0].icePwd, h = i2.media[0].fingerprint, p = {};
            i2.media.forEach((e3) => {
              const t3 = e3.type;
              if ("application" === t3) {
                if (!r2 || !r2.media) {
                  const t4 = a.default(e3);
                  return t4.mid = Object.keys(p).length.toString(), void (p[e3.mid] = t4);
                }
                const i4 = r2.media.findIndex((e4) => e4.type === t3);
                return void (i4 && (r2.media[i4] = e3, r2.media[i4].mid = i4));
              }
              const i3 = function(e4) {
                const t4 = {};
                return e4 && Array.isArray(e4) ? (e4.forEach((e5) => {
                  e5.ssrcs && Array.isArray(e5.ssrcs) && e5.ssrcs.forEach((i4) => {
                    void 0 === t4[i4] && (t4[i4] = []), t4[i4].push(e5);
                  });
                }), t4) : t4;
              }(e3.ssrcGroups);
              if (e3.sources) e3.sources.forEach((t4, s2) => {
                if (!t4.msid) return;
                if (!r2 || !r2.media) {
                  if (u(t4, i3, Object.values(p))) return;
                  const r3 = a.default(e3);
                  return r3.mid = Object.keys(p).length.toString(), r3.direction = s2 || "sendonly" === e3.direction ? "sendonly" : "sendrecv", r3.bundleOnly = void 0, l(r3, t4, i3, e3.sources), void (p[r3.mid] = r3);
                }
                if (u(t4, i3, r2.media)) return;
                const o2 = a.default(e3);
                o2.mid = r2.media.length.toString(), o2.direction = "sendonly", l(o2, t4, i3, e3.sources), r2.media.push(o2);
              });
              else if (!r2) {
                const t4 = a.default(e3);
                t4.mid = Object.keys(p).length.toString(), p[e3.mid] = t4;
              }
            }), i2.media = r2 ? r2.media : Object.values(p);
            const m = [];
            i2.media.forEach((e3) => {
              m.push(e3.mid), n2 && (e3.iceUfrag = d2, e3.icePwd = c2), e3.fingerprint = h;
            }), i2.groups.forEach((e3) => {
              "BUNDLE" === e3.type && (e3.mids = m.join(" "));
            }), i2.msidSemantic = { semantic: "WMS", token: "*" }, i2.origin.sessionVersion++;
            const g = s.default.write(i2);
            return new RTCSessionDescription({ type: e2.type, sdp: g });
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true });
        const s = r(i(50));
        t.default = { write: function(e2, t2) {
          return void 0 !== e2 && void 0 !== e2.media && Array.isArray(e2.media) && e2.media.forEach((e3) => {
            e3.sources && e3.sources.length && (e3.ssrcs = [], e3.sources.forEach((t3) => {
              Object.keys(t3).forEach((i2) => {
                "id" !== i2 && e3.ssrcs.push({ id: t3.id, attribute: i2, value: t3[i2] });
              });
            }), delete e3.sources), e3.ssrcGroups && e3.ssrcGroups.length && e3.ssrcGroups.forEach((e4) => {
              void 0 !== e4.ssrcs && Array.isArray(e4.ssrcs) && (e4.ssrcs = e4.ssrcs.join(" "));
            });
          }), s.default.write(e2, t2);
        }, parse: function(e2) {
          const t2 = s.default.parse(e2);
          return void 0 !== t2 && void 0 !== t2.media && Array.isArray(t2.media) && t2.media.forEach((e3) => {
            void 0 !== e3.ssrcs && Array.isArray(e3.ssrcs) && (e3.sources = [], e3.ssrcs.forEach((t3) => {
              const i2 = e3.sources.findIndex((e4) => e4.id === t3.id);
              if (i2 > -1) e3.sources[i2][t3.attribute] = t3.value;
              else {
                const i3 = { id: t3.id };
                i3[t3.attribute] = t3.value, e3.sources.push(i3);
              }
            }), delete e3.ssrcs), void 0 !== e3.ssrcGroups && Array.isArray(e3.ssrcGroups) && e3.ssrcGroups.forEach((e4) => {
              "string" == typeof e4.ssrcs && (e4.ssrcs = e4.ssrcs.split(" "));
            });
          }), t2;
        } };
      }, function(e, t, i) {
        (function(e2, i2) {
          var r = "[object Arguments]", s = "[object Function]", a = "[object GeneratorFunction]", o = "[object Map]", n = "[object Set]", d = /\w*$/, c = /^\[object .+?Constructor\]$/, l = /^(?:0|[1-9]\d*)$/, u = {};
          u[r] = u["[object Array]"] = u["[object ArrayBuffer]"] = u["[object DataView]"] = u["[object Boolean]"] = u["[object Date]"] = u["[object Float32Array]"] = u["[object Float64Array]"] = u["[object Int8Array]"] = u["[object Int16Array]"] = u["[object Int32Array]"] = u[o] = u["[object Number]"] = u["[object Object]"] = u["[object RegExp]"] = u[n] = u["[object String]"] = u["[object Symbol]"] = u["[object Uint8Array]"] = u["[object Uint8ClampedArray]"] = u["[object Uint16Array]"] = u["[object Uint32Array]"] = true, u["[object Error]"] = u[s] = u["[object WeakMap]"] = false;
          var h = "object" == typeof e2 && e2 && e2.Object === Object && e2, p = "object" == typeof self && self && self.Object === Object && self, m = h || p || Function("return this")(), g = t && !t.nodeType && t, f = g && "object" == typeof i2 && i2 && !i2.nodeType && i2, v = f && f.exports === g;
          function S(e3, t2) {
            return e3.set(t2[0], t2[1]), e3;
          }
          function y(e3, t2) {
            return e3.add(t2), e3;
          }
          function _(e3, t2, i3, r2) {
            var s2 = -1, a2 = e3 ? e3.length : 0;
            for (r2 && a2 && (i3 = e3[++s2]); ++s2 < a2; ) i3 = t2(i3, e3[s2], s2, e3);
            return i3;
          }
          function R(e3) {
            var t2 = false;
            if (null != e3 && "function" != typeof e3.toString) try {
              t2 = !!(e3 + "");
            } catch (e4) {
            }
            return t2;
          }
          function b(e3) {
            var t2 = -1, i3 = Array(e3.size);
            return e3.forEach(function(e4, r2) {
              i3[++t2] = [r2, e4];
            }), i3;
          }
          function T(e3, t2) {
            return function(i3) {
              return e3(t2(i3));
            };
          }
          function E(e3) {
            var t2 = -1, i3 = Array(e3.size);
            return e3.forEach(function(e4) {
              i3[++t2] = e4;
            }), i3;
          }
          var A, I = Array.prototype, w = Function.prototype, C = Object.prototype, O = m["__core-js_shared__"], k = (A = /[^.]+$/.exec(O && O.keys && O.keys.IE_PROTO || "")) ? "Symbol(src)_1." + A : "", P = w.toString, x = C.hasOwnProperty, M = C.toString, D = RegExp("^" + P.call(x).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), N = v ? m.Buffer : void 0, L = m.Symbol, F = m.Uint8Array, V = T(Object.getPrototypeOf, Object), H = Object.create, j = C.propertyIsEnumerable, U = I.splice, B = Object.getOwnPropertySymbols, $ = N ? N.isBuffer : void 0, W = T(Object.keys, Object), G = fe(m, "DataView"), J = fe(m, "Map"), q = fe(m, "Promise"), z = fe(m, "Set"), Y = fe(m, "WeakMap"), K = fe(Object, "create"), Q = Re(G), X = Re(J), Z = Re(q), ee = Re(z), te = Re(Y), ie = L ? L.prototype : void 0, re = ie ? ie.valueOf : void 0;
          function se(e3) {
            var t2 = -1, i3 = e3 ? e3.length : 0;
            for (this.clear(); ++t2 < i3; ) {
              var r2 = e3[t2];
              this.set(r2[0], r2[1]);
            }
          }
          function ae(e3) {
            var t2 = -1, i3 = e3 ? e3.length : 0;
            for (this.clear(); ++t2 < i3; ) {
              var r2 = e3[t2];
              this.set(r2[0], r2[1]);
            }
          }
          function oe(e3) {
            var t2 = -1, i3 = e3 ? e3.length : 0;
            for (this.clear(); ++t2 < i3; ) {
              var r2 = e3[t2];
              this.set(r2[0], r2[1]);
            }
          }
          function ne(e3) {
            this.__data__ = new ae(e3);
          }
          function de(e3, t2) {
            var i3 = Te(e3) || function(e4) {
              return function(e5) {
                return /* @__PURE__ */ function(e6) {
                  return !!e6 && "object" == typeof e6;
                }(e5) && Ee(e5);
              }(e4) && x.call(e4, "callee") && (!j.call(e4, "callee") || M.call(e4) == r);
            }(e3) ? function(e4, t3) {
              for (var i4 = -1, r2 = Array(e4); ++i4 < e4; ) r2[i4] = t3(i4);
              return r2;
            }(e3.length, String) : [], s2 = i3.length, a2 = !!s2;
            for (var o2 in e3) !t2 && !x.call(e3, o2) || a2 && ("length" == o2 || ye(o2, s2)) || i3.push(o2);
            return i3;
          }
          function ce(e3, t2, i3) {
            var r2 = e3[t2];
            x.call(e3, t2) && be(r2, i3) && (void 0 !== i3 || t2 in e3) || (e3[t2] = i3);
          }
          function le(e3, t2) {
            for (var i3 = e3.length; i3--; ) if (be(e3[i3][0], t2)) return i3;
            return -1;
          }
          function ue(e3, t2, i3, c2, l2, h2, p2) {
            var m2;
            if (c2 && (m2 = h2 ? c2(e3, l2, h2, p2) : c2(e3)), void 0 !== m2) return m2;
            if (!we(e3)) return e3;
            var g2 = Te(e3);
            if (g2) {
              if (m2 = function(e4) {
                var t3 = e4.length, i4 = e4.constructor(t3);
                t3 && "string" == typeof e4[0] && x.call(e4, "index") && (i4.index = e4.index, i4.input = e4.input);
                return i4;
              }(e3), !t2) return function(e4, t3) {
                var i4 = -1, r2 = e4.length;
                t3 || (t3 = Array(r2));
                for (; ++i4 < r2; ) t3[i4] = e4[i4];
                return t3;
              }(e3, m2);
            } else {
              var f2 = Se(e3), v2 = f2 == s || f2 == a;
              if (Ae(e3)) return function(e4, t3) {
                if (t3) return e4.slice();
                var i4 = new e4.constructor(e4.length);
                return e4.copy(i4), i4;
              }(e3, t2);
              if ("[object Object]" == f2 || f2 == r || v2 && !h2) {
                if (R(e3)) return h2 ? e3 : {};
                if (m2 = function(e4) {
                  return "function" != typeof e4.constructor || _e(e4) ? {} : (t3 = V(e4), we(t3) ? H(t3) : {});
                  var t3;
                }(v2 ? {} : e3), !t2) return function(e4, t3) {
                  return me(e4, ve(e4), t3);
                }(e3, function(e4, t3) {
                  return e4 && me(t3, Ce(t3), e4);
                }(m2, e3));
              } else {
                if (!u[f2]) return h2 ? e3 : {};
                m2 = function(e4, t3, i4, r2) {
                  var s2 = e4.constructor;
                  switch (t3) {
                    case "[object ArrayBuffer]":
                      return pe(e4);
                    case "[object Boolean]":
                    case "[object Date]":
                      return new s2(+e4);
                    case "[object DataView]":
                      return function(e5, t4) {
                        var i5 = t4 ? pe(e5.buffer) : e5.buffer;
                        return new e5.constructor(i5, e5.byteOffset, e5.byteLength);
                      }(e4, r2);
                    case "[object Float32Array]":
                    case "[object Float64Array]":
                    case "[object Int8Array]":
                    case "[object Int16Array]":
                    case "[object Int32Array]":
                    case "[object Uint8Array]":
                    case "[object Uint8ClampedArray]":
                    case "[object Uint16Array]":
                    case "[object Uint32Array]":
                      return function(e5, t4) {
                        var i5 = t4 ? pe(e5.buffer) : e5.buffer;
                        return new e5.constructor(i5, e5.byteOffset, e5.length);
                      }(e4, r2);
                    case o:
                      return function(e5, t4, i5) {
                        return _(t4 ? i5(b(e5), true) : b(e5), S, new e5.constructor());
                      }(e4, r2, i4);
                    case "[object Number]":
                    case "[object String]":
                      return new s2(e4);
                    case "[object RegExp]":
                      return function(e5) {
                        var t4 = new e5.constructor(e5.source, d.exec(e5));
                        return t4.lastIndex = e5.lastIndex, t4;
                      }(e4);
                    case n:
                      return function(e5, t4, i5) {
                        return _(t4 ? i5(E(e5), true) : E(e5), y, new e5.constructor());
                      }(e4, r2, i4);
                    case "[object Symbol]":
                      return a2 = e4, re ? Object(re.call(a2)) : {};
                  }
                  var a2;
                }(e3, f2, ue, t2);
              }
            }
            p2 || (p2 = new ne());
            var T2 = p2.get(e3);
            if (T2) return T2;
            if (p2.set(e3, m2), !g2) var A2 = i3 ? function(e4) {
              return function(e5, t3, i4) {
                var r2 = t3(e5);
                return Te(e5) ? r2 : function(e6, t4) {
                  for (var i5 = -1, r3 = t4.length, s2 = e6.length; ++i5 < r3; ) e6[s2 + i5] = t4[i5];
                  return e6;
                }(r2, i4(e5));
              }(e4, Ce, ve);
            }(e3) : Ce(e3);
            return function(e4, t3) {
              for (var i4 = -1, r2 = e4 ? e4.length : 0; ++i4 < r2 && false !== t3(e4[i4], i4, e4); ) ;
            }(A2 || e3, function(r2, s2) {
              A2 && (r2 = e3[s2 = r2]), ce(m2, s2, ue(r2, t2, i3, c2, s2, e3, p2));
            }), m2;
          }
          function he(e3) {
            return !(!we(e3) || (t2 = e3, k && k in t2)) && (Ie(e3) || R(e3) ? D : c).test(Re(e3));
            var t2;
          }
          function pe(e3) {
            var t2 = new e3.constructor(e3.byteLength);
            return new F(t2).set(new F(e3)), t2;
          }
          function me(e3, t2, i3, r2) {
            i3 || (i3 = {});
            for (var s2 = -1, a2 = t2.length; ++s2 < a2; ) {
              var o2 = t2[s2], n2 = r2 ? r2(i3[o2], e3[o2], o2, i3, e3) : void 0;
              ce(i3, o2, void 0 === n2 ? e3[o2] : n2);
            }
            return i3;
          }
          function ge(e3, t2) {
            var i3, r2, s2 = e3.__data__;
            return ("string" == (r2 = typeof (i3 = t2)) || "number" == r2 || "symbol" == r2 || "boolean" == r2 ? "__proto__" !== i3 : null === i3) ? s2["string" == typeof t2 ? "string" : "hash"] : s2.map;
          }
          function fe(e3, t2) {
            var i3 = function(e4, t3) {
              return null == e4 ? void 0 : e4[t3];
            }(e3, t2);
            return he(i3) ? i3 : void 0;
          }
          se.prototype.clear = function() {
            this.__data__ = K ? K(null) : {};
          }, se.prototype.delete = function(e3) {
            return this.has(e3) && delete this.__data__[e3];
          }, se.prototype.get = function(e3) {
            var t2 = this.__data__;
            if (K) {
              var i3 = t2[e3];
              return "__lodash_hash_undefined__" === i3 ? void 0 : i3;
            }
            return x.call(t2, e3) ? t2[e3] : void 0;
          }, se.prototype.has = function(e3) {
            var t2 = this.__data__;
            return K ? void 0 !== t2[e3] : x.call(t2, e3);
          }, se.prototype.set = function(e3, t2) {
            return this.__data__[e3] = K && void 0 === t2 ? "__lodash_hash_undefined__" : t2, this;
          }, ae.prototype.clear = function() {
            this.__data__ = [];
          }, ae.prototype.delete = function(e3) {
            var t2 = this.__data__, i3 = le(t2, e3);
            return !(i3 < 0) && (i3 == t2.length - 1 ? t2.pop() : U.call(t2, i3, 1), true);
          }, ae.prototype.get = function(e3) {
            var t2 = this.__data__, i3 = le(t2, e3);
            return i3 < 0 ? void 0 : t2[i3][1];
          }, ae.prototype.has = function(e3) {
            return le(this.__data__, e3) > -1;
          }, ae.prototype.set = function(e3, t2) {
            var i3 = this.__data__, r2 = le(i3, e3);
            return r2 < 0 ? i3.push([e3, t2]) : i3[r2][1] = t2, this;
          }, oe.prototype.clear = function() {
            this.__data__ = { hash: new se(), map: new (J || ae)(), string: new se() };
          }, oe.prototype.delete = function(e3) {
            return ge(this, e3).delete(e3);
          }, oe.prototype.get = function(e3) {
            return ge(this, e3).get(e3);
          }, oe.prototype.has = function(e3) {
            return ge(this, e3).has(e3);
          }, oe.prototype.set = function(e3, t2) {
            return ge(this, e3).set(e3, t2), this;
          }, ne.prototype.clear = function() {
            this.__data__ = new ae();
          }, ne.prototype.delete = function(e3) {
            return this.__data__.delete(e3);
          }, ne.prototype.get = function(e3) {
            return this.__data__.get(e3);
          }, ne.prototype.has = function(e3) {
            return this.__data__.has(e3);
          }, ne.prototype.set = function(e3, t2) {
            var i3 = this.__data__;
            if (i3 instanceof ae) {
              var r2 = i3.__data__;
              if (!J || r2.length < 199) return r2.push([e3, t2]), this;
              i3 = this.__data__ = new oe(r2);
            }
            return i3.set(e3, t2), this;
          };
          var ve = B ? T(B, Object) : function() {
            return [];
          }, Se = function(e3) {
            return M.call(e3);
          };
          function ye(e3, t2) {
            return !!(t2 = null == t2 ? 9007199254740991 : t2) && ("number" == typeof e3 || l.test(e3)) && e3 > -1 && e3 % 1 == 0 && e3 < t2;
          }
          function _e(e3) {
            var t2 = e3 && e3.constructor;
            return e3 === ("function" == typeof t2 && t2.prototype || C);
          }
          function Re(e3) {
            if (null != e3) {
              try {
                return P.call(e3);
              } catch (e4) {
              }
              try {
                return e3 + "";
              } catch (e4) {
              }
            }
            return "";
          }
          function be(e3, t2) {
            return e3 === t2 || e3 != e3 && t2 != t2;
          }
          (G && "[object DataView]" != Se(new G(new ArrayBuffer(1))) || J && Se(new J()) != o || q && "[object Promise]" != Se(q.resolve()) || z && Se(new z()) != n || Y && "[object WeakMap]" != Se(new Y())) && (Se = function(e3) {
            var t2 = M.call(e3), i3 = "[object Object]" == t2 ? e3.constructor : void 0, r2 = i3 ? Re(i3) : void 0;
            if (r2) switch (r2) {
              case Q:
                return "[object DataView]";
              case X:
                return o;
              case Z:
                return "[object Promise]";
              case ee:
                return n;
              case te:
                return "[object WeakMap]";
            }
            return t2;
          });
          var Te = Array.isArray;
          function Ee(e3) {
            return null != e3 && function(e4) {
              return "number" == typeof e4 && e4 > -1 && e4 % 1 == 0 && e4 <= 9007199254740991;
            }(e3.length) && !Ie(e3);
          }
          var Ae = $ || function() {
            return false;
          };
          function Ie(e3) {
            var t2 = we(e3) ? M.call(e3) : "";
            return t2 == s || t2 == a;
          }
          function we(e3) {
            var t2 = typeof e3;
            return !!e3 && ("object" == t2 || "function" == t2);
          }
          function Ce(e3) {
            return Ee(e3) ? de(e3) : function(e4) {
              if (!_e(e4)) return W(e4);
              var t2 = [];
              for (var i3 in Object(e4)) x.call(e4, i3) && "constructor" != i3 && t2.push(i3);
              return t2;
            }(e3);
          }
          i2.exports = function(e3) {
            return ue(e3, true, true);
          };
        }).call(this, i(70), i(235)(e));
      }, function(e, t) {
        e.exports = function(e2) {
          return e2.webpackPolyfill || (e2.deprecate = function() {
          }, e2.paths = [], e2.children || (e2.children = []), Object.defineProperty(e2, "loaded", { enumerable: true, get: function() {
            return e2.l;
          } }), Object.defineProperty(e2, "id", { enumerable: true, get: function() {
            return e2.i;
          } }), e2.webpackPolyfill = 1), e2;
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Firefox60 = void 0;
        const n = a(i(50)), d = o(i(6)), c = o(i(8)), l = i(43), u = i(1), h = i(29), p = a(i(79)), m = a(i(27)), g = i(87), f = a(i(88)), v = i(138), S = a(i(148)), y = i(89), _ = i(139), { generateRandomNumber: R } = i(27), b = "Firefox_", T = { OS: 1024, MIS: 1024 };
        let E = 0;
        class A extends g.HandlerInterface {
          constructor() {
            super(), this._sendingRemoteRtpParametersByKind = {}, this._mapMidTransceiver = /* @__PURE__ */ new Map(), this._sendStream = new MediaStream(), this._transportReady = false, this._appData = {}, this.signalingState = "stable";
          }
          static createFactory() {
            return () => new A();
          }
          get name() {
            return "Firefox60";
          }
          get remoteSdp() {
            return this._remoteSdp;
          }
          close() {
            if (h.Logger.debug(b, "close()"), this._pc) try {
              this._pc.oniceconnectionstatechange = null, this._pc.close();
            } catch (e2) {
            }
          }
          async getNativeRtpCapabilities() {
            h.Logger.debug(b, "getNativeRtpCapabilities()");
            const e2 = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require", sdpSemantics: "unified-plan" });
            try {
              e2.addTransceiver("audio"), e2.addTransceiver("video");
              const t2 = await e2.createOffer();
              t2.sdp.indexOf("a=rtcp-fb:111") && -1 === t2.sdp.indexOf("a=rtcp-fb:111 nack") && (t2.sdp = t2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack"));
              try {
                e2.close();
              } catch (e3) {
              }
              const i2 = n.parse(t2.sdp), r2 = f.extractRtpCapabilities({ sdpObject: i2 });
              return _.addNackSuppportForOpus(r2), r2;
            } catch (t2) {
              try {
                e2.close();
              } catch (e3) {
              }
              throw t2;
            }
          }
          async getNativeSctpCapabilities() {
            return h.Logger.debug(b, "getNativeSctpCapabilities()"), { numStreams: T };
          }
          run({ direction: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: n2, proprietaryConstraints: d2, extendedRtpCapabilities: c2, appData: l2 }) {
            h.Logger.debug(b, "run()", l2), this._appData = l2, this._direction = e2, this._sendingRtpParametersByKind = { audio: p.getSendingRtpParameters("audio", c2), video: p.getSendingRtpParameters("video", c2) }, this._sendingRemoteRtpParametersByKind = { audio: p.getSendingRemoteRtpParameters("audio", c2), video: p.getSendingRemoteRtpParameters("video", c2) }, h.Logger.debug(b, "iceServers: %o", a2);
            const u2 = { iceServers: a2 || [], iceTransportPolicy: o2 || "all", rtcpMuxPolicy: "require", sdpSemantics: "unified-plan" };
            l2.encodedInsertableStreams && (u2.encodedInsertableStreams = true), this._pc = new RTCPeerConnection(u2, d2), this._pc.pcid = E++, this._pc.oniceconnectionstatechange = () => {
              switch (this._pc.iceConnectionState) {
                case "checking":
                  this.emit("@connectionstatechange", "connecting");
                  break;
                case "connected":
                case "completed":
                  this.emit("@connectionstatechange", "connected");
                  break;
                case "failed":
                  this.emit("@connectionstatechange", "failed");
                  break;
                case "disconnected":
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                case "closed":
                  this.emit("@connectionstatechange", "closed");
              }
            }, this._pc.onicecandidate = (e3) => {
            }, this._pc.onicecandidateerror = (e3) => {
              h.Logger.debug("onicecandidateerror: ", e3);
            };
          }
          async updateIceServers(e2) {
            h.Logger.debug(b, "updateIceServers()");
            const t2 = this._pc.getConfiguration();
            t2.iceServers = e2, this._pc.setConfiguration(t2);
          }
          async restartIce(e2) {
            if (h.Logger.debug(b, "restartIce()"), this._remoteSdp.updateIceParameters(e2), this._transportReady) if (this._direction) {
              const e3 = await this._pc.createOffer({ iceRestart: true });
              e3.sdp.indexOf(`a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#`) < 0 && (e3.sdp = e3.sdp.replace(/a=ice-ufrag:([0-9a-zA-Z=+-_\/\\\\]+)/g, `a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#${this._direction}`));
              let t2 = n.parse(e3.sdp);
              t2.media.forEach((e4) => {
                "audio" === e4.type && "send" === this._direction && e4.ext && e4.rtcpFb && (e4.ext = e4.ext.filter((e5) => -1 == e5.uri.indexOf("transport-wide-cc") && -1 == e5.uri.indexOf("abs-send-time")), e4.rtcpFb.push({ payload: 111, type: "nack" }));
              }), e3.sdp = n.write(t2), h.Logger.debug(b, "restartIce() | calling pc.setLocalDescription()"), this.signalingState = "have-local-offer", await this._pc.setLocalDescription(e3);
              const i2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
              h.Logger.debug(b, "restartIce() | calling pc.setRemoteDescription()"), this.signalingState = "stable", await this._pc.setRemoteDescription(i2);
            } else {
              const e3 = { type: "offer", sdp: this._remoteSdp.getSdp() };
              h.Logger.debug(b, "restartIce() | calling pc.setRemoteDescription()"), this.signalingState = "stable", await this._pc.setRemoteDescription(e3);
              const t2 = await this._pc.createAnswer();
              h.Logger.debug(b, "restartIce() | calling pc.setLocalDescription() [answer:%o]", t2), this.signalingState = "have-local-offer", await this._pc.setLocalDescription(t2);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track: e2, trackLow: t2, encodings: i2, codecOptions: r2, codec: s2, appData: a2 }) {
            this._assertSendDirection(), h.Logger.debug(b, `[Produce] send() [kind: ${e2.kind}, track.id: ${e2.id}, appData: ${JSON.stringify(a2)}]`), i2 && i2.length > 1 && (i2.forEach((e3, t3) => {
              e3.rid = "r" + t3;
            }), i2.reverse());
            const o2 = m.clone(this._sendingRtpParametersByKind[e2.kind], {});
            let l2 = {}, u2 = {};
            const p2 = new MediaStream();
            "audio" === a2.mediaType && this._pc.audioSender ? (h.Logger.debug(b, "[Produce] audioSender更新track: ", this._pc.audioSender), this._pc.audioSender.replaceTrack(e2)) : "video" === a2.mediaType && this._pc.videoSender ? (h.Logger.debug(b, "[Produce] videoSender更新track: ", this._pc.videoSender), this._pc.videoSender.replaceTrack(e2), this._pc.videoSenderLow && this._pc.videoSenderLow.track !== t2 && (h.Logger.debug(b, "[Produce] videoSenderLow更新track: ", this._pc.videoSenderLow), this._pc.videoSenderLow.replaceTrack(t2))) : "screenShare" === a2.mediaType && this._pc.screenSender ? (h.Logger.debug(b, "[Produce] screenSender更新track: ", this._pc.screenSender), this._pc.screenSender.replaceTrack(e2), this._pc.screenSenderLow && this._pc.screenSenderLow.track !== t2 && (h.Logger.debug(b, "[Produce] screenSenderLow更新track: ", this._pc.screenSenderLow), this._pc.screenSenderLow.replaceTrack(t2))) : (p2.addTrack(e2), l2 = this._pc.addTransceiver(e2, { direction: "sendonly", streams: [p2] }), t2 && (u2 = this._pc.addTransceiver(t2, { direction: "sendonly", streams: [this._sendStream] })), "audio" !== a2.mediaType || this._pc.audioSender ? "video" !== a2.mediaType || this._pc.videoSender ? "screenShare" !== a2.mediaType || this._pc.screenSender || (this._pc.screenSender = l2.sender, this._pc.screenSenderLow = u2.sender) : (this._pc.videoSender = l2.sender, this._pc.videoSenderLow = u2.sender) : this._pc.audioSender = l2.sender), h.Logger.debug(b, "[Produce] send() | [transceivers:%d]", this._pc.getTransceivers().length);
            let g2 = await this._pc.createOffer();
            g2.sdp.indexOf(`a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#`) < 0 && (g2.sdp = g2.sdp.replace(/a=ice-ufrag:([0-9a-zA-Z=+-_\/\\\\]+)/g, `a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#send`));
            let v2 = n.parse(g2.sdp);
            a2.preferRemb && y.filterTransportCCFromSdp(v2);
            let _2, R2, T2 = void 0;
            const E2 = v2.media.filter((i3) => {
              const r3 = this._mapMidTransceiver.get("" + i3.mid);
              return i3.type === e2.kind && (!(r3 && r3.sender && r3.sender.track) || (r3.sender.track.id === e2.id ? (_2 = i3, false) : !t2 || r3.sender.track.id !== t2.id || (R2 = i3, false)));
            });
            _2 || (_2 = E2.pop()), t2 && !R2 && (R2 = E2.pop()), this._transportReady || (T2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: v2 }));
            let A2 = null == _2 ? void 0 : _2.mid;
            if ("number" == typeof A2 && (A2 = "" + A2), !A2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Firefox.send: localId 未找到" });
            let I = null;
            if (R2 && (I = "" + R2.mid), o2.mid = A2, o2.rtcp.cname = f.getCname({ offerMediaObject: _2 }), i2) if (1 === i2.length) {
              let e3 = S.getRtpEncodings({ offerMediaObject: _2 });
              Object.assign(e3[0], i2[0]), o2.encodings = e3;
            } else o2.encodings = i2.reverse();
            else o2.encodings = [], R2 && (o2.encodings = o2.encodings.concat(S.getRtpEncodings({ offerMediaObject: R2 }))), o2.encodings = o2.encodings.concat(S.getRtpEncodings({ offerMediaObject: _2 }));
            return o2.encodings.length > 1 && ("video/vp8" === o2.codecs[0].mimeType.toLowerCase() || o2.codecs[0].mimeType.toLowerCase()), v2.media.forEach((e3) => {
              "audio" === e3.type && e3.ext && e3.rtcpFb && (e3.ext = e3.ext.filter((e4) => -1 == e4.uri.indexOf("transport-wide-cc") && -1 == e4.uri.indexOf("abs-send-time")), e3.rtcpFb.push({ payload: 111, type: "nack" }));
            }), g2.sdp = n.write(v2), this._mapMidTransceiver.set(A2, l2), I && this._mapMidTransceiver.set(I, u2), { localId: A2, localIdLow: I, rtpParameters: o2, rtpSender: l2.sender, rtpSenderLow: u2.sender || null, dtlsParameters: T2, offer: g2 };
          }
          async fillRemoteRecvSdp({ kind: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, sendingRtpParameters: a2, codecOptions: o2, offer: d2, audioProfile: c2, codec: u2, resetVideoSdp: p2, appData: g2 }) {
            h.Logger.debug(b, "fillRemoteRecvSdp() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(d2), this._remoteSdp || (this._remoteSdp = new v.RemoteSdp({ iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2 }), this._remoteSdp.updateDtlsRole("client"));
            const f2 = m.clone(this._sendingRemoteRtpParametersByKind[e2]);
            g2.preferRemb ? (h.Logger.debug(b, "publish() fillRemoteRecvSdp() |  使用REMB作为带宽估计方式"), y.filterTransportCCFromRtpParameters(f2)) : (h.Logger.debug(b, "publish() fillRemoteRecvSdp() |  使用transport-cc作为带宽估计方式"), y.filterRembFromRtpParameters(f2)), f2.codecs = l.reduceCodecs(f2.codecs, u2);
            let S2 = n.parse(this._pc.localDescription.sdp), _2 = this._remoteSdp.getNextMediaSectionIdx();
            p2 && (a2.mid ? a2.encodings && a2.encodings.length > 1 ? _2.idx = Number(a2.mid) - (a2.encodings.length - 1) : _2.idx = Number(a2.mid) : h.Logger.warn(b, "fillRemoteRecvSdp() | mid 未找到"), _2.reuseMid = true);
            let R2 = S2.media[_2.idx], T2 = null;
            a2.encodings && a2.encodings.length > 1 && (T2 = S2.media[_2.idx + 1]), this._remoteSdp.send({ offerMediaObjectArr: [R2, T2], reuseMid: _2.reuseMid, offerRtpParameters: a2, answerRtpParameters: f2, codecOptions: o2, extmapAllowMixed: true });
            const E2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            if (h.Logger.debug(b, "audioProfile设置为: ", c2), c2) {
              let e3 = null;
              switch (c2) {
                case "speech_low_quality":
                  e3 = "maxplaybackrate=16000;sprop-maxcapturerate=16000;maxaveragebitrate=32000";
                  break;
                case "speech_standard":
                  e3 = "maxplaybackrate=32000;sprop-maxcapturerate=32000;maxaveragebitrate=36000";
                  break;
                case "music_standard":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;";
                  break;
                case "standard_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=56000";
                  break;
                case "high_quality":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=128000";
                  break;
                case "high_quality_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=192000";
              }
              E2.sdp.indexOf("a=fmtp:111") && (E2.sdp = E2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;useinbandfec=1;" + e3)), E2.sdp = E2.sdp.replace(/a=rtcp-fb:111 transport-cc/g, "a=maxptime:60");
            }
            h.Logger.debug(b, "fillRemoteRecvSdp() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(E2);
          }
          async stopSending(e2, t2) {
            this._assertSendDirection(), h.Logger.debug(b, "stopSending() [localId:%s]", e2);
            const i2 = this._mapMidTransceiver.get(e2);
            if (!i2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Firefox.stopSending: RTCRtpTransceiver 未找到" });
            "audio" === t2 ? this._pc.audioSender.replaceTrack(null) : "video" === t2 ? (this._pc.videoSender.replaceTrack(null), this._pc.videoSenderLow && this._pc.videoSenderLow.replaceTrack(null)) : "screenShare" === t2 ? (this._pc.screenSender.replaceTrack(null), this._pc.screenSenderLow && this._pc.screenSenderLow.replaceTrack(null)) : (i2.sender.replaceTrack(null), this._pc.removeTrack(i2.sender), this._remoteSdp.disableMediaSection(i2.mid));
            const r2 = await this._pc.createOffer();
            r2.sdp.indexOf(`a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#`) < 0 && (r2.sdp = r2.sdp.replace(/a=ice-ufrag:([0-9a-zA-Z=+-\/\\\\]+)/g, `a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#send`));
            let s2 = n.parse(r2.sdp);
            s2.media.forEach((e3) => {
              "audio" === e3.type && e3.ext && e3.rtcpFb && (e3.ext = e3.ext.filter((e4) => -1 == e4.uri.indexOf("transport-wide-cc") && -1 == e4.uri.indexOf("abs-send-time")), e3.rtcpFb.push({ payload: 111, type: "nack" }));
            }), r2.sdp = n.write(s2), h.Logger.debug(b, "stopSending() | calling pc.setLocalDescription()");
            try {
              await this._pc.setLocalDescription(r2);
            } catch (e3) {
              h.Logger.debug(b, "setLocalDescription error = %o", e3);
            }
            const a2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            h.Logger.debug(b, "stopSending() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(a2), this._mapMidTransceiver.delete(e2);
          }
          async replaceTrack(e2, t2) {
            this._assertSendDirection(), t2 ? h.Logger.debug(b, "replaceTrack() [localId:%s, track.id:%s]", e2, t2.id) : h.Logger.debug(b, "replaceTrack() [localId:%s, no track]", e2);
            const i2 = this._mapMidTransceiver.get(e2);
            await (null == i2 ? void 0 : i2.sender.replaceTrack(t2));
          }
          async setMaxSpatialLayer(e2, t2) {
            this._assertSendDirection(), h.Logger.debug(b, "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", e2, t2);
            const i2 = this._mapMidTransceiver.get(e2), r2 = null == i2 ? void 0 : i2.sender.getParameters();
            t2 = r2.encodings.length - 1 - t2, r2.encodings.forEach((e3, i3) => {
              e3.active = i3 >= t2;
            }), await (null == i2 ? void 0 : i2.sender.setParameters(r2));
          }
          async setRtpEncodingParameters(e2, t2) {
            this._assertSendDirection(), h.Logger.debug(b, "setRtpEncodingParameters() [localId:%s, params:%o]", e2, t2);
            const i2 = this._mapMidTransceiver.get(e2);
            if (!i2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Firefox.setRtpEncodingParameters: RTCRtpTransceiver 未找到" });
            const r2 = i2.sender.getParameters();
            r2.encodings.forEach((e3, i3) => {
              r2.encodings[i3] = Object.assign(Object.assign({}, e3), t2);
            }), await i2.sender.setParameters(r2);
          }
          async getSenderStats(e2) {
            this._assertSendDirection();
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Firefox.getSenderStats: RTCRtpTransceiver 未找到" });
            return t2.sender.getStats();
          }
          async recoverTransceiver(e2, t2, i2) {
            h.Logger.debug(b, "recoverTransceiver() [kind:%s, remoteUid:%s, mid: %s]", i2, e2, t2);
            const r2 = this._mapMidTransceiver.get(t2);
            r2 ? r2.isUseless = true : h.Logger.debug(b, "recoverTransceiver() transceiver undefined");
          }
          async prepareLocalSdp(e2, t2) {
            h.Logger.debug(b, `[Subscribe] prepareLocalSdp() [kind: ${e2}, remoteUid: ${t2}]`);
            let i2, r2 = -1;
            if (u.getParameters().reuseMid) for (const t3 of this._mapMidTransceiver.keys()) {
              const i3 = this._mapMidTransceiver.get(t3);
              if (!i3) continue;
              const s3 = i3.receiver && i3.receiver.track && i3.receiver.track.kind || e2;
              if (i3.isUseless && s3 === e2) {
                r2 = t3 - 0, i3.isUseless = false;
                break;
              }
            }
            let s2 = null;
            if (-1 === r2) {
              if (h.Logger.debug(b, "[Subscribe] prepareLocalSdp() 添加一个M行"), s2 = this._pc.addTransceiver(e2, { direction: "recvonly" }), s2.remoteUid = t2, i2 = await this._pc.createOffer(), !i2.sdp) throw h.Logger.error(b, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
              i2.sdp.indexOf(`a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#`) < 0 && (i2.sdp = i2.sdp.replace(/a=ice-ufrag:([0-9a-zA-Z=+-_\/\\\\]+)/g, `a=ice-ufrag:${this._appData.cid}#${this._appData.uid}#recv`), i2.sdp.indexOf("a=rtcp-fb:111") && -1 === i2.sdp.indexOf("a=rtcp-fb:111 nack") && (i2.sdp = i2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack")));
            } else if (this._pc.localDescription) i2 = { type: "offer", sdp: this._pc.localDescription.sdp };
            else {
              if (i2 = await this._pc.createOffer(), !i2.sdp) throw h.Logger.error(b, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
              i2.sdp.indexOf("a=rtcp-fb:111") && -1 === i2.sdp.indexOf("a=rtcp-fb:111 nack") && (i2.sdp = i2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack")), i2.sdp.indexOf("a=fmtp:111") && (i2.sdp = i2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z-]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1"));
              const e3 = n.parse(i2.sdp);
              r2 = e3.media[e3.media.length - 1].mid;
            }
            if (!i2.sdp) throw h.Logger.error(b, "[Subscribe] prepareLocalSdp() offer没有sdp"), new Error("INVALID_OFFER");
            const a2 = n.parse(i2.sdp);
            let o2 = void 0;
            this._transportReady || (o2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: a2 }));
            const d2 = f.extractRtpCapabilities({ sdpObject: a2 });
            return _.addNackSuppportForOpus(d2), -1 === r2 && (r2 = a2.media[a2.media.length - 1].mid, this._mapMidTransceiver.set("" + r2, s2)), { dtlsParameters: o2, rtpCapabilities: d2, offer: i2, mid: r2, iceUfragReg: "" };
          }
          async receive({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2, trackId: s2, kind: a2, rtpParameters: o2, offer: n2, probeSSrc: d2 = -1, remoteUid: c2, extendedRtpCapabilities: l2, appData: p2 }) {
            this._assertRecvDirection(), h.Logger.debug(b, `[Subscribe] receive() [trackId: ${s2}, kind: ${a2}, remoteUid: ${c2}]`), this._remoteSdp || (this._remoteSdp = new v.RemoteSdp({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2 }), this._remoteSdp.updateDtlsRole("client"));
            let m2 = o2 && o2.mid || p2.mid;
            if (h.Logger.debug(b, "[Subscribe] receive() mid: " + m2), o2.mid) this._remoteSdp.receive({ mid: m2, kind: a2, offerRtpParameters: o2, streamId: o2.rtcp.cname, trackId: s2 });
            else {
              const e3 = s2 + "_" + R();
              h.Logger.debug(b, "[Subscribe] receive() 容错流程 trackId: ", e3);
              const t3 = [];
              l2.codecs.forEach((e4) => {
                if (e4.kind === a2) {
                  const i4 = Object.assign({}, e4);
                  i4.parameters = i4.parameters || i4.localParameters, i4.payloadType = i4.payloadType || i4.localPayloadType, t3.push(i4);
                }
              });
              const i3 = { mid: m2, kind: a2, offerRtpParameters: { codecs: t3, encodings: [{ ssrc: 0 }], headerExtensions: [], rtcp: {}, mid: m2 }, streamId: a2, trackId: e3, reuseMediaSection: void 0 };
              this._remoteSdp.receive(i3), this._remoteSdp.disableMediaSection("" + m2);
            }
            const g2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            g2.sdp.indexOf("a=fmtp:111") && (g2.sdp = g2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1")), "all" === u.getParameters().enableSdpRrtr && (n2.sdp = n2.sdp.replace(/a=rtcp-fb:(\d+) rrtr ?\r\n/g, ""), n2.sdp = n2.sdp.replace(/a=rtcp-fb:(\d+) nack ?\r\n/g, "a=rtcp-fb:$1 rrtr\r\na=rtcp-fb:$1 nack\r\n"), g2.sdp = g2.sdp.replace(/a=rtcp-fb:(\d+) rrtr ?\r\n/g, ""), g2.sdp = g2.sdp.replace(/a=rtcp-fb:(\d+) nack ?\r\n/g, "a=rtcp-fb:$1 rrtr\r\na=rtcp-fb:$1 nack\r\n")), u.getParameters().enableUdpCandidate || (g2.sdp = g2.sdp.replace(/\r\na=candidate:udpcandidate[^\r]+/g, "")), u.getParameters().enableTcpCandidate || (g2.sdp = g2.sdp.replace(/\r\na=candidate:tcpcandidate[^\r]+/g, "")), h.Logger.debug(b, "[Subscribe] receive() | calling pc.setLocalDescription()");
            try {
              await this._pc.setLocalDescription(n2);
            } catch (e3) {
              if ("InvalidModificationError" !== e3.name) throw e3;
              await this._pc.createOffer();
              await this._pc.setLocalDescription(n2);
            }
            h.Logger.debug(b, "[Subscribe] receive() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(g2);
            const f2 = this._pc.getTransceivers().find((e3) => e3.mid === m2);
            return f2.isUseless = !o2.mid, this._mapMidTransceiver.set(m2, f2), { localId: m2, track: f2.receiver.track, rtpReceiver: f2.receiver };
          }
          async stopReceiving(e2) {
            this._assertRecvDirection(), h.Logger.debug(b, "stopReceiving() [localId:%s]", e2);
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2 || !t2.mid) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Firefox.stopReceiving: RTCRtpTransceiver 未找到" });
            t2.receiver && t2.receiver.track && t2.receiver.track && "audio" === t2.receiver.track.kind || (t2.isUseless = true), this._remoteSdp.disableMediaSection(t2.mid);
          }
          async getReceiverStats(e2) {
            this._assertRecvDirection();
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Firefox.getReceiverStats: RTCRtpTransceiver 未找到" });
            return t2.receiver.getStats();
          }
          async _setupTransport({ localDtlsRole: e2, localSdpObject: t2 }) {
            t2 || (t2 = n.parse(this._pc.localDescription.sdp));
            const i2 = f.extractDtlsParameters({ sdpObject: t2 });
            return i2.role = e2, this._transportReady = true, i2;
          }
          _assertSendDirection() {
            if ("send" !== this._direction) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "_assertSendDirection: 操作异常" });
          }
          _assertRecvDirection() {
            if ("recv" !== this._direction) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "_assertRecvDirection: 操作异常" });
          }
        }
        t.Firefox60 = A;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Safari12 = void 0;
        const n = a(i(50)), d = o(i(6)), c = o(i(8)), l = i(43), u = i(238), h = i(1), p = i(29), m = a(i(79)), g = a(i(27)), f = i(87), v = a(i(88)), S = i(138), y = a(i(148)), _ = i(89), R = i(139), { generateRandomNumber: b } = i(27), T = "Safari_", E = { OS: 1024, MIS: 1024 };
        let A = 0;
        class I extends f.HandlerInterface {
          constructor() {
            super(), this._sendingRemoteRtpParametersByKind = {}, this._mapMidTransceiver = /* @__PURE__ */ new Map(), this._sendStream = new MediaStream(), this._transportReady = false, this._appData = {};
          }
          static createFactory() {
            return () => new I();
          }
          get name() {
            return "Safari12";
          }
          get remoteSdp() {
            return this._remoteSdp;
          }
          close() {
            if (p.Logger.debug(T, "close()"), this._pc) try {
              this._pc.close();
            } catch (e2) {
            }
          }
          async getNativeRtpCapabilities() {
            p.Logger.debug(T, "getNativeRtpCapabilities()");
            const e2 = new RTCPeerConnection({ iceServers: [], iceTransportPolicy: "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require" });
            try {
              e2.addTransceiver("audio"), e2.addTransceiver("video");
              const t2 = await e2.createOffer();
              t2.sdp.indexOf("a=rtcp-fb:111") && -1 === t2.sdp.indexOf("a=rtcp-fb:111 nack") && (t2.sdp = t2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack"));
              try {
                e2.close();
              } catch (e3) {
              }
              const i2 = n.parse(t2.sdp), r2 = v.extractRtpCapabilities({ sdpObject: i2 });
              return R.addNackSuppportForOpus(r2), r2;
            } catch (t2) {
              try {
                e2.close();
              } catch (e3) {
              }
              throw t2;
            }
          }
          async getNativeSctpCapabilities() {
            return p.Logger.debug(T, "getNativeSctpCapabilities()"), { numStreams: E };
          }
          run({ direction: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, iceServers: a2, iceTransportPolicy: o2, additionalSettings: n2, proprietaryConstraints: d2, extendedRtpCapabilities: c2, appData: l2 }) {
            p.Logger.debug(T, "run()"), this._direction = e2, this._appData = l2, this._sendingRtpParametersByKind = { audio: m.getSendingRtpParameters("audio", c2), video: m.getSendingRtpParameters("video", c2) }, this._sendingRemoteRtpParametersByKind = { audio: m.getSendingRemoteRtpParameters("audio", c2), video: m.getSendingRemoteRtpParameters("video", c2) }, this._pc = new RTCPeerConnection(Object.assign({ iceServers: a2 || [], iceTransportPolicy: o2 || "all", bundlePolicy: "max-bundle", rtcpMuxPolicy: "require" }, n2), d2), this._pc.pcid = A++, this._pc.onconnectionstatechange = () => {
              switch (this._pc.connectionState) {
                case "checking":
                  this.emit("@connectionstatechange", "connecting");
                  break;
                case "connected":
                case "completed":
                  this.emit("@connectionstatechange", "connected");
                  break;
                case "failed":
                  this.emit("@connectionstatechange", "failed");
                  break;
                case "disconnected":
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                case "closed":
                  this.emit("@connectionstatechange", "closed");
              }
            };
          }
          async updateIceServers(e2) {
            p.Logger.debug(T, "updateIceServers()");
            const t2 = this._pc.getConfiguration();
            t2.iceServers = e2, this._pc.setConfiguration(t2);
          }
          async restartIce(e2) {
            if (p.Logger.debug(T, "restartIce()"), this._remoteSdp.updateIceParameters(e2), this._transportReady) if (this._direction) {
              const e3 = await this._pc.createOffer({ iceRestart: true });
              let t2 = n.parse(e3.sdp);
              t2.media.forEach((e4) => {
                "audio" === e4.type && "send" === this._direction && e4.ext && e4.rtcpFb && (e4.ext = e4.ext.filter((e5) => -1 == e5.uri.indexOf("transport-wide-cc") && -1 == e5.uri.indexOf("abs-send-time")), e4.rtcpFb.push({ payload: 111, type: "nack" }));
              }), e3.sdp = n.write(t2), p.Logger.debug(T, "restartIce() | calling pc.setLocalDescription() [offer:%o]", e3), await this._pc.setLocalDescription(e3);
              const i2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
              p.Logger.debug(T, "restartIce() | calling pc.setRemoteDescription() [answer:%o]", i2), await this._pc.setRemoteDescription(i2);
            } else {
              const e3 = { type: "offer", sdp: this._remoteSdp.getSdp() };
              p.Logger.debug(T, "restartIce() | calling pc.setRemoteDescription() [offer:%o]", e3), await this._pc.setRemoteDescription(e3);
              const t2 = await this._pc.createAnswer();
              p.Logger.debug(T, "restartIce() | calling pc.setLocalDescription() [answer:%o]", t2), await this._pc.setLocalDescription(t2);
            }
          }
          async getTransportStats() {
            return this._pc.getStats();
          }
          async send({ track: e2, trackLow: t2, encodings: i2, codecOptions: r2, codec: s2, appData: a2 }) {
            this._assertSendDirection(), p.Logger.debug(T, `send() [kind: ${e2.kind}, track.id: ${e2.id}, appData: ${JSON.stringify(a2)}]`);
            const o2 = g.clone(this._sendingRtpParametersByKind[e2.kind], {});
            let l2 = {}, u2 = {};
            const h2 = new MediaStream();
            "audio" === a2.mediaType && this._pc.audioSender ? (p.Logger.warn(T, "audioSender更新track: ", this._pc.audioSender.track, "=>", e2), this._pc.audioSender.replaceTrack(e2)) : "video" === a2.mediaType && this._pc.videoSender ? (p.Logger.warn(T, "videoSender更新track: ", this._pc.videoSender.track, "=>", e2), this._pc.videoSender.replaceTrack(e2), this._pc.videoSenderLow && this._pc.videoSenderLow.track !== t2 && (p.Logger.debug(T, "videoSenderLow更新track: ", this._pc.videoSenderLow), this._pc.videoSenderLow.replaceTrack(t2))) : "screenShare" === a2.mediaType && this._pc.screenSender ? (p.Logger.warn(T, "screenSender更新track: ", this._pc.screenSender.track, "=>", e2), this._pc.screenSender.replaceTrack(e2), this._pc.screenSenderLow && this._pc.screenSenderLow.track !== t2 && (p.Logger.debug(T, "screenSenderLow更新track: ", this._pc.screenSenderLow), this._pc.screenSenderLow.replaceTrack(t2))) : (h2.addTrack(e2), l2 = this._pc.addTransceiver(e2, { direction: "sendonly", streams: [h2] }), t2 && (u2 = this._pc.addTransceiver(t2, { direction: "sendonly", streams: [this._sendStream] })), "audio" !== a2.mediaType || this._pc.audioSender ? "video" !== a2.mediaType || this._pc.videoSender ? "screenShare" !== a2.mediaType || this._pc.screenSender || (this._pc.screenSender = l2.sender, this._pc.screenSenderLow = u2.sender) : (this._pc.videoSender = l2.sender, this._pc.videoSenderLow = u2.sender) : this._pc.audioSender = l2.sender), "audio" !== a2.mediaType || this._pc.audioSender ? "video" !== a2.mediaType || this._pc.videoSender ? "screenShare" !== a2.mediaType || this._pc.screenSender || (this._pc.screenSender = l2.sender) : this._pc.videoSender = l2.sender : this._pc.audioSender = l2.sender, p.Logger.debug(T, "send() | [transceivers:%d]", this._pc.getTransceivers().length);
            let m2 = await this._pc.createOffer(), f2 = n.parse(m2.sdp);
            a2.preferRemb && _.filterTransportCCFromSdp(f2);
            let S2, R2, b2 = void 0;
            const E2 = f2.media.filter((i3) => {
              const r3 = this._mapMidTransceiver.get("" + i3.mid);
              return i3.type === e2.kind && (!(r3 && r3.sender && r3.sender.track) || (r3.sender.track.id === e2.id ? (S2 = i3, false) : !t2 || r3.sender.track.id !== t2.id || (R2 = i3, false)));
            });
            S2 || (S2 = E2.pop()), t2 && !R2 && (R2 = E2.pop()), this._transportReady || (b2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: f2 }));
            let A2 = null == S2 ? void 0 : S2.mid;
            if ("number" == typeof A2 && (A2 = "" + A2), !A2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Safari.send: localId 未找到" });
            let I2 = null;
            if (R2 && (I2 = "" + R2.mid), o2.mid = A2, p.Logger.debug(T, "要检查M行: ", S2), o2.rtcp.cname = v.getCname({ offerMediaObject: S2 }), i2) if (1 === i2.length) {
              let e3 = y.getRtpEncodings({ offerMediaObject: S2 });
              Object.assign(e3[0], i2[0]), o2.encodings = e3;
            } else o2.encodings = i2;
            else o2.encodings = [], R2 && (o2.encodings = o2.encodings.concat(y.getRtpEncodings({ offerMediaObject: R2 }))), o2.encodings = o2.encodings.concat(y.getRtpEncodings({ offerMediaObject: S2 }));
            return o2.encodings.length > 1 && ("video/vp8" === o2.codecs[0].mimeType.toLowerCase() || "video/h264" === o2.codecs[0].mimeType.toLowerCase()) && f2.media.forEach((e3) => {
              "audio" === e3.type && e3.ext && e3.rtcpFb && (e3.ext = e3.ext.filter((e4) => -1 == e4.uri.indexOf("transport-wide-cc") && -1 == e4.uri.indexOf("abs-send-time")), e3.rtcpFb.push({ payload: 111, type: "nack" }));
            }), m2.sdp = n.write(f2), this._mapMidTransceiver.set(A2, l2), I2 && this._mapMidTransceiver.set(I2, u2), { localId: A2, localIdLow: I2, rtpParameters: o2, rtpSender: l2.sender, rtpSenderLow: u2.sender || null, dtlsParameters: b2, offer: m2 };
          }
          async fillRemoteRecvSdp({ kind: e2, iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2, sendingRtpParameters: a2, codecOptions: o2, offer: d2, audioProfile: c2, codec: h2, resetVideoSdp: m2, appData: f2 }) {
            let v2 = n.parse(d2.sdp);
            v2.media.forEach((e3) => {
              "audio" === e3.type && e3.ext && e3.rtcpFb && (e3.ext = e3.ext.filter((e4) => -1 == e4.uri.indexOf("transport-wide-cc") && -1 == e4.uri.indexOf("abs-send-time")), e3.rtcpFb.push({ payload: 111, type: "nack" }));
            }), d2.sdp = n.write(v2), p.Logger.debug(T, "fillRemoteRecvSdp() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(d2), this._remoteSdp || (this._remoteSdp = new S.RemoteSdp({ iceParameters: t2, iceCandidates: i2, dtlsParameters: r2, sctpParameters: s2 }), this._remoteSdp.updateDtlsRole("client"));
            const y2 = g.clone(this._sendingRemoteRtpParametersByKind[e2]);
            f2.preferRemb ? (p.Logger.debug(T, "publish() fillRemoteRecvSdp() |  使用REMB作为带宽估计方式"), _.filterTransportCCFromRtpParameters(y2)) : (p.Logger.debug(T, "publish() fillRemoteRecvSdp() |  使用transport-cc作为带宽估计方式"), _.filterRembFromRtpParameters(y2)), y2.codecs = l.reduceCodecs(y2.codecs, h2);
            let R2 = n.parse(this._pc.localDescription.sdp), b2 = this._remoteSdp.getNextMediaSectionIdx();
            m2 && (a2.mid ? a2.encodings && a2.encodings.length > 1 ? b2.idx = Number(a2.mid) - (a2.encodings.length - 1) : b2.idx = Number(a2.mid) : p.Logger.warn(T, "fillRemoteRecvSdp() | mid 未找到"), b2.reuseMid = true);
            let E2 = R2.media[b2.idx], A2 = null;
            a2.encodings && a2.encodings.length > 1 && (A2 = R2.media[b2.idx + 1]), this._remoteSdp.send({ offerMediaObjectArr: [E2, A2], reuseMid: b2.reuseMid, offerRtpParameters: a2, answerRtpParameters: y2, codecOptions: o2, extmapAllowMixed: true });
            const I2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            if (p.Logger.debug(T, "audioProfile设置为: ", c2), c2) {
              let e3 = null;
              switch (c2) {
                case "speech_low_quality":
                  e3 = "maxplaybackrate=16000;sprop-maxcapturerate=16000;maxaveragebitrate=32000";
                  break;
                case "speech_standard":
                  e3 = "maxplaybackrate=32000;sprop-maxcapturerate=32000;maxaveragebitrate=36000";
                  break;
                case "music_standard":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;";
                  break;
                case "standard_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=56000";
                  break;
                case "high_quality":
                  e3 = "maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=128000";
                  break;
                case "high_quality_stereo":
                  e3 = "stereo=1;sprop-stereo=1;maxplaybackrate=48000;sprop-maxcapturerate=48000;maxaveragebitrate=192000";
              }
              I2.sdp.indexOf("a=fmtp:111") && (I2.sdp = I2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;useinbandfec=1;" + e3)), I2.sdp = I2.sdp.replace(/a=rtcp-fb:111 transport-cc/g, "a=maxptime:60");
            }
            u.canShimVideoOrientation(d2, I2) && u.shimVideoOrientation(d2, I2), p.Logger.debug(T, "fillRemoteRecvSdp() | calling pc.setRemoteDescription() [answer:%o]", I2.sdp), await this._pc.setRemoteDescription(I2);
          }
          async stopSending(e2, t2) {
            this._assertSendDirection(), p.Logger.debug(T, "stopSending() [localId:%s]", e2);
            const i2 = this._mapMidTransceiver.get(e2);
            "audio" === t2 ? (this._pc.audioSender.replaceTrack(null), p.Logger.debug(T, "删除发送的audio track: ", this._pc.audioSender)) : "video" === t2 ? (this._pc.videoSenderLow && this._pc.videoSenderLow.replaceTrack(null), this._pc.videoSender.replaceTrack(null), p.Logger.debug(T, "删除发送的video track: ", this._pc.videoSender)) : "screenShare" === t2 ? (this._pc.screenSender.replaceTrack(null), this._pc.screenSenderLow && this._pc.screenSenderLow.replaceTrack(null), p.Logger.debug(T, "删除发送的screen track: ", this._pc.screenSender)) : null == i2 || i2.sender.replaceTrack(null);
            const r2 = await this._pc.createOffer();
            let s2 = n.parse(r2.sdp);
            s2.media.forEach((e3) => {
              "audio" === e3.type && e3.ext && e3.rtcpFb && (e3.ext = e3.ext.filter((e4) => -1 == e4.uri.indexOf("transport-wide-cc") && -1 == e4.uri.indexOf("abs-send-time")), e3.rtcpFb.push({ payload: 111, type: "nack" }));
            }), r2.sdp = n.write(s2), p.Logger.debug(T, "stopSending() | calling pc.setLocalDescription() [offer:%o]", r2.sdp), await this._pc.setLocalDescription(r2);
            const a2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            p.Logger.debug(T, "stopSending() | calling pc.setRemoteDescription() [answer:%o]", a2), await this._pc.setRemoteDescription(a2);
          }
          async replaceTrack(e2, t2) {
            this._assertSendDirection(), t2 ? p.Logger.debug(T, "replaceTrack() [localId:%s, track.id:%s]", e2, t2.id) : p.Logger.debug(T, "replaceTrack() [localId:%s, no track]", e2);
            const i2 = this._mapMidTransceiver.get(e2);
            await (null == i2 ? void 0 : i2.sender.replaceTrack(t2));
          }
          async setMaxSpatialLayer(e2, t2) {
            this._assertSendDirection(), p.Logger.debug(T, "setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", e2, t2);
            const i2 = this._mapMidTransceiver.get(e2);
            if (!i2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Safari.setMaxSpatialLayer: RTCRtpTransceiver 未找到" });
            const r2 = i2.sender.getParameters();
            r2.encodings.forEach((e3, i3) => {
              e3.active = i3 <= t2;
            }), await i2.sender.setParameters(r2);
          }
          async setRtpEncodingParameters(e2, t2) {
            this._assertSendDirection(), p.Logger.debug(T, "setRtpEncodingParameters() [localId:%s, params:%o]", e2, t2);
            const i2 = this._mapMidTransceiver.get(e2);
            if (!i2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Safari.setRtpEncodingParameters: RTCRtpTransceiver 未找到" });
            const r2 = i2.sender.getParameters();
            r2.encodings.forEach((e3, i3) => {
              r2.encodings[i3] = Object.assign(Object.assign({}, e3), t2);
            }), await i2.sender.setParameters(r2);
          }
          async getSenderStats(e2) {
            this._assertSendDirection();
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Safari.getSenderStats: RTCRtpTransceiver 未找到" });
            return t2.sender.getStats();
          }
          async recoverTransceiver(e2, t2, i2) {
            p.Logger.debug(T, "recoverTransceiver() [kind:%s, remoteUid:%s, mid: %s]", i2, e2, t2);
            const r2 = this._mapMidTransceiver.get(t2);
            r2 ? r2.isUseless = true : p.Logger.debug(T, "recoverTransceiver() transceiver undefined");
          }
          async prepareLocalSdp(e2, t2) {
            p.Logger.debug(T, `[Subscribe] prepareLocalSdp() [kind: ${e2}, remoteUid: ${t2}]`);
            let i2 = -1;
            if (h.getParameters().reuseMid) for (const t3 of this._mapMidTransceiver.keys()) {
              const r3 = this._mapMidTransceiver.get(t3);
              if (!r3) continue;
              const s3 = r3.receiver && r3.receiver.track && r3.receiver.track.kind || e2;
              if (r3.isUseless && s3 === e2) {
                i2 = t3 - 0, r3.isUseless = false;
                break;
              }
            }
            let r2 = null, s2 = null;
            if (-1 === i2) p.Logger.debug(T, "[Subscribe] prepareLocalSdp() 添加一个M行"), s2 = this._pc.addTransceiver(e2, { direction: "recvonly" }), s2.remoteUid = t2, r2 = await this._pc.createOffer(), r2.sdp.indexOf("a=rtcp-fb:111") && -1 === r2.sdp.indexOf("a=rtcp-fb:111 nack") && (r2.sdp = r2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack"));
            else if (this._pc.localDescription) r2 = { type: this._pc.localDescription.type, sdp: this._pc.localDescription.sdp };
            else if (!this._pc.localDescription) {
              r2 = await this._pc.createOffer(), r2.sdp.indexOf("a=rtcp-fb:111") && -1 === r2.sdp.indexOf("a=rtcp-fb:111 nack") && (r2.sdp = r2.sdp.replace(/(a=rtcp-fb:111.*)/, "$1\r\na=rtcp-fb:111 nack")), r2.sdp.indexOf("a=fmtp:111") && (r2.sdp = r2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z-]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1"));
              const e3 = n.parse(r2.sdp);
              i2 = e3.media[e3.media.length - 1].mid;
            }
            const a2 = n.parse(r2.sdp);
            let o2 = void 0;
            this._transportReady || (o2 = await this._setupTransport({ localDtlsRole: "server", localSdpObject: a2 }));
            const d2 = v.extractRtpCapabilities({ sdpObject: a2 });
            return R.addNackSuppportForOpus(d2), -1 === i2 && (i2 = a2.media[a2.media.length - 1].mid, this._mapMidTransceiver.set("" + i2, s2)), { dtlsParameters: o2, rtpCapabilities: d2, offer: r2, mid: i2, iceUfragReg: "" };
          }
          async receive({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2, trackId: s2, kind: a2, rtpParameters: o2, offer: n2, probeSSrc: l2 = -1, remoteUid: u2, extendedRtpCapabilities: m2, appData: g2 }) {
            this._assertRecvDirection(), p.Logger.debug(T, `[Subscribe] receive() [trackId: ${s2}, kind: ${a2}, remoteUid: ${u2}]`), this._remoteSdp || (this._remoteSdp = new S.RemoteSdp({ iceParameters: e2, iceCandidates: t2, dtlsParameters: i2, sctpParameters: r2 }), this._remoteSdp.updateDtlsRole("client"));
            let f2 = o2 && o2.mid || g2.mid;
            if (p.Logger.debug(T, "receive() mid: " + f2), o2.mid) this._remoteSdp.receive({ mid: f2, kind: a2, offerRtpParameters: o2, streamId: o2.rtcp.cname, trackId: s2 });
            else {
              const e3 = s2 + "_" + b();
              p.Logger.debug(T, "[Subscribe] receive() 容错流程 trackId: ", e3);
              const t3 = [];
              m2.codecs.forEach((e4) => {
                if (e4.kind === a2) {
                  const i4 = Object.assign({}, e4);
                  i4.parameters = i4.parameters || i4.localParameters, i4.payloadType = i4.payloadType || i4.localPayloadType, t3.push(i4);
                }
              });
              const i3 = { mid: f2, kind: a2, offerRtpParameters: { codecs: t3, encodings: [{ ssrc: 0 }], headerExtensions: [], rtcp: {}, mid: f2 }, streamId: a2, trackId: e3, reuseMediaSection: void 0 };
              this._remoteSdp.receive(i3), this._remoteSdp.disableMediaSection("" + f2);
            }
            let v2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            v2.sdp.indexOf("a=fmtp:111") && (v2.sdp = v2.sdp.replace(/a=fmtp:111 ([0-9=;a-zA-Z]*)/, "a=fmtp:111 minptime=10;stereo=1;sprop-stereo=1;useinbandfec=1")), "all" === h.getParameters().enableSdpRrtr && (n2.sdp = n2.sdp.replace(/a=rtcp-fb:(\d+) rrtr ?\r\n/g, ""), n2.sdp = n2.sdp.replace(/a=rtcp-fb:(\d+) nack ?\r\n/g, "a=rtcp-fb:$1 rrtr\r\na=rtcp-fb:$1 nack\r\n"), v2.sdp = v2.sdp.replace(/a=rtcp-fb:(\d+) rrtr ?\r\n/g, ""), v2.sdp = v2.sdp.replace(/a=rtcp-fb:(\d+) nack ?\r\n/g, "a=rtcp-fb:$1 rrtr\r\na=rtcp-fb:$1 nack\r\n")), h.getParameters().enableUdpCandidate || (v2.sdp = v2.sdp.replace(/\r\na=candidate:udpcandidate[^\r]+/g, "")), h.getParameters().enableTcpCandidate || (v2.sdp = v2.sdp.replace(/\r\na=candidate:tcpcandidate[^\r]+/g, "")), p.Logger.debug(T, "[Subscribe] receive() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(n2), p.Logger.debug(T, "[Subscribe] receive() | calling pc.setRemoteDescription()"), await this._pc.setRemoteDescription(v2);
            const y2 = this._pc.getTransceivers().find((e3) => e3.mid === f2);
            if (!y2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Safari.receive: RTCRtpTransceiver 未找到" });
            return this._mapMidTransceiver.set(f2, y2), { localId: f2, track: y2.receiver.track, rtpReceiver: y2.receiver };
          }
          async stopReceiving(e2) {
            this._assertRecvDirection(), p.Logger.debug(T, "stopReceiving() [localId:%s]", e2);
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2 || !t2.mid) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Safari.stopReceiving: RTCRtpTransceiver 未找到" });
            p.Logger.debug(T, "transceiver: ", t2), t2.receiver && t2.receiver.track && t2.receiver.track && "audio" === t2.receiver.track.kind || (t2.isUseless = true), this._remoteSdp.disableMediaSection(t2.mid);
            const i2 = this._pc.localDescription;
            p.Logger.debug(T, "stopReceiving() | calling pc.setLocalDescription()"), await this._pc.setLocalDescription(i2);
            const r2 = { type: "answer", sdp: this._remoteSdp.getSdp() };
            p.Logger.debug(T, "stopReceiving() | calling pc.setRemoteDescription() [answer:%o]", r2.sdp), await this._pc.setRemoteDescription(r2);
          }
          async getReceiverStats(e2) {
            this._assertRecvDirection();
            const t2 = this._mapMidTransceiver.get(e2);
            if (!t2) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "Safari.getReceiverStats: RTCRtpTransceiver 未找到" });
            return t2.receiver.getStats();
          }
          async _setupTransport({ localDtlsRole: e2, localSdpObject: t2 }) {
            t2 || (t2 = n.parse(this._pc.localDescription.sdp));
            const i2 = v.extractDtlsParameters({ sdpObject: t2 });
            return i2.role = e2, this._transportReady = true, i2;
          }
          _assertSendDirection() {
            if ("send" !== this._direction) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "_assertSendDirection: 操作异常" });
          }
          _assertRecvDirection() {
            if ("recv" !== this._direction) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "_assertRecvDirection: 操作异常" });
          }
        }
        t.Safari12 = I;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.shimVideoOrientation = t.canShimVideoOrientation = void 0;
        const o = i(1), n = a(i(7)), d = i(77), c = "a=extmap:4 ";
        t.canShimVideoOrientation = function(e2, t2) {
          if ("never" === o.getParameters().shimVideoOrientation) return false;
          if ("ios151" === o.getParameters().shimVideoOrientation) {
            if (!n.IS_IOS) return false;
            if (n.IS_SAFARI) {
              if (parseFloat(d.getBrowserInfo().browserVersion) < 15.1) return false;
            } else {
              if (!n.IS_WECHAT) return false;
              if (!navigator.userAgent.match(/OS 15_[1-9]/)) return false;
            }
          }
          if (-1 === t2.sdp.indexOf("H264") || -1 === t2.sdp.indexOf("m=video")) return false;
          const i2 = e2.sdp.match(/\r\n(.*3gpp\:video-orientation.*)\r\n/);
          return !!(i2 && e2.sdp.indexOf(c) > -1 && -1 === t2.sdp.indexOf(i2[1]));
        }, t.shimVideoOrientation = function(e2, t2) {
          if (-1 === t2.sdp.indexOf("H264") || -1 === t2.sdp.indexOf("m=video")) return;
          const i2 = e2.sdp.match(/\r\n(.*3gpp\:video-orientation.*)\r\n/);
          if (i2 && e2.sdp.indexOf(c) > -1 && -1 === t2.sdp.indexOf(i2[1])) {
            const e3 = i2[1];
            console.log(`shimVideoOrientation for ${d.getBrowserInfo().browserName} ${d.getBrowserInfo().browserVersion} ${e3}`), t2.sdp = t2.sdp.split(c).join(e3 + "\r\n" + c);
          } else console.error("Failed to shimVideoOrientation", i2, e2.sdp.indexOf(c), i2 && t2.sdp.indexOf(i2[1]));
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__awaiter || function(e2, t2, i2, r2) {
          return new (i2 || (i2 = Promise))(function(s, a) {
            function o(e3) {
              try {
                d(r2.next(e3));
              } catch (e4) {
                a(e4);
              }
            }
            function n(e3) {
              try {
                d(r2.throw(e3));
              } catch (e4) {
                a(e4);
              }
            }
            function d(e3) {
              var t3;
              e3.done ? s(e3.value) : (t3 = e3.value, t3 instanceof i2 ? t3 : new i2(function(e4) {
                e4(t3);
              })).then(o, n);
            }
            d((r2 = r2.apply(e2, t2 || [])).next());
          });
        };
        Object.defineProperty(t, "__esModule", { value: true });
        t.AwaitQueue = class {
          constructor({ ClosedErrorClass: e2 = Error, StoppedErrorClass: t2 = Error } = { ClosedErrorClass: Error, StoppedErrorClass: Error }) {
            this.closed = false, this.pendingTasks = [], this.ClosedErrorClass = Error, this.StoppedErrorClass = Error, this.ClosedErrorClass = e2, this.StoppedErrorClass = t2;
          }
          get size() {
            return this.pendingTasks.length;
          }
          close() {
            if (!this.closed) {
              this.closed = true;
              for (const e2 of this.pendingTasks) e2.stopped = true, e2.reject(new this.ClosedErrorClass("AwaitQueue closed"));
              this.pendingTasks.length = 0;
            }
          }
          push(e2, t2) {
            return r(this, void 0, void 0, function* () {
              if (this.closed) throw new this.ClosedErrorClass("AwaitQueue closed");
              if ("function" != typeof e2) throw new TypeError("given task is not a function");
              if (!e2.name && t2) try {
                Object.defineProperty(e2, "name", { value: t2 });
              } catch (e3) {
              }
              return new Promise((i2, r2) => {
                const s = { task: e2, name: t2, resolve: i2, reject: r2, stopped: false, enqueuedAt: /* @__PURE__ */ new Date(), executedAt: void 0 };
                this.pendingTasks.push(s), 1 === this.pendingTasks.length && this.next();
              });
            });
          }
          stop() {
            if (!this.closed) {
              for (const e2 of this.pendingTasks) e2.stopped = true, e2.reject(new this.StoppedErrorClass("AwaitQueue stopped"));
              this.pendingTasks.length = 0;
            }
          }
          dump() {
            const e2 = /* @__PURE__ */ new Date();
            return this.pendingTasks.map((t2) => ({ task: t2.task, name: t2.name, enqueuedTime: t2.executedAt ? t2.executedAt.getTime() - t2.enqueuedAt.getTime() : e2.getTime() - t2.enqueuedAt.getTime(), executingTime: t2.executedAt ? e2.getTime() - t2.executedAt.getTime() : 0 }));
          }
          next() {
            return r(this, void 0, void 0, function* () {
              const e2 = this.pendingTasks[0];
              e2 && (yield this.executeTask(e2), this.pendingTasks.shift(), this.next());
            });
          }
          executeTask(e2) {
            return r(this, void 0, void 0, function* () {
              if (!e2.stopped) {
                e2.executedAt = /* @__PURE__ */ new Date();
                try {
                  const t2 = yield e2.task();
                  if (e2.stopped) return;
                  e2.resolve(t2);
                } catch (t2) {
                  if (e2.stopped) return;
                  e2.reject(t2);
                }
              }
            });
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__exportStar || function(e2, t2) {
          for (var i2 in e2) "default" === i2 || Object.prototype.hasOwnProperty.call(t2, i2) || r(t2, e2, i2);
        };
        Object.defineProperty(t, "__esModule", { value: true }), s(i(172), t), s(i(168), t), s(i(78), t), s(i(87), t), s(i(173), t), s(i(241), t), s(i(242), t), s(i(171), t);
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parse = void 0;
        const r = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
        t.parse = function(e2) {
          const t2 = r.exec(e2 || "");
          return t2 ? { spatialLayers: Number(t2[1]), temporalLayers: Number(t2[2]) } : { spatialLayers: 1, temporalLayers: 1 };
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.VideoTrackLow = void 0;
        const r = i(245), s = i(174), a = i(71), o = i(1), n = i(85), d = i(253), c = i(7);
        t.VideoTrackLow = class {
          constructor(e2) {
            var t2;
            this.width = 0, this.height = 0, this.canvas = document.createElement("canvas"), this.context = n.get2DContext(this.canvas), this.timer = null, this.lastDrawAt = 0, this.lastState = "clear", this.high = { sender: null, track: null, stream: new MediaStream(), videoDom: r.getAutoplayVideo(), width: 0, height: 0 }, this.sender = null, this.emptyTrackInfo = { track: null, count: 0, visible: "unknown" }, this.mediaType = e2.mediaType, "video" === this.mediaType ? (this.WIDTH_MAX = o.getParameters().videoLowMaxWidth, this.HEIGHT_MAX = o.getParameters().videoLowMaxHeight, this.FRAME_RATE = o.getParameters().videoLowFramerate) : (this.WIDTH_MAX = o.getParameters().screenLowMaxWidth, this.HEIGHT_MAX = o.getParameters().screenLowMaxHeight, this.FRAME_RATE = o.getParameters().screenLowFramerate), this.stream = this.canvas.captureStream ? this.canvas.captureStream(this.FRAME_RATE) : null, this.track = (null === (t2 = this.stream) || void 0 === t2 ? void 0 : t2.getTracks()[0]) || null, a.watchTrack(this.track), this.logger = e2.logger.getChild(() => {
              let e3 = `low_${this.mediaType} ${this.width}x${this.height}`;
              return this.high.sender ? this.high.sender.track ? "live" !== this.high.sender.track.readyState ? e3 += " HIGH_STATE_" + this.high.sender.track.readyState : (this.high.sender && this.high.sender.track !== this.high.track && (e3 += " MISMATCH"), this.high.sender.track.enabled || (e3 += " muted"), e3 += ` 【${this.high.sender.track.label}】`) : e3 += " NO_HIGH_TRACK" : e3 += " NO_HIGH_SENDER", this.track ? "live" !== this.track.readyState && (e3 += " LOW_STATE_" + this.track.readyState) : e3 += " NO_LOW_TRACK", e3;
            }), this.track ? this.context ? this.timer = s.getRTCTimer().setInterval(() => {
              this.drawOneFrame();
            }, 1e3 / this.FRAME_RATE) : (this.logger.error("CanvasContext无法顺利启动"), this.stream = null, this.track = null) : this.logger.error("当前浏览器不支持CanvasTrack");
          }
          _correctSize() {
            if (this.high.sender && this._bindTrack(this.high.sender.track), this.high.width !== this.high.videoDom.videoWidth || this.high.height !== this.high.videoDom.videoHeight) {
              const e2 = this.high.videoDom.videoWidth / this.high.videoDom.videoHeight;
              let t2 = this.width, i2 = this.height;
              const r2 = e2 > 1 ? this.WIDTH_MAX : this.HEIGHT_MAX, s2 = e2 > 1 ? this.HEIGHT_MAX : this.WIDTH_MAX;
              e2 > r2 / s2 ? (i2 = Math.floor(this.high.videoDom.videoHeight / this.high.videoDom.videoWidth * r2), i2 > 0 ? t2 = r2 : (t2 = 0, i2 = 0)) : (i2 = s2, t2 = Math.floor(this.high.videoDom.videoWidth / this.high.videoDom.videoHeight * s2), t2 > 0 ? i2 = s2 : (t2 = 0, i2 = 0)), this.logger.log(`High resize ${this.high.width}x${this.high.height}=>${this.high.videoDom.videoWidth}x${this.high.videoDom.videoHeight}, low: ${this.width}x${this.height}=>${t2}x${i2}`), this.high.width = this.high.videoDom.videoWidth, this.high.height = this.high.videoDom.videoHeight, this.width = t2, this.height = i2, this.canvas.width = this.width, this.canvas.height = this.height;
            }
          }
          destroy() {
            var e2;
            this.timer && (s.getRTCTimer().clearInterval(this.timer), this.timer = null), null === (e2 = this.track) || void 0 === e2 || e2.stop(), this.stream = null;
          }
          drawOneFrame() {
            var e2, t2, i2, r2;
            if (this.context) if (this._correctSize(), true === (null === (e2 = this.high.track) || void 0 === e2 ? void 0 : e2.enabled) && false === (null === (t2 = this.track) || void 0 === t2 ? void 0 : t2.enabled) && (this.logger.log("恢复小流mute状态"), this.track.enabled = true), this.track) {
              if ("live" !== this.track.readyState) this.logger.error("小流 Track 已停止");
              else if (false === (null === (i2 = this.high.track) || void 0 === i2 ? void 0 : i2.enabled)) {
                if ("frame" === this.lastState || "clear" === this.lastState) {
                  this.logger.log("track处在mute状态");
                  let e3 = "black";
                  this.logger.log(`小流状态变更 ${this.lastState} => ${e3}`), this.lastState = e3, this.context.fillRect(0, 0, this.width, this.height);
                }
              } else if (this.high.videoDom.paused) {
                if ("frame" === this.lastState || "clear" === this.lastState) {
                  let e3 = "paused";
                  this.logger.log(`小流状态变更 ${this.lastState} => ${e3}`), this.lastState = e3, this.high.videoDom.play().catch((e4) => {
                  });
                }
                ("all" === o.getParameters().videoLowCheckCanvasBlank || c.IS_IOS && "ios" === o.getParameters().videoLowCheckCanvasBlank) && this._checkCanvasBlank();
              } else if ("live" === (null === (r2 = this.high.track) || void 0 === r2 ? void 0 : r2.readyState)) {
                if ("frame" !== this.lastState) {
                  let e4 = "frame";
                  this.logger.log(`小流状态变更 ${this.lastState} => ${e4}`), this.lastState = e4;
                }
                const e3 = this.high.track.canvas;
                e3 ? this.context.drawImage(e3, 0, 0, this.width, this.height) : this.context.drawImage(this.high.videoDom, 0, 0, this.width, this.height), this.lastDrawAt = Date.now(), ("all" === o.getParameters().videoLowCheckCanvasBlank || c.IS_IOS && "ios" === o.getParameters().videoLowCheckCanvasBlank) && this._checkCanvasBlank();
              } else if ("frame" === this.lastState) {
                let e3 = "clear";
                this.logger.log(`小流状态变更 ${this.lastState} => ${e3}`), this.lastState = e3, this.context.clearRect(0, 0, this.width, this.height);
              }
            } else this.logger.error("无法获取小流 Track");
          }
          _checkCanvasBlank() {
            var e2, t2;
            if ((null === (e2 = this.high.sender) || void 0 === e2 ? void 0 : e2.track) && (null === (t2 = this.sender) || void 0 === t2 ? void 0 : t2.track) && (this.high.sender.track !== this.emptyTrackInfo.track && (this.emptyTrackInfo = { track: this.high.sender.track, count: 0, visible: "unknown" }), "unknown" === this.emptyTrackInfo.visible)) {
              if (this.high.videoDom.paused || 4 !== this.high.videoDom.readyState) this.emptyTrackInfo.count++;
              else {
                d.isCanvasBlank(this.canvas) ? this.emptyTrackInfo.count++ : (this.emptyTrackInfo.visible = "yes", this.logger.log("_checkCanvasBlank: 小流画面可见", this.emptyTrackInfo.count), this.sender.track !== this.track && (this.logger.warn("小流切换至低分辨率模式"), this.sender.replaceTrack(this.track)));
              }
              this.emptyTrackInfo.count > 30 && (this.emptyTrackInfo.visible = "no", this.sender.track !== this.high.sender.track ? (this.logger.warn("_checkCanvasBlank: 小流两秒内无画面，小流切换至相同分辨率模式"), this.sender.replaceTrack(this.high.sender.track)) : this.logger.warn("_checkCanvasBlank: 小流两秒内无画面，继续使用相同分辨率模式"));
            }
          }
          _bindTrack(e2) {
            var t2;
            this.high.track !== e2 && (this.high.track && this.high.stream.removeTrack(this.high.track), e2 && this.high.stream.addTrack(e2), this.high.track = e2, this.high.videoDom.srcObject = this.high.stream, this.high.videoDom.play().catch((e3) => {
            }), (null === (t2 = this.sender) || void 0 === t2 ? void 0 : t2.track) && ("no" === this.emptyTrackInfo.visible ? (this.logger.warn("小流正在使用相同分辨率模式"), this.sender.replaceTrack(e2)) : this.sender.track !== this.track && (this.logger.warn("小流正在使用低分辨率模式"), this.sender.replaceTrack(this.track))));
          }
          bindSender(e2, t2) {
            this.high.sender = e2, this.sender = t2, e2 ? this._bindTrack(e2.track) : this._bindTrack(null);
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getAutoplayVideo = void 0;
        let r = 0;
        t.getAutoplayVideo = function() {
          const e2 = document.createElement("video");
          return e2.style.position = "absolute", e2.setAttribute("x-webkit-airplay", "x-webkit-airplay"), e2.setAttribute("playsinline", "playsinline"), e2.setAttribute("webkit-playsinline", "webkit-playsinline"), e2.preload = "auto", e2.className = "nertc-video-id-" + r++, e2.autoplay = true, e2.muted = true, e2;
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = "setInterval(() => {\n  self.postMessage('RTCTimer')\n}, 8)\n";
      }, function(e, t, i) {
        "use strict";
        e.exports = '!function(t){var e={};function s(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,s),i.l=!0,i.exports}s.m=t,s.c=e,s.d=function(t,e,n){s.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},s.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},s.t=function(t,e){if(1&e&&(t=s(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)s.d(n,i,function(e){return t[e]}.bind(null,i));return n},s.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return s.d(e,"a",e),e},s.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},s.p="",s(s.s=0)}([function(t,e,s){"use strict";Object.defineProperty(e,"__esModule",{value:!0});const n=self;class i{constructor(t){this.signalProbers={},this.pingInterval=t.pingInterval,this.maxRtt=t.maxRtt,this.wsTimeout=t.wsTimeout,this.reconnectionInterval=t.reconnectionInterval;for(let e in t.signalStates)t.signalStates[e]?this.signalProbers[e]=new r(this,t.signalStates[e]):this.error(`Unrecognized ${e} ${t.signalStates}`);this.timer=setInterval(()=>{this.sync()},1e3)}sync(){const t=Date.now(),e={};for(let s in this.signalProbers){const n=this.signalProbers[s].signalState;-1===n.ping.rtt?n.active=!1:n.ping.recvIndex<n.ping.sendIndex&&(n.ping.rtt=Math.max(n.ping.rtt,t-n.ping.lastSentAt)),e[s]=n}n.postMessage({cmd:"sync",data:e})}log(t){n.postMessage({cmd:"log",data:t})}error(t){n.postMessage({cmd:"error",data:t})}handleDebugMessage(t){var e;if("closeWs"===t.data.type)for(let s in this.signalProbers){const n=this.signalProbers[s];n.signalState.index===t.data.index&&(this.error(`Closing #${t.data.index} ${n.wsUrl}`),null===(e=n.ws)||void 0===e||e.close())}if("doNotSendPing"===t.data.type)for(let e in this.signalProbers){const s=this.signalProbers[e];s.signalState.index===t.data.index&&(s.debug.doNotSendPing=!!t.data.value,s.log("doNotSendPing: "+JSON.stringify(t.data)))}}handleOnlineMessage(t){this.log("收到在线事件，探测服务发起重连");for(let t in this.signalProbers){this.signalProbers[t].init()}}}let a=null;n.postMessage({cmd:"ohayo"}),n.onmessage=t=>{const e=t.data;if("init"===e.cmd){if(a)return void a.error("Already Inited");const t=e.data;a=new i(t)}else if("debug"===e.cmd)null==a||a.handleDebugMessage(e);else{if("onOnline"!==e.cmd)return void(null==a||a.log("Invalid message "+JSON.stringify(e)));null==a||a.handleOnlineMessage(e)}};class r{constructor(t,e){this.debug={doNotSendPing:!1},this.signalProbeWorker=t,this.signalState=e;const s=e.wsUrl.split(/\\/\\?|\\?/);this.wsUrl=`wss://${s[0]}/nertc/private/ping${s[1]?"?"+s[1]:""}`,this.pingTimer=setInterval(this.checkState.bind(this),100),this.ws=null,this.init()}init(){this.ws&&this.ws.close(),this.ws=new WebSocket(this.wsUrl),this.ws.onmessage=this.handleWsMessage.bind(this,this.ws),this.ws.onopen=this.handleWsOpen.bind(this,this.ws),this.ws.onclose=this.checkState.bind(this),this.ws.onerror=this.checkState.bind(this),this.signalState.connect.startCnt++,this.signalState.connect.initAt=Date.now(),this.signalState.connect.connectAt=-1,this.signalState.ping.sendIndex=0,this.signalState.ping.recvIndex=0}getTag(){return`[signalProber #${this.signalState.index} rtt${this.signalState.ping.rtt}ms ${this.signalState.connect.successCnt}_${this.signalState.connect.failCnt}]`}log(t){this.signalProbeWorker.log(`${this.getTag()}${t}`)}error(t){this.signalProbeWorker.error(`${this.getTag()}${t}`)}checkState(){const t=Date.now();if(this.ws)if(this.ws.readyState===WebSocket.OPEN)if(this.signalState.ping.sendIndex===this.signalState.ping.recvIndex){if(t-this.signalState.ping.lastSentAt>this.signalProbeWorker.pingInterval){const e=""+t;this.debug.doNotSendPing||this.ws.send(e),this.signalState.ping.lastSentAt=t,this.signalState.ping.lastSentMsg=e,this.signalState.ping.sendIndex++}}else t-this.signalState.ping.lastSentAt>this.signalProbeWorker.maxRtt&&(this.signalState.active=!1,this.signalState.ping.rtt=-1),t-this.signalState.ping.lastSentAt>this.signalProbeWorker.wsTimeout&&(this.log(`timeout: ${t-this.signalState.ping.lastSentAt}ms. Connect cnt:${this.signalState.connect.startCnt} ${this.wsUrl}`),this.ws.close(),this.ws=null,this.init());else this.ws.readyState===WebSocket.CONNECTING||this.ws.readyState!==WebSocket.CLOSED&&this.ws.readyState!==WebSocket.CLOSING||(-1===this.signalState.connect.connectAt||0===this.signalState.ping.recvIndex?(this.ws=null,this.signalState.connect.failCnt++,this.signalState.connect.failCntFromLastSuccess++,this.signalState.connect.failCnt<=3&&this.log(`[checkState]WebSocket Failed count:${this.signalState.connect.failCntFromLastSuccess}. Next try: ${this.getBackoffTime()}ms`)):this.signalState.active&&(this.log(`[checkState]WebSocket CLOSED. Next try: ${this.getBackoffTime()}ms`),this.signalState.active=!1,this.signalState.ping.rtt=-1,this.ws=null,this.signalProbeWorker.sync()));else t-this.signalState.connect.initAt>this.getBackoffTime()&&this.init()}getBackoffTime(){return this.signalProbeWorker.reconnectionInterval*this.signalState.connect.failCntFromLastSuccess}handleWsOpen(t,e){const s=e.data;if(this.ws===t){const t=Date.now();this.signalState.connect.connectAt=t,this.signalState.connect.failCnt<=3&&this.log(`open ${this.signalState.connect.connectAt-this.signalState.connect.initAt}ms ${this.signalState.wsUrl} => ${this.wsUrl}`),this.checkState()}else this.error("Detached ws open "+JSON.stringify(s))}handleWsMessage(t,e){const s=e.data;if(this.ws!==t)return void this.error("Detached ws message "+JSON.stringify(s));if(this.signalState.ping.lastSentMsg!==s)return void(this.signalState.connect.failCnt<=3&&this.error("Unrecognized message "+JSON.stringify(s)));const n=Date.now();this.signalState.ping.recvIndex++,this.signalState.ping.rtt=n-this.signalState.ping.lastSentAt,1===this.signalState.ping.recvIndex&&(this.signalState.connect.successCnt++,this.signalState.connect.failCntFromLastSuccess=0),this.signalState.ping.rtt>this.signalProbeWorker.maxRtt?(this.signalState.ping.rtt=-1,this.signalState.active=!1):this.signalState.ping.rtt>0&&(this.signalState.active=!0)}}}]);';
      }, function(e, t, i) {
        "use strict";
        e.exports = "const SMOOTHING_FACTOR = 0.8\nconst MINIMUM_VALUE = 0.00001\nregisterProcessor(\n  'vumeter',\n  class extends AudioWorkletProcessor {\n    constructor() {\n      super()\n      this._leftVolume = 0\n      this._rightVolume = 0\n      this._updateIntervalInMS = 25\n      this._nextUpdateFrame = this.intervalInFrames\n      this.port.onmessage = (event) => {\n        if (event.data.updateIntervalInMS) this._updateIntervalInMS = event.data.updateIntervalInMS\n      }\n      //缓存intervalInFrames数量的音频数据\n      this.leftChannelData = new Float32Array(sampleRate)\n      this.rightChannelData = new Float32Array(sampleRate)\n      this.dataIndex = 0\n    }\n\n    get intervalInFrames() {\n      return (this._updateIntervalInMS / 1000) * sampleRate\n    }\n\n    process(inputs, outputs, parameters) {\n      const input = inputs[0]\n\n      // Note that the input will be down-mixed to mono; however, if no inputs are\n      // connected then zero channels will be passed in.\n      if (input.length > 0) {\n        const samplesLeft = input[0]\n        const samplesRight = input[1]\n\n        let sum = 0\n        let rms = 0\n        // Calculated the squared-sum.\n        if (samplesLeft && samplesLeft.length) {\n          for (let i = 0; i < samplesLeft.length; ++i) {\n            sum += samplesLeft[i] * samplesLeft[i]\n          }\n          // Calculate the RMS level and update the volume.\n          rms = Math.sqrt(sum / samplesLeft.length)\n          this._leftVolume = Math.max(rms, this._leftVolume * SMOOTHING_FACTOR)\n          if (this._leftVolume < 1e-10) {\n            this._leftVolume = 0\n          }\n        }\n        if (samplesRight) {\n          sum = 0\n          rms = 0\n          // Calculated the squared-sum.\n          for (let j = 0; j < samplesRight.length; ++j) sum += samplesRight[j] * samplesRight[j]\n\n          // Calculate the RMS level and update the volume.\n          rms = Math.sqrt(sum / samplesRight.length)\n          this._rightVolume = Math.max(rms, this._rightVolume * SMOOTHING_FACTOR)\n          if (this._rightVolume < 1e-10) {\n            this._rightVolume = 0\n          }\n        }\n\n        //拷贝数据\n        try {\n          this.leftChannelData.set(samplesLeft, this.dataIndex)\n          if (samplesRight) {\n            this.rightChannelData.set(samplesRight, this.dataIndex)\n          }\n          this.dataIndex += samplesLeft.length\n        } catch (e) {\n          //正常情况下不会出现这种情况，这里用try catch是为了防止出现异常导致getAudioLevel不准确\n          this.leftChannelData = new Float32Array(sampleRate)\n          this.rightChannelData = new Float32Array(sampleRate)\n          this.dataIndex = 0\n        }\n\n        // Update and sync the volume property with the main thread.\n        this._nextUpdateFrame -= samplesLeft.length\n\n        if (this._nextUpdateFrame <= 0) {\n          this._nextUpdateFrame += this.intervalInFrames\n          let volume = Math.max(this._leftVolume, this._rightVolume)\n          if (!(volume > -1)) {\n            if (this._leftVolume > -1) {\n              volume = this._leftVolume\n            } else if (this._rightVolume > -1) {\n              volume = this._rightVolume\n            }\n          }\n          if (samplesRight) {\n            this.port.postMessage({\n              left: this._leftVolume,\n              right: this._rightVolume,\n              volume: volume,\n              leftData: this.leftChannelData.subarray(0, this.dataIndex),\n              rightData: this.rightChannelData.subarray(0, this.dataIndex),\n              sampleRate: sampleRate\n            })\n          } else {\n            this.port.postMessage({\n              volume: volume,\n              leftData: this.leftChannelData.subarray(0, this.dataIndex),\n              sampleRate: sampleRate\n            })\n          }\n          this.leftChannelData = new Float32Array(sampleRate)\n          this.rightChannelData = new Float32Array(sampleRate)\n          this.dataIndex = 0\n        }\n      }\n\n      return true\n    }\n  }\n)\n";
      }, function(e, t, i) {
        "use strict";
        e.exports = ";(function () {\n  const intervalIds = {}\n  const timeoutIds = {}\n\n  // 监听message 开始执行定时器或者销毁\n  self.onmessage = function onMsgFunc(e) {\n    switch (e.data.command) {\n      case 'interval:start': // 开启定时器\n        const intervalId = setInterval(function () {\n          postMessage({\n            message: 'interval:tick',\n            id: e.data.id\n          })\n        }, e.data.interval)\n\n        postMessage({\n          message: 'interval:started',\n          id: e.data.id\n        })\n\n        intervalIds[e.data.id] = intervalId\n        break\n      case 'interval:clear': // 销毁\n        clearInterval(intervalIds[e.data.id])\n\n        postMessage({\n          message: 'interval:cleared',\n          id: e.data.id\n        })\n\n        delete intervalIds[e.data.id]\n        break\n\n      case 'timeout:start': // 开启定时器\n        const timeoutId = this.setTimeout(function () {\n          postMessage({\n            message: 'timeout:tick',\n            id: e.data.id\n          })\n        }, e.data.timeout)\n\n        postMessage({\n          message: 'timeout:started',\n          id: e.data.id\n        })\n\n        timeoutIds[e.data.id] = timeoutId\n        break\n      case 'timeout:clear': // 销毁\n        clearTimeout(timeoutIds[e.data.id])\n\n        postMessage({\n          message: 'timeout:cleared',\n          id: e.data.id\n        })\n\n        delete timeoutIds[e.data.id]\n        break\n    }\n  }\n})()\n";
      }, function(e, t, i) {
        "use strict";
        e.exports = "/**\n * 模拟一个AI Worklet\n * 其实是个Delay\n */\nregisterProcessor(\n  'audioAIProcessor',\n  class extends AudioWorkletProcessor {\n    constructor() {\n      super()\n      // 尚未接入AI，以延迟1秒为例\n      this.inputSamplesHistory = []\n      this.delayMs = 3000\n    }\n\n    process(inputs, outputs, parameters) {\n      const now = Date.now()\n      const input = inputs[0].map((channel) => {\n        return channel.slice(0)\n      })\n      const output = outputs[0]\n      this.inputSamplesHistory.push({\n        input,\n        ms: now\n      })\n      const firstItem = this.inputSamplesHistory[0]\n      if (firstItem) {\n        if (now - firstItem.ms > this.delayMs) {\n          this.inputSamplesHistory.shift()\n          output.forEach((channel, index) => {\n            for (let i = 0; i < channel.length; i++) {\n              if (firstItem.input[index] && firstItem.input[index][i]) {\n                channel[i] = firstItem.input[index][i]\n              }\n            }\n          })\n        }\n      }\n      return true\n    }\n  }\n)\n";
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.shimCanvas = t.canShimCanvas = void 0;
        const o = i(1), n = i(150), d = a(i(7));
        t.canShimCanvas = function() {
          let e2 = false;
          if ("never" === o.getParameters().shimCanvas) e2 = false;
          else if ("always" === o.getParameters().shimCanvas) e2 = true;
          else if ("ios151" === o.getParameters().shimCanvas) return !!(d.IS_IOS && navigator.userAgent.indexOf(" OS 15_1") > -1);
          return e2;
        }, t.shimCanvas = function(e2) {
          let t2 = new n.RTCCanvas("canvas");
          const i2 = document.createElement("video");
          let r2, s2 = t2._canvas;
          r2 = "getSettings" in MediaStreamTrack.prototype ? e2.getSettings() : e2.getConstraints();
          let a2 = r2.frameRate || 15, o2 = t2._ctx;
          const d2 = new MediaStream([e2]);
          if (i2.srcObject = d2, i2.setAttribute("playsinline", "playsinline"), i2.setAttribute("muted", "muted"), i2.setAttribute("autoplay", "autoplay"), i2.className = "nertc-ios-shim", i2.style.display = "none", i2.onresize = () => {
            i2.videoWidth && i2.videoHeight && t2.setSize(i2.videoWidth, i2.videoHeight);
          }, o2) {
            const t3 = s2.captureStream(a2).getVideoTracks()[0];
            Object.defineProperty(t3, "enabled", { get: () => e2.enabled, set(t4) {
              console.warn("Delegate cameraTrack enabled", t4), e2.enabled = t4;
            } });
            const r3 = setInterval(() => {
              i2.paused ? i2.play() : "ended" === t3.readyState ? ("live" === e2.readyState && (console.warn("canvasTrack已停止，回收videoTrack中"), e2.stop()), clearInterval(r3), document.body.removeChild(i2)) : o2.drawImage(i2, 0, 0);
            }, 1e3 / a2);
            return document.body.appendChild(i2), t3;
          }
          throw new Error("Ctx not supported");
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.syncTrackState = void 0;
        const r = new (i(28)).Logger({ tagGen: () => "syncTrackState" }), s = [];
        setInterval(() => {
          for (let e2 = s.length - 1; e2 >= 0; e2--) {
            const t2 = s[e2];
            if ("ended" === t2.srcTrack.readyState) return "live" === t2.destTrack.readyState && (r.log(`同步MediaStreamTrack关闭状态。【${t2.srcTrack.label}】=>【${t2.destTrack.label}】`), t2.destTrack.stop()), void s.splice(e2, 1);
            if ("bidirectional" === t2.direction && "ended" === t2.destTrack.readyState) return "live" === t2.srcTrack.readyState && (r.warn(`同步MediaStreamTrack关闭状态。【${t2.destTrack.label}】=>【${t2.srcTrack.label}】`), t2.srcTrack.stop()), void s.splice(e2, 1);
            t2.srcTrack.enabled !== t2.enabled && (t2.enabled = t2.srcTrack.enabled, t2.srcTrack.enabled !== t2.destTrack.enabled && (r.warn(`同步MediaStreamTrack enabled:【${t2.srcTrack.label}】`, t2.enabled), t2.destTrack.enabled = t2.srcTrack.enabled)), "bidirectional" === t2.direction && t2.destTrack.enabled !== t2.enabled && (t2.enabled = t2.destTrack.enabled, t2.destTrack.enabled !== t2.srcTrack.enabled && (r.warn(`同步MediaStreamTrack enabled:【${t2.srcTrack.label}】`, t2.enabled), t2.srcTrack.enabled = t2.destTrack.enabled));
          }
        }, 1e3);
        t.syncTrackState = function(e2, t2, i2) {
          s.push({ srcTrack: e2, destTrack: t2, direction: i2, enabled: e2.enabled });
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.isCanvasBlank = void 0;
        let r = null;
        t.isCanvasBlank = function(e2) {
          r || (r = document.createElement("canvas")), r.width = e2.width, r.height = e2.height;
          let t2 = e2.toDataURL() === r.toDataURL();
          return t2 && console.error("result", t2, e2), t2;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.stringify = void 0;
        const r = i(140), s = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;
        let a, o;
        const n = { "\b": "\\b", "	": "\\t", "\n": "\\n", "\f": "\\f", "\r": "\\r", '"': '\\"', "\\": "\\\\" };
        let d;
        function c(e2) {
          return s.lastIndex = 0, s.test(e2) ? `"${e2.replace(s, (e3) => {
            const t2 = n[e3];
            return "string" == typeof t2 ? t2 : "\\u" + ("0000" + e3.charCodeAt(0).toString(16)).slice(-4);
          })}"` : `"${e2}"`;
        }
        t.stringify = function(e2, t2, i2) {
          let s2;
          if (a = "", o = "", "number" == typeof i2) for (s2 = 0; s2 < i2; s2 += 1) o += " ";
          else "string" == typeof i2 && (o = i2);
          if (d = t2, t2 && "function" != typeof t2 && !Array.isArray(t2)) throw new Error("JSON.stringify");
          return function e3(t3, i3) {
            let s3, n2, l, u;
            const h = a;
            let p, m = i3[t3];
            const g = null != m && m instanceof r.SimpleBig;
            switch (m && "object" == typeof m && "function" == typeof m.toJSON && (m = m.toJSON(t3)), "function" == typeof d && (m = d.call(i3, t3, m)), typeof m) {
              case "string":
                return c(m);
              case "number":
                return isFinite(m) ? String(m) : "null";
              case "boolean":
              case "bigint":
                return String(m);
              case "object":
                if (g) return m.toString();
                if (!m) return "null";
                if (a += o, p = [], "[object Array]" === Object.prototype.toString.apply(m)) {
                  for (u = m.length, s3 = 0; s3 < u; s3 += 1) p[s3] = e3(s3, m) || "null";
                  return l = 0 === p.length ? "[]" : a ? `[
${a}${p.join(",\n" + a)}
${h}]` : `[${p.join(",")}]`, a = h, l;
                }
                if (Array.isArray(d)) for (u = d.length, s3 = 0; s3 < u; s3 += 1) "string" == typeof d[s3] && (n2 = d[s3], l = e3(n2, m), l && p.push(c(n2) + (a ? ": " : ":") + l));
                else Object.keys(m).forEach((t4) => {
                  const i4 = e3(t4, m);
                  i4 && p.push(c(t4) + (a ? ": " : ":") + i4);
                });
                return l = 0 === p.length ? "{}" : a ? `{
${a}${p.join(",\n" + a)}
${h}}` : `{${p.join(",")}}`, a = h, l;
              default:
                return "";
            }
          }("", { "": e2 });
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.JSONParse = void 0;
        const r = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/, s = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
        t.JSONParse = function(e2) {
          const t2 = { strict: false, storeAsString: true, alwaysParseAsBig: false, useNativeBigInt: true, protoAction: "error", constructorAction: "error" };
          if (null != e2) {
            if (true === e2.strict && (t2.strict = true), true === e2.storeAsString && (t2.storeAsString = true), t2.alwaysParseAsBig = true === e2.alwaysParseAsBig && e2.alwaysParseAsBig, t2.useNativeBigInt = true === e2.useNativeBigInt && e2.useNativeBigInt, void 0 !== e2.constructorAction) {
              if ("error" !== e2.constructorAction && "ignore" !== e2.constructorAction && "preserve" !== e2.constructorAction) throw new Error('Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ' + e2.constructorAction);
              t2.constructorAction = e2.constructorAction;
            }
            if (void 0 !== e2.protoAction) {
              if ("error" !== e2.protoAction && "ignore" !== e2.protoAction && "preserve" !== e2.protoAction) throw new Error('Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ' + e2.protoAction);
              t2.protoAction = e2.protoAction;
            }
          }
          let i2, a;
          const o = { '"': '"', "\\": "\\", "/": "/", b: "\b", f: "\f", n: "\n", r: "\r", t: "	" };
          let n;
          const d = function(e3) {
            throw { name: "SyntaxError", message: e3, at: i2, text: n };
          }, c = function(e3) {
            return e3 && e3 !== a && d(`Expected '${e3}' instead of '${a}'`), a = n.charAt(i2), i2 += 1, a;
          }, l = function() {
            let e3, i3 = "";
            for ("-" === a && (i3 = "-", c("-")); a >= "0" && a <= "9"; ) i3 += a, c();
            if ("." === a) for (i3 += "."; c() && a >= "0" && a <= "9"; ) i3 += a;
            if ("e" === a || "E" === a) for (i3 += a, c(), "-" !== a && "+" !== a || (i3 += a, c()); a >= "0" && a <= "9"; ) i3 += a, c();
            if (e3 = +i3, isFinite(e3)) return i3.length > 15 ? t2.storeAsString ? i3 : t2.useNativeBigInt ? BigInt(i3) : null : t2.alwaysParseAsBig ? t2.useNativeBigInt ? BigInt(e3) : null : e3;
            d("Bad number");
          };
          function u() {
            let e3, t3, r2, s2 = "";
            if ('"' === a) {
              let d2 = i2;
              for (; c(); ) {
                if ('"' === a) return i2 - 1 > d2 && (s2 += n.substring(d2, i2 - 1)), c(), s2;
                if ("\\" === a) {
                  if (i2 - 1 > d2 && (s2 += n.substring(d2, i2 - 1)), c(), "u" === a) {
                    for (r2 = 0, t3 = 0; t3 < 4 && (e3 = parseInt(c(), 16), isFinite(e3)); t3 += 1) r2 = 16 * r2 + e3;
                    s2 += String.fromCharCode(r2);
                  } else {
                    if ("string" != typeof o[a]) break;
                    s2 += o[a];
                  }
                  d2 = i2;
                }
              }
            }
            d("Bad string");
          }
          const h = function() {
            for (; a && a <= " "; ) c();
          };
          function p() {
            switch (h(), a) {
              case "{":
                return m();
              case "[":
                return function() {
                  const e3 = [];
                  if ("[" === a) {
                    if (c("["), h(), "]" === a) return c("]"), e3;
                    for (; a; ) {
                      if (e3.push(p()), h(), "]" === a) return c("]"), e3;
                      c(","), h();
                    }
                  }
                  d("Bad array");
                }();
              case '"':
                return u();
              case "-":
                return l();
              default:
                return a >= "0" && a <= "9" ? l() : function() {
                  switch (a) {
                    case "t":
                      return c("t"), c("r"), c("u"), c("e"), true;
                    case "f":
                      return c("f"), c("a"), c("l"), c("s"), c("e"), false;
                    case "n":
                      return c("n"), c("u"), c("l"), c("l"), null;
                  }
                  d(`Unexpected '${a}'`);
                }();
            }
          }
          const m = function() {
            let e3;
            const i3 = /* @__PURE__ */ Object.create(null);
            if ("{" === a) {
              if (c("{"), h(), "}" === a) return c("}"), i3;
              for (; a; ) {
                if (e3 = u(), h(), c(":"), true === t2.strict && Object.hasOwnProperty.call(i3, e3) && d(`Duplicate key "${e3}"`), true === r.test(e3) ? "error" === t2.protoAction ? d("Object contains forbidden prototype property") : "ignore" === t2.protoAction ? p() : i3[e3] = p() : true === s.test(e3) ? "error" === t2.constructorAction ? d("Object contains forbidden constructor property") : "ignore" === t2.constructorAction ? p() : i3[e3] = p() : i3[e3] = p(), h(), "}" === a) return c("}"), i3;
                c(","), h();
              }
            }
            d("Bad object");
          };
          return function(e3, t3) {
            let r2;
            return n = "" + e3, i2 = 0, a = " ", r2 = p(), h(), a && d("Syntax error"), "function" == typeof t3 ? function e4(i3, r3) {
              let s2;
              const a2 = i3[r3];
              return a2 && "object" == typeof a2 && Object.keys(a2).forEach((t4) => {
                s2 = e4(a2, t4), void 0 !== s2 ? a2[t4] = s2 : delete a2[t4];
              }), t3.call(i3, r3, a2);
            }({ "": r2 }, "") : r2;
          };
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Meeting = void 0;
        const s = i(3), a = i(26), o = i(146), n = r(i(6)), d = r(i(8)), c = i(81), l = i(140);
        class u extends s.EventEmitter {
          constructor(e2) {
            super(), this.info = { turn: true, relay: false, forward: false, secure: true }, this._reset(), this.adapterRef = e2.adapterRef, this.sdkRef = e2.sdkRef, this.logger = e2.adapterRef.logger.getChild(() => {
              var t2, i2, r2;
              let s2 = "meeting";
              return this.info.secure || (s2 += " INSECURE"), this.info.forward && (s2 += " FORWARD"), this.info.turn || (s2 += " NOTURN"), (null === (r2 = null === (i2 = null === (t2 = e2.adapterRef.instance) || void 0 === t2 ? void 0 : t2._params) || void 0 === i2 ? void 0 : i2.neRtcServerAddresses) || void 0 === r2 ? void 0 : r2.channelServer) && (s2 += " PRIVATE"), s2;
            });
          }
          _reset() {
          }
          async getCloudProxyInfo(e2) {
            const { appkey: t2, channelName: i2, uid: r2, token: s2 = "" } = e2;
            this.adapterRef.logger.log("getCloudProxyInfo() url: ", a.getCloudProxyInfoUrl);
            let u2 = a.getCloudProxyInfoUrl;
            this.adapterRef.instance._params.neRtcServerAddresses.cloudProxyServer && (u2 = this.adapterRef.instance._params.neRtcServerAddresses.cloudProxyServer, this.adapterRef.logger.log("getCloudProxyInfo() 私有化配置cloudProxyServer: ", u2));
            let h = Date.parse(/* @__PURE__ */ new Date()) / 1e3;
            try {
              const e3 = await this.adapterRef.lbsManager.ajax({ url: u2, type: "POST", header: { "Session-Id": this.adapterRef.deviceId || "" }, data: { uid: new l.SimpleBig(r2), appkey: t2, channelName: i2, secureType: s2 ? "1" : "2", osType: "4", version: a.SDK_VERSION + ".0" || false, curtime: "" + h, checksum: o(t2 + "." + r2 + "." + h), proxy: "1", needIPV6: "0" } });
              if (this.adapterRef.logger.log("getCloudProxyInfo() 获取到云代理服务相关信息: ", c.JSONBigStringify(e3, null, " ")), this.adapterRef.instance.apiFrequencyControl({ name: "setCloudProxyInfo", code: 200 === e3.code ? 0 : -1, param: { channelName: i2, uid: r2, appkey: t2, token: s2, reason: e3.code } }), 200 === e3.code) {
                this.adapterRef.channelStatus = "join";
                const { wsProxyArray: t3, mediaProxyArray: i3, mediaProxyToken: s3, cname: a2, curTime: o2 } = e3;
                this.adapterRef.instance._params.neRtcServerAddresses.webSocketProxyServer ? (this.adapterRef.logger.warn("getCloudProxyInfo() webSocketProxyServer: ", this.adapterRef.instance._params.neRtcServerAddresses.webSocketProxyServer), this.adapterRef.proxyServer.wsProxyArray = [this.adapterRef.instance._params.neRtcServerAddresses.webSocketProxyServer]) : this.adapterRef.proxyServer.wsProxyArray = t3, this.adapterRef.instance._params.neRtcServerAddresses.mediaProxyServer ? (this.adapterRef.logger.warn("getCloudProxyInfo() mediaProxyServer:", this.adapterRef.instance._params.neRtcServerAddresses.mediaProxyServer), this.adapterRef.proxyServer.mediaProxyArray = [this.adapterRef.instance._params.neRtcServerAddresses.mediaProxyServer], this.adapterRef.proxyServer.mediaProxyToken = "netease", this.adapterRef.proxyServer.credential = "netease") : (this.adapterRef.proxyServer.mediaProxyArray = i3, this.adapterRef.proxyServer.mediaProxyToken = s3, this.adapterRef.proxyServer.credential = r2 + "/" + o2);
              } else this.adapterRef.logger.log("getCloudProxyInfo() 云代理服务相关信息获取失败, 回滚");
            } catch (t3) {
              throw this.adapterRef.logger.log("getCloudProxyInfo() 网络请求异常:", t3.name, t3.message, t3), this.adapterRef.channelStatus = "leave", this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "DISCONNECTED", this.adapterRef.connectState.reconnect = false, this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), this.adapterRef.instance.apiFrequencyControl({ name: "startProxyServer", code: -1, param: Object.assign(Object.assign({}, e2), { reason: t3.message }) }), new d.default({ code: n.default.NETWORK_REQUEST_ERROR, message: t3.message });
            }
          }
          async joinChannel(e2) {
            try {
              this.adapterRef.proxyServer.enable && await this.getCloudProxyInfo(e2);
            } catch (e3) {
              throw e3;
            }
            const { appkey: t2, channelName: i2, uid: r2, wssArr: s2 = null, sessionMode: u2 = "meeting", joinChannelRecordConfig: h, joinChannelLiveConfig: p, token: m = "", permKey: g = "", getChanneInfoResponse: f } = e2;
            let v = Date.now(), S = +/* @__PURE__ */ new Date(), y = a.getChannelInfoUrl;
            this.adapterRef.instance._params.neRtcServerAddresses.channelServer && (y = this.adapterRef.instance._params.neRtcServerAddresses.channelServer, this.logger.log("join() 私有化配置的 getChannelInfoUrl: ", y)), Object.assign(this.adapterRef.channelInfo, { uid: r2, sessionMode: u2, appkey: t2 });
            try {
              let _ = f;
              _ || (this.adapterRef.state.getChannelInfoRtt = 0, _ = await this.adapterRef.lbsManager.ajax({ url: y, type: "POST", contentType: "application/x-www-form-urlencoded", header: { "Session-Id": this.adapterRef.deviceId || "" }, data: { uid: new l.SimpleBig(r2), appkey: t2, platformType: 16, permKeySecret: g, channelName: i2, secureType: m ? "1" : "2", osType: "4", mode: 2, netType: "0", version: a.SDK_VERSION + ".0" || false, curtime: S, checksum: m || o(t2 + "." + r2 + "." + S), webrtc: 1, nrtcg2: 1, t1: v } }), this.adapterRef.state.getChannelInfoTime = Date.now(), this.adapterRef.state.getChannelInfoRtt || (this.adapterRef.state.getChannelInfoRtt = this.adapterRef.state.getChannelInfoTime - S));
              let R = !("0" == r2 || "0" != r2 && !r2);
              if (this.info.secure = !!m, "string" == typeof _ ? (this.logger.warn("join() 返回值类型为string, 强制类型转换: ", _), _ = c.JSONBigParse(_)) : this.logger.log("join() 获取到房间信息: ", c.JSONBigStringify(_, null, " ")), 200 === _.code) {
                this.adapterRef.channelStatus = "join";
                const { ips: a2, time: o2 } = _;
                a2 && a2.uid || this.logger.warn("join() 加入频道时服务端未返回 uid");
                const n2 = _.config && _.config.quality_level_limit || 16;
                this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now();
                let d2 = a2.webrtcarray && a2.webrtcarray.length && a2.webrtcarray[0];
                if (d2 && this.adapterRef.proxyServer.wsProxyArray) {
                  const e3 = a2.turnaddrs && a2.turnaddrs.length && a2.turnaddrs[0][0];
                  let t3 = e3.split(":").length > 1 ? e3.split(":")[1] : "", i3 = d2.split("/").length > 1 ? d2.split("/")[1] : "";
                  this.adapterRef.instance._params.neRtcServerAddresses.webSocketProxyServer && (t3 = i3.split(":")[1]), i3 && t3 ? this.adapterRef.proxyServer.wsProxyArray = this.adapterRef.proxyServer.wsProxyArray.map((e4) => e4 + "/" + i3.split(":")[0] + ":" + t3) : this.adapterRef.logger.log(`join() 云代理无法获取到代理信息, serverurl: ${i3}, port: ${t3}`);
                }
                Object.assign(this.adapterRef.channelInfo, { cid: +_.cid, permKey: g, token: _.token, turnToken: a2.token, channelName: i2, wssArr: s2 || this.adapterRef.proxyServer.enable && this.adapterRef.proxyServer.wsProxyArray || a2.webrtcarray || [], relayaddrs: this.adapterRef.proxyServer.mediaProxyArray || a2.relayaddrs || null, relaytoken: this.adapterRef.proxyServer.mediaProxyToken || a2.relaytoken || null, wssArrIndex: 0, maxVideoQuality: n2, netDetect: false }, { uid: R ? r2 : a2.uid, sessionMode: u2, appkey: t2 }), e2.uid = e2.uid ? e2.uid : this.adapterRef.channelInfo.uid, this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.token = _.token, this.adapterRef.channelInfo.T4 = Date.now();
                let c2 = this.adapterRef.channelInfo.T4 - o2.t1 - (o2.t3 - o2.t2);
                return this.adapterRef.channelInfo.clientNtpTime = o2.t3 + Math.round(c2 / 2), this.adapterRef.instance.setSessionConfig(Object.assign({ maxVideoQuality: n2 }, p, h)), this.info.relay = a2.relayaddrs && a2.relayaddrs.length > 0, this.info.turn = a2.turnaddrs && a2.turnaddrs.length > 0, this.adapterRef.instance.startSession();
              }
              {
                let e3 = "join() 服务器不允许加入房间, code: " + _.code;
                return _.desc ? e3 = _.desc : 4003 === _.code && (e3 = "房间人数超过最大值。"), this.logger.error(e3), this.adapterRef.channelStatus = "leave", this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "DISCONNECTED", this.adapterRef.connectState.reconnect = false, this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), this.adapterRef.instance.apiEventReport("setLogin", { a_record: h.recordAudio, v_record: h.recordVideo, record_type: h.recordType, host_speaker: h.isHostSpeaker, result: _.code, permKey: this.adapterRef.channelInfo.permKey, serverIp: y, desc: e3 }), Promise.reject(new d.default({ code: n.default.SERVER_AUTH_ERROR, extraCode: _.code, message: e3 }));
              }
            } catch (e3) {
              throw this.logger.log("joing() 获取到房间信息错误:", e3.name, e3.message), this.adapterRef.channelStatus = "leave", this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "DISCONNECTED", this.adapterRef.connectState.reconnect = false, this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), this.adapterRef.instance.apiEventReport("setLogin", { a_record: h.recordAudio, v_record: h.recordVideo, record_type: h.recordType, host_speaker: h.isHostSpeaker, result: -1, desc: `join() 内部错误: ${e3.name}, ${e3.message}`, serverIp: y }), new d.default({ code: e3.getCode && e3.getCode() || n.default.JOIN_FAILED, message: e3.getCode && e3.getMessage() || `join() 内部错误: ${e3.name}, ${e3.message}` });
            }
          }
          leaveChannel() {
            return this.adapterRef._signalling ? this.adapterRef._signalling.doSendLogout().then(() => (this.adapterRef.channelStatus = "leave", this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "DISCONNECTED", this.adapterRef.connectState.reconnect = false, this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), this.adapterRef.instance.stopSession())) : Promise.resolve();
          }
          async addTasks(e2) {
            const { rtmpTasks: t2 = [] } = e2;
            let i2 = a.roomsTaskUrl;
            this.adapterRef.instance._params.neRtcServerAddresses.roomServer && (i2 = this.adapterRef.instance._params.neRtcServerAddresses.roomServer, "/" !== i2.substr(-1) && (i2 += "/"), this.logger.log("addTasks() 私有化配置的 roomsTaskUrl: ", i2)), i2 = `${i2}${this.adapterRef.channelInfo.cid}/tasks`;
            for (let e3 = 0; e3 < t2.length; e3++) {
              t2[e3].hostUid = new l.SimpleBig(this.adapterRef.channelInfo.uid), t2[e3].version = 1, this.logger.log("addTasks() rtmpTask: ", c.JSONBigStringify(t2[e3]));
              const r2 = t2[e3].layout;
              r2.users.forEach((e4) => {
                "string" == typeof e4.uid && (e4.uid = new l.SimpleBig(e4.uid));
              });
              try {
                const s2 = await this.adapterRef.lbsManager.ajax({ url: i2, type: "POST", contentType: "application/json;charset=utf-8", header: { Token: this.adapterRef.channelInfo.turnToken, "Session-Id": this.adapterRef.deviceId || "" }, data: { version: 1, taskId: t2[e3].taskId, streamUrl: t2[e3].streamUrl, record: t2[e3].record, hostUid: t2[e3].hostUid, layout: r2, config: t2[e3].config, extraInfo: t2[e3].extraInfo || "" } });
                if (200 !== s2.code) return this.logger.error(`addTasks() 添加第 ${e3} 个推流任务失败: `, s2), Promise.reject(new d.default({ code: n.default.ADD_TASK_FAILED_ERROR, extraCode: s2.code, message: "addTasks() 添加推流任务失败: " + s2.code }));
                this.logger.log(`addTasks() 添加第 ${e3} 个推流任务完成`);
              } catch (e4) {
                return this.logger.error("addTasks: ", e4.name, e4.message), Promise.reject(new d.default({ code: n.default.ADD_TASK_FAILED_ERROR, message: "addTasks() 内部错误: $e.message}" }));
              }
            }
          }
          async deleteTasks(e2) {
            const { taskIds: t2 = [] } = e2;
            let i2 = a.roomsTaskUrl;
            this.adapterRef.instance._params.neRtcServerAddresses.roomServer && (i2 = this.adapterRef.instance._params.neRtcServerAddresses.roomServer, "/" !== i2.substr(-1) && (i2 += "/"), this.logger.log("deleteTasks() 私有化配置的 roomsTaskUrl: ", i2)), i2 = `${i2}${this.adapterRef.channelInfo.cid}/tasks/delete`;
            for (let e3 = 0; e3 < t2.length; e3++) {
              this.logger.log("deleteTasks() taskId: ", t2[e3]);
              try {
                const r2 = await this.adapterRef.lbsManager.ajax({ url: i2, type: "POST", contentType: "application/json;charset=utf-8", header: { Token: this.adapterRef.channelInfo.turnToken, "Session-Id": this.adapterRef.deviceId || "" }, data: { taskId: t2[e3] } });
                return 200 === r2.code ? (this.logger.log("删除推流任务完成"), Promise.resolve()) : (this.logger.log("删除推流任务请求失败:", c.JSONBigStringify(r2)), Promise.reject(new d.default({ code: n.default.DELETE_TASK_FAILED_ERROR, extraCode: r2.code, message: "deleteTasks() 删除推流任务失败: " + r2.code })));
              } catch (e4) {
                return this.logger.error("deleteTasks发生错误: ", e4.name, e4.message), Promise.reject(new d.default({ code: n.default.DELETE_TASK_FAILED_ERROR, message: "deleteTasks() 内部错误: $e.message}" }));
              }
            }
          }
          async updateTasks(e2) {
            const { rtmpTasks: t2 = [] } = e2;
            let i2 = a.roomsTaskUrl;
            this.adapterRef.instance._params.neRtcServerAddresses.roomServer && (i2 = this.adapterRef.instance._params.neRtcServerAddresses.roomServer, "/" !== i2.substr(-1) && (i2 += "/"), this.logger.log("updateTasks() 私有化配置的 roomsTaskUrl: ", i2)), i2 = `${i2}${this.adapterRef.channelInfo.cid}/task/update`;
            for (let e3 = 0; e3 < t2.length; e3++) {
              const r2 = t2[e3].layout;
              r2.users.forEach((e4) => {
                "string" == typeof e4.uid && (e4.uid = new l.SimpleBig(e4.uid));
              });
              try {
                const s2 = await this.adapterRef.lbsManager.ajax({ url: i2, type: "POST", contentType: "application/json;charset=utf-8", header: { Token: this.adapterRef.channelInfo.turnToken, "Session-Id": this.adapterRef.deviceId || "" }, data: { version: 1, taskId: t2[e3].taskId, streamUrl: t2[e3].streamUrl, record: t2[e3].record, hostUid: new l.SimpleBig(this.adapterRef.channelInfo.uid), layout: r2, config: t2[e3].config } });
                return 200 === s2.code ? (this.logger.log("updateTasks() 更新推流任务完成"), Promise.resolve()) : (this.logger.log("() 更新推流任务失败：", c.JSONBigStringify(s2)), Promise.reject(new d.default({ code: n.default.UPDATE_TASKS_FAILED_ERROR, extraCode: s2.code, message: "updateTasks() 更新推流任务失败: " + s2.code })));
              } catch (e4) {
                return this.logger.error("updateTasks 发生错误: ", e4.name, e4.message), Promise.reject(new d.default({ code: n.default.UPDATE_TASKS_FAILED_ERROR, message: "updateTasks() 内部错误: $e.message}" }));
              }
            }
          }
          destroy() {
            this.logger.log("清除 meeting"), this._reset();
          }
        }
        t.Meeting = u;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.processManager = void 0;
        const r = i(42), s = i(1);
        t.processManager = new class {
          constructor() {
            this.id = /* @__PURE__ */ new Date();
            const e2 = `${r.generateUUID().substr(0, 4)}-${(/* @__PURE__ */ new Date()).toISOString().replace(/[^\d]/g, "")}`;
            if (this.processId = "proc-" + e2, !s.getParameters().reportPageBrowserId) return this.pageId = "", void (this.browserId = "");
            try {
              let t2 = sessionStorage.getItem("NERTC_PAGEID");
              t2 || (t2 = "page-" + e2, sessionStorage.setItem("NERTC_PAGEID", t2)), this.pageId = t2;
            } catch (e3) {
              this.pageId = "";
            }
            try {
              let t2 = sessionStorage.getItem("NERTC_BROWSERID");
              t2 || (t2 = "brow-" + e2, localStorage.setItem("NERTC_BROWSERID", t2)), this.browserId = t2;
            } catch (e3) {
              this.browserId = "";
            }
          }
        }();
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.StatsReport = void 0;
        const s = i(3), a = i(26), o = r(i(259)), n = r(i(260)), d = i(276), c = i(1), l = i(77), u = i(279), h = i(177), p = Date.now();
        class m extends s.EventEmitter {
          constructor(e2) {
            var t2, i2;
            super(), this._reset(), this.heartbeat_ = -1, this.wsTransport_ = null, this.sdkRef = e2.sdkRef, this.adapterRef = e2.adapterRef, this.isReport = e2.isReport, this.appKey = this.adapterRef.instance._params.appkey || this.adapterRef.channelInfo && this.adapterRef.channelInfo.appKey || "", this.reportData = { appkey: this.appKey, cid: (null === (t2 = this.adapterRef) || void 0 === t2 ? void 0 : t2.channelInfo.cid) || 0, uid: "" + (null === (i2 = this.adapterRef) || void 0 === i2 ? void 0 : i2.channelInfo.uid) || "0", browser: l.getBrowserInfo().browserName, platform: l.getOSInfo().osName, timestamp: 0, local: {}, remote: {} }, this.stats = new d.GetStats({ adapterRef: this.adapterRef });
          }
          _reset() {
            this.stats && this.stats.destroy(), this.stats = null, this.stopHeartbeat();
          }
          stop() {
            this.stats && this.stats.stop();
          }
          start() {
            var e2, t2, i2;
            this.reportData.uid = "" + (null === (e2 = this.adapterRef) || void 0 === e2 ? void 0 : e2.channelInfo.uid) || "0", this.reportData.cid = null === (t2 = this.adapterRef) || void 0 === t2 ? void 0 : t2.channelInfo.cid;
            let r2 = null === (i2 = this.adapterRef) || void 0 === i2 ? void 0 : i2.deviceId, s2 = u(`0${p}${a.SDK_VERSION}webwebrtc${r2}40f5a1a1871e46089e1e5139a779dd77`), o2 = `${this.adapterRef.instance._params.neRtcServerAddresses.statisticsWebSocketServer || "wss://statistic.live.126.net/lps-websocket/websocket/collect"}?deviceId=${r2}&isTest=0&sdkVer=${a.SDK_VERSION}&sdktype=webrtc&timestamp=${p}&platform=web&checkSum=${s2}`;
            c.getParameters().disableAllReports || (this.wsTransport_ = new n.default({ url: o2, adapterRef: this.adapterRef }), c.getParameters().reportWS = this.wsTransport_, this.wsTransport_.init(), this.startHeartbeat());
          }
          startHeartbeat() {
            -1 === this.heartbeat_ && (this.adapterRef.logger.log("startHeartbeat..."), this.heartbeat_ = o.default.setInterval(this.doHeartbeat.bind(this), c.getParameters().doHeartbeatInterval));
          }
          stopHeartbeat() {
            -1 !== this.heartbeat_ && (o.default.clearInterval(this.heartbeat_), this.heartbeat_ = -1);
          }
          async doHeartbeat() {
            var e2;
            try {
              let t2 = await (null === (e2 = this.stats) || void 0 === e2 ? void 0 : e2.getAllStats());
              this.isReport && (null == t2 ? void 0 : t2.times) % 2 == 0 && (this.reportData.local = null == t2 ? void 0 : t2.local, this.reportData.remote = null == t2 ? void 0 : t2.remote, this.reportData.timestamp = (/* @__PURE__ */ new Date()).getTime(), this.wsTransport_.sendPB(this.reportData)), (null == t2 ? void 0 : t2.times) % 60 == 0 && this.sendDataReportHeartbeat();
            } catch (e3) {
              this.adapterRef.logger.warn("数据上报出现异常: ", e3.message);
            }
          }
          sendDataReportHeartbeat() {
            var e2;
            let t2 = new h.DataReport({ adapterRef: this.adapterRef });
            t2.setHeartbeat({ name: "setHeartbeat", uid: "" + (null === (e2 = this.adapterRef) || void 0 === e2 ? void 0 : e2.channelInfo.uid) || "0", cid: "" + this.adapterRef.channelInfo.cid }), t2.send();
          }
          destroy() {
            this.adapterRef.logger.log("[statsReport] destroy()"), this.sendDataReportHeartbeat(), this.stop(), this._reset(), this.isReport && this.wsTransport_ && this.wsTransport_.close();
          }
        }
        t.StatsReport = m;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = i(42);
        const s = new class {
          constructor() {
            this.intervalMap_ = /* @__PURE__ */ new Map();
          }
          setInterval(e2, t2, i2 = true) {
            const s2 = r.generateUUID();
            let a = Date.now(), o = a;
            this.intervalMap_.set(s2, { rafId: null, timeoutId: null, onVisibilityChange: null });
            const n = () => {
              if (i2 && document.hidden) {
                e2();
                const i3 = setTimeout(n, t2);
                this.setTimeoutId(s2, i3), a = Date.now(), o = a;
              } else {
                o = Date.now(), o - a >= t2 && (a = o, e2());
                const i3 = requestAnimationFrame(n);
                this.setRafId(s2, i3);
              }
            }, d = requestAnimationFrame(n);
            if (this.setRafId(s2, d), i2) {
              const e3 = () => {
                if (document.hidden) {
                  const e4 = Date.now() - a;
                  if (e4 >= t2) n();
                  else {
                    const i3 = setTimeout(n, t2 - e4);
                    this.setTimeoutId(s2, i3);
                  }
                }
              };
              document.addEventListener("visibilitychange", e3), this.setOnVisibilityChange(s2, e3);
            }
            return s2;
          }
          clearInterval(e2) {
            if (this.intervalMap_.has(e2)) {
              const { rafId: t2, timeoutId: i2, onVisibilityChange: r2 } = this.intervalMap_.get(e2);
              cancelAnimationFrame(t2), clearTimeout(i2), document.removeEventListener("visibilitychange", r2), this.intervalMap_.delete(e2);
            }
          }
          setTimeoutId(e2, t2) {
            if (this.intervalMap_.has(e2)) {
              const i2 = this.intervalMap_.get(e2);
              i2.timeoutId && clearTimeout(i2.timeoutId), i2.timeoutId = t2;
            }
          }
          setRafId(e2, t2) {
            if (this.intervalMap_.has(e2)) {
              const i2 = this.intervalMap_.get(e2);
              i2.rafId && cancelAnimationFrame(i2.rafId), i2.rafId = t2;
            }
          }
          setOnVisibilityChange(e2, t2) {
            if (this.intervalMap_.has(e2)) {
              this.intervalMap_.get(e2).onVisibilityChange = t2;
            }
          }
        }();
        t.default = s;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true });
        const o = i(3), n = a(i(178)), d = i(42), c = i(275), l = i(1);
        let u = new Uint8Array(1);
        u[0] = 10;
        const h = u;
        t.default = class {
          constructor(e2) {
            this.lastLogTime = 0, this.cachedLogs = [], this.textEncoder = new TextEncoder(), this.url_ = e2.url, this.socket_ = null, this.isConnected_ = false, this.isConnecting_ = false, this.pingPongTimeoutId_ = -1, this.pingTimeoutId_ = -1, this.reconnectionTimer_ = -1, this.reconnectionCount_ = 0, this.emitter_ = new o.EventEmitter(), this.adapterRef = e2.adapterRef, this.logger = this.adapterRef.logger.getChild(() => "wsTransport");
          }
          init() {
            if (l.getParameters().disableLBSService) this.logger.log("connect to url: " + this.url_);
            else {
              const e2 = this.adapterRef.lbsManager.getURLSettings(this.url_)[0];
              e2 && e2.url !== this.url_ ? (this.logger.log(`使用线路变更：From【${this.url_} 】to【${e2.url} 】`), this.url_ = e2.url) : this.logger.log(`使用线路： 【${this.url_}】`);
            }
            this.socket_ = new WebSocket(this.url_), this.bindSocket(this.socket_);
          }
          bindSocket(e2) {
            e2.onopen = this.onopen.bind(this), e2.onclose = this.onclose.bind(this), e2.onerror = this.onerror.bind(this), e2.onmessage = this.onmessage.bind(this);
          }
          unbindSocket(e2) {
            e2.onopen = () => {
            }, e2.onclose = () => {
            }, e2.onerror = () => {
            }, e2.onmessage = () => {
            };
          }
          onopen(e2) {
            if (this.isConnected_) return;
            this.isConnected_ = true, this.isConnecting_ = false;
            const t2 = e2.target.url;
            this.logger.log(`websocket[${t2}] is connected`), this.urlSetting && (this.logger.debug(`markFinish success seqId:${this.urlSetting.seqId} source:${this.urlSetting.item.source}  url:${t2}`), delete this.urlSetting), this.startPingPong();
          }
          onclose(e2) {
            const t2 = e2.target.url, i2 = e2.target === this.socket_;
            this.logger.log(`websocket[${t2} InUse: ${i2}] is closed with code: ${e2.code}`), this.socket_ && e2.target === this.socket_ && (this.isConnected_ = false, e2.wasClean && 1e3 === e2.code ? this.close() : (this.logger.warn(`onclose code:${e2.code} reason:${e2.reason}`), this.socket_.onclose = () => {
            }, this.socket_.close(4001), this.socket_ = null, this.reconnect()));
          }
          onerror(e2) {
            const t2 = e2.target.url;
            this.logger.warn(`websocket[${t2}] error observed`), this.urlSetting && (this.logger.debug(`markFinish fail seqId:${this.urlSetting.seqId} source:${this.urlSetting.item.source}  url:${t2}`), delete this.urlSetting), this.isConnected_ ? e2.target === this.socket_ && (this.isConnected_ = false, this.socket_ = null, this.reconnect()) : this.reconnect(), this.isConnecting_ = false, this.isConnected_ = false;
          }
          onmessage(e2) {
            if (this.isConnected_ && e2 && e2.data) {
              11 === JSON.parse(e2.data).action && this.emit(11, e2), this.clearReconnectionTimer();
            }
          }
          isConnected() {
            return this.isConnected_;
          }
          sendPB(e2) {
            var t2;
            if (this.isConnected_) {
              const i2 = this.createPBMessage(e2);
              1 === (null === (t2 = this.socket_) || void 0 === t2 ? void 0 : t2.readyState) && this.socket_.send(i2);
            }
          }
          sendPing(e2) {
            var t2;
            this.isConnected_ && 1 === (null === (t2 = this.socket_) || void 0 === t2 ? void 0 : t2.readyState) && this.socket_.send(e2);
          }
          async sendLog(e2) {
            var t2, i2;
            const r2 = Math.max(this.lastLogTime + 1, Date.now());
            this.lastLogTime = r2;
            try {
              this.cachedLogs.length && this.cachedLogs[this.cachedLogs.length - 1].data[0].replace("[NERTC", "[缓存][NERTC");
            } catch (e3) {
            }
            if (this.cachedLogs.push({ time: r2, data: e2 }), this.cachedLogs.length > 500 && this.cachedLogs.shift(), this.isConnected_ && 1 === (null === (t2 = this.socket_) || void 0 === t2 ? void 0 : t2.readyState) && (null === (i2 = this.adapterRef.channelInfo) || void 0 === i2 ? void 0 : i2.cid)) {
              const e3 = this.cachedLogs;
              this.cachedLogs = [];
              const t3 = 50, i3 = Math.ceil(e3.length / t3);
              for (let r3 = 0; r3 < i3; r3++) {
                const i4 = r3 * t3, s2 = i4 + t3, a2 = e3.slice(i4, s2);
                await this.delay(100), this.sendBatch(a2);
              }
            }
          }
          delay(e2) {
            return new Promise((t2) => setTimeout(t2, e2));
          }
          sendBatch(e2) {
            for (let t2 of e2) {
              const e3 = Object.assign({ uid: this.adapterRef.channelInfo.uid, cid: this.adapterRef.channelInfo.cid }, t2);
              try {
                const t3 = this.textEncoder.encode(JSON.stringify(e3));
                let i2 = [5, 1, 1, 1, 2, 0, 0, 0], r2 = Uint8Array.from(i2.concat(Array.from(t3)));
                this.socket_.send(r2);
              } catch (e4) {
              }
            }
          }
          createPBMessage(e2) {
            let t2 = n.Root.fromJSON(c).lookupType("WebrtcStats"), i2 = t2.create(e2), r2 = t2.encode(i2).finish();
            return Uint8Array.from([4, 1, 1, 1, 3, 0, 0, 0].concat(Array.from(r2)));
          }
          async startPingPong() {
            try {
              if (-1 !== this.pingPongTimeoutId_) return;
              await this.ping(), this.pingPongTimeoutId_ = setTimeout(() => {
                this.pingPongTimeoutId_ = -1, this.startPingPong();
              }, 1e4);
            } catch (e2) {
              this.logger.warn("ping-pong failed, start reconnection"), this.clearSocket(), this.reconnect();
            }
          }
          stopPingPong() {
            this.logger.log("stop ping pong"), clearTimeout(this.pingTimeoutId_), clearTimeout(this.pingPongTimeoutId_), this.pingTimeoutId_ = -1, this.pingPongTimeoutId_ = -1;
          }
          ping() {
            return new Promise((e2, t2) => {
              if (-1 !== this.pingTimeoutId_) return e2();
              this.sendPing(h), this.once(11, () => {
                clearTimeout(this.pingTimeoutId_), this.pingTimeoutId_ = -1, e2();
              }), this.pingTimeoutId_ = setTimeout(() => {
                this.pingTimeoutId_ = -1, t2();
              }, 1e4);
            });
          }
          reconnect() {
            var e2, t2, i2;
            if (this.isConnecting_ || -1 !== this.reconnectionTimer_) return void this.logger.log("websocket is reconnecting");
            if (this.isConnecting_ = true, this.reconnectionCount_++, null === (i2 = null === (t2 = null === (e2 = this.adapterRef.instance) || void 0 === e2 ? void 0 : e2._params) || void 0 === t2 ? void 0 : t2.neRtcServerAddresses) || void 0 === i2 ? void 0 : i2.channelServer) return void this.logger.log("WebSocket不启用备用线路：当前为私有化配置");
            {
              const e3 = this.adapterRef.lbsManager.getURLSettings(this.url_), t3 = e3[this.reconnectionCount_ % e3.length];
              t3.url !== this.url_ && (this.logger.warn(`${t3.seqId} WebSocket切换备用线路 ${this.url_} => ${t3.url}`), this.url_ = t3.url, this.urlSetting = t3);
            }
            this.socket_ = new WebSocket(this.url_), this.bindSocket(this.socket_);
            const r2 = d.getReconnectionTimeout(this.reconnectionCount_);
            this.reconnectionTimer_ = setTimeout(() => {
              this.isConnecting_ = false, this.clearReconnectionTimer(), this.socket_ && this.unbindSocket(this.socket_), this.socket_ = null, this.reconnect();
            }, r2);
          }
          clearReconnectionTimer() {
            -1 !== this.reconnectionTimer_ && (clearTimeout(this.reconnectionTimer_), this.reconnectionTimer_ = -1);
          }
          once(e2, t2, i2) {
            this.emitter_.once(e2, t2, i2);
          }
          emit(e2, t2, i2) {
            this.emitter_.emit(e2, t2, i2);
          }
          clearSocket() {
            this.socket_ && this.unbindSocket(this.socket_), this.isConnected_ = false, this.isConnecting_ = false, this.socket_ = null;
          }
          async close() {
            var e2;
            await this.delay(1e3), this.logger.log("close websocket"), this.clearReconnectionTimer(), this.stopPingPong(), null === (e2 = this.socket_) || void 0 === e2 || e2.close(), this.clearSocket();
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = e.exports = i(262);
        r.build = "light", r.load = function(e2, t2, i2) {
          return "function" == typeof t2 ? (i2 = t2, t2 = new r.Root()) : t2 || (t2 = new r.Root()), t2.load(e2, i2);
        }, r.loadSync = function(e2, t2) {
          return t2 || (t2 = new r.Root()), t2.loadSync(e2);
        }, r.encoder = i(183), r.decoder = i(188), r.verifier = i(189), r.converter = i(190), r.ReflectionObject = i(82), r.Namespace = i(91), r.Root = i(192), r.Enum = i(45), r.Type = i(184), r.Field = i(83), r.OneOf = i(141), r.MapField = i(185), r.Service = i(186), r.Method = i(187), r.Message = i(153), r.wrappers = i(191), r.types = i(92), r.util = i(19), r.ReflectionObject._configure(r.Root), r.Namespace._configure(r.Type, r.Service, r.Enum), r.Root._configure(r.Type), r.Field._configure(r.Type);
      }, function(e, t, i) {
        "use strict";
        var r = t;
        function s() {
          r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
        }
        r.build = "minimal", r.Writer = i(151), r.BufferWriter = i(269), r.Reader = i(152), r.BufferReader = i(270), r.util = i(44), r.rpc = i(181), r.roots = i(182), r.configure = s, s();
      }, function(e, t, i) {
        "use strict";
        var r = t;
        r.length = function(e2) {
          var t2 = e2.length;
          if (!t2) return 0;
          for (var i2 = 0; --t2 % 4 > 1 && "=" === e2.charAt(t2); ) ++i2;
          return Math.ceil(3 * e2.length) / 4 - i2;
        };
        for (var s = new Array(64), a = new Array(123), o = 0; o < 64; ) a[s[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
        r.encode = function(e2, t2, i2) {
          for (var r2, a2 = null, o2 = [], n = 0, d = 0; t2 < i2; ) {
            var c = e2[t2++];
            switch (d) {
              case 0:
                o2[n++] = s[c >> 2], r2 = (3 & c) << 4, d = 1;
                break;
              case 1:
                o2[n++] = s[r2 | c >> 4], r2 = (15 & c) << 2, d = 2;
                break;
              case 2:
                o2[n++] = s[r2 | c >> 6], o2[n++] = s[63 & c], d = 0;
            }
            n > 8191 && ((a2 || (a2 = [])).push(String.fromCharCode.apply(String, o2)), n = 0);
          }
          return d && (o2[n++] = s[r2], o2[n++] = 61, 1 === d && (o2[n++] = 61)), a2 ? (n && a2.push(String.fromCharCode.apply(String, o2.slice(0, n))), a2.join("")) : String.fromCharCode.apply(String, o2.slice(0, n));
        };
        r.decode = function(e2, t2, i2) {
          for (var r2, s2 = i2, o2 = 0, n = 0; n < e2.length; ) {
            var d = e2.charCodeAt(n++);
            if (61 === d && o2 > 1) break;
            if (void 0 === (d = a[d])) throw Error("invalid encoding");
            switch (o2) {
              case 0:
                r2 = d, o2 = 1;
                break;
              case 1:
                t2[i2++] = r2 << 2 | (48 & d) >> 4, r2 = d, o2 = 2;
                break;
              case 2:
                t2[i2++] = (15 & r2) << 4 | (60 & d) >> 2, r2 = d, o2 = 3;
                break;
              case 3:
                t2[i2++] = (3 & r2) << 6 | d, o2 = 0;
            }
          }
          if (1 === o2) throw Error("invalid encoding");
          return i2 - s2;
        }, r.test = function(e2) {
          return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e2);
        };
      }, function(e, t, i) {
        "use strict";
        function r() {
          this._listeners = {};
        }
        e.exports = r, r.prototype.on = function(e2, t2, i2) {
          return (this._listeners[e2] || (this._listeners[e2] = [])).push({ fn: t2, ctx: i2 || this }), this;
        }, r.prototype.off = function(e2, t2) {
          if (void 0 === e2) this._listeners = {};
          else if (void 0 === t2) this._listeners[e2] = [];
          else for (var i2 = this._listeners[e2], r2 = 0; r2 < i2.length; ) i2[r2].fn === t2 ? i2.splice(r2, 1) : ++r2;
          return this;
        }, r.prototype.emit = function(e2) {
          var t2 = this._listeners[e2];
          if (t2) {
            for (var i2 = [], r2 = 1; r2 < arguments.length; ) i2.push(arguments[r2++]);
            for (r2 = 0; r2 < t2.length; ) t2[r2].fn.apply(t2[r2++].ctx, i2);
          }
          return this;
        };
      }, function(e, t, i) {
        "use strict";
        function r(e2) {
          return "undefined" != typeof Float32Array ? function() {
            var t2 = new Float32Array([-0]), i2 = new Uint8Array(t2.buffer), r2 = 128 === i2[3];
            function s2(e3, r3, s3) {
              t2[0] = e3, r3[s3] = i2[0], r3[s3 + 1] = i2[1], r3[s3 + 2] = i2[2], r3[s3 + 3] = i2[3];
            }
            function a2(e3, r3, s3) {
              t2[0] = e3, r3[s3] = i2[3], r3[s3 + 1] = i2[2], r3[s3 + 2] = i2[1], r3[s3 + 3] = i2[0];
            }
            function o2(e3, r3) {
              return i2[0] = e3[r3], i2[1] = e3[r3 + 1], i2[2] = e3[r3 + 2], i2[3] = e3[r3 + 3], t2[0];
            }
            function n2(e3, r3) {
              return i2[3] = e3[r3], i2[2] = e3[r3 + 1], i2[1] = e3[r3 + 2], i2[0] = e3[r3 + 3], t2[0];
            }
            e2.writeFloatLE = r2 ? s2 : a2, e2.writeFloatBE = r2 ? a2 : s2, e2.readFloatLE = r2 ? o2 : n2, e2.readFloatBE = r2 ? n2 : o2;
          }() : function() {
            function t2(e3, t3, i3, r2) {
              var s2 = t3 < 0 ? 1 : 0;
              if (s2 && (t3 = -t3), 0 === t3) e3(1 / t3 > 0 ? 0 : 2147483648, i3, r2);
              else if (isNaN(t3)) e3(2143289344, i3, r2);
              else if (t3 > 34028234663852886e22) e3((s2 << 31 | 2139095040) >>> 0, i3, r2);
              else if (t3 < 11754943508222875e-54) e3((s2 << 31 | Math.round(t3 / 1401298464324817e-60)) >>> 0, i3, r2);
              else {
                var a2 = Math.floor(Math.log(t3) / Math.LN2);
                e3((s2 << 31 | a2 + 127 << 23 | 8388607 & Math.round(t3 * Math.pow(2, -a2) * 8388608)) >>> 0, i3, r2);
              }
            }
            function i2(e3, t3, i3) {
              var r2 = e3(t3, i3), s2 = 2 * (r2 >> 31) + 1, a2 = r2 >>> 23 & 255, o2 = 8388607 & r2;
              return 255 === a2 ? o2 ? NaN : s2 * (1 / 0) : 0 === a2 ? 1401298464324817e-60 * s2 * o2 : s2 * Math.pow(2, a2 - 150) * (o2 + 8388608);
            }
            e2.writeFloatLE = t2.bind(null, s), e2.writeFloatBE = t2.bind(null, a), e2.readFloatLE = i2.bind(null, o), e2.readFloatBE = i2.bind(null, n);
          }(), "undefined" != typeof Float64Array ? function() {
            var t2 = new Float64Array([-0]), i2 = new Uint8Array(t2.buffer), r2 = 128 === i2[7];
            function s2(e3, r3, s3) {
              t2[0] = e3, r3[s3] = i2[0], r3[s3 + 1] = i2[1], r3[s3 + 2] = i2[2], r3[s3 + 3] = i2[3], r3[s3 + 4] = i2[4], r3[s3 + 5] = i2[5], r3[s3 + 6] = i2[6], r3[s3 + 7] = i2[7];
            }
            function a2(e3, r3, s3) {
              t2[0] = e3, r3[s3] = i2[7], r3[s3 + 1] = i2[6], r3[s3 + 2] = i2[5], r3[s3 + 3] = i2[4], r3[s3 + 4] = i2[3], r3[s3 + 5] = i2[2], r3[s3 + 6] = i2[1], r3[s3 + 7] = i2[0];
            }
            function o2(e3, r3) {
              return i2[0] = e3[r3], i2[1] = e3[r3 + 1], i2[2] = e3[r3 + 2], i2[3] = e3[r3 + 3], i2[4] = e3[r3 + 4], i2[5] = e3[r3 + 5], i2[6] = e3[r3 + 6], i2[7] = e3[r3 + 7], t2[0];
            }
            function n2(e3, r3) {
              return i2[7] = e3[r3], i2[6] = e3[r3 + 1], i2[5] = e3[r3 + 2], i2[4] = e3[r3 + 3], i2[3] = e3[r3 + 4], i2[2] = e3[r3 + 5], i2[1] = e3[r3 + 6], i2[0] = e3[r3 + 7], t2[0];
            }
            e2.writeDoubleLE = r2 ? s2 : a2, e2.writeDoubleBE = r2 ? a2 : s2, e2.readDoubleLE = r2 ? o2 : n2, e2.readDoubleBE = r2 ? n2 : o2;
          }() : function() {
            function t2(e3, t3, i3, r2, s2, a2) {
              var o2 = r2 < 0 ? 1 : 0;
              if (o2 && (r2 = -r2), 0 === r2) e3(0, s2, a2 + t3), e3(1 / r2 > 0 ? 0 : 2147483648, s2, a2 + i3);
              else if (isNaN(r2)) e3(0, s2, a2 + t3), e3(2146959360, s2, a2 + i3);
              else if (r2 > 17976931348623157e292) e3(0, s2, a2 + t3), e3((o2 << 31 | 2146435072) >>> 0, s2, a2 + i3);
              else {
                var n2;
                if (r2 < 22250738585072014e-324) e3((n2 = r2 / 5e-324) >>> 0, s2, a2 + t3), e3((o2 << 31 | n2 / 4294967296) >>> 0, s2, a2 + i3);
                else {
                  var d = Math.floor(Math.log(r2) / Math.LN2);
                  1024 === d && (d = 1023), e3(4503599627370496 * (n2 = r2 * Math.pow(2, -d)) >>> 0, s2, a2 + t3), e3((o2 << 31 | d + 1023 << 20 | 1048576 * n2 & 1048575) >>> 0, s2, a2 + i3);
                }
              }
            }
            function i2(e3, t3, i3, r2, s2) {
              var a2 = e3(r2, s2 + t3), o2 = e3(r2, s2 + i3), n2 = 2 * (o2 >> 31) + 1, d = o2 >>> 20 & 2047, c = 4294967296 * (1048575 & o2) + a2;
              return 2047 === d ? c ? NaN : n2 * (1 / 0) : 0 === d ? 5e-324 * n2 * c : n2 * Math.pow(2, d - 1075) * (c + 4503599627370496);
            }
            e2.writeDoubleLE = t2.bind(null, s, 0, 4), e2.writeDoubleBE = t2.bind(null, a, 4, 0), e2.readDoubleLE = i2.bind(null, o, 0, 4), e2.readDoubleBE = i2.bind(null, n, 4, 0);
          }(), e2;
        }
        function s(e2, t2, i2) {
          t2[i2] = 255 & e2, t2[i2 + 1] = e2 >>> 8 & 255, t2[i2 + 2] = e2 >>> 16 & 255, t2[i2 + 3] = e2 >>> 24;
        }
        function a(e2, t2, i2) {
          t2[i2] = e2 >>> 24, t2[i2 + 1] = e2 >>> 16 & 255, t2[i2 + 2] = e2 >>> 8 & 255, t2[i2 + 3] = 255 & e2;
        }
        function o(e2, t2) {
          return (e2[t2] | e2[t2 + 1] << 8 | e2[t2 + 2] << 16 | e2[t2 + 3] << 24) >>> 0;
        }
        function n(e2, t2) {
          return (e2[t2] << 24 | e2[t2 + 1] << 16 | e2[t2 + 2] << 8 | e2[t2 + 3]) >>> 0;
        }
        e.exports = r(r);
      }, function(e, t, i) {
        "use strict";
        var r = t;
        r.length = function(e2) {
          for (var t2 = 0, i2 = 0, r2 = 0; r2 < e2.length; ++r2) (i2 = e2.charCodeAt(r2)) < 128 ? t2 += 1 : i2 < 2048 ? t2 += 2 : 55296 == (64512 & i2) && 56320 == (64512 & e2.charCodeAt(r2 + 1)) ? (++r2, t2 += 4) : t2 += 3;
          return t2;
        }, r.read = function(e2, t2, i2) {
          if (i2 - t2 < 1) return "";
          for (var r2, s = null, a = [], o = 0; t2 < i2; ) (r2 = e2[t2++]) < 128 ? a[o++] = r2 : r2 > 191 && r2 < 224 ? a[o++] = (31 & r2) << 6 | 63 & e2[t2++] : r2 > 239 && r2 < 365 ? (r2 = ((7 & r2) << 18 | (63 & e2[t2++]) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++]) - 65536, a[o++] = 55296 + (r2 >> 10), a[o++] = 56320 + (1023 & r2)) : a[o++] = (15 & r2) << 12 | (63 & e2[t2++]) << 6 | 63 & e2[t2++], o > 8191 && ((s || (s = [])).push(String.fromCharCode.apply(String, a)), o = 0);
          return s ? (o && s.push(String.fromCharCode.apply(String, a.slice(0, o))), s.join("")) : String.fromCharCode.apply(String, a.slice(0, o));
        }, r.write = function(e2, t2, i2) {
          for (var r2, s, a = i2, o = 0; o < e2.length; ++o) (r2 = e2.charCodeAt(o)) < 128 ? t2[i2++] = r2 : r2 < 2048 ? (t2[i2++] = r2 >> 6 | 192, t2[i2++] = 63 & r2 | 128) : 55296 == (64512 & r2) && 56320 == (64512 & (s = e2.charCodeAt(o + 1))) ? (r2 = 65536 + ((1023 & r2) << 10) + (1023 & s), ++o, t2[i2++] = r2 >> 18 | 240, t2[i2++] = r2 >> 12 & 63 | 128, t2[i2++] = r2 >> 6 & 63 | 128, t2[i2++] = 63 & r2 | 128) : (t2[i2++] = r2 >> 12 | 224, t2[i2++] = r2 >> 6 & 63 | 128, t2[i2++] = 63 & r2 | 128);
          return i2 - a;
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = function(e2, t2, i2) {
          var r = i2 || 8192, s = r >>> 1, a = null, o = r;
          return function(i3) {
            if (i3 < 1 || i3 > s) return e2(i3);
            o + i3 > r && (a = e2(r), o = 0);
            var n = t2.call(a, o, o += i3);
            return 7 & o && (o = 1 + (7 | o)), n;
          };
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = s;
        var r = i(44);
        function s(e2, t2) {
          this.lo = e2 >>> 0, this.hi = t2 >>> 0;
        }
        var a = s.zero = new s(0, 0);
        a.toNumber = function() {
          return 0;
        }, a.zzEncode = a.zzDecode = function() {
          return this;
        }, a.length = function() {
          return 1;
        };
        var o = s.zeroHash = "\0\0\0\0\0\0\0\0";
        s.fromNumber = function(e2) {
          if (0 === e2) return a;
          var t2 = e2 < 0;
          t2 && (e2 = -e2);
          var i2 = e2 >>> 0, r2 = (e2 - i2) / 4294967296 >>> 0;
          return t2 && (r2 = ~r2 >>> 0, i2 = ~i2 >>> 0, ++i2 > 4294967295 && (i2 = 0, ++r2 > 4294967295 && (r2 = 0))), new s(i2, r2);
        }, s.from = function(e2) {
          if ("number" == typeof e2) return s.fromNumber(e2);
          if (r.isString(e2)) {
            if (!r.Long) return s.fromNumber(parseInt(e2, 10));
            e2 = r.Long.fromString(e2);
          }
          return e2.low || e2.high ? new s(e2.low >>> 0, e2.high >>> 0) : a;
        }, s.prototype.toNumber = function(e2) {
          if (!e2 && this.hi >>> 31) {
            var t2 = 1 + ~this.lo >>> 0, i2 = ~this.hi >>> 0;
            return t2 || (i2 = i2 + 1 >>> 0), -(t2 + 4294967296 * i2);
          }
          return this.lo + 4294967296 * this.hi;
        }, s.prototype.toLong = function(e2) {
          return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(e2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(e2) };
        };
        var n = String.prototype.charCodeAt;
        s.fromHash = function(e2) {
          return e2 === o ? a : new s((n.call(e2, 0) | n.call(e2, 1) << 8 | n.call(e2, 2) << 16 | n.call(e2, 3) << 24) >>> 0, (n.call(e2, 4) | n.call(e2, 5) << 8 | n.call(e2, 6) << 16 | n.call(e2, 7) << 24) >>> 0);
        }, s.prototype.toHash = function() {
          return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
        }, s.prototype.zzEncode = function() {
          var e2 = this.hi >> 31;
          return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ e2) >>> 0, this.lo = (this.lo << 1 ^ e2) >>> 0, this;
        }, s.prototype.zzDecode = function() {
          var e2 = -(1 & this.lo);
          return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ e2) >>> 0, this.hi = (this.hi >>> 1 ^ e2) >>> 0, this;
        }, s.prototype.length = function() {
          var e2 = this.lo, t2 = (this.lo >>> 28 | this.hi << 4) >>> 0, i2 = this.hi >>> 24;
          return 0 === i2 ? 0 === t2 ? e2 < 16384 ? e2 < 128 ? 1 : 2 : e2 < 2097152 ? 3 : 4 : t2 < 16384 ? t2 < 128 ? 5 : 6 : t2 < 2097152 ? 7 : 8 : i2 < 128 ? 9 : 10;
        };
      }, function(e, t, i) {
        "use strict";
        e.exports = a;
        var r = i(151);
        (a.prototype = Object.create(r.prototype)).constructor = a;
        var s = i(44);
        function a() {
          r.call(this);
        }
        function o(e2, t2, i2) {
          e2.length < 40 ? s.utf8.write(e2, t2, i2) : t2.utf8Write ? t2.utf8Write(e2, i2) : t2.write(e2, i2);
        }
        a._configure = function() {
          a.alloc = s._Buffer_allocUnsafe, a.writeBytesBuffer = s.Buffer && s.Buffer.prototype instanceof Uint8Array && "set" === s.Buffer.prototype.set.name ? function(e2, t2, i2) {
            t2.set(e2, i2);
          } : function(e2, t2, i2) {
            if (e2.copy) e2.copy(t2, i2, 0, e2.length);
            else for (var r2 = 0; r2 < e2.length; ) t2[i2++] = e2[r2++];
          };
        }, a.prototype.bytes = function(e2) {
          s.isString(e2) && (e2 = s._Buffer_from(e2, "base64"));
          var t2 = e2.length >>> 0;
          return this.uint32(t2), t2 && this._push(a.writeBytesBuffer, t2, e2), this;
        }, a.prototype.string = function(e2) {
          var t2 = s.Buffer.byteLength(e2);
          return this.uint32(t2), t2 && this._push(o, t2, e2), this;
        }, a._configure();
      }, function(e, t, i) {
        "use strict";
        e.exports = a;
        var r = i(152);
        (a.prototype = Object.create(r.prototype)).constructor = a;
        var s = i(44);
        function a(e2) {
          r.call(this, e2);
        }
        a._configure = function() {
          s.Buffer && (a.prototype._slice = s.Buffer.prototype.slice);
        }, a.prototype.string = function() {
          var e2 = this.uint32();
          return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + e2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + e2, this.len));
        }, a._configure();
      }, function(e, t, i) {
        "use strict";
        e.exports = s;
        var r = i(44);
        function s(e2, t2, i2) {
          if ("function" != typeof e2) throw TypeError("rpcImpl must be a function");
          r.EventEmitter.call(this), this.rpcImpl = e2, this.requestDelimited = Boolean(t2), this.responseDelimited = Boolean(i2);
        }
        (s.prototype = Object.create(r.EventEmitter.prototype)).constructor = s, s.prototype.rpcCall = function e2(t2, i2, s2, a, o) {
          if (!a) throw TypeError("request must be specified");
          var n = this;
          if (!o) return r.asPromise(e2, n, t2, i2, s2, a);
          if (n.rpcImpl) try {
            return n.rpcImpl(t2, i2[n.requestDelimited ? "encodeDelimited" : "encode"](a).finish(), function(e3, i3) {
              if (e3) return n.emit("error", e3, t2), o(e3);
              if (null !== i3) {
                if (!(i3 instanceof s2)) try {
                  i3 = s2[n.responseDelimited ? "decodeDelimited" : "decode"](i3);
                } catch (e4) {
                  return n.emit("error", e4, t2), o(e4);
                }
                return n.emit("data", i3, t2), o(null, i3);
              }
              n.end(true);
            });
          } catch (e3) {
            return n.emit("error", e3, t2), void setTimeout(function() {
              o(e3);
            }, 0);
          }
          else setTimeout(function() {
            o(Error("already ended"));
          }, 0);
        }, s.prototype.end = function(e2) {
          return this.rpcImpl && (e2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
        };
      }, function(e, t, i) {
        "use strict";
        function r(e2, t2) {
          "string" == typeof e2 && (t2 = e2, e2 = void 0);
          var i2 = [];
          function s(e3) {
            if ("string" != typeof e3) {
              var t3 = a();
              if (r.verbose && console.log("codegen: " + t3), t3 = "return " + t3, e3) {
                for (var o = Object.keys(e3), n = new Array(o.length + 1), d = new Array(o.length), c = 0; c < o.length; ) n[c] = o[c], d[c] = e3[o[c++]];
                return n[c] = t3, Function.apply(null, n).apply(null, d);
              }
              return Function(t3)();
            }
            for (var l = new Array(arguments.length - 1), u = 0; u < l.length; ) l[u] = arguments[++u];
            if (u = 0, e3 = e3.replace(/%([%dfijs])/g, function(e4, t4) {
              var i3 = l[u++];
              switch (t4) {
                case "d":
                case "f":
                  return String(Number(i3));
                case "i":
                  return String(Math.floor(i3));
                case "j":
                  return JSON.stringify(i3);
                case "s":
                  return String(i3);
              }
              return "%";
            }), u !== l.length) throw Error("parameter count mismatch");
            return i2.push(e3), s;
          }
          function a(r2) {
            return "function " + (r2 || t2 || "") + "(" + (e2 && e2.join(",") || "") + "){\n  " + i2.join("\n  ") + "\n}";
          }
          return s.toString = a, s;
        }
        e.exports = r, r.verbose = false;
      }, function(e, t, i) {
        "use strict";
        e.exports = a;
        var r = i(179), s = i(180)("fs");
        function a(e2, t2, i2) {
          return "function" == typeof t2 ? (i2 = t2, t2 = {}) : t2 || (t2 = {}), i2 ? !t2.xhr && s && s.readFile ? s.readFile(e2, function(r2, s2) {
            return r2 && "undefined" != typeof XMLHttpRequest ? a.xhr(e2, t2, i2) : r2 ? i2(r2) : i2(null, t2.binary ? s2 : s2.toString("utf8"));
          }) : a.xhr(e2, t2, i2) : r(a, this, e2, t2);
        }
        a.xhr = function(e2, t2, i2) {
          var r2 = new XMLHttpRequest();
          r2.onreadystatechange = function() {
            if (4 === r2.readyState) {
              if (0 !== r2.status && 200 !== r2.status) return i2(Error("status " + r2.status));
              if (t2.binary) {
                var e3 = r2.response;
                if (!e3) {
                  e3 = [];
                  for (var s2 = 0; s2 < r2.responseText.length; ++s2) e3.push(255 & r2.responseText.charCodeAt(s2));
                }
                return i2(null, "undefined" != typeof Uint8Array ? new Uint8Array(e3) : e3);
              }
              return i2(null, r2.responseText);
            }
          }, t2.binary && ("overrideMimeType" in r2 && r2.overrideMimeType("text/plain; charset=x-user-defined"), r2.responseType = "arraybuffer"), r2.open("GET", e2), r2.send();
        };
      }, function(e, t, i) {
        "use strict";
        var r = t, s = r.isAbsolute = function(e2) {
          return /^(?:\/|\w+:)/.test(e2);
        }, a = r.normalize = function(e2) {
          var t2 = (e2 = e2.replace(/\\/g, "/").replace(/\/{2,}/g, "/")).split("/"), i2 = s(e2), r2 = "";
          i2 && (r2 = t2.shift() + "/");
          for (var a2 = 0; a2 < t2.length; ) ".." === t2[a2] ? a2 > 0 && ".." !== t2[a2 - 1] ? t2.splice(--a2, 2) : i2 ? t2.splice(a2, 1) : ++a2 : "." === t2[a2] ? t2.splice(a2, 1) : ++a2;
          return r2 + t2.join("/");
        };
        r.resolve = function(e2, t2, i2) {
          return i2 || (t2 = a(t2)), s(t2) ? t2 : (i2 || (e2 = a(e2)), (e2 = e2.replace(/(?:\/|^)[^/]+$/, "")).length ? a(e2 + "/" + t2) : t2);
        };
      }, function(e, t, i) {
        "use strict";
        var r = i(178), s = (r.roots.default || (r.roots.default = new r.Root())).addJSON({ WebrtcStats: { fields: { local: { type: "local_obj", id: 1 }, remote: { type: "remote_obj", id: 2 }, timestamp: { type: "int64", id: 3 }, appkey: { type: "string", id: 4 }, cid: { type: "int64", id: 5 }, uid: { type: "string", id: 6 }, browser: { type: "string", id: 7 }, platform: { type: "string", id: 8 }, sdkVersion: { type: "string", id: 9 } }, nested: { local_obj: { fields: { audio_ssrc: { rule: "repeated", type: "audio_ssrc_obj", id: 1 }, audioSlave_ssrc: { rule: "repeated", type: "audioSlave_ssrc_obj", id: 2 }, video_ssrc: { rule: "repeated", type: "video_ssrc_obj", id: 3 }, screen_ssrc: { rule: "repeated", type: "screen_ssrc_obj", id: 4 }, bwe: { rule: "repeated", type: "bwe_obj", id: 5 } }, nested: { audio_ssrc_obj: { fields: { audioInputLevel: { type: "int64", id: 1 }, totalAudioEnergy: { type: "int64", id: 2 }, totalSamplesDuration: { type: "int64", id: 3 }, bytesSent: { type: "int64", id: 4 }, bitsSentPerSecond: { type: "int64", id: 5 }, targetBitrate: { type: "int64", id: 6 }, packetsSent: { type: "int64", id: 7 }, packetsSentPerSecond: { type: "int64", id: 8 }, packetsLost: { type: "int64", id: 9 }, fractionLost: { type: "int64", id: 10 }, packetsLostRate: { type: "int64", id: 11 }, nackCount: { type: "int64", id: 12 }, rtt: { type: "int64", id: 13 }, jitterReceived: { type: "int64", id: 14 }, echoReturnLoss: { type: "string", id: 15 }, echoReturnLossEnhancement: { type: "string", id: 16 }, active: { type: "int64", id: 17 } } }, audioSlave_ssrc_obj: { fields: { audioInputLevel: { type: "int64", id: 1 }, totalAudioEnergy: { type: "int64", id: 2 }, totalSamplesDuration: { type: "int64", id: 3 }, bytesSent: { type: "int64", id: 4 }, bitsSentPerSecond: { type: "int64", id: 5 }, targetBitrate: { type: "int64", id: 6 }, packetsSent: { type: "int64", id: 7 }, packetsSentPerSecond: { type: "int64", id: 8 }, packetsLost: { type: "int64", id: 9 }, fractionLost: { type: "int64", id: 10 }, packetsLostRate: { type: "int64", id: 11 }, nackCount: { type: "int64", id: 12 }, rtt: { type: "int64", id: 13 }, jitterReceived: { type: "int64", id: 14 }, echoReturnLoss: { type: "string", id: 15 }, echoReturnLossEnhancement: { type: "string", id: 16 }, active: { type: "int64", id: 17 } } }, video_ssrc_obj: { fields: { bytesSent: { type: "int64", id: 1 }, bitsSentPerSecond: { type: "int64", id: 2 }, targetBitrate: { type: "int64", id: 3 }, packetsSent: { type: "int64", id: 4 }, packetsSentPerSecond: { type: "int64", id: 5 }, packetsLost: { type: "int64", id: 6 }, fractionLost: { type: "int64", id: 7 }, packetsLostRate: { type: "int64", id: 8 }, firCount: { type: "int64", id: 9 }, pliCount: { type: "int64", id: 10 }, nackCount: { type: "int64", id: 11 }, framesEncoded: { type: "int64", id: 12 }, framesEncodedPerSecond: { type: "int64", id: 13 }, avgEncodeMs: { type: "int64", id: 14 }, encodeUsagePercent: { type: "int64", id: 15 }, framesSent: { type: "int64", id: 16 }, frameRateInput: { type: "int64", id: 17 }, frameRateSent: { type: "int64", id: 18 }, frameWidthInput: { type: "int64", id: 19 }, frameWidthSent: { type: "int64", id: 20 }, frameHeightInput: { type: "int64", id: 21 }, frameHeightSent: { type: "int64", id: 22 }, hugeFramesSent: { type: "int64", id: 23 }, qpSum: { type: "int64", id: 24 }, qpPercentage: { type: "int64", id: 25 }, freezeTime: { type: "int64", id: 26 }, totalFreezeTime: { type: "int64", id: 27 }, qualityLimitationReason: { type: "string", id: 28 }, qualityLimitationResolutionChanges: { type: "int64", id: 29 }, jitter: { type: "int64", id: 30 }, rtt: { type: "int64", id: 31 }, active: { type: "int64", id: 32 }, streamType: { type: "string", id: 33 } } }, screen_ssrc_obj: { fields: { bytesSent: { type: "int64", id: 1 }, bitsSentPerSecond: { type: "int64", id: 2 }, targetBitrate: { type: "int64", id: 3 }, packetsSent: { type: "int64", id: 4 }, packetsSentPerSecond: { type: "int64", id: 5 }, packetsLost: { type: "int64", id: 6 }, fractionLost: { type: "int64", id: 7 }, packetsLostRate: { type: "int64", id: 8 }, firCount: { type: "int64", id: 9 }, pliCount: { type: "int64", id: 10 }, nackCount: { type: "int64", id: 11 }, framesEncoded: { type: "int64", id: 12 }, framesEncodedPerSecond: { type: "int64", id: 13 }, avgEncodeMs: { type: "int64", id: 14 }, encodeUsagePercent: { type: "int64", id: 15 }, framesSent: { type: "int64", id: 16 }, frameRateInput: { type: "int64", id: 17 }, frameRateSent: { type: "int64", id: 18 }, frameWidthInput: { type: "int64", id: 19 }, frameWidthSent: { type: "int64", id: 20 }, frameHeightInput: { type: "int64", id: 21 }, frameHeightSent: { type: "int64", id: 22 }, hugeFramesSent: { type: "int64", id: 23 }, qpSum: { type: "int64", id: 24 }, qpPercentage: { type: "int64", id: 25 }, freezeTime: { type: "int64", id: 26 }, totalFreezeTime: { type: "int64", id: 27 }, qualityLimitationReason: { type: "string", id: 28 }, qualityLimitationResolutionChanges: { type: "int64", id: 29 }, jitter: { type: "int64", id: 30 }, rtt: { type: "int64", id: 31 }, active: { type: "int64", id: 32 }, streamType: { type: "string", id: 33 } } }, bwe_obj: { fields: { googActualEncBitrate: { type: "int64", id: 1 }, googAvailableSendBandwidth: { type: "int64", id: 2 }, googRetransmitBitrate: { type: "int64", id: 3 }, googAvailableReceiveBandwidth: { type: "int64", id: 4 }, googTargetEncBitrate: { type: "int64", id: 5 }, googBucketDelay: { type: "int64", id: 6 }, googTransmitBitrate: { type: "int64", id: 7 } } } } }, remote_obj: { fields: { audio_ssrc: { rule: "repeated", type: "audio_ssrc_obj", id: 1 }, audioSlave_ssrc: { rule: "repeated", type: "audioSlave_ssrc_obj", id: 2 }, video_ssrc: { rule: "repeated", type: "video_ssrc_obj", id: 3 }, screen_ssrc: { rule: "repeated", type: "screen_ssrc_obj", id: 4 } }, nested: { audio_ssrc_obj: { fields: { audioOutputLevel: { type: "int64", id: 1 }, totalAudioEnergy: { type: "int64", id: 2 }, totalSamplesDuration: { type: "int64", id: 3 }, bytesReceived: { type: "int64", id: 4 }, bitsReceivedPerSecond: { type: "int64", id: 5 }, packetsReceived: { type: "int64", id: 6 }, packetsReceivedPerSecond: { type: "int64", id: 7 }, packetsLost: { type: "int64", id: 8 }, packetsLostRate: { type: "int64", id: 9 }, nackCount: { type: "int64", id: 10 }, lastPacketReceivedTimestamp: { type: "int64", id: 11 }, estimatedPlayoutTimestamp: { type: "int64", id: 12 }, freezeTime: { type: "int64", id: 13 }, totalFreezeTime: { type: "int64", id: 14 }, decodingPLC: { type: "int64", id: 15 }, decodingPLCCNG: { type: "int64", id: 16 }, decodingNormal: { type: "int64", id: 17 }, decodingMuted: { type: "int64", id: 18 }, decodingCNG: { type: "int64", id: 19 }, decodingCTN: { type: "int64", id: 20 }, currentDelayMs: { type: "int64", id: 21 }, preferredJitterBufferMs: { type: "int64", id: 22 }, jitterBufferMs: { type: "int64", id: 23 }, jitterBufferDelay: { type: "int64", id: 24 }, jitter: { type: "int64", id: 25 }, rtt: { type: "int64", id: 26 }, preemptiveExpandRate: { type: "int64", id: 27 }, speechExpandRate: { type: "int64", id: 28 }, concealedSamples: { type: "int64", id: 29 }, silentConcealedSamples: { type: "int64", id: 30 }, secondaryDecodedRate: { type: "int64", id: 31 }, secondaryDiscardedRate: { type: "int64", id: 32 }, remoteuid: { type: "string", id: 33 } } }, audioSlave_ssrc_obj: { fields: { audioOutputLevel: { type: "int64", id: 1 }, totalAudioEnergy: { type: "int64", id: 2 }, totalSamplesDuration: { type: "int64", id: 3 }, bytesReceived: { type: "int64", id: 4 }, bitsReceivedPerSecond: { type: "int64", id: 5 }, packetsReceived: { type: "int64", id: 6 }, packetsReceivedPerSecond: { type: "int64", id: 7 }, packetsLost: { type: "int64", id: 8 }, packetsLostRate: { type: "int64", id: 9 }, nackCount: { type: "int64", id: 10 }, lastPacketReceivedTimestamp: { type: "int64", id: 11 }, estimatedPlayoutTimestamp: { type: "int64", id: 12 }, freezeTime: { type: "int64", id: 13 }, totalFreezeTime: { type: "int64", id: 14 }, decodingPLC: { type: "int64", id: 15 }, decodingPLCCNG: { type: "int64", id: 16 }, decodingNormal: { type: "int64", id: 17 }, decodingMuted: { type: "int64", id: 18 }, decodingCNG: { type: "int64", id: 19 }, decodingCTN: { type: "int64", id: 20 }, currentDelayMs: { type: "int64", id: 21 }, preferredJitterBufferMs: { type: "int64", id: 22 }, jitterBufferMs: { type: "int64", id: 23 }, jitterBufferDelay: { type: "int64", id: 24 }, jitter: { type: "int64", id: 25 }, rtt: { type: "int64", id: 26 }, preemptiveExpandRate: { type: "int64", id: 27 }, speechExpandRate: { type: "int64", id: 28 }, concealedSamples: { type: "int64", id: 29 }, silentConcealedSamples: { type: "int64", id: 30 }, secondaryDecodedRate: { type: "int64", id: 31 }, secondaryDiscardedRate: { type: "int64", id: 32 }, remoteuid: { type: "string", id: 33 } } }, video_ssrc_obj: { fields: { bytesReceived: { type: "int64", id: 1 }, bitsReceivedPerSecond: { type: "int64", id: 2 }, packetsReceived: { type: "int64", id: 3 }, packetsReceivedPerSecond: { type: "int64", id: 4 }, packetsLost: { type: "int64", id: 5 }, packetsLostRate: { type: "int64", id: 6 }, firCount: { type: "int64", id: 7 }, pliCount: { type: "int64", id: 8 }, nackCount: { type: "int64", id: 9 }, lastPacketReceivedTimestamp: { type: "int64", id: 10 }, estimatedPlayoutTimestamp: { type: "int64", id: 11 }, pauseCount: { type: "int64", id: 12 }, totalPausesDuration: { type: "int64", id: 13 }, freezeCount: { type: "int64", id: 14 }, totalFreezesDuration: { type: "int64", id: 15 }, totalFreezeTime: { type: "int64", id: 16 }, freezeTime: { type: "int64", id: 17 }, framesDecoded: { type: "int64", id: 18 }, framesDropped: { type: "int64", id: 19 }, framesReceived: { type: "int64", id: 20 }, decodeMs: { type: "int64", id: 21 }, frameRateDecoded: { type: "int64", id: 22 }, frameRateOutput: { type: "int64", id: 23 }, frameRateReceived: { type: "int64", id: 24 }, frameWidthReceived: { type: "int64", id: 25 }, frameHeightReceived: { type: "int64", id: 26 }, powerEfficientDecoder: { type: "int64", id: 27 }, currentDelayMs: { type: "int64", id: 28 }, jitterBufferDelay: { type: "int64", id: 29 }, remoteuid: { type: "string", id: 30 } } }, screen_ssrc_obj: { fields: { bytesReceived: { type: "int64", id: 1 }, bitsReceivedPerSecond: { type: "int64", id: 2 }, packetsReceived: { type: "int64", id: 3 }, packetsReceivedPerSecond: { type: "int64", id: 4 }, packetsLost: { type: "int64", id: 5 }, packetsLostRate: { type: "int64", id: 6 }, firCount: { type: "int64", id: 7 }, pliCount: { type: "int64", id: 8 }, nackCount: { type: "int64", id: 9 }, lastPacketReceivedTimestamp: { type: "int64", id: 10 }, estimatedPlayoutTimestamp: { type: "int64", id: 11 }, pauseCount: { type: "int64", id: 12 }, totalPausesDuration: { type: "int64", id: 13 }, freezeCount: { type: "int64", id: 14 }, totalFreezesDuration: { type: "int64", id: 15 }, totalFreezeTime: { type: "int64", id: 16 }, freezeTime: { type: "int64", id: 17 }, framesDecoded: { type: "int64", id: 18 }, framesDropped: { type: "int64", id: 19 }, framesReceived: { type: "int64", id: 20 }, decodeMs: { type: "int64", id: 21 }, frameRateDecoded: { type: "int64", id: 22 }, frameRateOutput: { type: "int64", id: 23 }, frameRateReceived: { type: "int64", id: 24 }, frameWidthReceived: { type: "int64", id: 25 }, frameHeightReceived: { type: "int64", id: 26 }, powerEfficientDecoder: { type: "int64", id: 27 }, currentDelayMs: { type: "int64", id: 28 }, jitterBufferDelay: { type: "int64", id: 29 }, remoteuid: { type: "string", id: 30 } } } } } } } });
        e.exports = s;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.GetStats = void 0;
        const o = i(277), n = a(i(7)), d = i(1), c = i(278);
        let l = [], u = [], h = [], p = [], m = {}, g = {}, f = {}, v = {};
        function S(e2) {
          if (!e2) return 16;
          let t2;
          return t2 = (/* @__PURE__ */ new Map([["speech_low_quality", 16], ["speech_standard", 32], ["music_standard", 48], ["standard_stereo", 48], ["high_quality", 48], ["high_quality_stereo", 48]])).get(e2), t2;
        }
        function y(e2, t2, i2) {
          e2 && i2 >= Number.MIN_SAFE_INTEGER && (e2[t2] = Math.round(i2));
        }
        function _(e2, t2, i2) {
          if (e2 && t2 && e2[i2] > Number.MIN_SAFE_INTEGER && t2[i2] > Number.MIN_SAFE_INTEGER && e2.timestamp && t2.timestamp) {
            const r2 = (e2[i2] - t2[i2]) / (e2.timestamp - t2.timestamp) * 1e3;
            return Math.max(r2, -1);
          }
          return NaN;
        }
        t.GetStats = class {
          constructor(e2) {
            this.times = 0, this.tmp = { bytesSent: 0, bytesReceived: 0 }, this.chromeLegecy = d.getParameters().chromeLegacyDefault, this.resultMap = /* @__PURE__ */ new Map(), this.adapterRef = e2.adapterRef, this.browser = "chrome", this.audioLevel = [], this._reset(), this.formativeStatsReport = new o.FormativeStatsReport({ adapterRef: this.adapterRef }), this.statsInfo = { send: { firstStartAt: 0, lastStartAt: 0, totalCnt: 0, frequency: 0, errCnt: 0, cpStats: null, statsMapHistory: {}, logger: this.adapterRef.logger.getChild(() => `getStats ${this.browser} send ${this.statsInfo.send.errCnt}/${this.statsInfo.send.totalCnt}`) }, recv: { firstStartAt: 0, lastStartAt: 0, totalCnt: 0, frequency: 0, errCnt: 0, cpStats: null, statsMapHistory: {}, logger: this.adapterRef.logger.getChild(() => `getStats ${this.browser} recv ${this.statsInfo.recv.errCnt}/${this.statsInfo.recv.totalCnt} `) } };
          }
          _reset() {
            this.times = 0, this.browser = "chrome", n.IS_CHROME_ONLY && n.CHROME_MAJOR_VERSION && n.CHROME_MAJOR_VERSION >= 72 || n.IS_ANDROID ? this.browser = "chrome" : n.IS_ANY_SAFARI && n.SAFARI_MAJOR_VERSION && n.SAFARI_MAJOR_VERSION >= 12 || n.IS_ANY_SAFARI && n.IS_WECHAT ? this.browser = "safari" : n.IS_FIREFOX && n.FIREFOX_MAJOR_VERSION && n.FIREFOX_MAJOR_VERSION >= 60 && (this.browser = "firefox"), this.audioLevel = [], this.formativeStatsReport && this.formativeStatsReport.destroy(), this.formativeStatsReport = null;
          }
          markStatsStart(e2) {
            const t2 = this.statsInfo[e2];
            t2 && (t2.lastStartAt = Date.now(), t2.firstStartAt || (t2.firstStartAt = t2.lastStartAt), t2.totalCnt += 1, t2.frequency = Math.floor(t2.totalCnt / (t2.lastStartAt - t2.firstStartAt) * 6e4));
          }
          async getAllStats() {
            var e2, t2, i2, r2, s2, a2, o2, c2, l2, u2, h2;
            this.tmp = { bytesSent: 0, bytesReceived: 0 }, this.times = (this.times || 0) + 1;
            let p2 = null, S2 = null;
            try {
              let s3 = null === (r2 = null === (i2 = null === (t2 = null === (e2 = null == this ? void 0 : this.adapterRef) || void 0 === e2 ? void 0 : e2._mediasoup) || void 0 === t2 ? void 0 : t2._sendTransport) || void 0 === i2 ? void 0 : i2._handler) || void 0 === r2 ? void 0 : r2._pc;
              if (!s3) return;
              p2 = await this.getLocalStats(s3);
            } catch (e3) {
              this.statsInfo.send.errCnt++, this.statsInfo.send.errCnt <= d.getParameters().statsLogMaxCnt && this.statsInfo.send.logger.warn("数据汇集出现异常: ", e3.name, e3.message, e3.stack);
            }
            try {
              if (this.audioLevel.length = 0, this.adapterRef.remoteAudioStats = {}, this.adapterRef.remoteAudioSlaveStats = {}, this.adapterRef.remoteVideoStats = {}, this.adapterRef.remoteScreenStats = {}, n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION < 69) null === (s2 = this.adapterRef._mediasoup) || void 0 === s2 || s2.consumerMap.forEach(async (e3, t3) => {
                var i3, r3, s3, a3, o3, n2, d2, c3;
                let l3, u3, h3, p3, S3 = null === (r3 = null === (i3 = e3._recvTransportMainAudio) || void 0 === i3 ? void 0 : i3._handler) || void 0 === r3 ? void 0 : r3._pc;
                S3 && (l3 = await this.getRemoteStatsPlanB(S3, "audio"));
                let y3 = null === (a3 = null === (s3 = e3._recvTransportMainVideo) || void 0 === s3 ? void 0 : s3._handler) || void 0 === a3 ? void 0 : a3._pc;
                y3 && (u3 = await this.getRemoteStatsPlanB(y3, "video"));
                let _2 = null === (n2 = null === (o3 = e3._recvTransportSubScreen) || void 0 === o3 ? void 0 : o3._handler) || void 0 === n2 ? void 0 : n2._pc;
                _2 && (h3 = await this.getRemoteStatsPlanB(_2, "screen"));
                let R = null === (c3 = null === (d2 = e3._recvTransportSubAudioSlave) || void 0 === d2 ? void 0 : d2._handler) || void 0 === c3 ? void 0 : c3._pc;
                R && (p3 = await this.getRemoteStatsPlanB(R, "audioSlave")), m = l3, g = u3, v = p3, f = h3;
              }), S2 = { audio_ssrc: m ? m.audio_ssrc : null, video_ssrc: g ? g.video_ssrc : null, screen_ssrc: f ? f.screen_ssrc : null, audioSlave_ssrc: v ? v.audioSlave_ssrc : null };
              else {
                let e3 = null === (l2 = null === (c2 = null === (o2 = null === (a2 = null == this ? void 0 : this.adapterRef) || void 0 === a2 ? void 0 : a2._mediasoup) || void 0 === o2 ? void 0 : o2._recvTransport) || void 0 === c2 ? void 0 : c2._handler) || void 0 === l2 ? void 0 : l2._pc;
                if (!e3) return;
                S2 = await this.getRemoteStats(e3);
              }
              this.audioLevel.sort((y2 = "level", function(e3, t3) {
                var i3 = e3[y2], r3 = t3[y2];
                return 0 === r3 || r3 ? 0 === i3 || i3 ? r3 - i3 : 1 : -1;
              })), this.audioLevel.length > 0 && this.audioLevel[0].level > d.getParameters().activeSpeakerMin && (null === (u2 = null == this ? void 0 : this.adapterRef) || void 0 === u2 || u2.instance.safeEmit("active-speaker", this.audioLevel[0]), null === (h2 = null == this ? void 0 : this.adapterRef) || void 0 === h2 || h2.instance.safeEmit("volume-indicator", this.audioLevel));
            } catch (e3) {
              this.statsInfo.recv.errCnt++, this.statsInfo.recv.errCnt <= d.getParameters().statsLogMaxCnt && this.statsInfo.recv.logger.warn("数据汇集出现异常: ", e3.name, e3.message, e3.stack);
            }
            var y2;
            return { local: p2, remote: S2, times: this.times };
          }
          async getLocalStats(e2) {
            return !e2 || /(failed|closed|new)/gi.test(e2.iceConnectionState) ? {} : await this[this.browser](e2, "send");
          }
          async getRemoteStats(e2) {
            return !e2 || /(failed|closed|new)/gi.test(e2.iceConnectionState) ? {} : await this[this.browser](e2, "recv");
          }
          async getRemoteStatsPlanB(e2, t2) {
            return !e2 || /(failed|closed|new)/gi.test(e2.iceConnectionState) ? {} : await this.chrome69(e2, "recv", t2);
          }
          async chrome69(e2, t2, i2) {
            return await (() => new Promise((r2) => {
              e2.getStats((s2) => {
                this.markStatsStart(t2), this.chromeLegecy = "supported";
                let a2 = {};
                s2.result().forEach(function(e3) {
                  const t3 = {};
                  e3.names().forEach(function(i3) {
                    t3[i3] = e3.stat(i3);
                  }), t3.id = e3.id, t3.type = e3.type, t3.timestamp = e3.timestamp, a2[t3.id] = t3;
                }), e2.lastStats = e2.lastStats || {}, a2 = this.formatChromeNonStandardStats(e2, a2, t2, i2), r2(a2);
              });
            }))();
          }
          async chrome(e2, t2) {
            const i2 = "unsupported" === this.chromeLegecy ? null : await (() => new Promise(async (i3) => {
              try {
                this.markStatsStart(t2), await e2.getStats((r3) => {
                  this.chromeLegecy = "supported";
                  let s3 = {};
                  r3.result().forEach(function(e3) {
                    const t3 = {};
                    e3.names().forEach(function(i4) {
                      t3[i4] = e3.stat(i4);
                    }), t3.id = e3.id, t3.type = e3.type, t3.timestamp = e3.timestamp, s3[t3.id] = t3;
                  }), e2.lastStats = e2.lastStats || {}, s3 = this.formatChromeNonStandardStats(e2, s3, t2), i3(s3);
                });
              } catch (e3) {
                if (this.statsInfo[t2].errCnt++, "TypeError" === e3.name) {
                  if ("unknown" === this.chromeLegecy && n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION >= 122) return this.statsInfo[t2].logger.log(`getStats：当前浏览器不再支持非标准getStats ${e3.name} ${e3.message}`), this.chromeLegecy = "unsupported", i3(null);
                  this.statsInfo[t2].logger.warn(`getStats出现异常：${e3.name}。fallback: 切换getStats方式 ${this.browser} => safari`, e3.name, e3.message), this.browser = "safari";
                } else "NotSupportedError" === e3.name ? (this.statsInfo[t2].logger.log(`getStats：当前浏览器不再支持非标准getStats ${e3.name} ${e3.message}`), "unknown" === this.chromeLegecy && (this.chromeLegecy = "unsupported"), i3(null)) : (this.statsInfo[t2].errCnt <= d.getParameters().statsLogMaxCnt && this.statsInfo[t2].logger.warn(`getStats出现异常: ${e3.name} ${e3.message}`), i3(null));
              }
            }))(), r2 = await (async () => {
              if (!e2.getTransceivers) return {};
              let i3 = { audio_ssrc: [], audioSlave_ssrc: [], video_ssrc: [], screen_ssrc: [], bwe: [] };
              const r3 = e2.getTransceivers();
              for (let e3 = 0; e3 < r3.length; e3++) {
                let s3 = null;
                const a2 = r3[e3];
                if ("sendonly" === a2.direction) {
                  if (a2.sender && a2.sender.track && a2.sender.getStats) if (this.markStatsStart(t2), s3 = await a2.sender.getStats(), s3 = this.formatChromeStandardizedStats(s3, t2), s3.video_ssrc && i3.video_ssrc) {
                    if (i3.video_ssrc.push(s3.video_ssrc[0]), i3.video_ssrc.length > 1) {
                      "low" === (i3.video_ssrc[0] || {}).streamType && ([i3.video_ssrc[0], i3.video_ssrc[1]] = [i3.video_ssrc[1], i3.video_ssrc[0]]);
                    }
                  } else if (s3.screen_ssrc && i3.screen_ssrc) {
                    if (i3.screen_ssrc.push(s3.screen_ssrc[0]), i3.screen_ssrc.length > 1) {
                      "low" === (i3.screen_ssrc[0] || {}).streamType && ([i3.screen_ssrc[0], i3.screen_ssrc[1]] = [i3.screen_ssrc[1], i3.screen_ssrc[0]]);
                    }
                  } else Object.assign(i3, s3);
                  0 === i3.bwe.length && this.statsInfo.send.cpStats && i3.bwe.push({ googAvailableSendBandwidth: this.statsInfo.send.cpStats.availableOutgoingBitrate / 1e3 });
                } else "recvonly" === a2.direction && a2.receiver && a2.receiver.track && a2.receiver.getStats && (this.markStatsStart(t2), s3 = await a2.receiver.getStats(), s3 = this.formatChromeStandardizedStats(s3, t2), s3.audio_ssrc && i3.audio_ssrc ? i3.audio_ssrc.push(s3.audio_ssrc[0]) : s3.audioSlave_ssrc && i3.audioSlave_ssrc ? i3.audioSlave_ssrc.push(s3.audioSlave_ssrc[0]) : s3.video_ssrc && i3.video_ssrc ? i3.video_ssrc.push(s3.video_ssrc[0]) : s3.screen_ssrc && i3.screen_ssrc ? i3.screen_ssrc.push(s3.screen_ssrc[0]) : Object.assign(i3, s3));
              }
              return i3;
            })(), s2 = {};
            return i2 && r2 ? Object.keys(i2).forEach((e3) => {
              const t3 = i2[e3], a2 = r2[e3];
              if (s2[e3] = [], a2) for (let i3 = 0; i3 < t3.length; i3++) a2[i3] && s2[e3].push(Object.assign(t3[i3], a2[i3]));
              else s2[e3] = t3;
            }) : i2 ? Object.assign(s2, i2) : r2 && Object.assign(s2, r2), d.getParameters().showStatsLog && ("send" === t2 ? this.statsInfo.send.logger.warn("getStats send", s2) : this.statsInfo.recv.logger.warn("getStats recv", s2)), s2;
          }
          formatChromeNonStandardStats(e2, t2, i2, r2) {
            const s2 = [], a2 = [], o2 = [], d2 = [], c2 = [], m2 = { data: [] };
            Object.values(t2).forEach((t3) => {
              var g3, f2, v2, y2, _2, R, b, T, E, A, I, w, C, O, k, P, x, M, D, N, L, F, V, H, j, U, B, $, W;
              if (t3.id.includes("Conn-") && "true" === t3.googActiveConnection && (null === (g3 = this.formativeStatsReport) || void 0 === g3 || g3.formatTransportData(t3, i2)), t3.id.includes("Cand-") && t3.networkType) this.adapterRef.transportStats.NetworkType = t3.networkType || "";
              else if ("bweforvideo" === t3.id && "send" === i2) t3 = function(e3) {
                const t4 = { googAvailableSendBandwidth: 1, googTargetEncBitrate: 1, googActualEncBitrate: 1, googRetransmitBitrate: 1, googTransmitBitrate: 1 };
                return Object.keys(e3).map((i3) => {
                  t4[i3] && (e3[i3] = parseInt(e3[i3]) / 1024);
                }), e3;
              }(t3), this.adapterRef.transportStats.OutgoingAvailableBandwidth = t3.googAvailableSendBandwidth, c2.push({ googActualEncBitrate: parseInt(t3.googActualEncBitrate) || 0, googAvailableSendBandwidth: parseInt(t3.googAvailableSendBandwidth) || 0, googRetransmitBitrate: parseInt(t3.googRetransmitBitrate) || 0, googAvailableReceiveBandwidth: parseInt(t3.googAvailableReceiveBandwidth) || 0, googTargetEncBitrate: parseInt(t3.googTargetEncBitrate) || 0, googTransmitBitrate: parseInt(t3.googTransmitBitrate) || 0, googBucketDelay: parseInt(t3.googBucketDelay) || 0 });
              else if (/^ssrc_/i.test(t3.id)) {
                const c3 = null === (f2 = null == this ? void 0 : this.adapterRef) || void 0 === f2 ? void 0 : f2.instance.getUidAndKindBySsrc(parseInt(t3.ssrc)), g4 = null == c3 ? void 0 : c3.uid, G = null == c3 ? void 0 : c3.streamType;
                let J = "";
                J = (null == c3 ? void 0 : c3.kind) ? c3.kind : "screen" === t3.googContentType ? "screen" : t3.mediaType;
                let q = {};
                if ("send" === i2) {
                  if ("audio" === t3.mediaType) {
                    void 0 !== t3.audioInputLevel && (q.audioInputLevel = parseInt(t3.audioInputLevel)), q.totalAudioEnergy = parseInt(t3.totalAudioEnergy), q.totalSamplesDuration = parseInt(t3.totalSamplesDuration), q.bytesSent = parseInt(t3.bytesSent), q.packetsSent = parseInt(t3.packetsSent), q.packetsLost = parseInt(t3.packetsLost), q.rtt = parseInt(t3.googRtt), q.jitterReceived = parseInt(t3.googJitterReceived), void 0 !== t3.googEchoCancellationReturnLoss && (q.echoReturnLoss = "" + t3.googEchoCancellationReturnLoss), void 0 !== t3.googEchoCancellationReturnLossEnhancement && (q.echoReturnLossEnhancement = t3.googEchoCancellationReturnLossEnhancement), null === (v2 = this.formativeStatsReport) || void 0 === v2 || v2.formatSendData(q, J);
                    const i3 = { CodecType: "Opus", rtt: q.rtt || 0, MuteState: (null === (b = null === (R = null === (_2 = null === (y2 = null == this ? void 0 : this.adapterRef) || void 0 === y2 ? void 0 : y2.localStream) || void 0 === _2 ? void 0 : _2.muteStatus) || void 0 === R ? void 0 : R.audio) || void 0 === b ? void 0 : b.send) || false, RecordingLevel: q.audioInputLevel || 0, SamplingRate: S(null === (E = null === (T = null == this ? void 0 : this.adapterRef) || void 0 === T ? void 0 : T.localStream) || void 0 === E ? void 0 : E.audioProfile), SendBitrate: q.bitsSentPerSecond || 0, SendLevel: q.audioInputLevel || 0 };
                    "audio" === J ? (s2.push(q), (null === (A = e2.audioSender) || void 0 === A ? void 0 : A.track) ? this.adapterRef.localAudioStats[0] = i3 : this.adapterRef.localAudioStats = []) : "audioSlave" === J && (a2.push(q), (null === (I = e2.audioSlaveSender) || void 0 === I ? void 0 : I.track) ? this.adapterRef.localAudioSlaveStats[0] = i3 : this.adapterRef.localAudioSlaveStats = []);
                  } else if ("video" === t3.mediaType) {
                    q.bytesSent = parseInt(t3.bytesSent), q.packetsSent = parseInt(t3.packetsSent), q.packetsLost = parseInt(t3.packetsLost), q.firCount = parseInt(t3.googFirsReceived), q.pliCount = parseInt(t3.googPlisReceived), q.nackCount = parseInt(t3.googNacksReceived), void 0 !== t3.framesEncoded && (q.framesEncoded = parseInt(t3.framesEncoded)), q.avgEncodeMs = parseInt(t3.googAvgEncodeMs), q.encodeUsagePercent = parseInt(t3.googEncodeUsagePercent), q.frameRateInput = parseInt(t3.googFrameRateInput), q.frameRateSent = parseInt(t3.googFrameRateSent), q.frameWidthInput = parseInt(t3.googFrameWidthInput), q.frameWidthSent = parseInt(t3.googFrameWidthSent), q.frameHeightInput = parseInt(t3.googFrameHeightInput), q.frameHeightSent = parseInt(t3.googFrameHeightSent), void 0 !== t3.hugeFramesSent && (q.hugeFramesSent = parseInt(t3.hugeFramesSent)), "qpSum" in t3 && (q.qpSum = parseInt(t3.qpSum)), q.qualityLimitationReason = function(e3) {
                      return e3.googBandwidthLimitedResolution ? 1 : e3.googCpuLimitedResolution ? 2 : e3.googHasEnteredLowResolution ? 3 : 0;
                    }(t3), q.qualityLimitationResolutionChanges = parseInt(t3.googAdaptationChanges), q.rtt = parseInt(t3.googRtt), q.streamType = G, "high" === G && (null === (w = this.formativeStatsReport) || void 0 === w || w.formatSendData(q, J));
                    const i3 = { LayerType: 1, CodecName: t3.googCodecName || "h264", CodecImplementationName: t3.codecImplementationName || "", CaptureFrameRate: q.frameRateInput || 0, CaptureResolutionHeight: q.frameHeightInput || 0, CaptureResolutionWidth: q.frameWidthInput || 0, EncodeDelay: q.avgEncodeMs || 0, MuteState: (null === (k = null === (O = null === (C = this.adapterRef.localStream) || void 0 === C ? void 0 : C.muteStatus) || void 0 === O ? void 0 : O.video) || void 0 === k ? void 0 : k.send) || false, SendBitrate: q.bitsSentPerSecond || 0, SendFrameRate: q.frameRateSent || 0, SendResolutionHeight: q.frameHeightSent || 0, SendResolutionWidth: q.frameWidthSent || 0, TargetSendBitrate: q.bitsSentPerSecond || 0, TotalDuration: void 0 !== (null === (P = null == this ? void 0 : this.adapterRef) || void 0 === P ? void 0 : P.state.startPubVideoTime) ? (Date.now() - this.adapterRef.state.startPubVideoTime) / 1e3 : 0, TotalFreezeTime: q.totalFreezeTime || 0 };
                    if ("video" === J) if (o2.push(q), null === (x = e2.videoSender) || void 0 === x ? void 0 : x.track) {
                      if ("high" === G) {
                        const e3 = this.adapterRef.localVideoStats[0];
                        this.adapterRef.localVideoStats[0] = i3, m2.data.push({ mediaType: "video", streamType: "high", old: e3, new: i3 });
                      }
                    } else m2.data.push({ mediaType: "video", streamType: "high", old: this.adapterRef.localVideoStats[0] || null, new: null }), this.adapterRef.localVideoStats = [];
                    else if ("screen" === J) {
                      if (null === (M = e2.screenSender) || void 0 === M ? void 0 : M.track) {
                        if ("high" === G) {
                          i3.MuteState = (null === (L = null === (N = null === (D = this.adapterRef.localStream) || void 0 === D ? void 0 : D.muteStatus) || void 0 === N ? void 0 : N.screen) || void 0 === L ? void 0 : L.send) || false, i3.TotalDuration = void 0 !== (null === (F = null == this ? void 0 : this.adapterRef) || void 0 === F ? void 0 : F.state.startPubScreenTime) ? (Date.now() - this.adapterRef.state.startPubScreenTime) / 1e3 : 0, i3.LayerType = 2;
                          const e3 = this.adapterRef.localScreenStats[0];
                          this.adapterRef.localScreenStats[0] = i3, m2.data.push({ mediaType: "screen", streamType: "high", old: e3, new: i3 });
                        }
                      } else m2.data.push({ mediaType: "screen", streamType: "high", old: this.adapterRef.localScreenStats[0] || null, new: null }), this.adapterRef.localScreenStats = [];
                      d2.push(q);
                    }
                  }
                } else if ("recv" === i2) {
                  if (!g4) return {};
                  if (null === (V = this.formativeStatsReport) || void 0 === V || V.clearFirstRecvData(g4), q.remoteuid = g4, "audio" === t3.mediaType) {
                    q.audioOutputLevel = parseInt(t3.audioOutputLevel), q.totalAudioEnergy = parseInt(t3.totalAudioEnergy), q.totalSamplesDuration = parseInt(t3.totalSamplesDuration), q.bytesReceived = parseInt(t3.bytesReceived), q.packetsReceived = parseInt(t3.packetsReceived), q.packetsLost = parseInt(t3.packetsLost), q.decodingPLC = parseInt(t3.googDecodingPLC), q.decodingPLCCNG = parseInt(t3.googDecodingPLCCNG), q.decodingNormal = parseInt(t3.googDecodingNormal), q.decodingMuted = parseInt(t3.googDecodingMuted), q.decodingCNG = parseInt(t3.googDecodingCNG), q.decodingCTN = parseInt(t3.googDecodingCTN), q.currentDelayMs = parseInt(t3.googCurrentDelayMs), q.preferredJitterBufferMs = parseInt(t3.googPreferredJitterBufferMs), q.jitterBufferMs = parseInt(t3.googJitterBufferMs), q.jitter = parseInt(t3.googJitterReceived), q.preemptiveExpandRate = parseInt(t3.googPreemptiveExpandRate), q.speechExpandRate = parseInt(t3.googAccelerateRate), q.secondaryDecodedRate = parseInt(t3.googSecondaryDecodedRate), q.secondaryDiscardedRate = parseInt(t3.googSecondaryDiscardedRate), null === (H = this.formativeStatsReport) || void 0 === H || H.formatRecvData(q, J);
                    const e3 = null === (j = null == this ? void 0 : this.adapterRef) || void 0 === j ? void 0 : j.remoteStreamMap[q.remoteuid], i3 = null == e3 ? void 0 : e3.muteStatus[J], o3 = !!i3 && (i3.send || i3.recv), d3 = { CodecType: "Opus", End2EndDelay: (parseInt(t3.googCurrentDelayMs) || 0) + (parseInt(t3.googJitterBufferMs) || 0), MuteState: o3, PacketLossRate: q.packetsLostRate || 0, RecvBitrate: q.bitsReceivedPerSecond || 0, RecvLevel: q.audioOutputLevel || 0, TotalFreezeTime: q.totalFreezeTime || 0, TotalPlayDuration: parseInt(t3.totalSamplesDuration) || 0, TransportDelay: parseInt(t3.googCurrentDelayMs) || 0 };
                    if ("audio" === J) {
                      if (q.remoteuid && (this.adapterRef.remoteAudioStats[q.remoteuid] = d3), s2.push(q), n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION < 69 && "audio" === r2) {
                        let e4 = s2[0] && s2[0].remoteuid, t4 = l.findIndex((t5) => t5.remoteuid === e4);
                        -1 === t4 ? l.push(s2[0]) : l[t4] = s2[0];
                      }
                    } else if ("audioSlave" === J && (q.remoteuid && (this.adapterRef.remoteAudioSlaveStats[q.remoteuid] = d3), a2.push(q), n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION < 69 && "audioSlave" === r2)) {
                      let e4 = a2[0] && a2[0].remoteuid, t4 = h.findIndex((t5) => t5.remoteuid === e4);
                      -1 === t4 ? h.push(a2[0]) : h[t4] = a2[0];
                    }
                  } else if ("video" === t3.mediaType) {
                    q.bytesReceived = parseInt(t3.bytesReceived), q.bitsReceivedPerSecond = 0, q.packetsReceived = parseInt(t3.packetsReceived), q.packetsLost = parseInt(t3.packetsLost), q.firCount = parseInt(t3.googFirsSent), q.pliCount = parseInt(t3.googPlisSent), q.nackCount = parseInt(t3.googNacksSent), q.framesDecoded = parseInt(t3.framesDecoded), q.decodeMs = parseInt(t3.googDecodeMs), q.frameRateDecoded = parseInt(t3.googFrameRateDecoded), q.frameRateOutput = parseInt(t3.googFrameRateOutput), q.frameRateReceived = parseInt(t3.googFrameRateReceived), q.frameWidthReceived = parseInt(t3.googFrameWidthReceived), q.frameHeightReceived = parseInt(t3.googFrameHeightReceived), q.currentDelayMs = parseInt(t3.googCurrentDelayMs), void 0 !== t3.googJitterBufferMs && (q.jitterBufferDelay = parseInt(t3.googJitterBufferMs)), null === (U = this.formativeStatsReport) || void 0 === U || U.formatRecvData(q, J);
                    const e3 = null === (B = null == this ? void 0 : this.adapterRef) || void 0 === B ? void 0 : B.remoteStreamMap[q.remoteuid];
                    let i3 = e3 && e3.Play && (null === ($ = null == e3 ? void 0 : e3.Play) || void 0 === $ ? void 0 : $.video.dom), s3 = e3 && (e3.muteStatus.video.send || e3.muteStatus.video.recv) || false;
                    "screen" === J && (i3 = e3 && e3.Play && (null === (W = null == e3 ? void 0 : e3.Play) || void 0 === W ? void 0 : W.screen.dom), s3 = e3 && (e3.muteStatus.screen.send || e3.muteStatus.screen.recv) || false);
                    const a3 = { LayerType: 1, CodecName: t3.googCodecName, End2EndDelay: (parseInt(t3.googCurrentDelayMs) || 0) + (parseInt(t3.googJitterBufferMs) || 0) + (parseInt(t3.googRenderDelayMs) || 0), MuteState: s3, PacketLossRate: q.packetsLostRate || 0, RecvBitrate: q.bitsReceivedPerSecond || 0, RecvResolutionHeight: q.frameHeightReceived || 0, RecvResolutionWidth: q.frameWidthReceived || 0, RenderFrameRate: q.frameRateOutput || 0, RenderResolutionHeight: i3 ? i3.videoHeight : 0, RenderResolutionWidth: i3 ? i3.videoWidth : 0, TotalFreezeTime: t3.totalFreezeTime || 0, TotalPlayDuration: i3 && i3.played && i3.played.length ? i3.played.end(0) : 0, TransportDelay: parseInt(t3.googCurrentDelayMs) || 0 };
                    if ("video" === J) {
                      if (this.adapterRef.remoteVideoStats[q.remoteuid] = a3, o2.push(q), n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION < 69 && "video" === r2) {
                        let e4 = o2[0] && o2[0].remoteuid, t4 = u.findIndex((t5) => t5.remoteuid === e4);
                        -1 === t4 ? u.push(o2[0]) : u[t4] = o2[0];
                      }
                    } else if ("screen" === J && (a3.LayerType = 2, this.adapterRef.remoteScreenStats[q.remoteuid] = a3, d2.push(q), n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION < 69 && "screen" === r2)) {
                      let e4 = d2[0] && d2[0].remoteuid, t4 = p.findIndex((t5) => t5.remoteuid === e4);
                      -1 === t4 ? p.push(d2[0]) : p[t4] = d2[0];
                    }
                  }
                }
              }
            }), this.adapterRef.instance.safeEmit("@media-stats-change", m2);
            const g2 = {};
            if (n.ANY_CHROME_MAJOR_VERSION && n.ANY_CHROME_MAJOR_VERSION < 69 && "recv" === i2) "audio" === r2 ? g2.audio_ssrc = l : "video" === r2 ? g2.video_ssrc = u : "audioSlave" === r2 ? g2.audioSlave_ssrc = h : "screen" === r2 && (g2.screen_ssrc = p);
            else {
              if (s2.length && (g2.audio_ssrc = s2), a2.length && (g2.audioSlave_ssrc = a2), o2.length) {
                if (o2.length > 1) {
                  "low" === (o2[0] || {}).streamType && ([o2[0], o2[1]] = [o2[1], o2[0]]);
                }
                g2.video_ssrc = o2;
              }
              if (d2.length) {
                if (d2.length > 1) {
                  "low" === (d2[0] || {}).streamType && ([d2[0], d2[1]] = [d2[1], d2[0]]);
                }
                g2.screen_ssrc = d2;
              }
              c2.length && (g2.bwe = c2);
            }
            return g2;
          }
          formatChromeStandardizedStats(e2, t2) {
            var i2, r2, s2, a2, o2, n2, l2;
            const u2 = new c.FormativeStatsAudio(), h2 = new c.FormativeStatsVideo();
            let p2 = 0;
            e2.forEach((e3) => {
              var i3;
              const r3 = this.statsInfo[t2].statsMapHistory[e3.id];
              let s3 = null;
              if (r3) {
                for (let t3 = r3.length - 1; t3 >= 0; t3--) s3 ? r3.splice(t3, 1) : e3.timestamp - r3[t3].timestamp >= d.getParameters().statsHistoryInterval && (s3 = r3[t3]);
                r3.length < 10 && e3.timestamp && r3.push(e3);
              } else this.statsInfo[t2].statsMapHistory[e3.id] = [e3];
              if ("media-source" == e3.type) "audio" === e3.kind ? (u2.audioInputLevel = Math.round(32768 * e3.audioLevel), u2.totalAudioEnergy = Math.round(32768 * e3.totalAudioEnergy), u2.totalSamplesDuration = Math.round(e3.totalSamplesDuration), e3.echoReturnLoss && (u2.echoReturnLoss = "" + e3.echoReturnLoss), e3.echoReturnLossEnhancement && (u2.echoReturnLossEnhancement = "" + 100 * e3.echoReturnLossEnhancement)) : "video" === e3.kind && (h2.frameRateInput = e3.framesPerSecond, h2.frameWidthInput = e3.width, h2.frameHeightInput = e3.height);
              else if ("media-playout" === e3.type) {
                if ("audio" === e3.kind && s3) {
                  const t3 = 1e3 * _(e3, s3, "totalPlayoutDelay") / _(e3, s3, "totalSamplesCount");
                  u2.playoutDelayMs = t3;
                }
              } else if ("outbound-rtp" == e3.type) {
                if (p2 = e3.ssrc, "audio" === e3.kind) {
                  if (y(u2, "targetBitrate", e3.targetBitrate / 1e3), u2.bytesSent = e3.headerBytesSent + e3.bytesSent, u2.packetsSent = e3.packetsSent, s3 && "send" === t2) {
                    const t3 = _(e3, s3, "bytesSent"), i4 = _(e3, s3, "headerBytesSent");
                    y(u2, "bitsSentPerSecond", 8e-3 * (t3 + i4));
                    const r4 = _(e3, s3, "packetsSent");
                    y(u2, "packetsSentPerSecond", r4);
                  }
                  y(u2, "nackCount", e3.nackCount), "active" in e3 && (u2.active = e3.active ? 1 : 0);
                } else if ("video" === e3.kind) {
                  if ("active" in e3 && (h2.active = e3.active ? 1 : 0), h2.bytesSent = e3.headerBytesSent + e3.bytesSent, h2.firCount = e3.firCount, h2.nackCount = e3.nackCount, h2.pliCount = e3.pliCount, y(h2, "framesEncoded", e3.framesEncoded), y(h2, "framesSent", e3.framesSent), y(h2, "hugeFramesSent", e3.hugeFramesSent), h2.packetsSent = e3.packetsSent, "qpSum" in e3 && (h2.qpSum = e3.qpSum), s3 && "send" === t2) {
                    const t3 = _(e3, s3, "bytesSent"), i4 = _(e3, s3, "headerBytesSent");
                    y(h2, "bitsSentPerSecond", 8e-3 * (t3 + i4));
                    const r4 = _(e3, s3, "packetsSent");
                    y(h2, "packetsSentPerSecond", r4);
                    const a4 = _(e3, s3, "framesEncoded");
                    y(h2, "framesEncodedPerSecond", a4);
                    const o3 = _(e3, s3, "qpSum");
                    y(h2, "qpPercentage", o3 / a4);
                    const n3 = 100 * _(e3, s3, "totalEncodeTime");
                    y(h2, "encodeUsagePercent", n3);
                  }
                  if (h2.qualityLimitationReason = "" + ("bandwidth" === (a3 = e3.qualityLimitationReason) ? 1 : "cpu" === a3 ? 2 : "other" === a3 ? 3 : 0), h2.qualityLimitationResolutionChanges = e3.qualityLimitationResolutionChanges, h2.CodecImplementationName = e3.encoderImplementation, y(h2, "targetBitrate", e3.targetBitrate / 1e3), y(h2, "frameRateSent", e3.framesPerSecond), "frameWidth" in e3 && (h2.frameWidthSent = e3.frameWidth), "frameHeight" in e3 && (h2.frameHeightSent = e3.frameHeight), e3.framesEncoded && e3.totalEncodeTime && s3) {
                    const t3 = 1e3 * (e3.totalEncodeTime - s3.totalEncodeTime) / (e3.framesEncoded - s3.framesEncoded);
                    y(h2, "avgEncodeMs", t3);
                  }
                }
              } else if ("remote-inbound-rtp" == e3.type) {
                if ("audio" === e3.kind) {
                  if (y(u2, "fractionLost", 100 * e3.fractionLost), u2.jitterReceived = Math.round(1e3 * e3.jitter), u2.packetsLost = e3.packetsLost, s3 && "send" === t2) {
                    const t3 = _(e3, s3, "packetsLost") / (u2.packetsSentPerSecond || 50) * 100;
                    y(u2, "packetsLostRate", t3);
                  }
                  y(u2, "rtt", 1e3 * e3.roundTripTime);
                } else if ("video" === e3.kind) {
                  if (y(h2, "fractionLost", 100 * e3.fractionLost), h2.jitter = Math.round(1e3 * e3.jitter), h2.packetsLost = e3.packetsLost, s3 && "send" === t2) {
                    const t3 = _(e3, s3, "packetsLost") / (h2.packetsSentPerSecond || 0) * 100;
                    y(h2, "packetsLostRate", t3);
                  }
                  y(h2, "rtt", 1e3 * e3.roundTripTime);
                }
              } else if ("inbound-rtp" == e3.type) {
                if (p2 = e3.ssrc, "audio" === e3.kind) {
                  if (y(u2, "audioOutputLevel", 32768 * e3.audioLevel), y(u2, "totalAudioEnergy", 32768 * e3.totalAudioEnergy), y(u2, "totalSamplesDuration", e3.totalSamplesReceived / 48e3), u2.bytesReceived = e3.headerBytesReceived + e3.bytesReceived, y(u2, "concealedSamples", e3.concealedSamples), y(u2, "estimatedPlayoutTimestamp", e3.estimatedPlayoutTimestamp - e3.timestamp), y(u2, "jitter", 1e3 * e3.jitter), y(u2, "jitterBufferDelay", 1e3 * e3.jitterBufferDelay), s3) {
                    const t3 = 1e3 * _(e3, s3, "removedSamplesForAcceleration") / _(e3, s3, "totalSamplesCount");
                    y(u2, "speechExpandRate", t3);
                    const i4 = 1e3 * _(e3, s3, "insertedSamplesForDeceleration") / _(e3, s3, "totalSamplesCount");
                    y(u2, "preemptiveExpandRate", i4);
                  }
                  if (y(u2, "preferredJitterBufferMs", 1e3 * e3.jitterBufferTargetDelay / e3.jitterBufferEmittedCount), y(u2, "secondaryDecodedRate", e3.fecPacketsReceived - e3.fecPacketsDiscarded), y(u2, "secondaryDiscardedRate", e3.fecPacketsDiscarded), y(u2, "lastPacketReceivedTimestamp", e3.timestamp - e3.lastPacketReceivedTimestamp), y(u2, "nackCount", e3.nackCount), y(u2, "silentConcealedSamples", e3.silentConcealedSamples), u2.packetsLost = e3.packetsLost, u2.packetsReceived = e3.packetsReceived, s3 && "recv" === t2) {
                    const t3 = 8e-3 * _(e3, s3, "bytesReceived");
                    y(u2, "bitsReceivedPerSecond", t3);
                    const i4 = _(e3, s3, "packetsReceived");
                    y(u2, "packetsReceivedPerSecond", i4);
                    const r4 = _(e3, s3, "packetsLost"), a4 = r4 / (i4 + r4 || 50) * 100;
                    a4 >= 0 ? y(u2, "packetsLostRate", a4) : u2.packetsLostRate = 0;
                    const o3 = 1e3 * _(e3, s3, "jitterBufferDelay") / _(e3, s3, "jitterBufferEmittedCount");
                    y(u2, "jitterBufferMs", o3);
                  }
                } else if ("video" === e3.kind) {
                  h2.bytesReceived = e3.bytesReceived + e3.headerBytesReceived, y(h2, "lastPacketReceivedTimestamp", e3.timestamp - e3.lastPacketReceivedTimestamp), y(h2, "estimatedPlayoutTimestamp", e3.estimatedPlayoutTimestamp - e3.timestamp), h2.firCount = e3.firCount, h2.nackCount = e3.nackCount, h2.pliCount = e3.pliCount, h2.framesDecoded = e3.framesDecoded, y(h2, "framesDropped", e3.framesDropped), y(h2, "framesReceived", e3.framesReceived), h2.packetsReceived = e3.packetsReceived, h2.packetsLost = e3.packetsLost, y(h2, "pauseCount", e3.pauseCount), y(h2, "totalPausesDuration", 1e3 * e3.totalPausesDuration), y(h2, "freezeCount", e3.freezeCount), y(h2, "totalFreezesDuration", 1e3 * e3.totalFreezesDuration), y(h2, "frameRateReceived", e3.framesPerSecond), y(h2, "frameWidthReceived", e3.frameWidth), y(h2, "frameHeightReceived", e3.frameHeight);
                  const i4 = e3.decoderImplementation;
                  if (h2.powerEfficientDecoder = "OpenH264" === i4 ? 2 : i4 ? 1 : 0, y(h2, "jitterBufferDelay", 1e3 * e3.jitterBufferDelay), s3 && "recv" === t2) {
                    const t3 = 8e-3 * _(e3, s3, "bytesReceived");
                    y(h2, "bitsReceivedPerSecond", t3);
                    const i5 = _(e3, s3, "packetsReceived");
                    y(h2, "packetsReceivedPerSecond", i5);
                    const r4 = _(e3, s3, "packetsLost"), a4 = r4 / (i5 + r4) * 100;
                    a4 >= 0 && y(h2, "packetsLostRate", a4);
                    const o3 = 1e3 * _(e3, s3, "totalDecodeTime"), n3 = _(e3, s3, "framesDecoded");
                    y(h2, "decodeMs", o3 / n3);
                    const d2 = _(e3, s3, "framesDecoded");
                    y(h2, "frameRateDecoded", d2);
                    const c2 = _(e3, s3, "framesDropped");
                    y(h2, "frameRateOutput", d2 - c2);
                    const l3 = 1e3 * _(e3, s3, "jitterBufferDelay") / _(e3, s3, "jitterBufferEmittedCount");
                    y(h2, "jitterBufferMs", l3);
                  }
                }
              } else if ("remote-outbound-rtp" == e3.type) "audio" === e3.kind ? (e3.jitter && y(u2, "jitter", 1e3 * e3.jitter), e3.roundTripTime && y(u2, "rtt", 1e3 * e3.roundTripTime)) : e3.kind;
              else if ("track" == e3.type) "recv" === t2 && "audio" === e3.kind && y(u2, "audioOutputLevel", 32768 * e3.audioLevel), "audio" === e3.kind ? "ended" in e3 && (u2.active = e3.ended ? 0 : 1) : "video" === e3.kind && "ended" in e3 && (h2.active = e3.ended ? 0 : 1);
              else if ("candidate-pair" === e3.type) y(u2, "rtt", 1e3 * e3.currentRoundTripTime), y(h2, "rtt", 1e3 * e3.currentRoundTripTime), this.statsInfo[t2].cpStats = e3, null === (i3 = this.formativeStatsReport) || void 0 === i3 || i3.formatTransportDataChrome117(e3, t2);
              else if ("codec" === e3.type && e3.mimeType) {
                const [t3, i4] = e3.mimeType.split("/");
                "audio" === t3 ? "audio/opus" === e3.mimeType ? u2.CodecType = "Opus" : u2.CodecType = i4 : "video" === t3 ? e3.mimeType && (h2.CodecName = i4) : (u2.CodecType = e3.mimeType, h2.CodecName = e3.mimeType);
              }
              var a3;
            });
            const m2 = null === (i2 = null == this ? void 0 : this.adapterRef) || void 0 === i2 ? void 0 : i2.instance.getUidAndKindBySsrc(p2);
            if (!p2 || !m2) return {};
            let g2 = null == m2 ? void 0 : m2.kind;
            if ("recv" === t2 && ("audio" === g2 || "audioSlave" === g2 ? (u2.jitterBufferMs && y(u2, "currentDelayMs", u2.jitterBufferMs + (u2.playoutDelayMs || 0)), u2.rtt && (u2.End2EndDelay = u2.rtt + (u2.jitterBufferMs || 0))) : "video" !== g2 && "screen" !== g2 || (h2.jitterBufferMs && y(h2, "currentDelayMs", h2.jitterBufferMs), h2.rtt && (h2.End2EndDelay = h2.rtt + (h2.jitterBufferMs || 0)))), "send" === t2) {
              const e3 = this.adapterRef.localStream;
              if ("video" === g2 || "screen" === g2) {
                if (h2.streamType = (null == m2 ? void 0 : m2.streamType) || "high", "supported" !== this.chromeLegecy && "high" === h2.streamType) {
                  null === (r2 = this.formativeStatsReport) || void 0 === r2 || r2.formatSendData(h2, g2), h2.LayerType = "video" === g2 ? 1 : 2, h2.CaptureFrameRate = h2.frameRateInput, h2.CaptureResolutionHeight = h2.frameHeightInput, h2.CaptureResolutionWidth = h2.frameWidthInput, h2.EncodeDelay = h2.avgEncodeMs, e3 && (h2.MuteState = e3.getMuteStatus(g2).muted), h2.SendBitrate = h2.bitsSentPerSecond, h2.SendFrameRate = h2.frameRateSent, h2.SendResolutionHeight = h2.frameHeightSent, h2.SendResolutionWidth = h2.frameWidthSent, h2.TargetSendBitrate = h2.targetBitrate, h2.TotalFreezeTime = h2.totalFreezeTime, "video" === g2 && this.adapterRef.state.startPubVideoTime && (h2.TotalDuration = (Date.now() - this.adapterRef.state.startPubVideoTime) / 1e3), "screen" === g2 && this.adapterRef.state.startPubScreenTime && (h2.TotalDuration = (Date.now() - this.adapterRef.state.startPubScreenTime) / 1e3);
                  const t3 = { LayerType: h2.LayerType, CodecName: h2.CodecName, CodecImplementationName: h2.CodecImplementationName, CaptureFrameRate: h2.CaptureFrameRate, CaptureResolutionHeight: h2.CaptureResolutionHeight, CaptureResolutionWidth: h2.CaptureResolutionWidth, EncodeDelay: h2.EncodeDelay, MuteState: h2.MuteState, SendBitrate: h2.SendBitrate, SendFrameRate: h2.SendFrameRate, SendResolutionHeight: h2.SendResolutionHeight, SendResolutionWidth: h2.SendResolutionWidth, TargetSendBitrate: h2.TargetSendBitrate, TotalDuration: h2.TotalDuration, TotalFreezeTime: h2.TotalFreezeTime }, i3 = "video" === g2 ? this.adapterRef.localVideoStats : this.adapterRef.localScreenStats;
                  "high" === h2.streamType ? i3[0] = t3 : i3[1] = t3;
                }
              } else if (("audio" === g2 || "audioSlave" === g2) && "supported" !== this.chromeLegecy) {
                null === (s2 = this.formativeStatsReport) || void 0 === s2 || s2.formatSendData(u2, g2), e3 && (u2.MuteState = e3.getMuteStatus(g2).muted, "audio" === g2 && e3.audioLevelHelper ? u2.RecordingLevel = Math.round(32768 * e3.audioLevelHelper.volume) : "audioSlave" === g2 && e3.audioLevelHelperSlave ? u2.RecordingLevel = Math.round(32768 * e3.audioLevelHelperSlave.volume) : u2.RecordingLevel = u2.audioInputLevel, u2.SamplingRate = S(e3.audioProfile), u2.SendBitrate = u2.bitsSentPerSecond, u2.SendLevel = u2.audioInputLevel);
                const t3 = { CodecType: u2.CodecType, rtt: u2.rtt, MuteState: u2.MuteState, RecordingLevel: u2.RecordingLevel, SamplingRate: u2.SamplingRate, SendBitrate: u2.SendBitrate, SendLevel: u2.SendLevel };
                "audio" === g2 ? this.adapterRef.localAudioStats[0] = t3 : "audioSlave" === g2 && (this.adapterRef.localAudioSlaveStats[0] = t3);
              }
            }
            const f2 = {};
            if ("recv" === t2) {
              const e3 = (null == m2 ? void 0 : m2.uid) ? this.adapterRef.remoteStreamMap[null == m2 ? void 0 : m2.uid] : null;
              if ("video" === g2 || "screen" === g2) {
                h2.remoteuid = "" + (null == m2 ? void 0 : m2.uid);
                const t3 = null === (a2 = null == e3 ? void 0 : e3._play[g2]) || void 0 === a2 ? void 0 : a2.dom;
                if ("supported" !== this.chromeLegecy) {
                  null === (o2 = this.formativeStatsReport) || void 0 === o2 || o2.formatRecvData(h2, g2), h2.LayerType = "video" === g2 ? 1 : 2, e3 && (h2.MuteState = e3.getMuteStatus(g2).muted), h2.PacketLossRate = h2.packetsLostRate, h2.RecvBitrate = h2.bitsReceivedPerSecond, h2.RecvResolutionHeight = h2.frameHeightReceived, h2.RecvResolutionWidth = h2.frameWidthReceived, h2.RenderFrameRate = h2.frameRateReceived, t3 && (h2.RenderResolutionHeight = t3.videoHeight, h2.RenderResolutionWidth = t3.videoWidth, (null === (n2 = t3.played) || void 0 === n2 ? void 0 : n2.length) && t3.played.end && (h2.TotalPlayDuration = t3.played.end(0))), h2.TotalFreezeTime = h2.totalFreezeTime, h2.TransportDelay = h2.rtt;
                  const i3 = { LayerType: h2.LayerType, CodecName: h2.CodecName, End2EndDelay: h2.End2EndDelay, MuteState: h2.MuteState, PacketLossRate: h2.PacketLossRate, RecvBitrate: h2.RecvBitrate, RecvResolutionHeight: h2.RecvResolutionHeight, RecvResolutionWidth: h2.RecvResolutionWidth, RenderFrameRate: h2.RenderFrameRate, RenderResolutionHeight: h2.RenderResolutionHeight, RenderResolutionWidth: h2.RenderResolutionWidth, TotalFreezeTime: h2.TotalFreezeTime, TotalPlayDuration: h2.TotalPlayDuration, TransportDelay: h2.TransportDelay };
                  "video" === g2 ? this.adapterRef.remoteVideoStats[h2.remoteuid] = i3 : this.adapterRef.remoteScreenStats[h2.remoteuid] = i3;
                }
              } else if ("audio" === g2 || "audioSlave" === g2) {
                if (u2.remoteuid = "" + (null == m2 ? void 0 : m2.uid), "supported" !== this.chromeLegecy) {
                  null === (l2 = this.formativeStatsReport) || void 0 === l2 || l2.formatRecvData(u2, g2), e3 && (u2.MuteState = e3.getMuteStatus(g2).muted), u2.PacketLossRate = u2.packetsLostRate, u2.RecvBitrate = u2.bitsReceivedPerSecond, u2.RecvLevel = u2.audioOutputLevel, u2.TotalFreezeTime = u2.totalFreezeTime, u2.TotalPlayDuration = u2.totalSamplesDuration, u2.TransportDelay = u2.rtt;
                  const t3 = { CodecType: u2.CodecType, End2EndDelay: u2.End2EndDelay, MuteState: u2.MuteState, PacketLossRate: u2.PacketLossRate, RecvBitrate: u2.RecvBitrate, RecvLevel: u2.RecvLevel, TotalFreezeTime: u2.TotalFreezeTime, TotalPlayDuration: u2.TotalPlayDuration, TransportDelay: u2.TransportDelay };
                  "audio" === g2 ? this.adapterRef.remoteAudioStats[u2.remoteuid] = t3 : "audioSlave" === g2 && (this.adapterRef.remoteAudioSlaveStats[u2.remoteuid] = t3);
                }
                if (u2.audioOutputLevel) {
                  const t3 = g2 && (null == e3 ? void 0 : e3.isPlaying(g2)) || false;
                  this.audioLevel.push({ uid: u2.remoteuid, level: t3 && +u2.audioOutputLevel || 0, type: g2 });
                }
              }
            }
            return (null == g2 ? void 0 : g2.includes("audio")) ? f2[g2 + "_ssrc"] = [u2] : "video" !== g2 && "screen" !== g2 || (f2[g2 + "_ssrc"] = [h2]), f2;
          }
          async safari(e2, t2) {
            var i2, r2;
            if (!e2.getTransceivers) return {};
            let s2 = { audio_ssrc: [], audioSlave_ssrc: [], video_ssrc: [], screen_ssrc: [] };
            const a2 = e2.getTransceivers();
            for (let e3 = 0; e3 < a2.length; e3++) {
              let o2 = null;
              const n2 = a2[e3];
              if ("sendonly" === n2.direction) {
                if (n2.sender && n2.sender.getStats) if (this.markStatsStart(t2), o2 = await n2.sender.getStats(), o2 = this.formatSafariStandardizedStats(o2, t2, (null === (i2 = n2.sender.track) || void 0 === i2 ? void 0 : i2.kind) || ""), o2.video_ssrc && s2.video_ssrc) {
                  if (s2.video_ssrc.push(o2.video_ssrc[0]), s2.video_ssrc.length > 1) {
                    "low" === (s2.video_ssrc[0] || {}).streamType && ([s2.video_ssrc[0], s2.video_ssrc[1]] = [s2.video_ssrc[1], s2.video_ssrc[0]]);
                  }
                } else if (o2.screen_ssrc && s2.screen_ssrc) {
                  if (s2.screen_ssrc.push(o2.screen_ssrc[0]), s2.screen_ssrc.length > 1) {
                    "low" === (s2.screen_ssrc[0] || {}).streamType && ([s2.screen_ssrc[0], s2.screen_ssrc[1]] = [s2.screen_ssrc[1], s2.screen_ssrc[0]]);
                  }
                } else Object.assign(s2, o2);
              } else "recvonly" === n2.direction && n2.receiver && n2.receiver.getStats && (this.markStatsStart(t2), o2 = await n2.receiver.getStats(), o2 = this.formatSafariStandardizedStats(o2, t2, (null === (r2 = n2.receiver.track) || void 0 === r2 ? void 0 : r2.kind) || ""), o2.audio_ssrc && s2.audio_ssrc ? s2.audio_ssrc.push(o2.audio_ssrc[0]) : o2.audioSlave_ssrc && s2.audioSlave_ssrc ? s2.audioSlave_ssrc.push(o2.audioSlave_ssrc[0]) : o2.video_ssrc && s2.video_ssrc ? s2.video_ssrc.push(o2.video_ssrc[0]) : o2.screen_ssrc && s2.screen_ssrc ? s2.screen_ssrc.push(o2.screen_ssrc[0]) : Object.assign(s2, o2));
            }
            return s2;
          }
          formatSafariStandardizedStats(e2, t2, i2) {
            var r2, s2, a2, o2, d2, c2, l2;
            const u2 = {}, h2 = {};
            let p2 = 0;
            e2.forEach((e3) => {
              "track" == e3.type ? "audio" === e3.kind || "audio" === i2 ? ("ended" in e3 && (u2.active = e3.ended ? 0 : 1), void 0 !== e3.audioLevel && (u2.audioOutputLevel = Math.round(32768 * e3.audioLevel))) : "video" !== e3.kind && "video" !== i2 || ("ended" in e3 && (h2.active = e3.ended ? 0 : 1), "send" === t2 ? (h2.frameWidthInput = e3.width || e3.frameWidth, h2.frameHeightInput = e3.height || e3.frameHeight, void 0 !== e3.framesSent && (h2.framesSent = e3.framesSent)) : "recv" === t2 && (h2.frameWidthReceived = e3.width || e3.frameWidth, h2.frameHeightReceived = e3.height || e3.frameHeight, void 0 !== e3.framesDecoded && (h2.framesDecoded = e3.framesDecoded), void 0 !== e3.framesReceived && (h2.framesReceived = e3.framesReceived), void 0 !== e3.framesDropped && (h2.framesDropped = e3.framesDropped))) : "outbound-rtp" == e3.type ? (p2 = e3.ssrc, "audio" === e3.kind || "audio" === e3.mediaType || "audio" === i2 ? (u2.bytesSent = (e3.headerBytesSent || 0) + e3.bytesSent, u2.packetsSent = e3.packetsSent, void 0 !== e3.nackCount && (u2.nackCount = e3.nackCount), "active" in e3 && (u2.active = e3.active)) : "video" !== e3.kind && "video" !== e3.mediaType && "video" !== i2 || ("active" in e3 && (h2.active = e3.active), h2.bytesSent = (e3.headerBytesSent || 0) + e3.bytesSent, h2.firCount = e3.firCount, h2.nackCount = e3.nackCount, h2.pliCount = e3.pliCount, h2.framesEncoded = e3.framesEncoded, void 0 !== e3.hugeFramesSent && (h2.hugeFramesSent = e3.hugeFramesSent), h2.packetsSent = e3.packetsSent, "qpSum" in e3 && (h2.qpSum = e3.qpSum), void 0 !== e3.qualityLimitationResolutionChanges && (h2.qualityLimitationResolutionChanges = e3.qualityLimitationResolutionChanges), void 0 !== e3.totalEncodeTime && (h2.avgEncodeMs = Math.round(1e3 * e3.totalEncodeTime / e3.framesEncoded)), void 0 !== e3.framesPerSecond && (h2.frameRateSent = e3.framesPerSecond), void 0 !== e3.frameWidth && (h2.frameWidthSent = e3.frameWidth), void 0 !== e3.frameHeight && (h2.frameHeightSent = e3.frameHeight), n.IS_ANY_SAFARI && n.SAFARI_MAJOR_VERSION && n.SAFARI_MAJOR_VERSION >= 17 && (h2.frameWidthInput = e3.frameWidth, h2.frameHeightInput = e3.frameHeight, void 0 !== e3.framesSent && (h2.framesSent = e3.framesSent)))) : "remote-inbound-rtp" == e3.type ? "audio" === e3.kind ? (void 0 !== e3.jitter && (u2.jitterReceived = Math.round(1e3 * e3.jitter)), void 0 !== e3.packetsLost && (u2.packetsLost = e3.packetsLost), u2.rtt = Math.round(1e3 * e3.roundTripTime)) : "video" === e3.kind && (void 0 !== e3.jitter && (h2.jitter = Math.round(1e3 * e3.jitter)), void 0 !== e3.packetsLost && (h2.packetsLost = e3.packetsLost), h2.rtt = Math.round(1e3 * e3.roundTripTime)) : "inbound-rtp" == e3.type ? (p2 = e3.ssrc, "audio" === e3.kind || "audio" === e3.mediaType || "audio" === i2 ? (void 0 !== e3.audioLevel && (u2.audioOutputLevel = Math.round(32768 * e3.audioLevel)), void 0 !== e3.totalAudioEnergy && (u2.totalAudioEnergy = Math.round(32768 * e3.totalAudioEnergy)), void 0 !== e3.totalSamplesReceived && (u2.totalSamplesDuration = Math.round(e3.totalSamplesReceived / 48e3)), u2.bytesReceived = (e3.headerBytesReceived || 0) + e3.bytesReceived, void 0 !== e3.concealedSamples && (u2.concealedSamples = e3.concealedSamples), void 0 !== e3.estimatedPlayoutTimestamp && (u2.estimatedPlayoutTimestamp = e3.estimatedPlayoutTimestamp), void 0 !== e3.jitter && (u2.jitter = Math.round(1e3 * e3.jitter)), void 0 !== e3.jitterBufferDelay && (u2.jitterBufferDelay = Math.round(1e3 * e3.jitterBufferDelay / e3.jitterBufferEmittedCount)), void 0 !== e3.lastPacketReceivedTimestamp && (u2.lastPacketReceivedTimestamp = e3.lastPacketReceivedTimestamp), void 0 !== e3.nackCount && (u2.nackCount = e3.nackCount), void 0 !== e3.silentConcealedSamples && (u2.silentConcealedSamples = e3.silentConcealedSamples), u2.packetsLost = e3.packetsLost, u2.packetsReceived = e3.packetsReceived, void 0 !== e3.jitter && (u2.jitter = Math.round(1e3 * e3.jitter))) : "video" !== e3.kind && "video" !== e3.mediaType && "video" !== i2 || (h2.bytesReceived = e3.bytesReceived + (e3.headerBytesReceived || 0), void 0 !== e3.estimatedPlayoutTimestamp && (h2.estimatedPlayoutTimestamp = e3.estimatedPlayoutTimestamp), void 0 !== e3.lastPacketReceivedTimestamp && (h2.lastPacketReceivedTimestamp = e3.lastPacketReceivedTimestamp), h2.firCount = e3.firCount, h2.nackCount = e3.nackCount, h2.pliCount = e3.pliCount, void 0 !== e3.framesDecoded && (h2.framesDecoded = e3.framesDecoded), void 0 !== e3.framesDropped && (h2.framesDropped = e3.framesDropped), void 0 !== e3.framesReceived && (h2.framesReceived = e3.framesReceived), h2.packetsReceived = e3.packetsReceived, h2.packetsLost = e3.packetsLost, void 0 !== e3.framesPerSecond && (h2.frameRateReceived = e3.framesPerSecond), void 0 !== e3.frameWidth && (h2.frameWidthReceived = e3.frameWidth), void 0 !== e3.frameHeight && (h2.frameHeightReceived = e3.frameHeight), void 0 !== e3.jitter && (h2.jitter = Math.round(1e3 * e3.jitter)), void 0 !== e3.jitterBufferDelay && (h2.jitterBufferDelay = Math.round(1e3 * e3.jitterBufferDelay / e3.jitterBufferEmittedCount)), n.IS_ANY_SAFARI && n.SAFARI_MAJOR_VERSION && n.SAFARI_MAJOR_VERSION >= 17 && (h2.frameWidthReceived = e3.frameWidth, h2.frameHeightReceived = e3.frameHeight, void 0 !== e3.framesDecoded && (h2.framesDecoded = e3.framesDecoded), void 0 !== e3.framesReceived && (h2.framesReceived = e3.framesReceived), void 0 !== e3.framesDropped && (h2.framesDropped = e3.framesDropped)))) : "remote-outbound-rtp" == e3.type ? "audio" === e3.kind ? (void 0 !== e3.jitter && (u2.jitter = Math.round(1e3 * e3.jitter)), void 0 !== e3.roundTripTime && (u2.rtt = Math.round(1e3 * e3.roundTripTime))) : e3.kind : "media-source" == e3.type && ("send" !== t2 || "audio" !== e3.kind && "audio" !== i2 || (void 0 !== e3.audioLevel && (u2.audioOutputLevel = Math.round(32768 * e3.audioLevel)), void 0 !== e3.totalAudioEnergy && (u2.totalAudioEnergy = Math.round(32768 * e3.totalAudioEnergy)), void 0 !== e3.totalSamplesDuration && (u2.totalSamplesDuration = Math.round(e3.totalSamplesDuration))));
            });
            const m2 = null === (r2 = null == this ? void 0 : this.adapterRef) || void 0 === r2 ? void 0 : r2.instance.getUidAndKindBySsrc(p2);
            let g2 = null == m2 ? void 0 : m2.kind;
            "{}" !== JSON.stringify(h2) && "send" === t2 && (h2.streamType = (null == m2 ? void 0 : m2.streamType) || "high");
            const f2 = {};
            if ("recv" === t2) {
              if (null === (s2 = this.formativeStatsReport) || void 0 === s2 || s2.clearFirstRecvData(null == m2 ? void 0 : m2.uid), "{}" !== JSON.stringify(h2)) h2.remoteuid = null == m2 ? void 0 : m2.uid, null === (a2 = this.formativeStatsReport) || void 0 === a2 || a2.formatRecvData(h2, g2);
              else if ("{}" !== JSON.stringify(u2) && (u2.remoteuid = null == m2 ? void 0 : m2.uid, null === (o2 = this.formativeStatsReport) || void 0 === o2 || o2.formatRecvData(u2, g2), u2.audioOutputLevel)) {
                const e3 = null === (d2 = null == this ? void 0 : this.adapterRef) || void 0 === d2 ? void 0 : d2.remoteStreamMap[u2.remoteuid], t3 = g2 && (null == e3 ? void 0 : e3.isPlaying(g2)) || false;
                this.audioLevel.push({ uid: u2.remoteuid, level: t3 && +u2.audioOutputLevel || 0, type: g2 });
              }
            }
            return (null == g2 ? void 0 : g2.includes("audio")) ? ("send" === t2 && (null === (c2 = this.formativeStatsReport) || void 0 === c2 || c2.formatSendData(u2, g2)), n.IS_ANY_SAFARI && n.SAFARI_MAJOR_VERSION && n.SAFARI_MAJOR_VERSION < 17 ? "number" == typeof u2.active && (f2[g2 + "_ssrc"] = [u2]) : "send" === t2 ? "number" == typeof u2.bitsSentPerSecond && "number" == typeof u2.packetsSentPerSecond && (f2[g2 + "_ssrc"] = [u2]) : f2[g2 + "_ssrc"] = [u2]) : "video" !== g2 && "screen" !== g2 || ("high" === (null == m2 ? void 0 : m2.streamType) && "send" === t2 && (null === (l2 = this.formativeStatsReport) || void 0 === l2 || l2.formatSendData(h2, g2)), n.IS_ANY_SAFARI && n.SAFARI_MAJOR_VERSION && n.SAFARI_MAJOR_VERSION < 17 ? "number" == typeof h2.active && (f2[g2 + "_ssrc"] = [h2]) : "send" === t2 ? h2.frameWidthInput && "number" == typeof h2.frameWidthInput && h2.frameHeightInput && "number" == typeof h2.frameHeightInput && (f2[g2 + "_ssrc"] = [h2]) : f2[g2 + "_ssrc"] = [h2]), f2;
          }
          async firefox(e2, t2) {
            if (!e2.getTransceivers) return {};
            let i2 = { audio_ssrc: [], audioSlave_ssrc: [], video_ssrc: [], screen_ssrc: [] };
            const r2 = e2.getTransceivers();
            for (let e3 = 0; e3 < r2.length; e3++) {
              let s2 = null;
              const a2 = r2[e3];
              "sendonly" === a2.direction ? a2.sender && a2.sender.getStats && (this.markStatsStart(t2), s2 = await a2.sender.getStats(), s2 = this.formatFirefoxStandardizedStats(s2, t2), Object.assign(i2, s2)) : "recvonly" === a2.direction && a2.receiver && a2.receiver.getStats && (this.markStatsStart(t2), s2 = await a2.receiver.getStats(), s2 = this.formatFirefoxStandardizedStats(s2, t2), s2.audio_ssrc && i2.audio_ssrc ? i2.audio_ssrc.push(s2.audio_ssrc[0]) : s2.audioSlave_ssrc && i2.audioSlave_ssrc ? i2.audioSlave_ssrc.push(s2.audioSlave_ssrc[0]) : s2.video_ssrc && i2.video_ssrc ? i2.video_ssrc.push(s2.video_ssrc[0]) : s2.screen_ssrc && i2.screen_ssrc ? i2.screen_ssrc.push(s2.screen_ssrc[0]) : Object.assign(i2, s2));
            }
            return i2;
          }
          formatFirefoxStandardizedStats(e2, t2) {
            var i2, r2, s2, a2, o2, n2, d2;
            const c2 = {}, l2 = {};
            let u2 = 0;
            e2.forEach((e3) => {
              "outbound-rtp" == e3.type ? (u2 = e3.ssrc, "audio" === e3.kind ? (c2.bytesSent = (e3.headerBytesSent || 0) + e3.bytesSent, c2.packetsSent = e3.packetsSent, c2.nackCount = e3.nackCount) : "video" === e3.kind && (l2.bytesSent = (e3.headerBytesSent || 0) + e3.bytesSent, l2.firCount = e3.firCount, l2.nackCount = e3.nackCount, l2.pliCount = e3.pliCount, void 0 !== e3.hugeFramesSent && (l2.hugeFramesSent = e3.hugeFramesSent), l2.packetsSent = e3.packetsSent, "qpSum" in e3 && (l2.qpSum = e3.qpSum), void 0 !== e3.framesEncoded && (l2.framesEncoded = e3.framesEncoded), void 0 !== e3.framesSent && (l2.framesSent = e3.framesSent), void 0 !== e3.totalEncodeTime && void 0 !== e3.framesEncoded && (l2.avgEncodeMs = Math.round(1e3 * e3.totalEncodeTime / e3.framesEncoded)), void 0 !== e3.framesPerSecond && (l2.frameRateSent = e3.framesPerSecond), void 0 !== e3.frameWidth && (l2.frameWidthSent = e3.frameWidth), void 0 !== e3.frameHeight && (l2.frameHeightSent = e3.frameHeight))) : "remote-inbound-rtp" == e3.type ? "video" === e3.kind && (l2.fractionLost = e3.fractionLost, l2.jitter = Math.round(1e3 * e3.jitter), l2.packetsLost = e3.packetsLost, l2.rtt = Math.round(1e3 * e3.roundTripTime)) : "inbound-rtp" == e3.type && (u2 = e3.ssrc, "audio" === e3.kind ? (void 0 !== e3.audioLevel && (c2.audioOutputLevel = Math.round(32768 * e3.audioLevel)), void 0 !== e3.insertedSamplesForDeceleration && (c2.preemptiveExpandRate = parseInt(e3.insertedSamplesForDeceleration)), void 0 !== e3.removedSamplesForAcceleration && (c2.speechExpandRate = parseInt(e3.removedSamplesForAcceleration)), c2.bytesReceived = e3.bytesReceived + (e3.headerBytesReceived || 0), c2.concealedSamples = e3.concealedSamples, c2.jitter = Math.round(1e3 * e3.jitter), c2.jitterBufferDelay = Math.round(1e3 * e3.jitterBufferDelay / e3.jitterBufferEmittedCount), c2.silentConcealedSamples = e3.silentConcealedSamples, c2.packetsLost = e3.packetsLost, c2.packetsReceived = e3.packetsReceived, void 0 !== e3.totalSamplesReceived && (c2.totalSamplesDuration = Math.round(e3.totalSamplesReceived / 48e3)), void 0 !== e3.totalAudioEnergy && (c2.totalAudioEnergy = Math.round(32768 * e3.totalAudioEnergy)), void 0 !== e3.totalSamplesReceived && (c2.totalSamplesDuration = Math.round(e3.totalSamplesReceived / 48e3))) : "video" === e3.kind && (l2.bytesReceived = e3.bytesReceived + (e3.headerBytesReceived || 0), l2.firCount = e3.firCount, l2.nackCount = e3.nackCount, l2.pliCount = e3.pliCount, l2.framesDecoded = e3.framesDecoded, l2.framesDropped = e3.framesReceived - e3.framesDecoded, l2.framesReceived = e3.framesReceived, l2.packetsReceived = e3.packetsReceived, l2.packetsLost = e3.packetsLost, l2.frameRateReceived = e3.framesPerSecond || 0, l2.frameWidthReceived = e3.frameWidth, l2.frameHeightReceived = e3.frameHeight, l2.jitterBufferDelay = Math.round(1e3 * e3.jitterBufferDelay / e3.jitterBufferEmittedCount), void 0 !== e3.estimatedPlayoutTimestamp && (l2.estimatedPlayoutTimestamp = e3.estimatedPlayoutTimestamp), void 0 !== e3.lastPacketReceivedTimestamp && (l2.lastPacketReceivedTimestamp = e3.lastPacketReceivedTimestamp)));
            });
            const h2 = null === (i2 = null == this ? void 0 : this.adapterRef) || void 0 === i2 ? void 0 : i2.instance.getUidAndKindBySsrc(u2);
            let p2 = null == h2 ? void 0 : h2.kind;
            "{}" !== JSON.stringify(l2) && "send" === t2 && (l2.streamType = (null == h2 ? void 0 : h2.streamType) || "high");
            const m2 = {};
            if ("recv" === t2) {
              if (null === (r2 = this.formativeStatsReport) || void 0 === r2 || r2.clearFirstRecvData(null == h2 ? void 0 : h2.uid), "{}" !== JSON.stringify(l2)) l2.remoteuid = null == h2 ? void 0 : h2.uid, null === (s2 = this.formativeStatsReport) || void 0 === s2 || s2.formatRecvData(l2, p2);
              else if ("{}" !== JSON.stringify(c2) && (c2.remoteuid = null == h2 ? void 0 : h2.uid, null === (a2 = this.formativeStatsReport) || void 0 === a2 || a2.formatRecvData(c2, p2), c2.audioOutputLevel)) {
                const e3 = null === (o2 = null == this ? void 0 : this.adapterRef) || void 0 === o2 ? void 0 : o2.remoteStreamMap[c2.remoteuid], t3 = p2 && (null == e3 ? void 0 : e3.isPlaying(p2)) || false;
                this.audioLevel.push({ uid: c2.remoteuid, level: t3 && +c2.audioOutputLevel || 0, type: p2 });
              }
            }
            return (null == p2 ? void 0 : p2.includes("audio")) ? ("send" === t2 && (null === (n2 = this.formativeStatsReport) || void 0 === n2 || n2.formatSendData(c2, p2)), m2[p2 + "_ssrc"] = [c2]) : "video" !== p2 && "screen" !== p2 || ("high" === (null == h2 ? void 0 : h2.streamType) && "send" === t2 && (null === (d2 = this.formativeStatsReport) || void 0 === d2 || d2.formatSendData(l2, p2)), m2[p2 + "_ssrc"] = [l2]), m2;
          }
          stop() {
            this._reset();
          }
          destroy() {
            this._reset();
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FormativeStatsReport = void 0;
        t.FormativeStatsReport = class {
          constructor(e2) {
            this.adapterRef = e2.adapterRef, this.firstData = { recvFirstData: {}, sendFirstAudioPackage: false, sendFirstVideoPackage: false, sendFirstScreenPackage: false }, this.statsCatch = { upAudioCache: {}, upAudioSlaveCache: {}, upVideoCache: {}, upScreenCache: {}, downAudioCache: {}, downAudioSlaveCache: {}, downVideoCache: {}, downScreenCache: {}, upTransportCache: {}, downTransportCache: {}, upCandidatePairStatsCache: {}, downCandidatePairStatsCache: {} };
          }
          _reset() {
            this.firstData = { recvFirstData: {}, sendFirstAudioPackage: false, sendFirstVideoPackage: false, sendFirstScreenPackage: false }, this.statsCatch = { upAudioCache: {}, upAudioSlaveCache: {}, upVideoCache: {}, upScreenCache: {}, downAudioCache: {}, downAudioSlaveCache: {}, downVideoCache: {}, downScreenCache: {}, upTransportCache: {}, downTransportCache: {}, upCandidatePairStatsCache: {}, downCandidatePairStatsCache: {} };
          }
          clearFirstRecvData(e2) {
            const t2 = this.adapterRef.remoteStreamMap[e2], i2 = this.firstData.recvFirstData[e2];
            t2 && i2 && ("" === t2.pubStatus.audio.consumerId && (i2.recvFirstAudioFrame = i2.recvFirstAudioPackage = false, this.statsCatch.downAudioCache[e2] = null), "" === t2.pubStatus.audioSlave.consumerId && (this.statsCatch.downAudioSlaveCache[e2] = null), "" === t2.pubStatus.video.consumerId && (i2.recvFirstVideoFrame = i2.recvFirstVideoPackage = false, this.statsCatch.downVideoCache[e2] = null), "" === t2.pubStatus.screen.consumerId && (i2.recvFirstScreenFrame = i2.recvFirstScreenPackage = false, this.statsCatch.downScreenCache[e2] = null));
          }
          formatTransportData(e2, t2) {
            let i2;
            "send" === t2 ? (this.adapterRef.transportStats.rxRtt = e2.googRtt - 0, this.adapterRef.transportStats.txRtt = e2.googRtt - 0, this.adapterRef.sessionStats.SendBytes = e2.bytesSent - 0, this.statsCatch.upTransportCache && (i2 = this.statsCatch.upTransportCache), this.statsCatch.upTransportCache = e2, i2 && (this.adapterRef.sessionStats.SendBitrate = Math.round(8 * (e2.bytesSent - i2.bytesSent) / 1e3))) : (this.adapterRef.sessionStats.RecvBytes = e2.bytesReceived - 0, this.statsCatch.downTransportCache && (i2 = this.statsCatch.downTransportCache), this.statsCatch.downTransportCache = e2, i2 && (this.adapterRef.sessionStats.RecvBitrate = Math.round(8 * (e2.bytesReceived - i2.bytesReceived) / 1e3)));
          }
          formatTransportDataChrome117(e2, t2) {
            var i2, r;
            if ("send" === t2) {
              const t3 = this.statsCatch.upCandidatePairStatsCache;
              if (t3 && t3.timestamp && e2.timestamp - t3.timestamp < 900) return;
              this.adapterRef.transportStats.txRtt = Math.round(1e3 * e2.currentRoundTripTime);
              const r2 = null === (i2 = this.statsCatch.downCandidatePairStatsCache) || void 0 === i2 ? void 0 : i2.timestamp;
              (!r2 || e2.timestamp - r2 > 2e3) && (this.adapterRef.transportStats.rxRtt = this.adapterRef.transportStats.txRtt), this.adapterRef.sessionStats.SendBytes = e2.bytesSent, this.adapterRef.transportStats.OutgoingAvailableBandwidth = e2.availableOutgoingBitrate / 1e3, this.statsCatch.upCandidatePairStatsCache = e2, t3 && t3.timestamp && (this.adapterRef.sessionStats.SendBitrate = Math.round(8 * (e2.bytesSent - (t3.bytesSent || 0)) / 1e3));
            } else {
              const t3 = this.statsCatch.downCandidatePairStatsCache;
              if (t3 && t3.timestamp && e2.timestamp - t3.timestamp < 900) return;
              this.adapterRef.transportStats.rxRtt = Math.round(1e3 * e2.currentRoundTripTime), this.adapterRef.transportStats.txRtt < 1 && (this.adapterRef.transportStats.txRtt = this.adapterRef.transportStats.rxRtt);
              const i3 = null === (r = this.statsCatch.upCandidatePairStatsCache) || void 0 === r ? void 0 : r.timestamp;
              (!i3 || e2.timestamp - i3 > 2e3) && (this.adapterRef.transportStats.txRtt = this.adapterRef.transportStats.rxRtt), this.adapterRef.sessionStats.RecvBytes = e2.bytesReceived, this.statsCatch.downCandidatePairStatsCache = e2, t3 && t3.timestamp && (this.adapterRef.sessionStats.RecvBitrate = Math.round(8 * (e2.bytesReceived - (t3.bytesReceived || 0)) / 1e3));
            }
          }
          formatSendData(e2, t2) {
            var i2, r, s, a, o, n, d, c;
            let l;
            if ("audio" === t2) {
              if (!(null === (r = null === (i2 = null == this ? void 0 : this.adapterRef) || void 0 === i2 ? void 0 : i2._mediasoup) || void 0 === r ? void 0 : r._micProducer)) return this.firstData.sendFirstAudioPackage = false, void (this.statsCatch.upAudioCache = {});
              e2.packetsSent > 0 && !this.firstData.sendFirstAudioPackage && (this.firstData.sendFirstAudioPackage = true, this.adapterRef.instance.apiEventReport("setSendFirstPackage", { media_type: 0 })), this.statsCatch.upAudioCache && (l = this.statsCatch.upAudioCache), this.statsCatch.upAudioCache = e2;
            } else if ("audioSlave" === t2) {
              if (!(null === (a = null === (s = null == this ? void 0 : this.adapterRef) || void 0 === s ? void 0 : s._mediasoup) || void 0 === a ? void 0 : a._audioSlaveProducer)) return void (this.statsCatch.upAudioSlaveCache = {});
              this.statsCatch.upAudioSlaveCache && (l = this.statsCatch.upAudioSlaveCache), this.statsCatch.upAudioSlaveCache = e2, this.dispatchExceptionEventSendAudio(l, e2);
            } else if ("video" === t2) {
              if (!(null === (n = null === (o = null == this ? void 0 : this.adapterRef) || void 0 === o ? void 0 : o._mediasoup) || void 0 === n ? void 0 : n._webcamProducer)) return this.firstData.sendFirstVideoPackage = false, void (this.statsCatch.upVideoCache = {});
              e2.packetsSent > 0 && !this.firstData.sendFirstVideoPackage && (this.firstData.sendFirstVideoPackage = true, this.adapterRef.instance.apiEventReport("setSendFirstPackage", { media_type: 1 })), this.statsCatch.upVideoCache && (l = this.statsCatch.upVideoCache), this.statsCatch.upVideoCache = e2, this.dispatchExceptionEventSendVideo(l, e2);
            } else if ("screen" === t2) {
              if (!(null === (c = null === (d = null == this ? void 0 : this.adapterRef) || void 0 === d ? void 0 : d._mediasoup) || void 0 === c ? void 0 : c._screenProducer)) return this.firstData.sendFirstScreenPackage = false, void (this.statsCatch.upScreenCache = {});
              e2.packetsSent > 0 && !this.firstData.sendFirstScreenPackage && (this.firstData.sendFirstScreenPackage = true, this.adapterRef.instance.apiEventReport("setSendFirstPackage", { media_type: 2 })), this.statsCatch.upScreenCache && (l = this.statsCatch.upScreenCache), this.statsCatch.upScreenCache = e2;
            }
            if (e2.bitsSentPerSecond || (e2.bitsSentPerSecond = Math.round(8 * (e2.bytesSent - (l.bytesSent || 0)) / 1e3)), e2.packetsSentPerSecond || (e2.packetsSentPerSecond = e2.packetsSent - (l.packetsSent || 0)), e2.packetsLostRate || void 0 !== e2.packetsLost && (e2.packetsLostRate = this.getPacketLossRate(l, e2, true)), e2.streamType) {
              e2.framesEncodedPerSecond || e2.framesEncoded >= l.framesEncoded && (e2.framesEncodedPerSecond = e2.framesEncoded - l.framesEncoded), e2.qpPercentage || (e2.qpPercentage = this.getQpPercentage(l, e2)), e2.frameRateSent || (e2.frameRateSent = e2.framesSent - l.framesSent);
              let i3 = { freezeTime: 0, totalFreezeTime: 0 };
              "video" === t2 ? i3 = this.getLocalVideoFreezeStats(e2) : "screen" === t2 && (i3 = this.getLocalScreenFreezeStats(e2)), e2.freezeTime || (e2.freezeTime = i3.freezeTime), e2.totalFreezeTime || (e2.totalFreezeTime = i3.totalFreezeTime);
            }
          }
          formatRecvData(e2, t2) {
            let i2;
            const r = e2.remoteuid || 0;
            if (this.clearFirstRecvData(r), this.firstData.recvFirstData[r] || (this.firstData.recvFirstData[r] = { recvFirstAudioFrame: false, recvFirstVideoFrame: false, recvFirstScreenFrame: false, recvFirstAudioPackage: false, recvFirstVideoPackage: false, recvFirstScreenPackage: false }), "audio" === t2 ? (!this.firstData.recvFirstData[r].recvFirstAudioPackage && e2.packetsReceived > 0 && (this.firstData.recvFirstData[r].recvFirstAudioPackage = true, this.adapterRef.instance.apiEventReport("setRecvFirstPackage", { media_type: 0, pull_uid: r })), e2.decodingNormal && e2.decodingNormal > 0 && !this.firstData.recvFirstData[r].recvFirstAudioFrame && (this.firstData.recvFirstData[r].recvFirstAudioFrame = true, this.adapterRef.instance.apiEventReport("setRecvFirstFrame", { media_type: 0, pull_uid: r })), this.statsCatch.downAudioCache && (i2 = this.statsCatch.downAudioCache[r]), this.statsCatch.downAudioCache[r] = e2, this.dispatchExceptionEventRecvAudio(i2, e2, r)) : "audioSlave" === t2 ? (this.statsCatch.downAudioSlaveCache && (i2 = this.statsCatch.downAudioSlaveCache[r]), this.statsCatch.downAudioSlaveCache[r] = e2) : "video" === t2 ? (!this.firstData.recvFirstData[r].recvFirstVideoPackage && e2.packetsReceived > 0 && (this.firstData.recvFirstData[r].recvFirstVideoPackage = true, this.adapterRef.instance.apiEventReport("setRecvFirstPackage", { media_type: 1, pull_uid: r })), !this.firstData.recvFirstData[r].recvFirstVideoFrame && e2.framesDecoded > 0 && (this.firstData.recvFirstData[r].recvFirstVideoFrame = true, this.adapterRef.instance.apiEventReport("setRecvFirstFrame", { media_type: 1, pull_uid: r })), this.statsCatch.downVideoCache && (i2 = this.statsCatch.downVideoCache[r]), this.statsCatch.downVideoCache[r] = e2, this.dispatchExceptionEventRecvVideo(i2, e2, r)) : "screen" === t2 && (!this.firstData.recvFirstData[r].recvFirstScreenPackage && e2.packetsReceived > 0 && (this.firstData.recvFirstData[r].recvFirstScreenPackage = true, this.adapterRef.instance.apiEventReport("setRecvFirstPackage", { media_type: 2, pull_uid: r })), !this.firstData.recvFirstData[r].recvFirstScreenFrame && e2.framesDecoded > 0 && (this.firstData.recvFirstData[r].recvFirstScreenFrame = true, this.adapterRef.instance.apiEventReport("setRecvFirstFrame", { media_type: 2, pull_uid: r })), this.statsCatch.downScreenCache && (i2 = this.statsCatch.downScreenCache[r]), this.statsCatch.downScreenCache[r] = e2, this.dispatchExceptionEventRecvScreen(i2, e2, r)), !i2 || e2.bytesReceived < i2.bytesReceived) return;
            let s = { freezeTime: 0, totalFreezeTime: 0 };
            e2.bitsReceivedPerSecond || (e2.bitsReceivedPerSecond = Math.round(8 * (e2.bytesReceived - i2.bytesReceived) / 1e3)), e2.packetsReceivedPerSecond || (e2.packetsReceivedPerSecond = e2.packetsReceived - i2.packetsReceived), e2.packetsLost || void 0 !== e2.packetsLost && (e2.packetsLostRate = this.getPacketLossRate(i2, e2)), "video" === t2 || "screen" === t2 ? (e2.frameRateReceived || (e2.frameRateReceived = e2.framesReceived - i2.framesReceived), e2.frameRateDecoded || (e2.frameRateDecoded = e2.framesDecoded - i2.framesDecoded), "video" === t2 ? s = this.getRemoteVideoFreezeStats(i2, e2, r) : "screen" === t2 && (s = this.getRemoteScreenFreezeStats(i2, e2, r))) : e2.decodingCTN && (s = this.getRemoteAudioFreezeStats(i2, e2, r)), e2.freezeTime || (e2.freezeTime = s.freezeTime), e2.totalFreezeTime || (e2.totalFreezeTime = s.totalFreezeTime);
          }
          getQpPercentage(e2, t2) {
            if (!(e2 && e2.framesEncoded && e2.qpSum && t2 && t2.framesEncoded && t2.qpSum)) return 0;
            const i2 = t2.qpSum - e2.qpSum, r = t2.framesEncoded - e2.framesEncoded;
            return i2 <= 0 || r <= 0 ? 0 : i2 > r ? 100 : Math.round(i2 / r * 100);
          }
          getPacketLossRate(e2, t2, i2 = false) {
            if (!e2 || !t2) return 0;
            const r = parseInt(e2.packetsLost) || 0, s = parseInt(t2.packetsLost) || 0;
            if (s <= r) return 0;
            const a = i2 ? e2.packetsSent : e2.packetsReceived, o = i2 ? t2.packetsSent : t2.packetsReceived, n = parseInt(a || "") || 0, d = parseInt(o || "") || 0;
            if (d <= n) return 0;
            return i2 ? Math.round((s - r) / (d - n) * 100) : Math.round((s - r) / (s - r + (d - n)) * 100);
          }
          getLocalVideoFreezeStats(e2) {
            let t2 = 0;
            if (!e2 || !e2.frameRateSent) return { totalFreezeTime: t2, freezeTime: 0 };
            let i2 = 0, r = parseInt(e2.frameRateSent);
            if (r <= 0) return { totalFreezeTime: 2e3, freezeTime: 6 };
            if (r > 10) return { totalFreezeTime: 0, freezeTime: 0 };
            i2 = Math.abs(10 - r), t2 = parseInt(2e3 * (i2 / 10));
            let s = 0;
            t2 < 300 ? (t2 = 0, s = 0) : s = t2 > 1500 ? 6 : parseInt(t2 / 300);
            return { totalFreezeTime: t2, freezeTime: s };
          }
          getLocalScreenFreezeStats(e2) {
            let t2 = 0;
            if (!e2 || !e2.frameRateSent) return { totalFreezeTime: t2, freezeTime: 0 };
            let i2 = parseInt(e2.framesEncoded) || 0, r = parseInt(e2.framesSent) || 0;
            if (i2 <= 0 || r <= 0) return { totalFreezeTime: 2e3, freezeTime: 6 };
            let s = Math.abs(i2 - r);
            t2 = parseInt(2e3 * (s / i2));
            let a = 0;
            t2 < 300 ? (t2 = 0, a = 0) : a = t2 > 1500 ? 6 : parseInt(t2 / 300);
            return { totalFreezeTime: t2, freezeTime: a };
          }
          getRemoteAudioFreezeStats(e2, t2, i2) {
            if (!e2 || !t2) return { totalFreezeTime: 0, freezeTime: 0 };
            let r = parseInt(e2.decodingPLC) + parseInt(e2.decodingCNG) + parseInt(e2.decodingPLCCNG), s = parseInt(e2.decodingCTN), a = parseInt(e2.decodingPLC) + parseInt(e2.decodingCNG) + parseInt(e2.decodingPLCCNG), o = parseInt(t2.decodingCTN);
            if (o <= r) return { totalFreezeTime: 0, freezeTime: 0 };
            let n = (a - r) / (o - s);
            return { totalFreezeTime: parseInt(1e3 * n), freezeTime: 10 * n > 1 ? parseInt(10 * n) : n > 0 ? 1 : 0 };
          }
          getRemoteVideoFreezeStats(e2, t2, i2) {
            let r = 0;
            if (!t2 || 0 == t2.framesDecoded) return { totalFreezeTime: r, freezeTime: 0 };
            if (t2 && t2.framesDecoded && 0 == t2.frameRateDecoded) return { totalFreezeTime: 2e3, freezeTime: 6 };
            let s = parseInt(t2.frameRateReceived) || 0, a = parseInt(t2.frameRateDecoded);
            if (s <= 0 || a <= 0) return { totalFreezeTime: 2e3, freezeTime: 6 };
            let o = 0;
            if (s > 10) return { totalFreezeTime: 0, freezeTime: 0 };
            o = Math.abs(10 - s), r = parseInt(2e3 * (o / 10)), r > 2e3 && (r = 2e3);
            let n = 0;
            r < 300 ? (r = 0, n = 0) : n = r > 1500 ? 6 : parseInt(r / 300);
            return { totalFreezeTime: r, freezeTime: n };
          }
          getRemoteScreenFreezeStats(e2, t2, i2) {
            let r = 0;
            if (!t2) return { totalFreezeTime: r, freezeTime: 0 };
            let s = parseInt(t2.frameRateReceived), a = parseInt(t2.frameRateDecoded);
            if (s <= 0 || a <= 0) return { totalFreezeTime: 2e3, freezeTime: 6 };
            let o = Math.abs(a - s);
            r = parseInt(2e3 * (o / s)) || 0;
            let n = 0;
            r < 300 ? (r = 0, n = 0) : n = r > 1500 ? 6 : parseInt(r / 300);
            return { totalFreezeTime: r, freezeTime: n };
          }
          dispatchExceptionEventSendAudio(e2, t2) {
            var i2, r, s, a;
            if (!e2 || !t2) return;
            const o = null === (i2 = this.adapterRef.localStream) || void 0 === i2 ? void 0 : i2.muteStatus.audio.send, n = null === (r = this.adapterRef.localStream) || void 0 === r ? void 0 : r.pubStatus.audio.audio;
            if (true === o || false === n) return;
            0 === t2.audioInputLevel && this.adapterRef.instance.safeEmit("exception", { msg: "AUDIO_INPUT_LEVEL_TOO_LOW", code: 2001, uid: (null === (s = this.adapterRef) || void 0 === s ? void 0 : s.channelInfo.uid) || 0 }), 0 === parseInt(t2.bytesSent) - parseInt(e2.bytesSent) && this.adapterRef.instance.safeEmit("exception", { msg: "SEND_AUDIO_BITRATE_TOO_LOW", code: 2003, uid: (null === (a = this.adapterRef) || void 0 === a ? void 0 : a.channelInfo.uid) || 0 });
          }
          dispatchExceptionEventSendVideo(e2, t2) {
            var i2, r, s, a;
            if (!e2 || !t2) return;
            const o = null === (i2 = this.adapterRef.localStream) || void 0 === i2 ? void 0 : i2.muteStatus.video.send, n = null === (r = this.adapterRef.localStream) || void 0 === r ? void 0 : r.pubStatus.video.video;
            if (true === o || false === n) return;
            t2.frameRateInput && parseInt(t2.frameRateInput) > 5 && parseInt(t2.frameRateSent) <= 1 && this.adapterRef.instance.safeEmit("exception", { msg: "FRAMERATE_SENT_TOO_LOW", code: 1002, uid: (null === (s = this.adapterRef) || void 0 === s ? void 0 : s.channelInfo.uid) || 0 }), 0 === parseInt(t2.bytesSent) - parseInt(e2.bytesSent) && this.adapterRef.instance.safeEmit("exception", { msg: "FRAMERATE_VIDEO_BITRATE_TOO_LOW", code: 1003, uid: (null === (a = this.adapterRef) || void 0 === a ? void 0 : a.channelInfo.uid) || 0 });
          }
          dispatchExceptionEventRecvAudio(e2, t2, i2) {
            if (!e2 || !t2 || !t2.googDecodingNormal) return;
            const r = this.adapterRef.remoteStreamMap[i2], s = r && (r.muteStatus.audio.send || r.muteStatus.audio.recv);
            if (r && s) return;
            if (!r || !r.Play || !r.Play.audio.dom || !r.Play.audio.dom.srcObject || r.Play.audio.dom.muted) return;
            let a = parseInt(t2.bytesReceived) - parseInt(e2.bytesReceived), o = parseInt(t2.decodingNormal) - parseInt(e2.decodingNormal);
            if (a > 0 && 0 === o && this.adapterRef.instance.safeEmit("exception", { msg: "RECV_AUDIO_DECODE_FAILED", code: 2005, uid: i2 }), a > 0 && o > 0 && 0 == +(t2.audioOutputLevel || t2.audioLevel)) {
              const e3 = r && r.Play && r.Play.audio.dom && r.Play.audio.dom.volume;
              e3 && e3 > 0 && this.adapterRef.instance.safeEmit("exception", { msg: "AUDIO_OUTPUT_LEVEL_TOO_LOW", code: 2002, uid: i2 });
            }
          }
          dispatchExceptionEventRecvVideo(e2, t2, i2) {
            if (!e2 || !t2) return;
            const r = this.adapterRef.remoteStreamMap[i2], s = r && (r.muteStatus.video.send || r.muteStatus.video.recv);
            if (r && s) return;
            parseInt(t2.bytesReceived) - parseInt(e2.bytesReceived) > 0 && 0 === parseInt(t2.frameRateDecoded) && this.adapterRef.instance.safeEmit("exception", { msg: "RECV_VIDEO_DECODE_FAILED", code: 1005, uid: i2 });
          }
          dispatchExceptionEventRecvScreen(e2, t2, i2) {
            if (!e2 || !t2) return;
            const r = this.adapterRef.remoteStreamMap[i2], s = r && (r.muteStatus.screen.send || r.muteStatus.screen.recv);
            if (r && s) return;
            parseInt(t2.bytesReceived) - parseInt(e2.bytesReceived) > 0 && 0 === parseInt(t2.frameRateDecoded) && this.adapterRef.instance.safeEmit("exception", { msg: "RECV_SCREEN_DECODE_FAILED", code: 1005, uid: i2 });
          }
          destroy() {
            this._reset();
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.FormativeStatsVideo = t.FormativeStatsAudio = void 0;
        t.FormativeStatsAudio = class {
          constructor() {
            this.echoReturnLoss = "", this.echoReturnLossEnhancement = "", this.CodecType = "", this.totalFreezeTime = 0, this.remoteuid = "";
          }
        };
        t.FormativeStatsVideo = class {
          constructor() {
            this.totalFreezeTime = 0, this.qualityLimitationReason = "", this.streamType = "", this.CodecName = "", this.CodecImplementationName = "", this.remoteuid = "";
          }
        };
      }, function(module, exports, __webpack_require__) {
        (function(process, global) {
          var __WEBPACK_AMD_DEFINE_RESULT__;
          !function() {
            "use strict";
            var root = "object" == typeof window ? window : {}, NODE_JS = !root.JS_SHA1_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
            NODE_JS && (root = global);
            var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && "object" == typeof module && module.exports, AMD = __webpack_require__(280), HEX_CHARS = "0123456789abcdef".split(""), EXTRA = [-2147483648, 8388608, 32768, 128], SHIFT = [24, 16, 8, 0], OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"], blocks = [], createOutputMethod = function(e) {
              return function(t) {
                return new Sha1(true).update(t)[e]();
              };
            }, createMethod = function() {
              var e = createOutputMethod("hex");
              NODE_JS && (e = nodeWrap(e)), e.create = function() {
                return new Sha1();
              }, e.update = function(t2) {
                return e.create().update(t2);
              };
              for (var t = 0; t < OUTPUT_TYPES.length; ++t) {
                var i = OUTPUT_TYPES[t];
                e[i] = createOutputMethod(i);
              }
              return e;
            }, nodeWrap = function(method) {
              var crypto = eval("require('crypto')"), Buffer = eval("require('buffer').Buffer"), nodeMethod = function(e) {
                if ("string" == typeof e) return crypto.createHash("sha1").update(e, "utf8").digest("hex");
                if (e.constructor === ArrayBuffer) e = new Uint8Array(e);
                else if (void 0 === e.length) return method(e);
                return crypto.createHash("sha1").update(new Buffer(e)).digest("hex");
              };
              return nodeMethod;
            };
            function Sha1(e) {
              e ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.h0 = 1732584193, this.h1 = 4023233417, this.h2 = 2562383102, this.h3 = 271733878, this.h4 = 3285377520, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = false, this.first = true;
            }
            Sha1.prototype.update = function(e) {
              if (!this.finalized) {
                var t = "string" != typeof e;
                t && e.constructor === root.ArrayBuffer && (e = new Uint8Array(e));
                for (var i, r, s = 0, a = e.length || 0, o = this.blocks; s < a; ) {
                  if (this.hashed && (this.hashed = false, o[0] = this.block, o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0), t) for (r = this.start; s < a && r < 64; ++s) o[r >> 2] |= e[s] << SHIFT[3 & r++];
                  else for (r = this.start; s < a && r < 64; ++s) (i = e.charCodeAt(s)) < 128 ? o[r >> 2] |= i << SHIFT[3 & r++] : i < 2048 ? (o[r >> 2] |= (192 | i >> 6) << SHIFT[3 & r++], o[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]) : i < 55296 || i >= 57344 ? (o[r >> 2] |= (224 | i >> 12) << SHIFT[3 & r++], o[r >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & r++], o[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]) : (i = 65536 + ((1023 & i) << 10 | 1023 & e.charCodeAt(++s)), o[r >> 2] |= (240 | i >> 18) << SHIFT[3 & r++], o[r >> 2] |= (128 | i >> 12 & 63) << SHIFT[3 & r++], o[r >> 2] |= (128 | i >> 6 & 63) << SHIFT[3 & r++], o[r >> 2] |= (128 | 63 & i) << SHIFT[3 & r++]);
                  this.lastByteIndex = r, this.bytes += r - this.start, r >= 64 ? (this.block = o[16], this.start = r - 64, this.hash(), this.hashed = true) : this.start = r;
                }
                return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this;
              }
            }, Sha1.prototype.finalize = function() {
              if (!this.finalized) {
                this.finalized = true;
                var e = this.blocks, t = this.lastByteIndex;
                e[16] = this.block, e[t >> 2] |= EXTRA[3 & t], this.block = e[16], t >= 56 && (this.hashed || this.hash(), e[0] = this.block, e[16] = e[1] = e[2] = e[3] = e[4] = e[5] = e[6] = e[7] = e[8] = e[9] = e[10] = e[11] = e[12] = e[13] = e[14] = e[15] = 0), e[14] = this.hBytes << 3 | this.bytes >>> 29, e[15] = this.bytes << 3, this.hash();
              }
            }, Sha1.prototype.hash = function() {
              var e, t, i = this.h0, r = this.h1, s = this.h2, a = this.h3, o = this.h4, n = this.blocks;
              for (e = 16; e < 80; ++e) t = n[e - 3] ^ n[e - 8] ^ n[e - 14] ^ n[e - 16], n[e] = t << 1 | t >>> 31;
              for (e = 0; e < 20; e += 5) i = (t = (r = (t = (s = (t = (a = (t = (o = (t = i << 5 | i >>> 27) + (r & s | ~r & a) + o + 1518500249 + n[e] << 0) << 5 | o >>> 27) + (i & (r = r << 30 | r >>> 2) | ~i & s) + a + 1518500249 + n[e + 1] << 0) << 5 | a >>> 27) + (o & (i = i << 30 | i >>> 2) | ~o & r) + s + 1518500249 + n[e + 2] << 0) << 5 | s >>> 27) + (a & (o = o << 30 | o >>> 2) | ~a & i) + r + 1518500249 + n[e + 3] << 0) << 5 | r >>> 27) + (s & (a = a << 30 | a >>> 2) | ~s & o) + i + 1518500249 + n[e + 4] << 0, s = s << 30 | s >>> 2;
              for (; e < 40; e += 5) i = (t = (r = (t = (s = (t = (a = (t = (o = (t = i << 5 | i >>> 27) + (r ^ s ^ a) + o + 1859775393 + n[e] << 0) << 5 | o >>> 27) + (i ^ (r = r << 30 | r >>> 2) ^ s) + a + 1859775393 + n[e + 1] << 0) << 5 | a >>> 27) + (o ^ (i = i << 30 | i >>> 2) ^ r) + s + 1859775393 + n[e + 2] << 0) << 5 | s >>> 27) + (a ^ (o = o << 30 | o >>> 2) ^ i) + r + 1859775393 + n[e + 3] << 0) << 5 | r >>> 27) + (s ^ (a = a << 30 | a >>> 2) ^ o) + i + 1859775393 + n[e + 4] << 0, s = s << 30 | s >>> 2;
              for (; e < 60; e += 5) i = (t = (r = (t = (s = (t = (a = (t = (o = (t = i << 5 | i >>> 27) + (r & s | r & a | s & a) + o - 1894007588 + n[e] << 0) << 5 | o >>> 27) + (i & (r = r << 30 | r >>> 2) | i & s | r & s) + a - 1894007588 + n[e + 1] << 0) << 5 | a >>> 27) + (o & (i = i << 30 | i >>> 2) | o & r | i & r) + s - 1894007588 + n[e + 2] << 0) << 5 | s >>> 27) + (a & (o = o << 30 | o >>> 2) | a & i | o & i) + r - 1894007588 + n[e + 3] << 0) << 5 | r >>> 27) + (s & (a = a << 30 | a >>> 2) | s & o | a & o) + i - 1894007588 + n[e + 4] << 0, s = s << 30 | s >>> 2;
              for (; e < 80; e += 5) i = (t = (r = (t = (s = (t = (a = (t = (o = (t = i << 5 | i >>> 27) + (r ^ s ^ a) + o - 899497514 + n[e] << 0) << 5 | o >>> 27) + (i ^ (r = r << 30 | r >>> 2) ^ s) + a - 899497514 + n[e + 1] << 0) << 5 | a >>> 27) + (o ^ (i = i << 30 | i >>> 2) ^ r) + s - 899497514 + n[e + 2] << 0) << 5 | s >>> 27) + (a ^ (o = o << 30 | o >>> 2) ^ i) + r - 899497514 + n[e + 3] << 0) << 5 | r >>> 27) + (s ^ (a = a << 30 | a >>> 2) ^ o) + i - 899497514 + n[e + 4] << 0, s = s << 30 | s >>> 2;
              this.h0 = this.h0 + i << 0, this.h1 = this.h1 + r << 0, this.h2 = this.h2 + s << 0, this.h3 = this.h3 + a << 0, this.h4 = this.h4 + o << 0;
            }, Sha1.prototype.hex = function() {
              this.finalize();
              var e = this.h0, t = this.h1, i = this.h2, r = this.h3, s = this.h4;
              return HEX_CHARS[e >> 28 & 15] + HEX_CHARS[e >> 24 & 15] + HEX_CHARS[e >> 20 & 15] + HEX_CHARS[e >> 16 & 15] + HEX_CHARS[e >> 12 & 15] + HEX_CHARS[e >> 8 & 15] + HEX_CHARS[e >> 4 & 15] + HEX_CHARS[15 & e] + HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[i >> 28 & 15] + HEX_CHARS[i >> 24 & 15] + HEX_CHARS[i >> 20 & 15] + HEX_CHARS[i >> 16 & 15] + HEX_CHARS[i >> 12 & 15] + HEX_CHARS[i >> 8 & 15] + HEX_CHARS[i >> 4 & 15] + HEX_CHARS[15 & i] + HEX_CHARS[r >> 28 & 15] + HEX_CHARS[r >> 24 & 15] + HEX_CHARS[r >> 20 & 15] + HEX_CHARS[r >> 16 & 15] + HEX_CHARS[r >> 12 & 15] + HEX_CHARS[r >> 8 & 15] + HEX_CHARS[r >> 4 & 15] + HEX_CHARS[15 & r] + HEX_CHARS[s >> 28 & 15] + HEX_CHARS[s >> 24 & 15] + HEX_CHARS[s >> 20 & 15] + HEX_CHARS[s >> 16 & 15] + HEX_CHARS[s >> 12 & 15] + HEX_CHARS[s >> 8 & 15] + HEX_CHARS[s >> 4 & 15] + HEX_CHARS[15 & s];
            }, Sha1.prototype.toString = Sha1.prototype.hex, Sha1.prototype.digest = function() {
              this.finalize();
              var e = this.h0, t = this.h1, i = this.h2, r = this.h3, s = this.h4;
              return [e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, 255 & e, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, 255 & i, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, s >> 24 & 255, s >> 16 & 255, s >> 8 & 255, 255 & s];
            }, Sha1.prototype.array = Sha1.prototype.digest, Sha1.prototype.arrayBuffer = function() {
              this.finalize();
              var e = new ArrayBuffer(20), t = new DataView(e);
              return t.setUint32(0, this.h0), t.setUint32(4, this.h1), t.setUint32(8, this.h2), t.setUint32(12, this.h3), t.setUint32(16, this.h4), e;
            };
            var exports = createMethod();
            COMMON_JS ? module.exports = exports : (root.sha1 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
              return exports;
            }).call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)));
          }();
        }).call(this, __webpack_require__(80), __webpack_require__(70));
      }, function(e, t) {
        (function(t2) {
          e.exports = t2;
        }).call(this, {});
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Signalling = void 0;
        const s = i(3), a = i(282), o = i(26), n = i(48), d = r(i(6)), c = r(i(8)), l = i(295), u = i(71), h = i(77), p = i(145), m = i(1), g = i(140), f = i(7), v = i(297);
        let S = 0;
        class y extends s.EventEmitter {
          constructor(e2) {
            super(), this.signallingId = S++, this._reconnectionTimer = null, this.reconnectionMaxTimeoutTimer = null, this._protoo = null, this._url = null, this._resolve = null, this._reject = null, this.consumers = {}, this.keepAliveTimer = null, this.joinTimestamps = [], this.joinFailedServers = [], this.reconnectionReason = n.ReconnectReason.Unknown, this.reconnectionControl = { current: null, next: null, copynext: null }, this.autoMask = { timer: null, data: [] }, this.logger = e2.logger.getChild(() => {
              var t2, i2;
              let r2 = "signal";
              return this.signallingId && (r2 += this.signallingId), this._protoo ? (this._protoo.id && (r2 += "#" + this._protoo.id + "_" + (null === (t2 = this._protoo._transport) || void 0 === t2 ? void 0 : t2.wsid)), this._protoo.connected || (r2 += "!connected")) : r2 += " PROTOO_UNINIT", (null === (i2 = e2.adapterRef._signalling) || void 0 === i2 ? void 0 : i2.signallingId) !== this.signallingId && (r2 += " DETACHED"), r2;
            }), this._reset(), this.adapterRef = e2.adapterRef, this.browserDevice = h.getOSInfo().osName + "-" + h.getBrowserInfo().browserName + "-" + h.getBrowserInfo().browserVersion;
          }
          _reset() {
            this._reconnectionTimer && clearTimeout(this._reconnectionTimer), this._reconnectionTimer = null, this.reconnectionMaxTimeoutTimer && clearTimeout(this.reconnectionMaxTimeoutTimer), this.reconnectionMaxTimeoutTimer = null, this._destroyProtoo(), this.reconnectionControl.current = null, this.reconnectionControl.next = null, this.reconnectionControl.copynext = null, this._resolve = null, this._reject = null, this.joinFailedServers.length = 0;
          }
          init(e2, t2) {
            return this._reconnectionTimer ? Promise.resolve() : new Promise(async (i2, r2) => {
              var s2;
              e2 || (this._resolve = i2), e2 || (this._reject = r2);
              let a2 = this.reconnectionControl.next || { timeout: t2 ? m.getParameters().reconnectionFirstTimeout : m.getParameters().joinFirstTimeout, url: this.adapterRef.channelInfo.wssArr[0], serverIndex: 0, times: t2 ? 1 : 0, isJoinRetry: e2, isReconnection: t2, isLastTry: false };
              if (a2.isJoinRetry = e2, a2.isReconnection = t2, t2 && "unknown" !== this.adapterRef.signalProbeManager.online && 1 === a2.times && m.getParameters().reconnectionWaitTimeout > 0 && 0 === this.adapterRef.signalProbeManager.getActiveServerCount().cnt) {
                const e3 = m.getParameters().reconnectionWaitTimeout;
                this.logger.warn(`目前所有服务端不在线，判断为网络断开。等待服务端起上线或 ${e3}ms`);
                const t3 = await this.adapterRef.signalProbeManager.waitForServerActive(e3);
                if ((null === (s2 = this.adapterRef._signalling) || void 0 === s2 ? void 0 : s2.signallingId) !== this.signallingId) return;
                this.logger.warn("恢复重连过程。reason:" + t3);
              }
              for (let e3 = 0; e3 < 6; e3++) {
                const e4 = this.adapterRef.signalProbeManager.getServerState(a2.url);
                if (!e4 || a2.isLastTry) break;
                if (this.adapterRef.signalProbeManager.getActiveServerCount().cnt > 0) if (e4.active) {
                  if (!(2 * e4.ping.rtt > a2.timeout)) break;
                  this.logger.warn(`重连跳过：当前服务器rtt过长：${a2.url} ${a2.serverIndex + 1}/${this.adapterRef.channelInfo.wssArr.length} timeout: ${a2.timeout}ms, rtt x2: ${e4.ping.rtt}x2=${2 * e4.ping.rtt}ms`), a2 = this._getNextConnConfig(a2);
                } else this.logger.error(`重连跳过：当前服务器不可用：${a2.url} ${a2.serverIndex + 1}/${this.adapterRef.channelInfo.wssArr.length} ${a2.timeout}ms`), a2 = this._getNextConnConfig(a2);
              }
              this.adapterRef.channelInfo.wssArrIndex = a2.serverIndex, e2 ? (t2 ? this.adapterRef.logger.error(`Signalling 开始尝试第 ${a2.serverIndex + 1}/${this.adapterRef.channelInfo.wssArr.length} 台服务器的第 ${a2.times}/${m.getParameters().reconnectionMaxRetry} 次重连，退避时间：${a2.timeout}毫秒，服务器地址：${a2.url}`) : this.adapterRef.logger.error(`join() 正在尝试第 ${a2.serverIndex + 1}/${this.adapterRef.channelInfo.wssArr.length} 台服务器的第 ${a2.times}/${m.getParameters().joinMaxRetry} 次重连，退避时间：${a2.timeout}毫秒，服务器地址：${a2.url}`), this.joinFailedServers.push({ addr: a2.url, code: -1, err_msg: "reconnection timeout", time_elapsed_for_signaling_connect: a2.timeout, signalling_rtt: -1, server_type: 0, time: Date.now(), network_type: "unknown" })) : this.adapterRef.logger.log(`join() 正在尝试第 ${a2.serverIndex + 1} / ${this.adapterRef.channelInfo.wssArr.length} 个服务器的第 ${a2.times} / ${m.getParameters().joinMaxRetry} 次连接`), this.reconnectionControl.current = a2, this.reconnectionControl.next = null, this._init(a2.url);
              let o2 = this._getNextConnConfig(a2);
              this.reconnectionControl.next = this.reconnectionControl.copynext = o2, this._reconnectionTimer && clearTimeout(this._reconnectionTimer), this._reconnectionTimer = setTimeout(() => {
                var e3;
                this._reconnectionTimer && clearTimeout(this._reconnectionTimer), this._reconnectionTimer = null, (null === (e3 = this.adapterRef._signalling) || void 0 === e3 ? void 0 : e3.signallingId) === this.signallingId && (this._destroyProtoo(), t2 ? (this.adapterRef.instance.safeEmit("@pairing-websocket-reconnection-error"), this._reconnection()) : this._connection());
              }, o2.timeout);
            });
          }
          _getNextConnConfig(e2) {
            let t2 = Object.assign({}, e2);
            return e2.times ? t2.serverIndex++ : (t2.times = 1, t2.serverIndex = 1), t2.serverIndex >= this.adapterRef.channelInfo.wssArr.length && (t2.times++, t2.serverIndex = 0), e2.isJoinRetry ? t2.timeout = m.getParameters().joinFirstTimeout + 2e3 * (t2.times - 1) : e2.isReconnection && (t2.timeout = m.getParameters().reconnectionFirstTimeout + 2e3 * (t2.times - 1)), t2.isJoinRetry = e2.isJoinRetry, t2.isReconnection = e2.isReconnection, t2.isJoinRetry && t2.times >= m.getParameters().joinMaxRetry && (m.getParameters().reconnectionMaxTimeout ? t2.times > m.getParameters().joinMaxRetry && (t2.times = 0) : t2.isLastTry = true), t2.isReconnection && t2.times >= m.getParameters().reconnectionMaxRetry && (m.getParameters().reconnectionMaxTimeout ? t2.times > m.getParameters().reconnectionMaxRetry && (t2.times = 0) : t2.isLastTry = true), t2.url = this.adapterRef.channelInfo.wssArr[t2.serverIndex], t2;
          }
          joinConnectTimeout() {
            this.adapterRef.logger.error("join() 所有的服务器地址都连接失败, 主动离开房间");
            const e2 = Date.now(), t2 = this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2;
            this.adapterRef.instance.apiEventReport("setLogin", { a_record: this.adapterRef.channelInfo.sessionConfig.recordAudio, v_record: this.adapterRef.channelInfo.sessionConfig.recordVideo, record_type: this.adapterRef.channelInfo.sessionConfig.recordType, host_speaker: this.adapterRef.channelInfo.sessionConfig.isHostSpeaker, permKey: this.adapterRef.channelInfo.permKey, result: -2, server_ip: this.adapterRef.channelInfo._protooUrl, signalling_rtt: this.adapterRef.state.signalJoinMsgRtt, signalling_time: t2.startWssTime - t2.startJoinTime, time_elapsed: e2 - t2.startJoinTime, join_failed_server: this.joinFailedServers, model: this.browserDevice, desc: "signalling server connection failed(timeout)" }), this.joinFailedServers.length = 0, this.adapterRef.channelInfo.wssArrIndex = 0, this.adapterRef.instance.leave(d.default.SIGNAL_CONNECTION_DISCONNECTED), this.adapterRef.instance.safeEmit("error", "SOCKET_ERROR"), this._reject && this._reject(new c.default({ code: d.default.NETWORK_ERROR, message: "join() 所有的服务器地址都连接失败" }));
          }
          async _connection() {
            m.getParameters().reconnectionMaxTimeout && (this.adapterRef.logger.warn("connection 设置了最大重连时间 reconnectionMaxTimeout: ", m.getParameters().reconnectionMaxTimeout), this.reconnectionMaxTimeoutTimer || (this.reconnectionMaxTimeoutTimer = setTimeout(() => {
              this.joinConnectTimeout();
            }, 1e3 * m.getParameters().reconnectionMaxTimeout))), this._destroyProtoo();
            const e2 = this.reconnectionControl.current, t2 = this.reconnectionControl.next;
            t2 ? !e2 || t2.times <= m.getParameters().joinMaxRetry ? this.init(true, false) : this.joinConnectTimeout() : this.adapterRef.logger.error("Join() 结束");
          }
          async _reconnection() {
            var e2, t2;
            if (!this._reconnectionTimer) {
              m.getParameters().reconnectionMaxTimeout && (this.adapterRef.logger.warn("reconnection 设置了最大重连时间 reconnectionMaxTimeout: ", m.getParameters().reconnectionMaxTimeout), this.reconnectionMaxTimeoutTimer || (this.reconnectionMaxTimeoutTimer = setTimeout(() => {
                this.adapterRef.instance.safeEmit("@pairing-websocket-reconnection-skip"), this.adapterRef.logger.error("所有的服务器地址都连接失败, 主动离开房间"), this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "socketError", ext: "signalling server reconnection failed(timeout)" }), this.adapterRef.channelInfo.wssArrIndex = 0, this.adapterRef.instance.leave(d.default.SIGNAL_CONNECTION_DISCONNECTED), this.adapterRef.instance.safeEmit("error", "SOCKET_ERROR");
              }, 1e3 * m.getParameters().reconnectionMaxTimeout))), this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "CONNECTING", this.adapterRef.connectState.reconnect = true, this.adapterRef.connectState.prevState !== this.adapterRef.connectState.curState && this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), this.adapterRef.instance.safeEmit("@pairing-websocket-reconnection-start"), this._destroyProtoo(), (null === (e2 = this.adapterRef._mediasoup) || void 0 === e2 ? void 0 : e2._sendTransportTimeoutTimer) && (clearTimeout(this.adapterRef._mediasoup._sendTransportTimeoutTimer), this.adapterRef._mediasoup._sendTransportTimeoutTimer = null), (null === (t2 = this.adapterRef._mediasoup) || void 0 === t2 ? void 0 : t2._recvTransportTimeoutTimer) && (clearTimeout(this.adapterRef._mediasoup._recvTransportTimeoutTimer), this.adapterRef._mediasoup._recvTransportTimeoutTimer = null), "CONNECTED" === this.adapterRef.connectState.prevState && (this.adapterRef.netStatusList.forEach((e3) => {
                e3.uplinkNetworkQuality = 0, e3.downlinkNetworkQuality = 0;
              }), this.adapterRef.instance.safeEmit("network-quality", this.adapterRef.netStatusList));
              for (let e3 in this.adapterRef.remoteStreamMap) {
                const t3 = this.adapterRef.remoteStreamMap[e3];
                t3._play && (this.logger.warn("Destroy Remote Player", e3), t3._play.destroy());
              }
              this.reconnectionControl.next && this.reconnectionControl.next.times > m.getParameters().reconnectionMaxRetry ? (this.adapterRef.instance.safeEmit("@pairing-websocket-reconnection-skip"), this.adapterRef.logger.error("所有的服务器地址都连接失败, 主动离开房间"), this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "socketError", ext: "signalling server reconnection failed(timeout)" }), this.adapterRef.channelInfo.wssArrIndex = 0, this.adapterRef.instance.leave(d.default.SIGNAL_CONNECTION_DISCONNECTED), this.adapterRef.instance.safeEmit("error", "SOCKET_ERROR")) : this.init(true, true);
            }
          }
          _init(e2) {
            -1 === e2.indexOf("?") && (e2 += "?"), this.logger.log("Signalling: init url = ", e2), this.adapterRef.channelInfo._protooUrl = e2, this._url = `${-1 === e2.indexOf("://") ? "wss://" : ""}${e2}&cid=${this.adapterRef.channelInfo.cid}&uid=${this.adapterRef.channelInfo.uid}&deviceid=${this.adapterRef.deviceId}`, this.logger.log("Signalling: 连接 url  ", this._url);
            const t2 = new v.WebSocketTransport(this._url, { retry: { retries: 0, factor: 2, minTimeout: 1e3, maxTimeout: 2e3, forever: false, maxRetryTime: 2e3 } }), i2 = new v.Peer(t2);
            this._protoo = i2, i2.signalling = this, this.adapterRef.state.signalEstablishTime = Date.now(), this._bindEvent();
          }
          _bindEvent() {
            var e2, t2, i2, r2, s2;
            null === (e2 = this._protoo) || void 0 === e2 || e2.on("failed", this._handleFailed.bind(this)), null === (t2 = this._protoo) || void 0 === t2 || t2.on("close", this._handleClose.bind(this)), null === (i2 = this._protoo) || void 0 === i2 || i2.on("open", this._handleOpen.bind(this, this._protoo)), null === (r2 = this._protoo) || void 0 === r2 || r2.on("notification", this._handleMessage.bind(this, this._protoo)), null === (s2 = this._protoo) || void 0 === s2 || s2.on("disconnected", this._handleDisconnected.bind(this, this._protoo));
          }
          _destroyProtoo() {
            var e2;
            if (this._protoo) {
              this.logger.debug(`信令通道#${this._protoo.id}_${null === (e2 = this._protoo._transport) || void 0 === e2 ? void 0 : e2.wsid} 被主动关闭。`), this._protoo.removeAllListeners();
              try {
                this._protoo && this._protoo.close();
              } catch (e3) {
              }
              this._protoo = null;
            }
          }
          async _handleMessage(e2, t2) {
            var i2, r2, s2, o2, c2, l2, h2;
            if (!(e2 && this._isProtooDetached(e2) || "connectioning" === this.adapterRef.channelStatus)) switch (t2.method) {
              case "OnPeerJoin": {
                const { requestId: e3, externData: i3 } = t2.data;
                this.logger.log("收到OnPeerJoin成员加入消息 uid =", i3.uid);
                let r3 = i3.uid;
                "string" === this.adapterRef.channelInfo.uidType && (r3 = r3.toString());
                let s3 = this.adapterRef.remoteStreamMap[r3];
                s3 ? s3.active = true : (s3 = new a.RemoteStream({ uid: r3, audio: false, audioSlave: false, video: false, screen: false, videoThird: false, videoFourth: false, client: this.adapterRef.instance, platformType: i3.platformType }), this.adapterRef.remoteStreamMap[r3] = s3, this.adapterRef.memberMap[r3] = r3), this.adapterRef.instance._roleInfo.audienceList[r3] = false, this.adapterRef.instance.safeEmit("peer-online", { uid: r3 }), i3.customData && this.adapterRef.instance.safeEmit("custom-data", { uid: r3, customData: i3.customData });
                break;
              }
              case "OnPeerLeave": {
                const { requestId: e3, externData: i3 } = t2.data;
                this.logger.log("OnPeerLeave externData =", JSON.stringify(i3, null, "")), i3.userList && i3.userList.forEach((e4) => {
                  var t3;
                  let i4 = e4.uid;
                  "string" === this.adapterRef.channelInfo.uidType && (i4 = i4.toString());
                  const r3 = e4.reason;
                  null === (t3 = this.adapterRef._mediasoup) || void 0 === t3 || t3.removeUselessConsumeRequest(i4, "all"), this.adapterRef.instance.clearMember(i4, r3), this.adapterRef.instance.removeSsrc(i4), delete this.adapterRef.instance._roleInfo.audienceList[i4];
                });
                break;
              }
              case "OnNewProducer": {
                const { externData: e3 } = t2.data;
                this.logger.log("收到OnNewProducer发布消息 externData =", JSON.stringify(e3.producerInfo));
                let s3, { uid: o3, producerId: n2, mediaType: d2, mute: c3, simulcastEnable: l3, spatialLayerCount: u2 } = e3.producerInfo;
                switch ("string" === this.adapterRef.channelInfo.uidType && (o3 = o3.toString()), d2) {
                  case "screenShare":
                    s3 = "screen";
                    break;
                  case "subAudio":
                    s3 = "audioSlave";
                    break;
                  case "audio":
                  case "video":
                  case "videoThird":
                  case "videoFourth":
                    s3 = d2;
                    break;
                  default:
                    return void this.logger.warn(`OnNewProducer 不支持的媒体类型:${d2}, uid ${o3}`);
                }
                let h3 = this.adapterRef.remoteStreamMap[o3];
                h3 ? h3.active = true : (h3 = new a.RemoteStream({ uid: o3, audio: "audio" === s3, audioSlave: "audioSlave" === s3, video: "video" === s3, screen: "screen" === s3, videoThird: "videoThird" === s3, videoFourth: "videoFourth" === s3, client: this.adapterRef.instance, platformType: e3.platformType }), this.adapterRef.remoteStreamMap[o3] = h3, this.adapterRef.memberMap[o3] = o3), h3.muteStatus[s3].send = e3.producerInfo.mute, h3.pubStatus[s3].consumerId ? null === (i2 = this.adapterRef._mediasoup) || void 0 === i2 || i2.destroyConsumer(h3.pubStatus[s3].consumerId, h3, s3) : null === (r2 = this.adapterRef._mediasoup) || void 0 === r2 || r2.removeUselessConsumeRequest(o3, d2), h3[s3] = true, h3.pubStatus[s3][s3] = true, h3.pubStatus[s3].producerId = n2, h3.pubStatus[s3].mute = c3, h3.pubStatus[s3].simulcastEnable = l3, h3.pubStatus[s3].consumerId = "", "video" !== s3 && "screen" !== s3 && "videoThird" !== s3 && "videoFourth" !== s3 || (h3.spatialLayerCount[s3] = u2), this.adapterRef.instance.safeEmit("stream-added", { stream: h3, mediaType: s3, dualStream: u2 > 1 }), c3 && ("audioSlave" === s3 ? this.adapterRef.instance.safeEmit("mute-audio-slave", { uid: h3.getId() }) : "videoThird" === s3 ? this.adapterRef.instance.safeEmit("mute-video-thrid", { uid: h3.getId() }) : "videoFourth" === s3 ? this.adapterRef.instance.safeEmit("mute-video-fourth", { uid: h3.getId() }) : this.adapterRef.instance.safeEmit("mute-" + s3, { uid: h3.getId() }));
                break;
              }
              case "OnProducerClose": {
                const { code: e3, errMsg: i3, externData: r3 } = t2.data;
                let { uid: a2, producerId: n2, mediaType: d2 } = r3;
                "string" === this.adapterRef.channelInfo.uidType && (a2 = a2.toString());
                let c3, l3 = this.adapterRef.remoteStreamMap[a2];
                if (!l3) return void this.logger.warn(`收到OnProducerClose消息，但是当前没有该Producer： code = ${e3}, errMsg = ${i3}, uid = ${a2}, mediaType = ${d2}, producerId: ${n2}`);
                switch (this.logger.log(`收到OnProducerClose消息 code = ${e3}, errMsg = ${i3}, uid = ${a2}, mediaType = ${d2}, producerId: ${n2}`), d2) {
                  case "screenShare":
                    c3 = "screen";
                    break;
                  case "subAudio":
                    c3 = "audioSlave";
                    break;
                  case "audio":
                  case "video":
                  case "videoThird":
                  case "videoFourth":
                    c3 = d2;
                    break;
                  default:
                    return void this.logger.warn(`OnProducerClose 不支持的媒体类型:${d2}, uid ${a2}`);
                }
                if (l3.pubStatus[c3].producerId !== n2) return void this.logger.log("该 producerId 已经无效，不处理");
                null === (s2 = this.adapterRef._mediasoup) || void 0 === s2 || s2.removeUselessConsumeRequest(a2, d2), l3.pubStatus[c3].consumerId && (null === (o2 = this.adapterRef._mediasoup) || void 0 === o2 || o2.destroyConsumer(l3.pubStatus[c3].consumerId, l3, c3), l3.pubStatus[c3].consumerId = ""), this.adapterRef.instance.removeSsrc(a2, c3), l3.subStatus[c3] = false, l3.pubStatus[c3][c3] = false, l3[c3] = false, l3.pubStatus[c3].consumerId = "", l3.pubStatus[c3].producerId = "", "video" !== c3 && "screen" !== c3 && "videoThird" !== c3 && "videoFourth" !== c3 || (l3.spatialLayerCount[c3] = 0), "audio" === c3 ? (l3.mediaHelper.audio.micTrack = null, u.emptyStreamWith(l3.mediaHelper.audio.audioStream, null)) : "audioSlave" === c3 ? (l3.mediaHelper.screenAudio.screenAudioTrack = null, u.emptyStreamWith(l3.mediaHelper.screenAudio.screenAudioStream, null)) : "video" === c3 ? (l3.mediaHelper.video.cameraTrack = null, u.emptyStreamWith(l3.mediaHelper.video.videoStream, null)) : "screen" === c3 ? (l3.mediaHelper.screen.screenVideoTrack = null, u.emptyStreamWith(l3.mediaHelper.screen.screenVideoStream, null)) : "videoThird" === c3 ? (l3.mediaHelper.videoThird.videoThirdTrack = null, u.emptyStreamWith(l3.mediaHelper.videoThird.videoThirdStream, null)) : "videoFourth" === c3 && (l3.mediaHelper.videoFourth.videoFourthTrack = null, u.emptyStreamWith(l3.mediaHelper.videoFourth.videoFourthStream, null)), this.adapterRef.instance.safeEmit("stream-removed", { stream: l3, mediaType: c3 });
                break;
              }
              case "OnConsumerClose": {
                const { requestId: e3, code: i3, errMsg: r3, consumerId: s3, producerId: a2 } = t2.data;
                this.logger.log(`chence OnConsumerClose code = ${i3} errMsg = ${r3} producerId = ${a2}`);
                const o3 = this.consumers[s3];
                if (!o3) break;
                o3.close();
                break;
              }
              case "consumerPaused": {
                const { consumerId: e3 } = t2.data;
                if (!this.consumers[e3]) break;
                break;
              }
              case "consumerResumed":
              case "consumerScore":
                break;
              case "OnTransportClose": {
                const { requestId: e3, code: i3, errMsg: r3, transportId: s3 } = t2.data;
                this.logger.warn(`chence OnTransportClose: code = ${i3}, errMsg = ${r3}, transportId = ${s3}`), (null === (c2 = this.adapterRef._mediasoup) || void 0 === c2 ? void 0 : c2._sendTransport) || (null === (l2 = this.adapterRef._mediasoup) || void 0 === l2 ? void 0 : l2._recvTransport) ? (this.logger.warn("服务器媒体进程crash，上行媒体和下行媒体同时重连"), this.adapterRef.channelStatus = "connectioning", this.reconnectionReason = n.ReconnectReason.OnTransportClose, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "OnTransportClose", ext: "" }), this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this._reconnection()) : this.logger.warn("服务器发送了错误信息");
                break;
              }
              case "OnSignalRestart": {
                const { requestId: e3, code: i3, errMsg: r3 } = t2.data;
                this.logger.warn(`chence OnSignalRestart code = ${i3} errMsg = ${r3}`), this.logger.warn("服务器信令进程crash，重连"), this.reconnectionReason = n.ReconnectReason.OnSignalRestart, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "OnSignalRestart", ext: "" }), (null === (h2 = this._protoo) || void 0 === h2 ? void 0 : h2.connected) && "CONNECTED" === this.adapterRef.connectState.curState || (this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this._reconnection());
                break;
              }
              case "OnPermKeyTimeout":
                this.adapterRef.instance.safeEmit("permkey-will-expire");
                break;
              case "OnPeerClose":
                this.logger.warn("相同UID在其他地方登录，您被踢出房间"), this.adapterRef.instance.safeEmit("uid-duplicate"), this.adapterRef.instance.leave(d.default.UID_DUPLICATE);
                break;
              case "OnKickOff": {
                let { reason: e3 } = t2.data.externData;
                this._handleKickedNotify(e3);
                break;
              }
              case "OnUserData": {
                let { type: e3, data: i3 } = t2.data.externData;
                if ("StreamStatus" === e3) this.logger.log("StreamStatus变更: ", JSON.stringify(i3, null, "")), this._handleStreamStatusNotify(i3);
                else if ("NetStatus" === e3) this._handleNetStatusNotify(i3);
                else if ("Mute" === e3) this.logger.log("mute变更: ", JSON.stringify(i3, null, "")), this._handleMuteNotify(i3);
                else if ("UserRole" === e3) this.logger.log("UserRole变更: ", JSON.stringify(i3, null, "")), this._handleUserRoleNotify(t2.data.externData);
                else if ("RtmpTaskStatus" === e3) this.logger.log("RtmpTaskStatus变更: ", JSON.stringify(i3, null, "")), this.adapterRef.instance.safeEmit("rtmp-state", i3);
                else if ("AutoMaskUid" === e3) {
                  const e4 = i3;
                  this.logger.log("收到打码通知：", e4.maskUid, "时长", e4.duration, "秒"), e4.maskUid && e4.duration && (e4.targetEndMs = Date.now() + 1e3 * e4.duration, this.autoMask.data.push(e4), this.updateMaskStatus());
                } else if ("MediaCapability" === e3) {
                  if (this.logger.warn("MediaCapability房间能力变更: ", JSON.stringify(i3, null, "")), this.adapterRef.mediaCapability.parseRoom(i3), this.adapterRef.instance.safeEmit("@mediaCapabilityChange"), this.adapterRef._mediasoup && this.adapterRef.mediaCapability.room.videoCodecType && this.adapterRef.localStream) {
                    const e4 = this.adapterRef.mediaCapability.getCodecSend("video", this.adapterRef._mediasoup._sendTransport.handler._sendingRtpParametersByKind.video), t3 = this.adapterRef.mediaCapability.getCodecSend("screen", this.adapterRef._mediasoup._sendTransport.handler._sendingRtpParametersByKind.video), i4 = this.adapterRef._mediasoup._webcamProducerCodec && this.adapterRef._mediasoup._webcamProducerCodec !== e4.codecName;
                    i4 && (this.logger.warn("将视频的Codec切走：", this.adapterRef._mediasoup._webcamProducerCodec, "=>", e4.codecName), e4.codecName && (f.IS_FIREFOX ? this.logger.warn("Firefox不支持动态切换Codec，触发重连") : (this.logger.log("尝试切换Codec"), await this.adapterRef._mediasoup.setRemoteRecvSdp(e4.codecName, "video"))));
                    const r3 = this.adapterRef._mediasoup._screenProducerCodec && this.adapterRef._mediasoup._screenProducerCodec !== e4.codecName;
                    r3 && (this.logger.warn("将辅流的Codec切走：", this.adapterRef._mediasoup._screenProducerCodec, "=>", t3.codecName), e4.codecName && (f.IS_FIREFOX ? this.logger.warn("Firefox不支持动态切换Codec，触发重连") : (this.logger.log("尝试切换Codec"), await this.adapterRef._mediasoup.setRemoteRecvSdp(e4.codecName, "screenShare")))), i4 || r3 ? f.IS_FIREFOX && (this.adapterRef.channelStatus = "connectioning", this.reconnectionReason = n.ReconnectReason.MediaCapability, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "MediaCapability", ext: "" }), this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this._reconnection()) : this.logger.log("Codec保持不动。video:", this.adapterRef._mediasoup._webcamProducerCodec, ", screen:", this.adapterRef._mediasoup._screenProducerCodec);
                  }
                } else if ("Ability" === e3) this._handleAbility(t2.data.externData.data);
                else if ("ChangeRight" === e3) {
                  let e4 = i3.uid;
                  if (1 === i3.audioRight ? (this.adapterRef.isAudioBanned = true, this.adapterRef.instance.safeEmit("audioVideoBanned", { uid: e4, mediaType: "audio", state: true, duration: i3.audioDuration })) : 2 === i3.audioRight && (this.adapterRef.isAudioBanned = false, this.adapterRef.instance.safeEmit("audioVideoBanned", { uid: e4, mediaType: "audio", state: false, duration: i3.audioDuration })), 1 === i3.videoRight ? (this.adapterRef.isVideoBanned = true, this.adapterRef.instance.safeEmit("audioVideoBanned", { uid: e4, mediaType: "video", state: true, duration: i3.videoDuration })) : 2 === i3.videoRight && (this.adapterRef.isVideoBanned = false, this.adapterRef.instance.safeEmit("audioVideoBanned", { uid: e4, mediaType: "video", state: false, duration: i3.videoDuration })), this.adapterRef.isAudioBanned && this.adapterRef.isVideoBanned && this.adapterRef.instance.apiEventReport("setAudioVideoBanned", { name: "set_mediaRightChange", oper: "1", isAudioBanned: true, isVideoBanned: true }), !this.adapterRef.isAudioBanned && this.adapterRef.isVideoBanned && this.adapterRef.instance.apiEventReport("setAudioVideoBanned", { name: "set_mediaRightChange", oper: "1", isAudioBanned: false, isVideoBanned: true }), this.adapterRef.isAudioBanned && !this.adapterRef.isVideoBanned && this.adapterRef.instance.apiEventReport("setAudioVideoBanned", { name: "set_mediaRightChange", oper: "1", isAudioBanned: true, isVideoBanned: false }), this.adapterRef.isAudioBanned || this.adapterRef.isVideoBanned || this.adapterRef.instance.apiEventReport("setAudioVideoBanned", { name: "set_mediaRightChange", oper: "1", isAudioBanned: false, isVideoBanned: false }), !this.adapterRef.localStream) return;
                } else this.logger.error(`收到OnUserData通知消息 type = ${e3}, data: `, i3);
                break;
              }
              case "OnAsrData": {
                const { externData: e3 } = t2.data;
                this.adapterRef.instance.safeEmit("asr-captions", e3);
                break;
              }
            }
          }
          _handleFailed() {
            this.logger.log("Signalling:_handleFailed");
          }
          _handleClose() {
          }
          _isProtooDetached(e2) {
            var t2, i2, r2;
            return this._protoo ? this._protoo.id !== e2.id ? (this.logger.warn(`Protoo is detached: ${e2.id} => ${this._protoo.id}`), true) : (null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2.signallingId) !== this.signallingId && (this.logger.warn(`Protoo.signaling is detached: ${this._protoo.id} => ${null === (r2 = null === (i2 = this.adapterRef._signalling) || void 0 === i2 ? void 0 : i2._protoo) || void 0 === r2 ? void 0 : r2.id}`), true) : (this.logger.warn("Protoo is destroyed: " + e2.id), true);
          }
          _handleDisconnected(e2) {
            var t2, i2, r2, s2;
            this.logger.log("Signalling:_handleDisconnected"), this.adapterRef.instance.outOfConnect || (!this._reconnectionTimer || "connectioning" !== this.adapterRef.channelStatus && "join" !== this.adapterRef.channelStatus ? (this.logger.warn(`信令通道#${e2.id}_${null === (s2 = e2._transport) || void 0 === s2 ? void 0 : s2.wsid} 收到关闭信号，即将开始重连过程。`), this.adapterRef.channelStatus = "connectioning", this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.startWssTime = Date.now(), this._reconnection()) : e2.closed ? this.logger.warn(`信令通道#${e2.id}_${null === (t2 = e2._transport) || void 0 === t2 ? void 0 : t2.wsid} 在建立过程中被关闭。当前正在重连中，等待下次重连过程。`) : this.logger.warn(`信令通道#${e2.id}_${null === (i2 = e2._transport) || void 0 === i2 ? void 0 : i2.wsid} 在建立过程中被关闭。信令通道会自动重试。连接地址：${null === (r2 = e2._transport) || void 0 === r2 ? void 0 : r2._url}`), this.reconnectionReason = n.ReconnectReason.WebsocketDisconnect, this.adapterRef.instance.apiEventReport("setDisconnect", { reason: "websocketDisconnect", ext: "" }));
          }
          async _handleOpen(e2) {
            var t2, i2, r2, s2;
            if (e2 && this._isProtooDetached(e2)) return;
            if (this.joinTimestamps.push(Date.now()), this.joinTimestamps.length > 4 && this.joinTimestamps.shift(), this.joinTimestamps.length >= 4 && this.joinTimestamps[3] - this.joinTimestamps[0] < 1e3) return void this.logger.error("signaling.join: 在1秒以内连续发生了 4 次Join事件, 异常退出。");
            let l2;
            this.adapterRef.state.signalOpenTime = Date.now(), this.adapterRef.state.signalWebsocketOpenRtt = this.adapterRef.state.signalOpenTime - this.adapterRef.state.signalEstablishTime, this._reconnectionTimer && (clearTimeout(this._reconnectionTimer), this._reconnectionTimer = null), this.reconnectionMaxTimeoutTimer && clearTimeout(this.reconnectionMaxTimeoutTimer), this.reconnectionMaxTimeoutTimer = null, l2 = !!this.adapterRef.encryption.encryptionSecret && "none" !== this.adapterRef.encryption.encryptionMode;
            const u2 = { method: "Join", permKeySecret: this.adapterRef.channelInfo.permKey, requestId: "" + Math.ceil(1e9 * Math.random()), supportStdRed: true, supportTurn: !this.adapterRef.proxyServer.enable, externData: { requestStunServers: !(!f.ANDROID_VERSION || 0 !== f.ANDROID_VERSION.indexOf("11")), userName: "" + this.adapterRef.channelInfo.uid, token: this.adapterRef.channelInfo.token, cname: "" + this.adapterRef.channelInfo.channelName, subType: "select", role: "part", version: "2.0", sessionMode: "meeting", engineVersion: o.ENGINE_VERSION, userRole: this.adapterRef.instance._roleInfo.userRole, userType: m.getParameters().userType, platformType: 16, rtmp: { support: this.adapterRef.channelInfo.sessionConfig.liveEnable }, record: { host: this.adapterRef.channelInfo.sessionConfig.isHostSpeaker, supportVideo: this.adapterRef.channelInfo.sessionConfig.recordVideo, supportAuido: this.adapterRef.channelInfo.sessionConfig.recordAudio, recordType: this.adapterRef.channelInfo.sessionConfig.recordType - 0 }, mediaCapabilitySet: this.adapterRef.mediaCapability.stringify(), browser: { name: h.getBrowserInfo().browserName, version: "" + h.getBrowserInfo().browserVersion }, customData: this.adapterRef.channelInfo.customData || "", gmEnable: l2, gmMode: p.encryptionModeToInt(this.adapterRef.encryption.encryptionMode), gmKey: this.adapterRef.encryption.encryptionSecret, customEncryption: !m.getParameters().forceCustomEncryptionOff && this.adapterRef.encryption.encodedInsertableStreams, userPriority: this.adapterRef.userPriority, supportTmmbrFeedback: true } };
            if ((null === (t2 = this.adapterRef._signalling) || void 0 === t2 ? void 0 : t2.signallingId) === this.signallingId) {
              this.logger.log("signaling.join: socket连接成功，开始发送Join请求"), null === (i2 = this._protoo) || void 0 === i2 || i2.clear();
              try {
                let t3 = null, i3 = this._protoo;
                const o2 = Date.now();
                try {
                  const e3 = null === (r2 = this._protoo) || void 0 === r2 ? void 0 : r2.request("Join", u2);
                  "connectioning" === this.adapterRef.channelStatus ? this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelRejoining, reason: n.ConStateChange_reason.Join }) : "join" === this.adapterRef.channelStatus && this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelJoining, reason: n.ConStateChange_reason.Join }), !this.adapterRef.signalProbeManager.worker && m.getParameters().signalProbeEnabled && this.adapterRef.signalProbeManager.start(this.adapterRef.channelInfo.wssArr), t3 = await e3, this.adapterRef.state.signalJoinResTime = Date.now(), this.adapterRef.state.signalJoinMsgRtt = this.adapterRef.state.signalJoinResTime - o2;
                } catch (e3) {
                  if (i3 !== this._protoo) return void this.logger.warn(`Signalling.Join 过期的信令通道消息：【${e3.name}】`, e3.message);
                  throw this.logger.warn("Signalling.Join Login request error: ", e3.message), this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelJoinFailed, reason: n.ConStateChange_reason.JoinChannelFailed }), new c.default({ code: d.default.LOGIN_REQUEST_ERROR, message: e3.message });
                }
                if (this._isProtooDetached(e2)) return;
                if (this.logger.log("Signalling.Join 请求收到response"), 200 != t3.code) {
                  let e3 = "Unknown Error";
                  return t3.externData ? e3 = t3.externData.errMsg : t3.errMsg && (e3 = t3.errMsg), this.logger.error(`Signalling.Join: 加入房间失败, code = ${t3.code}, reason = ${e3}`), this.adapterRef.instance.safeEmit("@pairing-websocket-reconnection-error"), this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelJoinFailed, reason: n.ConStateChange_reason.RequestChannelFailed }), void this._joinFailed(t3.code, e3);
                }
                let l3 = this.adapterRef.channelInfo.uid;
                t3.PermKey && (this.adapterRef.permKeyInfo = t3.PermKey), 1 === t3.externData.audioRight ? (this.adapterRef.isAudioBanned = true, this.adapterRef.instance.safeEmit("audioVideoBanned", { uid: l3, mediaType: "audio", state: true })) : this.adapterRef.isAudioBanned = false, 1 === t3.externData.videoRight ? (this.adapterRef.isVideoBanned = true, this.adapterRef.isAudioBanned = true, this.adapterRef.instance.safeEmit("audioVideoBanned", { uid: l3, mediaType: "audio", state: true })) : this.adapterRef.isVideoBanned = false, this.adapterRef.instance.apiEventReport("setAudioVideoBanned", { name: "set_mediaRightChange", oper: "1", isAudioBanned: !!this.adapterRef.isAudioBanned, isVideoBanned: !!this.adapterRef.isVideoBanned }), this.adapterRef.isAudioBanned && this.adapterRef.isVideoBanned && this.logger.warn("Signalling.Join 服务器禁止发送音频流"), this.reconnectionControl.next = null, this.logger.log("Signalling.Join: 加入房间成功", this.adapterRef.channelStatus), this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "CONNECTED", "no" === m.getParameters().forceBWE ? t3.preferRemb ? (this.logger.log("Signalling.Join 服务端配置bwe：上行使用remb"), this.adapterRef.preferRemb = true) : (this.logger.log("Signalling.Join 服务端配置bwe：上行使用transport-cc"), this.adapterRef.preferRemb = false) : (this.adapterRef.preferRemb || t3.preferRemb) && "transport-cc" === m.getParameters().forceBWE ? (this.logger.warn("Signalling.Join 强行使用transport-cc。忽略服务端配置bwe：preferRemb: " + t3.preferRemb), this.adapterRef.preferRemb = false) : "remb" === m.getParameters().forceBWE && (this.logger.warn("Signalling.Join 强行使用REMB。忽略服务端配置bwe：preferRemb: " + t3.preferRemb), this.adapterRef.preferRemb = true), this.adapterRef.audioAsl.enabled = t3.supportWebAsl ? "yes" : "no", this.adapterRef.audioAsl.aslActiveNum = t3.aslActiveNum, t3.supportWebAsl ? t3.aslActiveNum ? this.logger.log("Signalling.Join aslActiveNum数量: " + t3.aslActiveNum) : this.logger.warn("Signalling.Join 服务端支持ASL但没有返回ASL数量") : this.logger.log("Signalling.Join 服务端未开启ASL"), this.adapterRef.instance.safeEmit("aslStatus", { enabled: !!t3.supportWebAsl, aslActiveNum: t3.aslActiveNum });
                const h2 = this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2;
                if (this.joinFailedServers.pop(), "connectioning" === this.adapterRef.channelStatus) {
                  if (this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelJoined, reason: n.ConStateChange_reason.ReJoinSucceed }), this.adapterRef.connectState.reconnect = true, this.logger.log("Signalling.Join: 重连成功, 清除之前的媒体的通道"), null === (s2 = this._protoo) || void 0 === s2 || s2.clear(), this.adapterRef.channelStatus = "join", this.adapterRef.instance.apiEventReport("setRelogin", { a_record: this.adapterRef.channelInfo.sessionConfig.recordAudio, v_record: this.adapterRef.channelInfo.sessionConfig.recordVideo, record_type: this.adapterRef.channelInfo.sessionConfig.recordType, host_speaker: this.adapterRef.channelInfo.sessionConfig.isHostSpeaker, permKey: this.adapterRef.channelInfo.permKey, result: 0, reason: this.reconnectionReason, server_ip: this.adapterRef.channelInfo._protooUrl, signalling_rtt: this.adapterRef.state.signalJoinMsgRtt, time_elapsed_for_signaling_connect: o2 - h2.startWssTime, join_failed_server: this.joinFailedServers }), this.joinFailedServers.length = 0, this.adapterRef.instance.resetChannel(), !this.adapterRef._mediasoup) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "signalling_join: 媒体服务异常 1" });
                  this.adapterRef._mediasoup._edgeRtpCapabilities = t3.edgeRtpCapabilities, this.adapterRef.mediaCapability.parseRoom(t3.externData.roomCapability), this.adapterRef.instance.safeEmit("@mediaCapabilityChange"), await this.adapterRef._mediasoup.init(t3.stunServers), this.adapterRef.asrCaptionConfig.enable && (this.logger.log(`Signalling.Join 重连后再次发送startCaptions, source: ${this.adapterRef.asrCaptionConfig.source}, target: ${this.adapterRef.asrCaptionConfig.target}`), this.adapterRef.instance.startAsrCaptions(this.adapterRef.asrCaptionConfig.source, this.adapterRef.asrCaptionConfig.target)), this.adapterRef.localStream ? this.adapterRef.localStream.audio || this.adapterRef.localStream.video || this.adapterRef.localStream.screen || this.adapterRef.localStream.screenAudio || m.getParameters().allowEmptyMedia || this.adapterRef.localStream.audioSlave ? (this.logger.log(`Signalling.Join 重连成功, 重新publish本端流: audio ${this.adapterRef.localStream.hasAudio()}, video ${this.adapterRef.localStream.hasVideo()}, screen ${this.adapterRef.localStream.hasScreen()}, audioSlave ${this.adapterRef.localStream.hasAudioSlave()}`), this.adapterRef.instance.doPublish(this.adapterRef.localStream, "all")) : this.logger.log("Signalling.Join 重连成功，当前没有媒体流，无需发布") : this.logger.log("Signalling.Join 重连成功, 当前在未发布状态, 无需发布");
                } else {
                  this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelJoined, reason: n.ConStateChange_reason.JoinSucceed }), this.adapterRef.connectState.reconnect = false;
                  const e3 = Date.now();
                  if (this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2.joinedSuccessedTime = e3, this.adapterRef.instance.apiEventReport("setLogin", { a_record: this.adapterRef.channelInfo.sessionConfig.recordAudio, v_record: this.adapterRef.channelInfo.sessionConfig.recordVideo, record_type: this.adapterRef.channelInfo.sessionConfig.recordType, host_speaker: this.adapterRef.channelInfo.sessionConfig.isHostSpeaker, permKey: this.adapterRef.channelInfo.permKey, result: 0, server_ip: this.adapterRef.channelInfo._protooUrl, signalling_rtt: this.adapterRef.state.signalJoinMsgRtt, signalling_time: this.adapterRef.state.getChannelInfoRtt, time_elapsed_for_signaling_connect: o2 - h2.startWssTime, time_elapsed: e3 - h2.startJoinTime, model: this.browserDevice, join_failed_server: this.joinFailedServers }), this.joinFailedServers.length = 0, !this.adapterRef._mediasoup) throw new c.default({ code: d.default.UNKNOWN_TYPE_ERROR, message: "signalling_join: 媒体服务异常 2" });
                  this.adapterRef._mediasoup._edgeRtpCapabilities = t3.edgeRtpCapabilities, this.adapterRef.mediaCapability.parseRoom(t3.externData.roomCapability), this.adapterRef.instance.safeEmit("@mediaCapabilityChange"), await this.adapterRef._mediasoup.init(t3.stunServers);
                }
                this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), this.logger.log("Signalling.Join 查看房间其他人的发布信息: " + JSON.stringify(t3.externData.userList));
                const p2 = [];
                if (void 0 !== t3.externData && t3.externData.userList && t3.externData.userList.length) {
                  let e3 = this;
                  for (const i4 of t3.externData.userList) {
                    let t4 = i4.uid;
                    "string" === this.adapterRef.channelInfo.uidType && (t4 = t4.toString());
                    let r3 = this.adapterRef.remoteStreamMap[t4];
                    if (r3 ? (r3.active = true, this.adapterRef.memberMap[t4] = "" + t4, p2.push({ eventName: "peer-online", eventData: { uid: t4 } })) : (r3 = new a.RemoteStream({ uid: t4, audio: false, audioSlave: false, video: false, screen: false, videoThird: false, videoFourth: false, client: this.adapterRef.instance, platformType: i4.platformType }), this.adapterRef.remoteStreamMap[t4] = r3, this.adapterRef.memberMap[t4] = "" + t4, p2.push({ eventName: "peer-online", eventData: { uid: t4 } })), i4.customData && p2.push({ eventName: "custom-data", eventData: { uid: t4, customData: i4.customData } }), i4.producerInfoList) for (const s3 of i4.producerInfoList) {
                      const { mediaType: i5, producerId: a2, mute: o3, simulcastEnable: n2, spatialLayerCount: d2 } = s3;
                      let c2;
                      switch (i5) {
                        case "screenShare":
                          c2 = "screen";
                          break;
                        case "subAudio":
                          c2 = "audioSlave";
                          break;
                        case "audio":
                        case "video":
                        case "videoThird":
                        case "videoFourth":
                          c2 = i5;
                          break;
                        default:
                          return void this.logger.warn(`OnNewProducer 不支持的媒体类型:${i5}, uid ${t4}`);
                      }
                      if (r3[c2] = true, r3.pubStatus[c2][c2] = true, r3.pubStatus[c2].producerId = a2, r3.pubStatus[c2].mute = o3, r3.muteStatus[c2].send = o3, r3.pubStatus[c2].simulcastEnable = n2, "video" !== c2 && "screen" !== c2 && "videoThird" !== c2 && "videoFourth" !== c2 || (r3.spatialLayerCount[c2] = d2), e3.logger.log(`Signalling.Join: 通知 ${r3.getId()} 发布信息: ${JSON.stringify(r3.pubStatus, null, "")}`), (r3.pubStatus.audio.audio || r3.pubStatus.video.video || r3.pubStatus.screen.screen || r3.pubStatus.audioSlave.audioSlave || r3.pubStatus.videoThird.videoThird || r3.pubStatus.videoFourth.videoFourth) && p2.push({ eventName: "stream-added", eventData: { stream: r3, mediaType: c2, dualStream: d2 > 1 } }), o3) {
                        let e4 = "";
                        e4 = "audioSlave" === c2 ? "mute-audio-slave" : "videoThird" === c2 ? "mute-video-thrid" : "videoFourth" === c2 ? "mute-video-fourth" : "mute-" + c2, p2.push({ eventName: e4, eventData: { uid: r3.getId() } });
                      }
                    }
                  }
                  for (let e4 in this.adapterRef.remoteStreamMap) {
                    this.adapterRef.remoteStreamMap[e4].active || (this.logger.warn("Signalling.Join 重连期间远端流停止发布：" + e4), delete this.adapterRef.remoteStreamMap[e4]);
                  }
                }
                const g2 = this.adapterRef.instance;
                setTimeout(() => {
                  for (let e3 = 0; e3 < p2.length; e3++) {
                    const t4 = p2[e3].eventName, i4 = p2[e3].eventData;
                    g2 && ("stream-added" === t4 && ("audio" === i4.mediaType ? g2.adapterRef.state.signalAudioAddedTime < g2.adapterRef.state.signalOpenTime && (g2.adapterRef.state.signalAudioAddedTime = Date.now()) : "video" === i4.mediaType && g2.adapterRef.state.signalVideoAddedTime < g2.adapterRef.state.signalOpenTime && (g2.adapterRef.state.signalVideoAddedTime = Date.now())), g2.safeEmit(t4, i4));
                  }
                }, 0), this.adapterRef.state.signalJoinSuccessTime = Date.now(), this._resolve ? (this.logger.log("Signalling.Join 加入房间成功, 反馈通知"), this._resolve(t3), this._resolve = null, this._reject = null) : this.adapterRef.instance.safeEmit("@pairing-websocket-reconnection-success"), this.doSendKeepAliveTask();
              } catch (e3) {
                this.logger.error("Signalling.Join: 登录流程内部错误: ", e3.message), this._joinFailed(-1, e3.message || "LOGIN_ERROR");
              }
            }
          }
          _joinFailed(e2, t2) {
            this.adapterRef.connectState.prevState = this.adapterRef.connectState.curState, this.adapterRef.connectState.curState = "DISCONNECTED", this.adapterRef.connectState.reconnect = false, this.adapterRef.channelStatus = "init", this.adapterRef.instance.safeEmit("connection-state-change", this.adapterRef.connectState), 4009 === e2 && this.adapterRef.instance.safeEmit("crypt-error", { cryptType: this.adapterRef.encryption.encryptionMode });
            const i2 = Date.now(), r2 = this.adapterRef.instance._params.JoinChannelRequestParam4WebRTC2;
            if (this.adapterRef.instance.apiEventReport("setLogin", { a_record: this.adapterRef.channelInfo.sessionConfig.recordAudio, v_record: this.adapterRef.channelInfo.sessionConfig.recordVideo, record_type: this.adapterRef.channelInfo.sessionConfig.recordType, host_speaker: this.adapterRef.channelInfo.sessionConfig.isHostSpeaker, permKey: this.adapterRef.channelInfo.permKey, result: e2, server_ip: this.adapterRef.channelInfo._protooUrl, signalling_rtt: this.adapterRef.state.signalJoinMsgRtt, signalling_time: r2.startWssTime - r2.startJoinTime, time_elapsed: i2 - r2.startJoinTime, join_failed_server: this.joinFailedServers, model: this.browserDevice, desc: t2 || "" }), this.joinFailedServers.length = 0, this._reject) this.logger.error("Signalling.Join 加入房间失败, 反馈通知"), this._reject(new c.default({ code: d.default.SERVER_AUTH_ERROR, extraCode: e2, message: t2 || "join failed" })), this._resolve = null, this._reject = null, this.keepAliveTimer && (clearInterval(this.keepAliveTimer), this.keepAliveTimer = null), this.adapterRef.channelStatus = "leave", this.adapterRef.instance.stopSession();
            else {
              switch (t2) {
                case "room not found":
                  this.logger.error("Signalling.Join 网络重连时，加入房间失败，主动离开。重连失败原因：", t2, "，这通常是因为房间内其他人都已离开，房间关闭引起的");
                  break;
                default:
                  this.logger.error("Signalling.Join 网络重连时，加入房间失败，主动离开。重连失败原因：", t2);
              }
              this.adapterRef.instance.safeEmit("error", "RELOGIN_ERROR"), this.adapterRef.instance.leave(d.default.LOGIN_FAILED);
            }
          }
          doSendKeepAliveTask() {
            this.keepAliveTimer && (clearInterval(this.keepAliveTimer), this.keepAliveTimer = null);
            let e2 = false;
            this.keepAliveTimer = setInterval(async () => {
              e2 || (e2 = true, await this.doSendKeepAlive(), e2 = false);
            }, 6e3);
          }
          async doSendKeepAlive() {
            var e2, t2;
            if (!(null === (e2 = this._protoo) || void 0 === e2 ? void 0 : e2.connected)) return;
            this._protoo.id, null === (t2 = this._protoo._transport) || void 0 === t2 || t2.wsid;
            const i2 = Date.now();
            try {
              await this._protoo.request("Heartbeat");
            } catch (e3) {
              this.logger.error(`信令包保活失败, reason: ${e3.message}, ${Date.now() - i2}ms`);
            }
          }
          async updatePermKey(e2) {
            var t2;
            if (this.logger.log("updatePermKey newwork isConnect: ", null === (t2 = this._protoo) || void 0 === t2 ? void 0 : t2.connected), !this._protoo || !this._protoo.connected) return;
            const i2 = await this._protoo.request("PermKeyUpdate", { requestId: "" + Math.ceil(1e9 * Math.random()), permKeySecret: e2 });
            200 !== i2.code ? new c.default({ code: d.default.UPDATE_PERMKEY_ERROR, extraCode: i2.code, message: "update permkey 认证错误" }) : this.adapterRef.permKeyInfo = i2.PermKey;
          }
          updateMaskStatus() {
            var e2, t2, i2;
            let r2 = Date.now();
            for (let i3 = this.autoMask.data.length - 1; i3 >= 0; i3--) {
              let s3 = this.autoMask.data[i3];
              if (r2 >= s3.targetEndMs) {
                if (this.adapterRef.channelInfo.uid === s3.maskUid && this.adapterRef.localStream) this.logger.log("updateMaskStatus 本地用户去除打码", s3.maskUid), null === (e2 = this.adapterRef.localStream._play) || void 0 === e2 || e2.disableMask();
                else {
                  const e3 = this.adapterRef.remoteStreamMap[s3.maskUid];
                  e3 && (null === (t2 = e3._play) || void 0 === t2 ? void 0 : t2.mask.enabled) && (this.logger.log("updateMaskStatus 远端用户去除打码", s3.maskUid), e3._play.disableMask());
                }
                this.autoMask.data.splice(i3, 1);
              }
            }
            let s2 = Number.MAX_SAFE_INTEGER;
            for (let e3 = 0; e3 < this.autoMask.data.length; e3++) {
              let t3 = this.autoMask.data[e3];
              s2 = Math.min(s2, t3.targetEndMs);
              if (this.adapterRef.channelInfo.uid == t3.maskUid && this.adapterRef.localStream) this.logger.log("updateMaskStatus 本地用户增加打码", t3.maskUid), null === (i2 = this.adapterRef.localStream._play) || void 0 === i2 || i2.enableMask();
              else {
                const e4 = this.adapterRef.remoteStreamMap[t3.maskUid];
                e4 ? e4._play && !e4._play.mask.enabled && (this.logger.log("updateMaskStatus 远端用户增加打码", t3.maskUid, "打码时长", t3.duration, "秒"), e4._play.enableMask()) : this.logger.log("updateMaskStatus 远端用户不在频道中", t3.maskUid, "打码时长", t3.duration, "秒");
              }
            }
            this.autoMask.timer && clearTimeout(this.autoMask.timer), this.autoMask.timer = setTimeout(() => {
              this.updateMaskStatus();
            }, s2 - r2);
          }
          async doSendLogout() {
            if (this.logger.log("doSendLogout() begin"), this.keepAliveTimer && (clearInterval(this.keepAliveTimer), this.keepAliveTimer = null), !this._protoo || !this._protoo.connected) return;
            let e2 = { requestId: "" + Math.ceil(1e9 * Math.random()), externData: { reason: 0 } };
            this._protoo.notify("Leave", e2), this.logger.log("doSendLogout() success");
          }
          _handleStreamStatusNotify(e2) {
          }
          _handleNetStatusNotify(e2) {
            const t2 = e2.netStatusList;
            let i2 = l.parseBase64(t2).toString(), r2 = [], s2 = i2.substr(2, 2) + i2.substr(0, 2);
            s2 = parseInt(s2, 16), i2 = i2.substr(4);
            for (let e3 = 0; e3 < s2; e3++) {
              let e4 = i2.substr(0, 16);
              e4 = a2(e4);
              const t3 = i2.substr(16, 2), s3 = i2.substr(18, 2);
              let o3 = 0, n3 = null;
              if ("00" != i2.substr(20, 2)) {
                const e5 = i2.substr(22, 2);
                o3 = parseInt(e5, 16), n3 = i2.substr(24, o3), o3++;
              }
              const d3 = { uid: "string" === this.adapterRef.channelInfo.uidType ? g.SimpleBig.fromHex(e4).toString() : parseInt(e4, 16), downlinkNetworkQuality: parseInt(t3, 16), uplinkNetworkQuality: parseInt(s3, 16), receiveTs: Date.now() };
              r2.push(d3), i2 = i2.substr(22 + o3);
            }
            function a2(e3) {
              let t3 = [];
              for (var i3 = e3.length; i3 >= 1; i3 -= 2) t3.push(e3[i3 - 2], e3[i3 - 1]);
              return t3.join("");
            }
            let o2 = true, n2 = [];
            r2 = r2.filter((e3) => 0 != e3.uid), this.adapterRef.netStatusList.map((e3) => {
              o2 = true, r2.map((t3) => {
                e3.uid != t3.uid && 0 != t3.uid || (o2 = false);
              }), o2 && n2.push(e3);
            });
            let d2 = n2.concat(r2);
            d2 = d2.filter((e3) => this.adapterRef.memberMap[e3.uid] || e3.uid == this.adapterRef.channelInfo.uid), this.adapterRef.netStatusList = d2, this.adapterRef.instance.safeEmit("network-quality", this.adapterRef.netStatusList);
          }
          _handleMuteNotify(e2) {
            const t2 = e2.producerId, i2 = e2.mute;
            Object.values(this.adapterRef.remoteStreamMap).forEach((e3) => {
              n.MediaTypeList.forEach((r2) => {
                e3.pubStatus[r2].producerId === t2 && (e3.muteStatus[r2].send = i2, i2 ? "audioSlave" === r2 ? this.adapterRef.instance.safeEmit("mute-audio-slave", { uid: e3.getId() }) : this.adapterRef.instance.safeEmit("mute-" + r2, { uid: e3.getId() }) : "audioSlave" === r2 ? this.adapterRef.instance.safeEmit("unmute-audio-slave", { uid: e3.getId() }) : this.adapterRef.instance.safeEmit("unmute-" + r2, { uid: e3.getId() }));
              });
            });
          }
          _handleUserRoleNotify(e2) {
            let t2 = e2.uid;
            "string" === this.adapterRef.channelInfo.uidType && (t2 = t2.toString());
            const i2 = e2.data && e2.data.userRole;
            if (this.logger.warn(`用户${t2}角色变为${i2 ? "观众" : "主播"}`), t2 && 1 === i2 && (this.adapterRef.instance.clearMember(t2, 0), this.adapterRef.instance.removeSsrc(t2), this.adapterRef.instance._roleInfo.audienceList[t2] = true), t2 && 0 === i2) {
              this.adapterRef.instance.safeEmit("peer-online", { uid: t2 });
              let i3 = this.adapterRef.remoteStreamMap[t2];
              i3 ? i3.active = true : (i3 = new a.RemoteStream({ uid: t2, audio: false, audioSlave: false, video: false, screen: false, videoThird: false, videoFourth: false, client: this.adapterRef.instance, platformType: e2.platformType }), this.adapterRef.remoteStreamMap[t2] = i3, this.adapterRef.memberMap[t2] = t2), this.adapterRef.instance._roleInfo.audienceList[t2] = false;
            }
          }
          _handleAbility(e2) {
            this.adapterRef.instance.safeEmit("warning", { code: e2.code, msg: e2.msg });
          }
          _handleKickedNotify(e2, t2 = this.adapterRef.channelInfo.uid) {
            "string" === this.adapterRef.channelInfo.uidType && (t2 = t2.toString()), 1 == e2 ? (this.logger.warn("房间被关闭"), this.adapterRef.instance.outOfConnect = true, this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelLeave, reason: n.ConStateChange_reason.Closed }), this.adapterRef.instance.leave(d.default.CHANNEL_CLOSED), this.adapterRef.instance.safeEmit("channel-closed", {})) : 2 == e2 ? (this.logger.warn(t2 + "被踢出房间"), this.adapterRef.instance.outOfConnect = true, t2.toString() == this.adapterRef.channelInfo.uid.toString() && (this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelLeave, reason: n.ConStateChange_reason.BeKicked }), this.adapterRef.instance.leave(d.default.CLIENT_BANNED)), this.adapterRef.instance.safeEmit("client-banned", { uid: t2 })) : 5 == e2 && (this.logger.warn(t2 + " permKey 超时被踢出房间"), this.adapterRef.instance.outOfConnect = true, t2.toString() == this.adapterRef.channelInfo.uid.toString() && (this.adapterRef.instance.apiEventReport("setConnectionStateChange", { state: n.ConStateChange_state.ChannelLeave, reason: n.ConStateChange_reason.TimeOut }), this.adapterRef.instance.leave(d.default.PERMKEY_TIMEOUT)), this.adapterRef.instance.safeEmit("permkey-timeout", { uid: t2 }));
          }
          destroy() {
            this.logger.log("清除 Signalling"), this._destroyProtoo(), this._reset();
          }
        }
        t.Signalling = y;
      }, function(module, exports, __webpack_require__) {
        "use strict";
        var __importDefault = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : { default: e };
        };
        Object.defineProperty(exports, "__esModule", { value: true }), exports.RemoteStream = void 0;
        const videoQuality_1 = __webpack_require__(69), alerter_1 = __webpack_require__(142), media_1 = __webpack_require__(193), parameters_1 = __webpack_require__(1), play_1 = __webpack_require__(195), record_1 = __webpack_require__(147), types_1 = __webpack_require__(48), errorCode_1 = __importDefault(__webpack_require__(6)), rtcError_1 = __importDefault(__webpack_require__(8)), param_1 = __webpack_require__(49), RTCEventEmitter_1 = __webpack_require__(46), webAudio_1 = __webpack_require__(47), Config_1 = __webpack_require__(26), StageAIProcessing_1 = __webpack_require__(198), plugin_1 = __webpack_require__(200), plugin_list_1 = __webpack_require__(155);
        let remoteStreamCnt = 0;
        class RemoteStream extends RTCEventEmitter_1.RTCEventEmitter {
          constructor(e) {
            if (super(), this.audioLevelHelper = null, this.platformType = types_1.PlatformType.unknown, this.isRemote = true, this.__v_skip = parameters_1.getParameters().enableVSkip, this.pubStatus = { audio: { audio: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, audioSlave: { audioSlave: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, video: { video: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, screen: { screen: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, videoThird: { videoThird: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, videoFourth: { videoFourth: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false } }, this.subStatus = { audio: false, audioSlave: false, video: false, screen: false, videoThird: false, videoFourth: false }, this.muteStatus = { audio: { send: false, recv: false }, audioSlave: { send: false, recv: false }, video: { send: false, recv: false }, screen: { send: false, recv: false }, videoThird: { send: false, recv: false }, videoFourth: { send: false, recv: false } }, this.active = true, this.destroyed = false, this.spatialPosition = { x: 0, y: 0 }, this.spatialLayerCount = { video: 0, screen: 0, videoThird: 0, videoFourth: 0 }, this.supportWasm = true, this.supportAIAudioEffects = true, this.canEnableAIAudioEffects = true, this.remoteStreamId = remoteStreamCnt++, this.streamID = e.uid, this.stringStreamID = this.streamID.toString(), this.platformType = e.platformType, this.logger = e.client.adapterRef.logger.getChild(() => {
              var t;
              let i = "remote#" + this.stringStreamID;
              return types_1.PlatformTypeMap[this.platformType] && (i += " " + types_1.PlatformTypeMap[this.platformType]), i += this.remoteStreamId, this.pubStatus.audio.consumerId ? i += "M" : this.pubStatus.audio.producerId && (i += "m"), this.pubStatus.video.consumerId ? i += "C" : this.pubStatus.video.producerId && (i += "c"), this.pubStatus.screen.consumerId ? i += "S" : this.pubStatus.screen.producerId && (i += "s"), (null === (t = e.client.adapterRef.remoteStreamMap[this.streamID]) || void 0 === t ? void 0 : t.remoteStreamId) !== this.remoteStreamId && (i += " DETACHED"), i;
            }), "string" == typeof e.uid) e.client.adapterRef.channelInfo.uidType = "string";
            else {
              if ("number" != typeof e.uid) throw this.logger.error("remoteSteram: uid参数格式非法"), new rtcError_1.default({ code: errorCode_1.default.STREAM_UID_ERROR, message: "remoteSteram: uid参数格式非法" });
              if (e.client.adapterRef.channelInfo.uidType = "number", e.uid > Number.MAX_SAFE_INTEGER) throw this.logger.error("remoteSteram: uid超出number类型精度"), new rtcError_1.default({ code: errorCode_1.default.STREAM_UID_ERROR, message: "Number 类型的 uid 最大值是 2^53 - 1， 请输入正确的参数" });
            }
            this.videoView = null, this.screenView = null, this.renderMode = { remote: { video: {}, screen: {}, videoThird: {}, videoFourth: {} } }, this.subConf = { audio: true, audioSlave: true, video: true, screen: true, videoThird: true, videoFourth: true, highOrLow: { video: videoQuality_1.STREAM_TYPE.HIGH, screen: videoQuality_1.STREAM_TYPE.HIGH, videoThird: videoQuality_1.STREAM_TYPE.HIGH, videoFourth: videoQuality_1.STREAM_TYPE.HIGH } }, this.renderMode = { remote: { video: {}, screen: {}, videoThird: {}, videoFourth: {} } }, this._reset(), this.streamID = e.uid, this.stringStreamID = this.streamID.toString(), this.audio = e.audio, this.audioSlave = e.audioSlave || false, this.video = e.video || false, this.screen = e.screen || false, this.videoThird = e.videoThird || false, this.videoFourth = e.videoFourth || false, this.client = e.client, this.mediaHelper = new media_1.MediaHelper({ stream: this }), this._play = new play_1.Play({ stream: this }), this._record = new record_1.Record({ logger: this.logger, client: this.client }), "never" !== parameters_1.getParameters().enableAlerter && alerter_1.alerter.watchRemoteStream(this), this.client.apiFrequencyControl({ name: "createRemoteStream", code: 0, param: { streamID: this.stringStreamID, isRemote: true, clientUid: this.client.adapterRef.channelInfo.uid || "" } });
          }
          _reset() {
            var e, t, i;
            this.audio = false, this.audioSlave = false, this.video = false, this.screen = false, this.videoView = null, this.screenView = null, this.renderMode = { remote: { video: {}, screen: {}, videoThird: {}, videoFourth: {} } }, this.pubStatus = { audio: { audio: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, audioSlave: { audioSlave: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, video: { video: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, screen: { screen: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, videoThird: { videoThird: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false }, videoFourth: { videoFourth: false, producerId: "", consumerId: "", consumerStatus: "init", stopconsumerStatus: "init", mute: false, simulcastEnable: false } }, this.subConf = { audio: true, audioSlave: true, video: true, screen: true, videoThird: true, videoFourth: true, highOrLow: { video: videoQuality_1.STREAM_TYPE.HIGH, screen: videoQuality_1.STREAM_TYPE.HIGH, videoThird: videoQuality_1.STREAM_TYPE.HIGH, videoFourth: videoQuality_1.STREAM_TYPE.HIGH } }, this.subStatus = { audio: false, audioSlave: false, video: false, screen: false, videoThird: false, videoFourth: false }, this.muteStatus = { audio: { send: false, recv: false }, audioSlave: { send: false, recv: false }, video: { send: false, recv: false }, screen: { send: false, recv: false }, videoThird: { send: false, recv: false }, videoFourth: { send: false, recv: false } }, this.renderMode = { remote: { video: {}, screen: {}, videoThird: {}, videoFourth: {} } }, this.mediaHelper && this.mediaHelper.destroy(), this._play && this._play.destroy(), this._record && this._record.destroy(), this._record = null, (null === (i = null === (t = null === (e = this.mediaHelper) || void 0 === e ? void 0 : e.audio) || void 0 === t ? void 0 : t.stageAIProcessing) || void 0 === i ? void 0 : i.hasWorkingPlugin()) && this.unregisterPlugin("AIAudioEffects");
          }
          get Play() {
            return this._play;
          }
          get Record() {
            return this._record;
          }
          getId() {
            return "string" === this.client.adapterRef.channelInfo.uidType ? this.stringStreamID : this.streamID;
          }
          doSetSubscribeConfig(e) {
            const t = Object.assign({}, this.subConf);
            t.highOrLow = Object.assign({}, this.subConf.highOrLow);
            for (let t2 of types_1.MediaTypeListAudio) {
              const i2 = e[t2];
              "boolean" == typeof i2 && (this.subConf[t2] = i2);
            }
            for (let t2 of types_1.MediaTypeListVideo) {
              const i2 = e[t2];
              e.highOrLow && (this.subConf.highOrLow[t2] = e.highOrLow), "high" === i2 || "low" === i2 ? (this.subConf[t2] = true, this.subConf.highOrLow[t2] = videoQuality_1.STREAM_TYPE["high" === i2 ? "HIGH" : "LOW"]) : "boolean" == typeof i2 && (this.subConf[t2] = i2);
            }
            this.pubStatus.audio.audio && this.subConf.audio ? (this.subConf.audio = true, this.audio = true) : this.subConf.audio = false, this.pubStatus.audioSlave.audioSlave && this.subConf.audioSlave ? (this.subConf.audioSlave = true, this.audioSlave = true) : this.subConf.audioSlave = false, this.pubStatus.video.video && this.subConf.video ? (this.subConf.video = true, this.video = true) : this.subConf.video = false, this.pubStatus.screen.screen && this.subConf.screen ? (this.subConf.screen = true, this.screen = true) : this.subConf.screen = false;
            let i = "doSetSubscribeConfig", r = false;
            for (let e2 of types_1.MediaTypeList) i += ` ${e2}:${t[e2]}`, t[e2] !== this.subConf[e2] && (i += "=>" + this.subConf[e2], r = true), "video" !== e2 && "screen" !== e2 || (i += " " + videoQuality_1.STREAM_TYPE_REV[t.highOrLow[e2]], t.highOrLow[e2] !== this.subConf.highOrLow[e2] && (i += "=>" + videoQuality_1.STREAM_TYPE_REV[this.subConf.highOrLow[e2]], r = true));
            r || (i += "【Unchanged】"), this.logger.log(i);
          }
          setSubscribeConfig(e) {
            if (this.logger.log(`setSubscribeConfig() 设置 ${this.stringStreamID} 订阅规则：${JSON.stringify(e)}`), this.doSetSubscribeConfig(e), this.logger.log(`setSubscribeConfig() 设置 ${this.stringStreamID} 订阅规则结果：${JSON.stringify(this.subConf)}`), this.client.apiFrequencyControl({ name: "setSubscribeConfig", code: 0, param: { streamID: this.stringStreamID, isRemote: true, conf: Object.assign({}, this.subConf) } }), this.pubStatus.screen.screen) {
              const e2 = { uid: "string" === this.client.adapterRef.channelInfo.uidType ? this.stringStreamID : this.streamID, subscribe: this.subConf.screen };
              this.client.apiFrequencyControl({ name: "subscribeRemoteSubStreamVideo", code: 0, param: JSON.stringify(e2, null, " ") });
            }
          }
          getAudioStream() {
            return this.client.apiFrequencyControl({ name: "getAudioStream", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.getId() }, null, " ") }), this.mediaHelper.audio.audioStream;
          }
          getAudioTrack() {
            return this.mediaHelper.audio.audioStream.getAudioTracks()[0] || null;
          }
          getVideoTrack() {
            return this.mediaHelper.video.videoStream.getVideoTracks()[0] || null;
          }
          getScreenTrack() {
            return this.mediaHelper.screen.screenVideoStream.getVideoTracks()[0] || null;
          }
          getAudioSlaveTrack() {
            return this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks()[0] || null;
          }
          getVideoThirdTrack() {
            return this.mediaHelper.videoThird.videoThirdStream.getVideoTracks()[0] || null;
          }
          getVideoFourthTrack() {
            return this.mediaHelper.videoFourth.videoFourthStream.getVideoTracks()[0] || null;
          }
          async play(e, t = {}) {
            var i, r, s;
            if ((t.video || t.screen || t.videoThird || t.videoFourth) && !e) throw this.logger.warn(`play() remoteStream ${this.getId()} 播放视频没有指定div标签`), new rtcError_1.default({ code: errorCode_1.default.STREAM_PLAY_ARGUMENT_ERROR, message: "play() 播放视频没有指定div标签" });
            if (param_1.isExistOptions({ tag: "Stream.playOptions.audio", value: t.audio }).result || (t.audio = true), param_1.isExistOptions({ tag: "Stream.playOptions.audioSlave", value: t.audioSlave }).result || (t.audioSlave = true), param_1.isExistOptions({ tag: "Stream.playOptions.video", value: t.video }).result || (t.video = true), param_1.isExistOptions({ tag: "Stream.playOptions.screen", value: t.screen }).result || (t.screen = true), param_1.isExistOptions({ tag: "Stream.playOptions.videoThird", value: t.videoThird }).result || (t.videoThird = true), param_1.isExistOptions({ tag: "Stream.playOptions.videoFourth", value: t.videoFourth }).result || (t.videoFourth = true), this.logger.log(`play() uid ${this.stringStreamID} 播放, playOptions:${JSON.stringify(t)}`), t.audio && this._play && this.mediaHelper.audio.audioStream.getTracks().length) if (this.client.spatialManager) this.logger.log("[play] 启用了空间音频，跳过本地音频播放。");
            else {
              this.logger.log(`[play] uid ${this.stringStreamID} 开始播放远端音频`);
              try {
                if (this.client.adapterRef.enableMixAudio) {
                  (null === (i = this.client.adapterRef.audioMixer) || void 0 === i ? void 0 : i.getAudioContext()) ? await (null === (r = this.client.adapterRef.audioMixer) || void 0 === r ? void 0 : r.addStream(this.mediaHelper.audio.audioStream)) : this.logger.error("play() 未找到AudioContext");
                } else await this._play.playAudioStream("audio", this.mediaHelper.audio.audioStream, t.muted);
              } catch (e2) {
                this.client.emit("notAllowedError", e2), this.client.emit("NotAllowedError", e2), this.safeEmit("notAllowedError", e2);
              }
            }
            if (t.audioSlave && this._play && this.mediaHelper.screenAudio.screenAudioStream.getTracks().length) if (this.client.spatialManager) this.logger.log("[play] 启用了空间音频，跳过本地音频辅流播放。");
            else {
              this.logger.log(`[play] uid ${this.stringStreamID} 开始播放远端音频辅流`);
              try {
                this.client.adapterRef.enableMixAudio ? await (null === (s = this.client.adapterRef.audioMixer) || void 0 === s ? void 0 : s.addStream(this.mediaHelper.screenAudio.screenAudioStream)) : await this._play.playAudioStream("audioSlave", this.mediaHelper.screenAudio.screenAudioStream, t.muted);
              } catch (e2) {
                this.client.emit("notAllowedError", e2), this.client.emit("NotAllowedError", e2), this.safeEmit("notAllowedError", e2);
              }
            }
            let a;
            if (a = "string" == typeof e ? document.getElementById(e) : e || null, a) {
              if (t.video && (this.videoView = a, this._play && this.mediaHelper.video.videoStream.getVideoTracks().length)) {
                this.logger.log(`[play] uid ${this.stringStreamID} 开始启动视频播放 主流 远端`);
                try {
                  await this._play.playVideoStream("video", this.mediaHelper.video.renderStream, a), "width" in this.renderMode.remote.video && this._play.setRender("video", this.renderMode.remote.video);
                } catch (e2) {
                  this.client.emit("notAllowedError", e2), this.client.emit("NotAllowedError", e2), this.safeEmit("notAllowedError", e2);
                }
              }
              if (t.screen && (this.screenView = a, this._play && this.mediaHelper && this.mediaHelper.screen.screenVideoStream.getVideoTracks().length)) {
                this.logger.log(`[play] uid ${this.stringStreamID} 开始启动视频播放 辅流 远端`);
                try {
                  await this._play.playVideoStream("screen", this.mediaHelper.screen.renderStream, a), "width" in this.renderMode.remote.screen && this._play.setRender("screen", this.renderMode.remote.screen);
                } catch (e2) {
                  this.client.emit("notAllowedError", e2), this.client.emit("NotAllowedError", e2), this.safeEmit("notAllowedError", e2);
                }
              }
              if (t.videoThird && (this.videoThirdView = a, this._play && this.mediaHelper && this.mediaHelper.videoThird.videoThirdStream.getVideoTracks().length)) {
                this.logger.log(`[play] uid ${this.stringStreamID} 开始播放第三路视频远端`);
                try {
                  await this._play.playVideoStream("videoThird", this.mediaHelper.videoThird.renderStream, a), "width" in this.renderMode.remote.videoThird && this._play.setRender("videoThird", this.renderMode.remote.videoThird);
                } catch (e2) {
                  this.client.emit("notAllowedError", e2), this.client.emit("NotAllowedError", e2), this.safeEmit("notAllowedError", e2);
                }
              }
              if (t.videoFourth && (this.videoFourthView = a, this._play && this.mediaHelper && this.mediaHelper.videoFourth.videoFourthStream.getVideoTracks().length)) {
                this.logger.log(`[play] uid ${this.stringStreamID} 开始播放第四路视频远端`);
                try {
                  await this._play.playVideoStream("videoFourth", this.mediaHelper.videoFourth.renderStream, a), "width" in this.renderMode.remote.videoFourth && this._play.setRender("videoFourth", this.renderMode.remote.videoFourth);
                } catch (e2) {
                  this.client.emit("notAllowedError", e2), this.client.emit("NotAllowedError", e2), this.safeEmit("notAllowedError", e2);
                }
              }
            }
            this.client.apiFrequencyControl({ name: "play", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, playOptions: t, isRemote: true }, null, " ") });
          }
          async resume() {
            var e;
            this.client.adapterRef.enableMixAudio ? (this.logger.log("尝试恢复混流播放 uid: ", this.stringStreamID), await (null === (e = this.client.adapterRef.audioMixer) || void 0 === e ? void 0 : e.resume())) : (webAudio_1.tryResumeAudioContext() && this.logger.log("正在尝试恢复AudioContext自动播放受限"), this._play && (this.logger.log("resume() uid: ", this.stringStreamID), await this._play.resume())), this.client.apiFrequencyControl({ name: "resume", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true }, null, " ") });
          }
          setRemoteRenderMode(e, t) {
            if (!e || !Number.isInteger(e.width) || !Number.isInteger(e.height)) throw this.logger.warn("setRemoteRenderMode 参数宽高错误"), this.client.apiFrequencyControl({ name: "setRemoteRenderMode", code: -1, param: Object.assign({ streamID: this.stringStreamID, isRemote: true, mediaType: t }, e) }), new rtcError_1.default({ code: errorCode_1.default.STREAM_RENDER_ARGUMENT_ERROR, message: "setLocalRenderMode() 参数宽高错误" });
            this.client && this._play && (this.logger.log(`uid ${this.stringStreamID} 设置远端视频播放窗口大小: `, t || "video+screen", JSON.stringify(e)), t && "video" !== t || (this._play && this._play.setRender("video", e), this.renderMode.remote.video = e), t && "screen" !== t || (this.renderMode.remote.screen = e, this._play && this._play.setRender("screen", e)), t && "videoThird" !== t || (this.renderMode.remote.videoThird = e, this._play && this._play.setRender("videoThird", e)), t && "videoFourth" !== t || (this.renderMode.remote.videoFourth = e, this._play && this._play.setRender("videoFourth", e)), this.client.apiFrequencyControl({ name: "setRemoteRenderMode", code: 0, param: Object.assign(Object.assign({}, e), { mediaType: t, isRemote: true, streamID: this.stringStreamID }) }));
          }
          stop(e) {
            var t, i;
            if (this.logger.log(`stop() uid ${this.stringStreamID}, 停止播放 ${e || "音视频流"}`), this.client.adapterRef.enableMixAudio) e && "audio" != e || null === (t = this.client.adapterRef.audioMixer) || void 0 === t || t.removeStream(this.mediaHelper.audio.audioStream), e && "audioSlave" != e || null === (i = this.client.adapterRef.audioMixer) || void 0 === i || i.removeStream(this.mediaHelper.screenAudio.screenAudioStream);
            else {
              if (!this._play) return;
              types_1.MediaTypeList.forEach((t2) => {
                e && t2 !== e || this._play.stopPlayStream(t2);
              }), e && "audio" != e || !this.mediaHelper.audio.audioDom || (this.mediaHelper.audio.audioDom.srcObject = null, this.mediaHelper.audio.audioDom = null);
            }
            this.client.apiFrequencyControl({ name: "stop", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true, audio: this.audio, video: this.video, screen: this.screen, type: e }, null, " ") });
          }
          isPlaying(e) {
            if (this._play) {
              if (types_1.MediaTypeList.indexOf(e) > -1) return this._play.isPlaying(e);
              throw this.logger.warn("isPlaying() unknown type"), new rtcError_1.default({ code: errorCode_1.default.STREAM_ISPLAYING_ARGUMENT_ERROR, message: "isPlaying() type 参数类型非法" });
            }
            return this.client.apiFrequencyControl({ name: "isPlaying", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true, type: e }, null, " ") }), this.logger.log(`检查${this.stringStreamID}的${e}播放状态: false`), false;
          }
          canPlay(e) {
            return -1 === types_1.MediaTypeList.indexOf(e) ? null : this._play.canPlay(e);
          }
          hasAudio() {
            return this.mediaHelper.audio.audioStream.getAudioTracks().length > 0;
          }
          hasAudioSlave() {
            return this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks().length > 0;
          }
          getAudioLevel(e = "audio") {
            const t = this.mediaHelper.getOrCreateAudioPipeline(e);
            if (!t) return 0;
            {
              let i = 0;
              if (!t.audioLevelNode) {
                const t2 = webAudio_1.getAudioContext();
                if (t2 && t2.audioWorklet && t2.audioWorklet.addModule || (this.logger.error("getAudioLevel is not supported in this browser"), this.client.safeEmit("error", "AUDIOLEVEL_NOT_SUPPORTED")), "suspended" === (null == t2 ? void 0 : t2.state)) {
                  const e2 = new rtcError_1.default({ code: errorCode_1.default.AUTO_PLAY_NOT_ALLOWED, url: "https://doc.yunxin.163.com/docs/jcyOTA0ODM/jM3NDE0NTI?platformId=50082", message: "playVideoStream: 浏览器自动播放受限: AudioContext is Suspended" });
                  this.client.safeEmit("notAllowedError", e2), this.safeEmit("notAllowedError", e2);
                } else this.client.apiFrequencyControl({ name: "getAudioLevel", code: 0, param: { mediaType: e, isRemote: true, streamID: this.stringStreamID } });
              }
              const r = t.getAudioLevel();
              switch (r ? i = r.volume : (this.logger.log("getAudioLevel() 正在加载音频模块"), i = 0), parameters_1.getParameters().audioLevelFittingAlgorithm) {
                case "classic":
                  return i;
                case "linear":
                  return Math.max(0, Math.min(100, parameters_1.getParameters().audioLevelRatioRemote * Math.round(200 * i)));
                case "log2":
                  return Math.max(0, Math.min(100, parameters_1.getParameters().audioLevelRatioRemote * Math.round(8.638 * Math.log2(i) + 97.244)));
              }
            }
          }
          setAudioVolume(e = 100) {
            var t;
            let i, r;
            (!Number.isInteger(e) || e < 0 || e > 100) && (i = errorCode_1.default.SET_AUDIO_VOLUME_ARGUMENTS_ERROR, r = "setAudioVolume() volume 应该为 0 - 100 的整数");
            const s = e / 100;
            if (this.client.adapterRef.enableMixAudio) {
              if (this.client.adapterRef.audioMixer ? (this.logger.log(`setAudioVolume() 调节${this.stringStreamID}的音量大小: ${2.55 * e} (normalized: ${s})`), this.client.adapterRef.audioMixer.setVolume(s, this.mediaHelper.audio.audioStream)) : (r = "setAudioVolume() 未找到AudioMixer", i = errorCode_1.default.SET_AUDIO_VOLUME_ERROR), this.client.apiFrequencyControl({ name: "setAudioVolume", code: i ? -1 : 0, param: { streamID: this.stringStreamID, isRemote: true, volume: 2.55 * e, normalizedVolume: s, reason: r, isMixAudio: true } }), i) throw this.logger.error(r), new rtcError_1.default({ code: i, message: r });
            } else {
              if (this.audio && this._play && this._play.audio && this._play.audio.dom || (r = "setAudioVolume() 没有音频流，请检查是否有订阅播放过音频", i = errorCode_1.default.SET_AUDIO_VOLUME_ERROR), this.client.apiFrequencyControl({ name: "setAudioVolume", code: i ? -1 : 0, param: { streamID: this.stringStreamID, isRemote: true, volume: 2.55 * e, normalizedVolume: s, reason: r } }), i) throw this.logger.error(r), new rtcError_1.default({ code: i, message: r });
              this.logger.log(`setAudioVolume() 调节${this.stringStreamID}的音量大小: ${2.55 * e} (normalized: ${s})`), null === (t = this._play) || void 0 === t || t.setPlayVolume("audio", s);
            }
          }
          setAudioSlaveVolume(e = 100) {
            var t;
            let i, r;
            Number.isInteger(e) ? e < 0 ? e = 0 : e > 100 && (e = 100) : (i = errorCode_1.default.SET_AUDIO_VOLUME_ARGUMENTS_ERROR, r = "setAudioSlaveVolume() volume 应该为 0 - 100 的整数");
            const s = e / 100;
            if (this.client.adapterRef.enableMixAudio) {
              if (this.client.adapterRef.audioMixer ? (this.logger.log(`setAudioSlaveVolume() 调节${this.stringStreamID}的音量大小: ${2.55 * e} (normalized: ${s})`), this.client.adapterRef.audioMixer.setVolume(s, this.mediaHelper.screenAudio.screenAudioStream)) : (r = "setAudioSlaveVolume() 未找到AudioMixer", i = errorCode_1.default.SET_AUDIO_VOLUME_ERROR), this.client.apiFrequencyControl({ name: "setAudioSlaveVolume", code: i ? -1 : 0, param: { streamID: this.stringStreamID, isRemote: true, volume: 2.55 * e, normalizedVolume: s, reason: r || "", isMixAudio: true } }), i) throw this.logger.error(r), new rtcError_1.default({ code: i, message: r });
            } else {
              if (this.audio && this._play && this._play.audioSlave && this._play.audioSlave.dom || (r = "setAudioSlaveVolume() 没有音频流，请检查是否有订阅播放过音频辅流", i = errorCode_1.default.SET_AUDIO_VOLUME_ERROR), this.client.apiFrequencyControl({ name: "setAudioSlaveVolume", code: i ? -1 : 0, param: { streamID: this.stringStreamID, isRemote: true, volume: 2.55 * e, normalizedVolume: s, reason: r || "" } }), i) throw this.logger.error(r), new rtcError_1.default({ code: i, message: r });
              this.logger.log(`setAudioSlaveVolume() 调节${this.stringStreamID}的音量大小: ${2.55 * e} (normalized: ${s})`), null === (t = this._play) || void 0 === t || t.setPlayVolume("audioSlave", s);
            }
          }
          async setAudioOutput(e, t) {
            if (this.client.adapterRef.enableMixAudio) {
              if (!this.client.adapterRef.audioMixer) throw t && setTimeout(() => {
                t("未找到AudioMixer");
              }, 0), this.logger.error("设置输出设备失败, setAudioOutput() 未找到AudioMixer"), new rtcError_1.default({ code: errorCode_1.default.SET_AUDIO_OUTPUT_ERROR, message: "设置输出设备失败, setAudioOutput() 未找到AudioMixer" });
              this.client.adapterRef.audioMixer.setAudioOutput(e), t && setTimeout(t, 0);
            } else if (this._play) {
              try {
                await this._play.setAudioOutput(e);
              } catch (e2) {
                throw t && setTimeout(() => {
                  t(e2);
                }, 0), this.logger.error("设置输出设备失败", e2.name, e2.message), new rtcError_1.default({ code: errorCode_1.default.SET_AUDIO_OUTPUT_ERROR, message: e2.message || "系统内部错误" });
              }
              t && setTimeout(t, 0);
            }
            this.client.apiFrequencyControl({ name: "setAudioOutput", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, deviceId: e, isRemote: true }, null, " ") });
          }
          async unmuteAudio() {
            var e;
            let t, i;
            if (this.muteStatus.audio.recv || (t = errorCode_1.default.STREAM_NOT_MUTE_AUDIO_YET, i = "remoteStream.unmuteAudio: 当前没有mute音频, 不支持unmute"), this._play.audio.dom && (null === (e = this.mediaHelper.audio.audioStream) || void 0 === e ? void 0 : e.active) || (t = errorCode_1.default.STREAM_UNMUTE_AUDIO_WITHOUT_STREAM, i = "remoteStream.unmuteAudio: 没有音频流, 无法执行unmute操作"), this.client.apiFrequencyControl({ name: "unmuteAudio", code: t ? -1 : 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true, reason: i || "" }, null, " ") }), t) throw this.logger.error(i), new rtcError_1.default({ code: t, message: i });
            try {
              this.logger.log("unmuteAudio() 启用音频轨道: ", this.stringStreamID), this.muteStatus.audio.recv = false, this.mediaHelper.audio.audioStream.getAudioTracks().length && (this.mediaHelper.audio.audioStream.getAudioTracks()[0].enabled = true), this._play.playAudioStream("audio", this.mediaHelper.audio.audioStream, false);
            } catch (e2) {
              this.logger.error("unmuteAudio() 异常: ", e2.name, e2.message), this.client.apiFrequencyControl({ name: "unmuteAudio", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true, reason: e2 }, null, " ") });
            }
          }
          async muteAudio() {
            var e, t, i, r, s, a;
            if (this.logger.log("禁用音频轨道: ", this.stringStreamID), !(null === (i = null === (t = null === (e = this._play) || void 0 === e ? void 0 : e.audio) || void 0 === t ? void 0 : t.dom) || void 0 === i ? void 0 : i.srcObject) || !(null === (a = null === (s = null === (r = this.mediaHelper) || void 0 === r ? void 0 : r.audio) || void 0 === s ? void 0 : s.audioStream) || void 0 === a ? void 0 : a.active)) throw this.logger.log("muteAudio() 之前没有播放过音频, 不支持unmute: ", this.stringStreamID), new rtcError_1.default({ code: errorCode_1.default.STREAM_MUTE_AUDIO_ERROR, message: "remoteStream.muteAudio: 之前没有播放过音频, 不支持muteAudio" });
            try {
              this.muteStatus.audio.recv = true, this.mediaHelper.audio.audioStream.getAudioTracks().length && (this.mediaHelper.audio.audioStream.getAudioTracks()[0].enabled = false), this._play.stopPlayStream("audio"), this.client.apiFrequencyControl({ name: "muteAudio", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true }, null, " ") });
            } catch (e2) {
              this.logger.error("API调用失败: Stream:muteAudio", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "muteAudio", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true, reason: e2.message }, null, " ") });
            }
          }
          async unmuteAudioSlave() {
            var e;
            let t, i;
            if (this.muteStatus.audioSlave.recv || (t = errorCode_1.default.STREAM_NOT_MUTE_AUDIO_SLAVE_YET, i = "remoteStream.unmuteAudioSlave: 当前没有mute音频辅流, 不支持unmute"), this._play.audioSlave.dom && (null === (e = this.mediaHelper.screenAudio.screenAudioStream) || void 0 === e ? void 0 : e.active) || (t = errorCode_1.default.STREAM_UNMUTE_AUDIO_SLAVE_WITHOUT_STREAM, i = "remoteStream.unmuteAudioSlave: 没有音频辅流, 无法执行unmute操作"), this.client.apiFrequencyControl({ name: "unmuteAudioSlave", code: t ? -1 : 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: i || "" }, null, " ") }), t) throw this.logger.error(i), new rtcError_1.default({ code: t, message: i });
            try {
              this.logger.log("unmuteAudioSlave() 启用音频辅流轨道: ", this.stringStreamID), this.muteStatus.audioSlave.recv = false, this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks().length && (this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks()[0].enabled = true), this._play.playAudioStream("audioSlave", this.mediaHelper.screenAudio.screenAudioStream, false);
            } catch (e2) {
              this.logger.error("Stream:unmuteAudioSlave 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteAudioSlave", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          async muteAudioSlave() {
            var e, t, i, r, s, a;
            if (!(null === (i = null === (t = null === (e = this._play) || void 0 === e ? void 0 : e.audioSlave) || void 0 === t ? void 0 : t.dom) || void 0 === i ? void 0 : i.srcObject) || !(null === (a = null === (s = null === (r = this.mediaHelper) || void 0 === r ? void 0 : r.screenAudio) || void 0 === s ? void 0 : s.screenAudioStream) || void 0 === a ? void 0 : a.active)) throw this.logger.error("muteAudioSlave() 之前没有播放过音频辅流, 不支持unmute: ", this.stringStreamID), new rtcError_1.default({ code: errorCode_1.default.STREAM_MUTE_AUDIO_SLAVE_ERROR, message: "remoteStream.muteAudioSlave: 之前没有播放过音频辅流, 不支持mute" });
            try {
              this.logger.log("muteAudioSlave() 禁用音频辅流轨道: ", this.stringStreamID), this.muteStatus.audioSlave.recv = true, this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks().length && (this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks()[0].enabled = false), this._play.stopPlayStream("audioSlave"), this.client.apiFrequencyControl({ name: "muteAudioSlave", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("Stream:muteAudioSlave 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "muteAudioSlave", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true, reason: e2 }, null, " ") });
            }
          }
          async unmuteVideo() {
            let e, t;
            if (this.muteStatus.video.recv || (e = errorCode_1.default.STREAM_NOT_MUTE_VIDEO_YET, t = "remoteStream.unmuteVideo: 当前没有mute视频, 不支持unmute"), this.mediaHelper.video.cameraTrack || (e = errorCode_1.default.STREAM_UNMUTE_VIDEO_WITHOUT_STREAM, t = "remoteStream.unmuteVideo: 没有视频流, 无法执行unmute操作"), this.client.apiFrequencyControl({ name: "unmuteVideo", code: e ? -1 : 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: t || "" }, null, " ") }), e) throw this.logger.error(t), new rtcError_1.default({ code: e, message: t });
            try {
              this.logger.log(`unmuteVideo() 启用 ${this.stringStreamID} 的视频轨道`), this.muteStatus.video.recv = false, this.mediaHelper && this.mediaHelper.video.cameraTrack && (this.mediaHelper.video.cameraTrack.enabled = true);
            } catch (e2) {
              this.logger.error("API调用失败：Stream:unmuteVideo", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteVideo", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          async muteVideo() {
            var e, t, i, r, s;
            if (!(null === (i = null === (t = null === (e = this._play) || void 0 === e ? void 0 : e.video) || void 0 === t ? void 0 : t.dom) || void 0 === i ? void 0 : i.srcObject) || !(null === (s = null === (r = this.mediaHelper) || void 0 === r ? void 0 : r.video) || void 0 === s ? void 0 : s.cameraTrack)) throw this.logger.log("muteVideo() 之前没有播放过视频, 不支持unmute: ", this.stringStreamID), new rtcError_1.default({ code: errorCode_1.default.STREAM_MUTE_VIDEO_ERROR, message: "remoteStream.muteVideo: 之前没有播放过视频, 不支持mute" });
            try {
              this.logger.log(`muteVideo() 禁用 ${this.stringStreamID} 的视频轨道`), this.muteStatus.video.recv = true, this.mediaHelper && this.mediaHelper.video.cameraTrack && (this.mediaHelper.video.cameraTrack.enabled = false), this.client.apiFrequencyControl({ name: "muteVideo", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true }, null, " ") });
            } catch (e2) {
              this.logger.error("API调用失败：Stream:muteVideo", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "muteVideo", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: true, reason: e2.message }, null, " ") });
            }
          }
          async unmuteScreen() {
            let e, t;
            if (this.muteStatus.screen.recv || (e = errorCode_1.default.STREAM_NOT_MUTE_SCREEN_YET, t = "remoteStream.unmuteScreen: 当前没有mute屏幕共享, 不支持unmute"), this.mediaHelper.screen.screenVideoTrack || (e = errorCode_1.default.STREAM_UNMUTE_SCREEN_WITHOUT_STREAM, t = "remoteStream.unmuteScreen: 没有屏幕共享流, 无法执行unmute操作"), this.client.apiFrequencyControl({ name: "unmuteScreen", code: e ? -1 : 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: t || "" }, null, " ") }), e) throw this.logger.error(t), new rtcError_1.default({ code: e, message: t });
            try {
              this.logger.log(`unmuteScreen() 启用 ${this.stringStreamID} 的屏幕共享轨道`), this.muteStatus.screen.recv = false, this.mediaHelper && this.mediaHelper.screen.screenVideoTrack && (this.mediaHelper.screen.screenVideoTrack.enabled = true), this.client.apiFrequencyControl({ name: "unmuteScreen", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("unmuteScreen() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteScreen", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          async muteScreen() {
            var e, t, i, r;
            if (!(null === (i = null === (t = null === (e = this._play) || void 0 === e ? void 0 : e.screen) || void 0 === t ? void 0 : t.dom) || void 0 === i ? void 0 : i.srcObject) || !(null === (r = this.mediaHelper) || void 0 === r ? void 0 : r.screen.screenVideoTrack)) throw this.logger.log("muteScreen() 之前没有播放过屏幕共享, 不支持unmute: ", this.stringStreamID), new rtcError_1.default({ code: errorCode_1.default.STREAM_MUTE_SCREEN_ERROR, message: "remoteStream.muteScreen: 之前没有播放过屏幕共享, 不支持mute" });
            try {
              this.logger.log(`muteScreen() 禁用 ${this.stringStreamID} 的屏幕共享轨道`), this.mediaHelper && this.mediaHelper.screen.screenVideoTrack && (this.mediaHelper.screen.screenVideoTrack.enabled = false), this.muteStatus.screen.recv = true, this.client.apiFrequencyControl({ name: "muteScreen", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("muteScreen() 异常: ", e2, ...arguments), this.client.apiFrequencyControl({ name: "muteScreen", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          async unmuteVideoThird() {
            let e, t;
            if (this.muteStatus.videoThird.recv || (e = errorCode_1.default.STREAM_NOT_MUTE_VIDEO_THIRD_YET, t = "remoteStream.unmuteVideoThird: 当前没有mute第三路视频流, 不支持unmute"), this.mediaHelper.videoThird.videoThirdTrack || (e = errorCode_1.default.STREAM_UNMUTE_VIDEO_THIRD_WITHOUT_STREAM, t = "remoteStream.unmuteVideoThird: 没有第三路视频流,, 无法执行unmute操作"), this.client.apiFrequencyControl({ name: "unmuteVideoThird", code: e ? -1 : 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: t || "" }, null, " ") }), e) throw this.logger.error(t), new rtcError_1.default({ code: e, message: t });
            try {
              this.logger.log(`unmuteVideoThird() 启用 ${this.stringStreamID} 的第三路视频流`), this.muteStatus.videoThird.recv = false, this.mediaHelper && this.mediaHelper.videoThird.videoThirdTrack && (this.mediaHelper.videoThird.videoThirdTrack.enabled = true), this.client.apiFrequencyControl({ name: "unmuteVideoThird", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("unmuteVideoThird() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteVideoThird", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          async muteVideoThird() {
            var e, t, i, r;
            if (!(null === (i = null === (t = null === (e = this._play) || void 0 === e ? void 0 : e.videoThird) || void 0 === t ? void 0 : t.dom) || void 0 === i ? void 0 : i.srcObject) || !(null === (r = this.mediaHelper) || void 0 === r ? void 0 : r.videoThird.videoThirdTrack)) throw this.logger.log("muteVideoThird() 之前没有播放过第三路视频流, 不支持unmute: ", this.stringStreamID), new rtcError_1.default({ code: errorCode_1.default.STREAM_MUTE_VIDEO_THIRD_ERROR, message: "remoteStream.muteVideoThird: 之前没有播放过第三路视频流, 不支持mute" });
            try {
              this.logger.log(`muteVideoThird() 禁用 ${this.stringStreamID} 的第三路视频流`), this.mediaHelper && this.mediaHelper.videoThird.videoThirdTrack && (this.mediaHelper.videoThird.videoThirdTrack.enabled = false), this.muteStatus.videoThird.recv = true, this.client.apiFrequencyControl({ name: "muteVideoThird", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("muteVideoThird() 异常: ", e2, ...arguments), this.client.apiFrequencyControl({ name: "muteVideoThird", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          async unmuteVideoFourth() {
            let e, t;
            if (this.muteStatus.videoFourth.recv || (e = errorCode_1.default.STREAM_NOT_MUTE_VIDEO_FOURTH_YET, t = "remoteStream.unmuteVideoFourth: 当前没有mute第四路视频流 不支持unmute"), this.mediaHelper.videoFourth.videoFourthTrack || (e = errorCode_1.default.STREAM_UNMUTE_VIDEO_THIRD_WITHOUT_STREAM, t = "remoteStream.unmuteVideoFourth: 没有第四路视频流, 无法执行unmute操作"), this.client.apiFrequencyControl({ name: "unmuteVideoFourth", code: e ? -1 : 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: t || "" }, null, " ") }), e) throw this.logger.error(t), new rtcError_1.default({ code: e, message: t });
            try {
              this.logger.log(`unmuteVideoFourth() 启用 ${this.stringStreamID} 的第四路视频流`), this.muteStatus.videoFourth.recv = false, this.mediaHelper && this.mediaHelper.videoFourth.videoFourthTrack && (this.mediaHelper.videoFourth.videoFourthTrack.enabled = true), this.client.apiFrequencyControl({ name: "unmuteVideoFourth", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("unmuteVideoFourth() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteVideoFourth", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          async muteVideoFourth() {
            var e, t, i, r;
            if (!(null === (i = null === (t = null === (e = this._play) || void 0 === e ? void 0 : e.videoFourth) || void 0 === t ? void 0 : t.dom) || void 0 === i ? void 0 : i.srcObject) || !(null === (r = this.mediaHelper) || void 0 === r ? void 0 : r.videoFourth.videoFourthTrack)) throw this.logger.log("muteVideoFourth() 之前没有播放过第四路视频流, 不支持unmute: ", this.stringStreamID), new rtcError_1.default({ code: errorCode_1.default.STREAM_MUTE_SCREEN_ERROR, message: "remoteStream.muteVideoFourth: 之前没有播放过第四路视频流, 不支持mute" });
            try {
              this.logger.log(`muteVideoFourth() 禁用 ${this.stringStreamID} 的第四路视频流`), this.mediaHelper && this.mediaHelper.videoFourth.videoFourthTrack && (this.mediaHelper.videoFourth.videoFourthTrack.enabled = false), this.muteStatus.videoFourth.recv = true, this.client.apiFrequencyControl({ name: "muteVideoFourth", code: 0, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("muteVideoFourth() 异常: ", e2, ...arguments), this.client.apiFrequencyControl({ name: "muteVideoFourth", code: -1, param: JSON.stringify({ isRemote: true, streamID: this.stringStreamID, reason: e2.message }, null, " ") });
            }
          }
          hasVideo() {
            this.logger.log("获取视频 flag"), this.mediaHelper.video.videoStream.getVideoTracks().length;
          }
          hasScreen() {
            this.logger.log("获取屏幕共享 flag"), this.mediaHelper.screen.screenVideoStream.getVideoTracks().length;
          }
          hasVideoThird() {
            this.logger.log("获取第三路视频 flag"), this.mediaHelper.videoThird.videoThirdStream.getVideoTracks().length;
          }
          hasVideoFourth() {
            this.logger.log("获取第四路视频 flag"), this.mediaHelper.videoFourth.videoFourthStream.getVideoTracks().length;
          }
          async takeSnapshot(e) {
            var t, i, r, s, a, o, n, d;
            let c, l;
            const u = this.video && (null === (i = null === (t = this._play) || void 0 === t ? void 0 : t.video) || void 0 === i ? void 0 : i.dom), h = this.screen && (null === (s = null === (r = this.Play) || void 0 === r ? void 0 : r.screen) || void 0 === s ? void 0 : s.dom), p = this.videoThird && (null === (o = null === (a = this._play) || void 0 === a ? void 0 : a.videoThird) || void 0 === o ? void 0 : o.dom), m = this.videoFourth && (null === (d = null === (n = this.Play) || void 0 === n ? void 0 : n.videoFourth) || void 0 === d ? void 0 : d.dom);
            if (u || h || p || m ? (await this._play.takeSnapshot(e, "download", this.streamID), this.client.apiFrequencyControl({ name: "takeSnapshot", code: 0, param: Object.assign(Object.assign({}, e), { streamID: this.stringStreamID, isRemote: true }) })) : (l = "takeSnapshot(): 没有视频流, 请检查视频是否正在播放", c = errorCode_1.default.STREAM_TAKE_SNAPSHOT_ERROR), c) throw this.logger.error(l), this.client.apiFrequencyControl({ name: "takeSnapshot", code: -1, param: JSON.stringify(Object.assign(Object.assign({ streamID: this.stringStreamID, isRemote: true }, e), { reason: l }), null, " ") }), new rtcError_1.default({ code: c, message: l });
          }
          takeSnapshotBase64(e) {
            var t, i, r, s, a, o, n, d;
            let c, l;
            const u = this.video && (null === (i = null === (t = this._play) || void 0 === t ? void 0 : t.video) || void 0 === i ? void 0 : i.dom), h = this.screen && (null === (s = null === (r = this.Play) || void 0 === r ? void 0 : r.screen) || void 0 === s ? void 0 : s.dom), p = this.videoThird && (null === (o = null === (a = this._play) || void 0 === a ? void 0 : a.videoThird) || void 0 === o ? void 0 : o.dom), m = this.videoFourth && (null === (d = null === (n = this.Play) || void 0 === n ? void 0 : n.videoFourth) || void 0 === d ? void 0 : d.dom);
            if (u || h || p || m) {
              let t2 = this._play.takeSnapshot(e, "base64");
              return this.client.apiFrequencyControl({ name: "takeSnapshotBase64", code: 0, param: Object.assign({ streamID: this.stringStreamID, isRemote: true }, e) }), t2;
            }
            if (l = "takeSnapshotBase64(): 没有视频流, 请检查视频是否正在播放", c = errorCode_1.default.STREAM_TAKE_SNAPSHOT_ERROR, c) throw this.logger.error(l), this.client.apiFrequencyControl({ name: "takeSnapshotBase64", code: -1, param: JSON.stringify(Object.assign(Object.assign({ streamID: this.stringStreamID, isRemote: true }, e), { reason: l }), null, " ") }), new rtcError_1.default({ code: c, message: l });
          }
          getCurrentFrameData(e = { mediaType: "video" }) {
            return this._play.getCurrentFrameData(e);
          }
          async startMediaRecording(e) {
            const t = [];
            switch (e.type) {
              case "screen":
                t.push(this.mediaHelper.screen.screenVideoStream), t.push(this.mediaHelper.audio.audioStream);
                break;
              case "camera":
              case "video":
                t.push(this.mediaHelper.video.videoStream), t.push(this.mediaHelper.audio.audioStream);
                break;
              case "audio":
                t.push(this.mediaHelper.audio.audioStream);
            }
            if (0 !== t.length) {
              if (!this._record || !this.streamID || !t) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_ERROR, message: "remoteStream_startMediaRecording: 开始录制时参数异常" });
              return this._record && this._record.start({ uid: "string" === this.client.adapterRef.channelInfo.uidType ? this.stringStreamID : this.streamID, type: e.type, reset: e.reset, stream: t });
            }
            this.logger.log("未发现要录制的媒体流");
          }
          stopMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "remoteStream.stopMediaRecording: 录制未开始" });
            return this._record.stop({});
          }
          playMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "remoteStream.playMediaRecording: 录制未开始" });
            return this._record.play(e.view);
          }
          listMediaRecording() {
            let e = [];
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "remoteStream.listMediaRecording: 录制未开始" });
            const t = this._record.getRecordStatus();
            return "init" !== t.status && e.push(t), e;
          }
          cleanMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "remoteStream.cleanMediaRecording: 录制未开始" });
            return this._record.clean();
          }
          downloadMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "remoteStream.downloadMediaRecording: 录制未开始" });
            return this._record.download();
          }
          clearRemotePubStatus() {
            for (let e of types_1.MediaTypeList) this[e] = false, this.pubStatus[e][e] = false, this.pubStatus[e].producerId = "", this.pubStatus[e].consumerId = "", this.pubStatus[e].consumerStatus = "init", this.pubStatus[e].stopconsumerStatus = "init";
          }
          setCanvasWatermarkConfigs(e) {
            if (this._play) {
              let t = this._play[e.mediaType].canvasWatermark;
              if (!t) return void this.logger.error("setCanvasWatermarkConfigs：播放器未初始化", e.mediaType);
              const i = { TEXT: 10, TIMESTAMP: 1, IMAGE: 4 };
              if (e.textWatermarks && e.textWatermarks.length > i.TEXT) throw this.logger.error(`目前的文字水印数量：${e.textWatermarks.length}。允许的数量：${i.TEXT}`), new rtcError_1.default({ code: errorCode_1.default.WATERMARKS_EXCEEDED_ERROR, message: "最多可以设置 10 个文字水印" });
              if (e.imageWatermarks && e.imageWatermarks.length > i.IMAGE) throw this.logger.error(`目前的图片水印数量：${e.imageWatermarks.length}。允许的数量：${i.IMAGE}`), new rtcError_1.default({ code: errorCode_1.default.WATERMARKS_EXCEEDED_ERROR, message: "最多可以设置 4 个图片水印" });
              t.checkWatermarkParams(e), t.updateWatermarks(e);
              Object.assign({ uid: this.stringStreamID }, e);
              this.client.apiFrequencyControl({ name: "setRemoteCanvasWatermarkConfigs", code: 0, param: { isRemote: true, streamID: this.stringStreamID, mediaType: e.mediaType } });
            } else this.logger.error("setCanvasWatermarkConfigs：播放器未初始化");
          }
          async registerPlugin(options) {
            if (options.async) return this.registerPluginAsync(options);
            if (this.logger.log("register plugin:" + options.key), !this.supportWasm) throw this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: "unsupportWasm" } }), new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_SUPPORT_ERROR, message: `该浏览器不支持WebAssembly，注册 ${options.key} 失败。` });
            const stageAIProcessing = this.mediaHelper.audio.stageAIProcessing;
            if (null == stageAIProcessing ? void 0 : stageAIProcessing.getPluginConfig(options.key)) return this.logger.warn(`plugin ${options.key} already exists.`), false;
            let plugin = null;
            options.adapterRef = this.client.adapterRef;
            try {
              if (options.pluginUrl ? (await plugin_1.loadPlugin(options.key, options.pluginUrl), plugin = eval(`new window.${options.key}(options)`)) : options.pluginObj && (plugin = new options.pluginObj(options)), !plugin) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: "unsupport plugin " + options.key });
              plugin.once("plugin-load", () => {
                if (plugin.version !== Config_1.SDK_VERSION) throw this.logger.error(`插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。`), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_VERSION_ERROR, message: `插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。` });
                if (this.logger.log(`plugin ${options.key} loaded`), -1 !== plugin_list_1.videoPlugins.indexOf(options.key)) ;
                else {
                  if (-1 === plugin_list_1.audioPlugins.indexOf(options.key)) throw new Error("unsupport plugin " + options.key + JSON.stringify(options));
                  {
                    let e;
                    if (this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
                    else {
                      const t2 = webAudio_1.getAudioContext();
                      if (!t2) return this.logger.error("当前环境不支持AudioContext"), false;
                      e = new StageAIProcessing_1.StageAIProcessing(t2, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
                    }
                    "AIAudioEffects" == options.key && (this.supportAIAudioEffects = true);
                    const t = Object.assign(Object.assign({}, options), { blobUrl: plugin.url, wasmBinary: plugin.wasmBinary });
                    e.registerPlugin(t), e.once("error", (e2) => {
                      const { msg: t2, key: i } = e2;
                      this.logger.error(`plugin ${options.key} error: ${i} ${t2}`), "AIAudioEffects" == i && (this.supportAIAudioEffects = false), this.unregisterPlugin(i), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${t2}。` } });
                    }), e.on("plugin-process-unstable", (e2) => {
                      this.emit("plugin-process-unstable", Object.assign({ streamID: this.stringStreamID }, e2));
                    });
                  }
                }
                this.emit("plugin-load", options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: 0, param: { streamID: this.stringStreamID, plugin: options.key } });
              }), plugin.once("plugin-load-error", (e) => {
                this.emit("plugin-load-error", { key: options.key, msg: `load ${options.wasmUrl} error.` }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `load ${options.wasmUrl} error.` } });
              }), plugin.once("error", (e) => {
                "AIAudioEffects" == options.key && (this.supportAIAudioEffects = false), this.unregisterPlugin(options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${e}。` } });
              });
            } catch (e) {
              throw this.emit("plugin-load-error", { key: options.key, msg: e }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: e } }), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: e.message });
            }
          }
          async registerPluginAsync(options) {
            return new Promise(async (resolve, reject) => {
              if (this.logger.log("register plugin:" + options.key), !this.supportWasm) throw this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: "unsupportWasm" } }), new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_SUPPORT_ERROR, message: `该浏览器不支持WebAssembly，注册 ${options.key} 失败。` });
              const stageAIProcessing = this.mediaHelper.audio.stageAIProcessing;
              if (null == stageAIProcessing ? void 0 : stageAIProcessing.getPluginConfig(options.key)) return this.logger.warn(`plugin ${options.key} already exists.`), void resolve(`plugin ${options.key} already exists.`);
              let plugin = null;
              options.adapterRef = this.client.adapterRef;
              try {
                if (options.pluginUrl ? (await plugin_1.loadPlugin(options.key, options.pluginUrl), plugin = eval(`new window.${options.key}(options)`)) : options.pluginObj && (plugin = new options.pluginObj(options)), !plugin) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: "unsupport plugin " + options.key });
                plugin.once("plugin-load", () => {
                  if (plugin.version !== Config_1.SDK_VERSION) throw this.logger.error(`插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。`), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_VERSION_ERROR, message: `插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。` });
                  if (this.logger.log(`plugin ${options.key} loaded`), -1 === plugin_list_1.videoPlugins.indexOf(options.key)) {
                    if (-1 === plugin_list_1.audioPlugins.indexOf(options.key)) throw new Error(`unsupport plugin ${options.key} ${options.wasmUrl}`);
                    {
                      let e;
                      if (this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
                      else {
                        const t2 = webAudio_1.getAudioContext();
                        if (!t2) return this.logger.error("当前环境不支持AudioContext"), false;
                        e = new StageAIProcessing_1.StageAIProcessing(t2, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
                      }
                      "AIAudioEffects" == options.key && (this.supportAIAudioEffects = true);
                      const t = Object.assign(Object.assign({}, options), { blobUrl: plugin.url, wasmBinary: plugin.wasmBinary });
                      e.registerPlugin(t), e.once("error", (e2) => {
                        const { msg: t2, key: i } = e2;
                        this.logger.error(`plugin ${options.key} error: ${i} ${t2}`), "AIAudioEffects" == i && (this.supportAIAudioEffects = false), this.unregisterPlugin(i), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${t2}。` } });
                      }), e.on("plugin-process-unstable", (e2) => {
                        this.emit("plugin-process-unstable", Object.assign({ streamID: this.stringStreamID }, e2));
                      });
                    }
                    this.emit("plugin-load", options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: 0, param: { streamID: this.stringStreamID, plugin: options.key } }), resolve(void 0);
                  } else reject("unsupport video plugin");
                }), plugin.once("plugin-load-error", (e) => {
                  this.emit("plugin-load-error", { key: options.key, msg: `load ${options.wasmUrl} error.` }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `load ${options.wasmUrl} error.` } }), reject(new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: e }));
                }), plugin.once("error", (e) => {
                  "AIAudioEffects" == options.key && (this.supportAIAudioEffects = false), this.unregisterPlugin(options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${e}。` } }), reject(new rtcError_1.default({ code: errorCode_1.default.PLUGIN_ERROR, message: e }));
                });
              } catch (e) {
                throw this.emit("plugin-load-error", { key: options.key, msg: e }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: e } }), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: e.message || e.msg || "unsupport plugin " + options.key });
              }
            });
          }
          async unregisterPlugin(e) {
            var t;
            if (this.logger.log("unRegister plugin:" + e), -1 !== plugin_list_1.audioPlugins.indexOf(e)) {
              const i = this.mediaHelper.audio.stageAIProcessing;
              if ("AIAudioEffects" === e) {
                const e2 = null == i ? void 0 : i.getProcessor("AIAudioEffects");
                (null == e2 ? void 0 : e2.getState("AudioEffect")) && this.disableAudioEffect();
              }
              null == i || i.unregisterPlugin(e), (null == i ? void 0 : i.hasWorkingPlugin()) || (null === (t = this.mediaHelper.audio.stageAIProcessing) || void 0 === t || t.destroy(), this.mediaHelper.audio.stageAIProcessing = null);
            }
            this.client.apiFrequencyControl({ name: "unregisterPlugin", code: 0, param: { streamID: this.stringStreamID, plugin: e } });
          }
          async enableAudioEffect() {
            if (!this.canEnableAIAudioEffects) return this.logger.error("请先关闭伴音功能"), false;
            if (!this.supportAIAudioEffects) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_SUPPORT, message: "Unsupport Plugin, Please check your plugin version" });
            let e;
            if (this.logger.log("start audio effect."), this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
            else {
              const t2 = webAudio_1.getAudioContext();
              if (!t2) return this.logger.error("当前环境不支持AudioContext"), false;
              e = new StageAIProcessing_1.StageAIProcessing(t2, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
            }
            if (!e.getPluginConfig("AIAudioEffects")) throw this.logger.error("AudioEffects plugin is not register."), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_REGISTER, message: "ai audio effect plugin is not register" });
            e.enabled = true;
            const t = e.getProcessor("AIAudioEffects");
            return t ? (t.getState("AudioEffect") ? this.logger.warn("audio effect is already opened.") : (t.setState("AudioEffect", true), this.emit("audio-effect-enabled"), this.client.apiFrequencyControl({ name: "enableAudioEffect", code: 0, param: { streamID: this.stringStreamID } })), true) : (e.once("effects-load", async () => {
              var t2, i, r, s;
              this.logger.log("ai audio effects loaded");
              const a = e.getProcessor("AIAudioEffects");
              if (null == a || a.setState("AudioEffect", true), this.emit("audio-effect-enabled"), this.client.apiFrequencyControl({ name: "enableAudioEffect", code: 0, param: { streamID: this.stringStreamID } }), this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.updateWebAudio(), this.client.adapterRef.enableMixAudio) {
                null === (t2 = this.client.adapterRef.audioMixer) || void 0 === t2 || t2.disconnectStream(this.mediaHelper.audio.audioStream);
                const e2 = null === (r = null === (i = this.mediaHelper.audio.webAudio) || void 0 === i ? void 0 : i.destination) || void 0 === r ? void 0 : r.stream;
                e2 && (null === (s = this.client.adapterRef.audioMixer) || void 0 === s || s.addStream(e2));
              }
            }), await e.initProcessor("AIAudioEffects"), true);
          }
          async disableAudioEffect() {
            var e, t, i, r;
            this.logger.log("close audio effect.");
            const s = this.mediaHelper.audio.stageAIProcessing, a = null == s ? void 0 : s.getProcessor("AIAudioEffects");
            if (!s) return this.logger.warn("disableAudioEffect: audio process is not created"), true;
            if (!a) return this.logger.warn("ai audio effect is already closed."), true;
            if (null == a || a.setState("AudioEffect", false), (null == a ? void 0 : a.getState("AIDenoise")) || (null == a ? void 0 : a.getState("AudioEffect")) || s.destroyProcessor("AIAudioEffects"), !s.hasWorkingPlugin()) {
              if (this.client.adapterRef.enableMixAudio) {
                const s2 = null === (t = null === (e = this.mediaHelper.audio.webAudio) || void 0 === e ? void 0 : e.destination) || void 0 === t ? void 0 : t.stream;
                s2 && (null === (i = this.client.adapterRef.audioMixer) || void 0 === i || i.removeStream(s2)), null === (r = this.client.adapterRef.audioMixer) || void 0 === r || r.connectStream(this.mediaHelper.audio.audioStream);
              }
              s.enabled = false, this.mediaHelper.updateWebAudio(), this.mediaHelper.canDisableAudioRouting() && this.mediaHelper.disableAudioRouting();
            }
            return this.client.apiFrequencyControl({ name: "disableAudioEffect", code: 0, param: { streamID: this.stringStreamID } }), true;
          }
          setAudioEffect(e, t) {
            this.logger.log(`setAudioEffect:${e} `, JSON.stringify(t));
            const i = this.mediaHelper.audio.stageAIProcessing, r = null == i ? void 0 : i.getProcessor("AIAudioEffects");
            (null == r ? void 0 : r.getState("AudioEffect")) ? (r.setAudioEffect(e, t), this.client.apiFrequencyControl({ name: "setAudioEffect", code: 0, param: { streamID: this.stringStreamID, type: e, value: JSON.stringify(t) } })) : this.logger.warn("audio effect is not opened.");
          }
          getMuteStatus(e) {
            if (types_1.MediaTypeList.indexOf(e) > -1) return { send: this.muteStatus[e].send, recv: this.muteStatus[e].recv, muted: this.muteStatus[e].send || this.muteStatus[e].recv };
            throw new Error("getMuteStatus Invalid Media " + e);
          }
          getAdapterRef() {
            var e;
            return (null === (e = this.client.adapterRef.remoteStreamMap[this.streamID]) || void 0 === e ? void 0 : e.remoteStreamId) === this.remoteStreamId ? this.client.adapterRef : null;
          }
          getNativeDom(e) {
            var t;
            const i = this[e], r = null === (t = this._play[e]) || void 0 === t ? void 0 : t.dom;
            return i && r || this.logger.warn("No remote " + e), r;
          }
          destroy() {
            this.client && (this.client.apiFrequencyControl({ name: "destroy", code: 0, param: { streamID: this.stringStreamID, isRemote: true } }), this.logger.log(`uid ${this.stringStreamID} 销毁 Stream 实例`), this.stop(), this._reset());
          }
        }
        exports.RemoteStream = RemoteStream;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.pcCloneTrack = void 0, t.pcCloneTrack = function(e2) {
          const t2 = new RTCPeerConnection(), i2 = new RTCPeerConnection();
          window.pcLocal = t2, window.pcRemote = i2, t2.onicecandidate = (e3) => {
            e3.candidate && i2.addIceCandidate(e3.candidate);
          }, t2.onnegotiationneeded = async (e3) => {
            const r2 = await t2.createOffer();
            await t2.setLocalDescription(r2), await i2.setRemoteDescription(r2);
            const s = await i2.createAnswer();
            await i2.setLocalDescription(s), await t2.setRemoteDescription(s);
          };
          const r = t2.addTransceiver("video", { direction: "recvonly" });
          return i2.addTrack(e2), e2.addEventListener("neTrackEnded", () => {
            i2.close(), r.receiver.track.stop();
          }), r.receiver.track;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.preProcessingPureColor = t.preProcessingCopy = t.preProcessingSyncState = t.disablePreProcessing = t.canDisablePreProcessing = t.enablePreProcessing = void 0;
        const r = i(71), s = i(174), a = i(150);
        function o(e2, t2, i2) {
          i2.videoTrack && i2.videoTrack.enabled !== i2.canvasTrack.enabled && (e2.logger.log(`preProcessingCopy: 更改mute状态 ${t2} ${i2.canvasTrack.enabled} => ${i2.videoTrack.enabled}`), i2.canvasTrack.enabled = i2.videoTrack.enabled);
        }
        function n(e2, t2, i2) {
          i2.videoTrack && i2.videoTrack.enabled !== i2.canvasTrack.enabled && (e2.logger.log(`preProcessingCopy: 更改mute状态 ${t2} ${i2.canvasTrack.enabled} => ${i2.videoTrack.enabled}`), i2.canvasTrack.enabled = i2.videoTrack.enabled), i2.canvasCtx.drawImage(i2.videoElem, 0, 0);
        }
        t.enablePreProcessing = async function(e2, t2, i2) {
          let d;
          if (i2 || (i2 = e2[t2].captureConfig.high.frameRate), d = "video" === t2 ? e2.video.cameraTrack || e2.video.videoSource : e2.screen.screenVideoTrack || e2.screen.screenVideoSource, !d) return void e2.logger.warn("enablePreProcessing：当前没有视频输入 " + t2);
          let c, l = e2[t2].preProcessing;
          if (!l) {
            e2.logger.log("enablePreProcessing:初始化 mediaType " + t2);
            const i3 = document.createElement("video");
            let r2 = new a.RTCCanvas("canvas"), s2 = r2._canvas, d2 = r2._ctx;
            if (!d2) throw new Error("无法创建canvasCtx 2d");
            const c2 = s2.captureStream();
            i3.onresize = () => {
              r2.setSize(i3.videoWidth, i3.videoHeight), i3.play();
            };
            const u2 = c2.getVideoTracks()[0];
            l = { canvasTrack: u2, canvasCtx: d2, videoTrack: null, videoElem: i3, canvasElem: s2, handlers: [{ name: "syncState", enabled: true, func: o }, { name: "copy", enabled: true, func: n }, { name: "mirror", enabled: false, func: () => {
            } }, e2.stream._play[t2].encoderWatermark.handler], history: [], timer: null }, e2[t2].preProcessing = l;
          }
          if (!l) return;
          "video" === t2 ? r.emptyStreamWith(e2.video.videoStream, l.canvasTrack) : r.emptyStreamWith(e2.screen.screenVideoStream, l.canvasTrack), l.videoElem.srcObject = new MediaStream([d]), l.videoTrack = d, e2.stream.isRemote || (c = e2.stream.getSender(t2, "high")), c && (c.replaceTrack(l.canvasTrack), e2.logger.log(`enablePreProcessing ${t2} 成功替换上行`));
          const u = async () => {
            if (l) if (l.videoElem.videoWidth && l.videoElem.videoHeight && (l.videoElem.videoWidth === l.canvasElem.width && l.videoElem.videoHeight === l.canvasElem.height || (e2.logger.warn(`前处理宽高变化 ${t2} ${l.canvasElem.width}x${l.canvasElem.height} => ${l.videoElem.videoWidth}x${l.videoElem.videoHeight}`), l.canvasElem.width = l.videoElem.videoWidth, l.canvasElem.height = l.videoElem.videoHeight)), l.handlers.length) {
              const i3 = Date.now(), r2 = [];
              for (let s3 of l.handlers) if (s3 && s3.enabled) {
                const a3 = i3;
                await s3.func(e2, t2, l);
                const o2 = Date.now() - a3;
                r2.push({ name: s3.name, spent: o2 });
              }
              const s2 = Date.now();
              let a2 = 0;
              for (; a2 < l.history.length && s2 - l.history[a2].endTs > 5e3; a2++) ;
              l.history.splice(0, a2), l.history.push({ startTs: i3, endTs: s2, handlerTs: r2 });
            } else n(e2, t2, l);
          };
          l.timer && clearInterval(l.timer);
          const h = Math.floor(1e3 / i2);
          try {
            u();
          } catch (t3) {
            e2.logger.error("drawFrame", t3.name, t3.message, t3.stack);
          }
          l.timer = s.getRTCTimer().setInterval(u, h), e2[t2].preProcessingEnabled = true, e2.emit("preProcessChange", { mediaType: t2, isOn: true });
        }, t.canDisablePreProcessing = function(e2, t2) {
          const i2 = e2[t2].preProcessing;
          return !(!i2 || !i2.timer) && 0 === i2.handlers.filter((e3) => e3 && e3.enabled && "syncState" !== e3.name && "copy" !== e3.name).length;
        }, t.disablePreProcessing = async function(e2, t2 = "video", i2 = false) {
          e2.logger.log("disablePreProcessing " + t2);
          const a2 = e2[t2].preProcessing;
          if (!a2) return void e2.logger.warn(`disablePreProcessing ${t2}:当前没有前处理配置`);
          let o2, n2;
          a2.canvasCtx.clearRect(0, 0, a2.canvasElem.width, a2.canvasElem.height), (null == a2 ? void 0 : a2.timer) && (s.getRTCTimer().clearInterval(a2.timer), a2.timer = null), "video" === t2 ? (o2 = e2.video.cameraTrack || e2.video.videoSource, r.emptyStreamWith(e2.video.videoStream, o2)) : (o2 = e2.screen.screenVideoTrack || e2.screen.screenVideoSource, r.emptyStreamWith(e2.screen.screenVideoStream, o2)), a2.videoElem.srcObject && (a2.videoElem.srcObject = null), e2.stream.isRemote || (n2 = e2.stream.getSender(t2, "high")), n2 && ("live" === (null == o2 ? void 0 : o2.readyState) ? (n2.replaceTrack(o2), e2.logger.log(`disablePreProcessing ${t2} 成功替换上行为【${o2.label}】`)) : (n2.replaceTrack(null), e2.logger.warn("disablePreProcessing 删除上行"))), i2 || (e2[t2].preProcessingEnabled = false), e2.emit("preProcessChange", { mediaType: t2, isOn: false });
        }, t.preProcessingSyncState = o, t.preProcessingCopy = n, t.preProcessingPureColor = function(e2, t2, i2) {
          i2.canvasCtx.fillStyle = "green", i2.canvasCtx.fillRect(0, 0, i2.canvasElem.width, i2.canvasElem.height);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AudioPipeline = void 0;
        const r = i(286), s = i(72), a = i(287), o = i(288), n = i(289), d = i(290);
        let c = 0;
        t.AudioPipeline = class {
          constructor(e2) {
            this.id = ++c, this.inputs = { local: { track: null, node: null, label: "" }, remote: { track: null, node: null, label: "" } }, this.audioLevelNode = null, this.stages = [], this.mixins = {}, this.output = { track: null, stream: new MediaStream(), destination: null, directOutput: true }, this.context = e2.context, this.logger = e2.logger.getChild(() => {
              let e3 = "AudioPipeline#" + this.id;
              this.inputs.local.track && (e3 += " LOCAL", this.inputs.local.track === this.output.track && (e3 += `[${this.inputs.local.label}]`)), this.inputs.remote.track && (e3 += " REMOTE", this.inputs.remote.track === this.output.track && (e3 += `[${this.inputs.remote.label}]`));
              let t2 = "";
              for (let e4 in this.mixins) this.output.destination && this.mixins[e4].node.isConnectedTo(this.output.destination) && (t2 += " m" + e4);
              t2 && (e3 += " " + t2);
              for (let t3 in this.stages) this.stages[t3].enabled && (e3 += "/" + this.stages[t3].type);
              return e3;
            }), this.stageInputVolume = new o.StageInputVolume(this.context), this.stageDelay = new n.StageDelay(this.context), this.stages = [this.stageInputVolume, this.stageDelay], this.output.stream = e2.outputStream, this.pluginList = [], this.logger.log("Audio Pipeline Init");
          }
          getMixin(e2) {
            return this.mixins[e2] || (this.mixins[e2] = new d.AudioMix(this)), this.mixins[e2];
          }
          getEnabledStages() {
            return this.stages.filter((e2) => e2.enabled);
          }
          setInput(e2, t2, i2) {
            this.inputs[e2].track = t2, this.updateConnection();
          }
          getInputVolume() {
            return this.stageInputVolume.volume;
          }
          setInputVolume(e2) {
            this.stageInputVolume.setVolume(e2), this.stageInputVolume.isTransparent() ? this.stageInputVolume.enabled && (this.stageInputVolume.enabled = false, this.updateConnection()) : this.stageInputVolume.enabled || (this.stageInputVolume.enabled = true, this.updateConnection());
          }
          setDelay(e2) {
            this.stageDelay.setDelay(e2), this.stageDelay.isTransparent() ? this.stageDelay.enabled && (this.stageDelay.enabled = false, this.updateConnection()) : this.stageDelay.enabled || (this.stageDelay.enabled = true, this.updateConnection());
          }
          getAudioLevel() {
            return this.audioLevelNode || (this.initAudioLevelNode(), this.updateConnection()), this.audioLevelNode ? (this.audioLevelNode.audioNode && !this.audioLevelNode.audioNode.port.onmessage && (this.audioLevelNode.logger.warn("Rebinding Audio Worklet Node"), this.audioLevelNode.bindAudioWorkletNode(this.audioLevelNode.audioNode)), this.audioLevelNode.getAudioLevel()) : 0;
          }
          initAudioLevelNode() {
            this.audioLevelNode ? this.logger.log("initAudioLevelNode: audioLevelNode Already Inited") : (this.audioLevelNode = new r.AudioLevelNode({ logger: this.logger, context: this.context }), this.updateConnection());
          }
          hasWorkingMixin() {
            for (let e2 in this.mixins) if ("MIX_PLAYING" === this.mixins[e2].mixAudioConf.state) return true;
            return false;
          }
          updateConnection() {
            var e2, t2, i2, r2, o2, n2;
            const d2 = this.getInputsInfo();
            let c2 = null;
            switch (d2.cnt) {
              case 0:
                this.output.directOutput = true, this.output.stream.getTracks().length && (this.output.stream.getTracks().forEach((e3) => {
                  this.output.stream.removeTrack(e3);
                }), this.logger.log("updateConnection:NoInput"), this.output.stream.dispatchEvent(new Event("neTrackUpdated")), this.output.track = null), this.audioLevelNode && this.audioLevelNode.disconnectFromAll();
                break;
              case 1:
                if (this.getEnabledStages().length || this.hasWorkingMixin()) {
                  this.output.destination || (this.logger.log("updateConnection: Creating output destination"), this.output.destination = new s.NeAudioNode("destination", this.context.createMediaStreamDestination())), this.output.track = this.output.destination.audioNode.stream.getTracks()[0], this.output.stream.getTracks()[0] !== this.output.track && (this.output.stream.getTracks().forEach((e4) => {
                    var t3;
                    this.logger.log(`updateConnection: Updating output track ${e4.label} => ${null === (t3 = this.output.track) || void 0 === t3 ? void 0 : t3.label}`), this.output.stream.removeTrack(e4);
                  }), this.output.stream.addTrack(this.output.track), this.output.stream.dispatchEvent(new Event("neTrackUpdated")));
                  let e3 = false;
                  for (let t3 in this.mixins) {
                    const i3 = this.mixins[t3];
                    "MIX_PLAYING" === i3.mixAudioConf.state ? (i3.mixAudioConf.replace && (e3 = true), i3.node.isConnectedTo(this.output.destination) || (this.logger.log(`connect ${t3} to destination`), i3.node.connect(this.output.destination))) : i3.node.isConnectedTo(this.output.destination) && i3.node.disconnect(this.output.destination);
                  }
                  if (this.stages) {
                    let t3 = this.output.destination;
                    for (let s2 = this.stages.length - 1; s2 >= 0; s2--) {
                      const a2 = this.stages[s2];
                      a2.enabled && a2.node ? (c2 || (c2 = a2.node), e3 && t3 === this.output.destination ? a2.node.isConnectedTo(t3) && a2.node.disconnect(t3) : a2.node.isConnectedTo(t3) || (a2.node.disconnectToAll(), a2.node.connect(t3)), t3 = a2.node) : a2.enabled || (null === (i2 = a2.node) || void 0 === i2 || i2.disconnectToAll(), null === (r2 = a2.node) || void 0 === r2 || r2.disconnectFromAll());
                    }
                    d2.singleInput && (d2.singleInput.track && (d2.singleInput.node = a.getMediaStreamSourceNode(this.context, d2.singleInput.track, d2.singleInput === this.inputs.remote)), e3 && t3 === this.output.destination ? (null === (o2 = d2.singleInput.node) || void 0 === o2 ? void 0 : o2.isConnectedTo(t3)) && (null === (n2 = d2.singleInput.node) || void 0 === n2 || n2.disconnect(t3)) : d2.singleInput.node && !d2.singleInput.node.isConnectedTo(t3) && (d2.singleInput.node.disconnectToAll(), d2.singleInput.node.connect(t3)));
                  }
                } else this.output.directOutput = true, (null === (e2 = d2.singleInput) || void 0 === e2 ? void 0 : e2.track) && (this.output.track = d2.singleInput.track, this.output.stream.getTracks()[0] !== this.output.track && (this.output.stream.getTracks().forEach((e3) => {
                  this.output.stream.removeTrack(e3);
                }), this.output.stream.addTrack(this.output.track), this.logger.log("updateConnection: DIRECT", this.output.track.label), this.output.stream.dispatchEvent(new Event("neTrackUpdated"))), this.audioLevelNode && (d2.singleInput.node = a.getMediaStreamSourceNode(this.context, d2.singleInput.track, d2.singleInput === this.inputs.remote), c2 = d2.singleInput.node)), (null === (t2 = d2.singleInput) || void 0 === t2 ? void 0 : t2.node) && d2.singleInput.node.disconnectToAll();
            }
            this.audioLevelNode && c2 && (c2.isConnectedTo(this.audioLevelNode) || (this.audioLevelNode.disconnectFromAll(), c2.connect(this.audioLevelNode)));
          }
          getInputsInfo() {
            let e2 = 0, t2 = null;
            return this.inputs.local.track && (e2++, t2 = this.inputs.local), this.inputs.remote.track && (e2++, t2 = this.inputs.remote), { cnt: e2, singleInput: 1 === e2 ? t2 : null };
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AudioLevelNode = void 0;
        const r = i(90), s = i(72), a = i(47);
        let o = "NOTREADY", n = null;
        class d extends s.NeAudioNodeNullable {
          constructor(e2) {
            super("AudioLevelNode", null), this.volume = 0, this.volumeTs = Date.now(), this.left = null, this.right = null, this.channelState = "balance", this.stateChangeCnt = 0, this.context = e2.context, this.logger = e2.logger.getChild(() => {
              let e3 = "AudioLevelNode#" + this.id;
              return e3 += "READY" !== o ? " " + o : " " + this.channelState, this.stateChangeCnt && (e3 += " change" + this.stateChangeCnt), e3;
            }), this.initAudioWorklet();
          }
          async initAudioWorklet() {
            if (this.logger.log("AudioLevelNode initAudioWorklet"), !this.context.audioWorklet) return void this.logger.error("该环境不支持音频处理");
            n ? "LOADING" === o && await n : (o = "LOADING", this.logger.log("正在载入音量模块"), n = this.context.audioWorklet.addModule(r.getBlobUrl("volumeProcessor")), await n, o = "READY", this.logger.log("载入音量模块成功"));
            const e2 = new AudioWorkletNode(this.context, "vumeter");
            this.bindAudioWorkletNode(e2);
            const t2 = a.getAudioLevelDestination();
            t2 && e2.connect(t2), this.connectedFrom.forEach((e3) => {
              e3.connect(this);
            }), this.connectedTo.forEach((e3) => {
              this.connect(e3);
            });
          }
          bindAudioWorkletNode(e2) {
            this.audioNode = e2, e2.port.onmessage = (t2) => {
              var i2, r2;
              if (this.audioNode !== e2) return;
              const s2 = Date.now(), a2 = Math.floor(s2);
              if (t2.data.volume > -1) {
                if (this.volume = t2.data.volume, this.volumeTs = s2, t2.data.left > -1) this.left || (this.left = { volume: 0, history: [] }), this.left.history.length && this.left.history[0].sec === a2 || this.left.history.unshift({ sec: a2, sum: 0 }), this.left.volume = t2.data.left, this.left.history[0].sum += t2.data.left, this.left.history.length > 2 && this.left.history.pop();
                else {
                  const e3 = this.channelState;
                  this.channelState = "mono", e3 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e3} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e3 }));
                }
                if (t2.data.right > -1 && (this.right || (this.right = { volume: 0, history: [] }), this.right.history.length && this.right.history[0].sec === a2 || this.right.history.unshift({ sec: a2, sum: 0 }), this.right.volume = t2.data.right, this.right.history[0].sum += t2.data.right, this.right.history.length > 2 && this.right.history.pop()), (null === (i2 = this.left) || void 0 === i2 ? void 0 : i2.history[1]) && (null === (r2 = this.right) || void 0 === r2 ? void 0 : r2.history[1])) if (this.left.history[1].sum > 4 * this.right.history[1].sum) {
                  const e3 = this.channelState;
                  this.channelState = "leftLoud", e3 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e3} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e3 }));
                } else if (this.right.history[1].sum > 4 * this.left.history[1].sum) {
                  const e3 = this.channelState;
                  this.channelState = "rightLoud", e3 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e3} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e3 }));
                } else {
                  if (this.left.history[1].sum > this.right.history[1].sum && "leftLoud" !== this.channelState) {
                    const e3 = this.channelState;
                    this.channelState = "balance", e3 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e3} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e3 }));
                  }
                  if (this.right.history[1].sum > this.left.history[1].sum && "rightLoud" !== this.channelState) {
                    const e3 = this.channelState;
                    this.channelState = "balance", e3 !== this.channelState && (this.stateChangeCnt++, this.stateChangeCnt < 20 && this.logger.log(`声道状态变更 ${e3} => ${this.channelState}`), this.emit("channel-state-change", { state: this.channelState, prev: e3 }));
                  }
                }
              } else this.logger.error("Unsupported message", t2.data);
            };
          }
          getAudioLevel() {
            var e2, t2;
            return Date.now() - this.volumeTs > 1e3 ? { volume: 0 } : { volume: this.volume, left: null === (e2 = this.left) || void 0 === e2 ? void 0 : e2.volume, right: null === (t2 = this.right) || void 0 === t2 ? void 0 : t2.volume };
          }
        }
        t.AudioLevelNode = d;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.getMediaStreamSourceNode = void 0;
        const r = i(72), s = [];
        t.getMediaStreamSourceNode = function(e2, t2, i2) {
          const a = s.find((i3) => i3.ctx === e2 && i3.track === t2);
          if (a) {
            if (i2) {
              if (!a.audioElem) {
                const e3 = document.createElement("audio");
                e3.muted = true, e3.volume = 0, e3.autoplay = true, e3.controls = true, a.audioElem = e3;
              }
              a.audioElem.srcObject = a.stream, a.audioElem.play().catch((e3) => {
              });
            }
            return a.node;
          }
          {
            const a2 = new MediaStream([t2]), o = e2.createMediaStreamSource(a2), n = new r.NeAudioNode("MediaStreamSource", o);
            let d = null;
            i2 && (d = document.createElement("audio"), d.muted = true, d.volume = 0, d.autoplay = true, d.controls = true, d.srcObject = a2, d.play().catch((e3) => {
            }));
            const c = { track: t2, stream: a2, source: o, ctx: e2, node: n, audioElem: d };
            return s.push(c), n;
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.StageInputVolume = void 0;
        const r = i(194), s = i(72);
        class a extends r.StageBase {
          constructor(e2) {
            super(e2), this.type = "stageInputVolume", this.node = null, this.volume = 1;
          }
          async init() {
            "UNINIT" === this.state && (this.node = new s.NeAudioNode("gain", this.context.createGain()), this.state = "INITED");
          }
          isTransparent() {
            return Math.abs(this.volume - 1) < 0.01;
          }
          setVolume(e2) {
            "UNINIT" === this.state && this.init(), this.node && e2 <= this.node.audioNode.gain.maxValue && e2 >= this.node.audioNode.gain.minValue && (this.node.audioNode.gain.value = e2, this.volume = e2);
          }
        }
        t.StageInputVolume = a;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.StageDelay = void 0;
        const r = i(194), s = i(72);
        class a extends r.StageBase {
          constructor(e2) {
            super(e2), this.type = "stageDelay", this.node = null, this.delayTime = 1;
          }
          async init() {
            "UNINIT" === this.state && (this.node = new s.NeAudioNode("delay", this.context.createDelay(10)), this.state = "INITED", this.node.audioNode.delayTime.value = this.delayTime);
          }
          isTransparent() {
            return this.delayTime < 0.01;
          }
          setDelay(e2) {
            "UNINIT" === this.state && this.init(), this.node && (this.delayTime = e2, this.node.audioNode.delayTime.value = e2);
          }
        }
        t.StageDelay = a;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AudioMix = void 0;
        const r = i(72), s = i(46), a = i(154);
        class o extends s.RTCEventEmitter {
          constructor(e2) {
            super(), this.pipeline = e2, this.context = e2.context;
            const t2 = new r.NeAudioNode("AudioMixingGain", this.context.createGain());
            this.node = t2, this.mixAudioConf = { audioFilePath: "", state: "MIX_UNSTART", buffer: null, cachedBuffers: {}, audioSource: null, gainFilter: t2, replace: false, loopback: false, cycle: 0, pauseTime: 0, startTime: 0, totalTime: 0, volume: 1, playStartTime: 0, setPlayStartTime: 0, auidoMixingEnd: null }, this.logger = e2.logger.getChild(() => "AudioMix " + this.mixAudioConf.state);
          }
          async startAudioMixing(e2) {
            if ((null == e2 ? void 0 : e2.audioFilePath) ? this.logger.log("即将开始伴音:", JSON.stringify(e2, null, " ")) : this.logger.error("startAudioMixing:未指定伴音文件"), Object.assign(this.mixAudioConf, e2), this.mixAudioConf.audioFilePath) {
              if (this.mixAudioConf.cachedBuffers[this.mixAudioConf.audioFilePath]) return this.mixAudioConf.buffer = this.mixAudioConf.cachedBuffers[this.mixAudioConf.audioFilePath], this.logger.log("即将从缓存播放伴音", this.mixAudioConf.audioFilePath), this.startMix();
              {
                this.logger.log("即将加载云端音乐", this.mixAudioConf.audioFilePath), this.mixAudioConf.state = "MIX_STARTING";
                const e3 = await this.loadAudioBuffer(this.mixAudioConf.audioFilePath);
                if ("MIX_STARTING" === this.mixAudioConf.state) return this.mixAudioConf.buffer = e3, this.startMix();
                this.logger.warn("startAudioMixing: 播放行为被覆盖");
              }
            }
          }
          stopAudioMixing(e2 = false) {
            return this.mixAudioConf.audioSource ? (this.logger.log("即将停止混音"), this.mixAudioConf.audioSource.audioNode.onended = null, this.mixAudioConf.audioSource.disconnect(this.mixAudioConf.gainFilter), this.mixAudioConf.audioSource.audioNode.stop(), this.mixAudioConf.audioSource = null) : this.logger.warn("stopAudioMixing:当前没有在混音"), this.mixAudioConf.startTime = 0, this.mixAudioConf.pauseTime = 0, this.mixAudioConf.playStartTime = 0, e2 && this.resetMixConf(), this.mixAudioConf.state = "MIX_STOPED", this.pipeline.updateConnection(), this.logger.log("混音已停止"), Promise.resolve();
          }
          pauseAudioMixing() {
            if (!this.mixAudioConf.audioSource) return void this.logger.error("pauseAudioMixing:参数不够");
            this.logger.log("暂停混音"), this.mixAudioConf.audioSource.audioNode.onended = null, this.mixAudioConf.audioSource.disconnect(this.mixAudioConf.gainFilter), this.mixAudioConf.audioSource.audioNode.stop(), this.mixAudioConf.audioSource.disconnectToAll(), this.mixAudioConf.audioSource = null, this.mixAudioConf.pauseTime = Date.now(), this.mixAudioConf.state = "MIX_PAUSED";
            let e2 = (this.mixAudioConf.pauseTime - this.mixAudioConf.startTime) / 1e3 + this.mixAudioConf.playStartTime;
            return this.logger.log("已经播放的时间: ", e2), e2 > this.mixAudioConf.totalTime && (e2 %= this.mixAudioConf.totalTime), this.logger.log("暂停位置:", e2), Promise.resolve();
          }
          resumeAudioMixing() {
            let e2, t2 = (this.mixAudioConf.pauseTime - this.mixAudioConf.startTime) / 1e3 + this.mixAudioConf.playStartTime;
            return t2 > this.mixAudioConf.totalTime && (this.logger.log("播放过的圈数 playedCycle: ", Math.floor(t2 / this.mixAudioConf.totalTime)), this.mixAudioConf.cycle = this.mixAudioConf.cycle - Math.floor(t2 / this.mixAudioConf.totalTime)), this.mixAudioConf.setPlayStartTime ? (this.logger.log("暂停期间，用户设置混音播放时间: ", this.mixAudioConf.setPlayStartTime), e2 = this.mixAudioConf.setPlayStartTime, this.mixAudioConf.setPlayStartTime = 0) : (this.logger.log("恢复混音:", this.mixAudioConf), this.logger.log("已经播放的时间: ", t2), t2 > this.mixAudioConf.totalTime && (t2 %= this.mixAudioConf.totalTime), e2 = t2), this.logger.log("回复重置的时间点：", e2), this.mixAudioConf.playStartTime = e2, this.startMix();
          }
          setAudioMixingVolume(e2) {
            if (e2 <= 255 && e2 >= 0) {
              const t2 = e2 / 255;
              this.logger.log(`setAudioMixingVolume ${this.mixAudioConf.gainFilter.audioNode.gain.value} => ${t2}`), this.mixAudioConf.gainFilter.audioNode.gain.value = e2 / 255, this.mixAudioConf.volume = this.mixAudioConf.gainFilter.audioNode.gain.value;
            } else this.logger.error("setAudioMixingVolume: volume不在0~255范围内：", e2);
          }
          getAudioMixingPlayedTime() {
            let e2 = Date.now();
            "MIX_PAUSED" == this.mixAudioConf.state && this.mixAudioConf.pauseTime && (this.logger.log("当前是暂停状态"), e2 = this.mixAudioConf.pauseTime);
            let t2 = (e2 - this.mixAudioConf.startTime) / 1e3 + this.mixAudioConf.playStartTime;
            return t2 > this.mixAudioConf.totalTime && (t2 %= this.mixAudioConf.totalTime), { playedTime: t2 };
          }
          getAudioMixingTotalTime() {
            return { totalTime: this.mixAudioConf.totalTime };
          }
          startMix() {
            if (this.logger.log("startMix: ", this.mixAudioConf), this.mixAudioConf.buffer) {
              if (this.mixAudioConf.audioSource && this.mixAudioConf.audioSource.disconnectToAll(), this.mixAudioConf.audioSource = new r.NeAudioNode("AudioMixBufferSource", this.pipeline.context.createBufferSource()), this.mixAudioConf.audioSource.audioNode.buffer = this.mixAudioConf.buffer, this.mixAudioConf.audioSource.connect(this.mixAudioConf.gainFilter), this.mixAudioConf.audioSource.audioNode.onended = (e2) => {
                this.audioEnd(e2);
              }, this.mixAudioConf.totalTime = this.mixAudioConf.buffer.duration, (this.mixAudioConf.playStartTime < 0 || this.mixAudioConf.playStartTime >= this.mixAudioConf.totalTime) && (this.mixAudioConf.playStartTime = 0), this.logger.log("设置音量:", this.mixAudioConf.volume), this.mixAudioConf.gainFilter.audioNode.gain.value = this.mixAudioConf.volume, this.mixAudioConf.loopback && this.mixAudioConf.cycle > 1) {
                this.mixAudioConf.audioSource.audioNode.loop = this.mixAudioConf.loopback;
                const e2 = this.mixAudioConf.cycle * this.mixAudioConf.totalTime - this.mixAudioConf.playStartTime;
                this.logger.log("循环播放: options.playStartTime: ", this.mixAudioConf.playStartTime), this.logger.log("循环播放: totalTime: ", e2), this.mixAudioConf.audioSource.audioNode.start(0, this.mixAudioConf.playStartTime, e2 - 1);
              } else this.mixAudioConf.loopback && 1 == this.mixAudioConf.cycle ? (this.mixAudioConf.audioSource.audioNode.loop = false, this.mixAudioConf.audioSource.audioNode.start(0, this.mixAudioConf.playStartTime)) : (this.logger.log("无限循环播放 loop: ", this.mixAudioConf.loopback), this.mixAudioConf.audioSource.audioNode.loop = this.mixAudioConf.loopback, this.mixAudioConf.audioSource.audioNode.start(0, this.mixAudioConf.playStartTime));
              return this.mixAudioConf.state = "MIX_PLAYING", this.mixAudioConf.startTime = Date.now(), this.pipeline.updateConnection(), Promise.resolve();
            }
            this.logger.error("startMix: 缺少 mixAudioConf.buffer");
          }
          audioEnd(e2) {
            return "MIX_PLAYING" !== this.mixAudioConf.state ? void this.logger.error("audioEnd:状态不对") : this.mixAudioConf.audioSource && this.mixAudioConf.audioSource.audioNode.loop && this.mixAudioConf.cycle <= 0 ? void this.logger.log("无限循环时，伴音播放完成event: ", e2) : (this.logger.log("伴音播放完成: ", this.mixAudioConf), this.mixAudioConf.audioSource && (this.mixAudioConf.audioSource.audioNode.onended = null), this.mixAudioConf.auidoMixingEnd && (this.mixAudioConf.auidoMixingEnd(e2), this.mixAudioConf.auidoMixingEnd = null), this.resetMixConf(), this.pipeline.updateConnection(), Promise.resolve());
          }
          async loadAudioBuffer(e2) {
            let t2, i2;
            this.mixAudioConf.cachedBuffers[e2] ? this.logger.warn(`loadAudioBuffer: 该文件已有缓存，长度：${this.mixAudioConf.cachedBuffers[e2].duration} 秒。即将更新该文件地址：${e2}`) : this.logger.warn("loadAudioBuffer: 开始加载文件。地址：" + e2);
            try {
              t2 = await a.ajax({ url: e2, type: "GET", dataType: "arraybuffer" });
            } catch (e3) {
              throw this.logger.error("loadAudioBuffer 加载云端音乐失败: ", e3), e3;
            }
            this.logger.log(`loadAudioBuffer 文件下载成功。大小：${Math.floor(t2.byteLength / 1024)} KB`);
            try {
              i2 = await this.pipeline.context.decodeAudioData(t2);
            } catch (e3) {
              throw this.logger.log("loadAudioBuffer 解码失败:", e3), e3;
            }
            return this.logger.log(`loadAudioBuffer 解码成功。长度：${i2.duration} 秒。`), this.mixAudioConf.cachedBuffers[e2] = i2, i2;
          }
          resetMixConf() {
            this.mixAudioConf.audioSource && (this.mixAudioConf.audioSource.disconnect(this.mixAudioConf.gainFilter), this.mixAudioConf.audioSource = null), this.mixAudioConf.audioFilePath = "", this.mixAudioConf.buffer = null, this.mixAudioConf.state = "MIX_UNSTART", this.mixAudioConf.replace = false, this.mixAudioConf.cycle = 0, this.mixAudioConf.pauseTime = 0, this.mixAudioConf.startTime = 0, this.mixAudioConf.totalTime = 0, this.mixAudioConf.volume = 1, this.mixAudioConf.playStartTime = 0, this.mixAudioConf.setPlayStartTime = 0, this.mixAudioConf.auidoMixingEnd = null, this.emit("audioFilePlaybackCompleted");
          }
        }
        t.AudioMix = o;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.createCanvasWatermarkControl = t.CanvasWatermarkControl = void 0;
        const s = r(i(196)), a = i(3), o = i(49), n = i(197);
        class d extends a.EventEmitter {
          constructor(e2) {
            super(), this.logger = e2, this.settings = { defaultStyle: { background: "rgba(128,128,128, 0.5)", overflow: "hidden", "white-space": "break-spaces", position: "absolute", wordBreak: "break-all", color: "white", fontSize: "10pt" } }, this.watermarks = [], this.div = null;
          }
          checkWatermarkParams(e2) {
            e2.textWatermarks && e2.textWatermarks.forEach((e3) => {
              const t2 = { tag: "Stream.setCanvasWatermarkConfigs:textWatermarks.fontSize", value: e3.fontSize, min: 1 };
              o.isExistOptions(t2).result && o.checkValidInteger(t2);
              const i2 = { tag: "Stream.setCanvasWatermarkConfigs:textWatermarks.fontColor", value: e3.fontColor, min: 0 };
              o.isExistOptions(i2).result && o.checkValidInteger(i2);
              const r2 = { tag: "Stream.setCanvasWatermarkConfigs:textWatermarks.wmWidth", value: e3.wmWidth, min: 0 };
              o.isExistOptions(r2).result && o.checkValidInteger(r2);
              const s2 = { tag: "Stream.setCanvasWatermarkConfigs:textWatermarks.wmHeight", value: e3.wmHeight, min: 0 };
              o.isExistOptions(s2).result && o.checkValidInteger(s2);
              const a2 = { tag: "Stream.setCanvasWatermarkConfigs:textWatermarks.offsetX", value: e3.offsetX };
              o.isExistOptions(a2).result && o.checkValidInteger(a2);
              const n2 = { tag: "Stream.setCanvasWatermarkConfigs:textWatermarks.offsetY", value: e3.offsetY };
              o.isExistOptions(n2).result && o.checkValidInteger(n2);
            }), e2.timestampWatermarks && [e2.timestampWatermarks].forEach((e3) => {
              const t2 = { tag: "Stream.setCanvasWatermarkConfigs:timestampWatermarks.fontSize", value: e3.fontSize, min: 1 };
              o.isExistOptions(t2).result && o.checkValidInteger(t2);
              const i2 = { tag: "Stream.setCanvasWatermarkConfigs:timestampWatermarks.fontColor", value: e3.fontColor, min: 0 };
              o.isExistOptions(i2).result && o.checkValidInteger(i2);
              const r2 = { tag: "Stream.setCanvasWatermarkConfigs:timestampWatermarks.wmWidth", value: e3.wmWidth, min: 0 };
              o.isExistOptions(r2).result && o.checkValidInteger(r2);
              const s2 = { tag: "Stream.setCanvasWatermarkConfigs:timestampWatermarks.wmHeight", value: e3.wmHeight, min: 0 };
              o.isExistOptions(s2).result && o.checkValidInteger(s2);
              const a2 = { tag: "Stream.setCanvasWatermarkConfigs:timestampWatermarks.offsetX", value: e3.offsetX };
              o.isExistOptions(a2).result && o.checkValidInteger(a2);
              const n2 = { tag: "Stream.setCanvasWatermarkConfigs:timestampWatermarks.offsetY", value: e3.offsetY };
              o.isExistOptions(n2).result && o.checkValidInteger(n2);
            }), e2.imageWatermarks && e2.imageWatermarks.forEach((e3) => {
              const t2 = { tag: "Stream.setCanvasWatermarkConfigs.imageWatermarks.wmWidth", value: e3.wmWidth, min: 0 };
              o.isExistOptions(t2).result && o.checkValidInteger(t2);
              const i2 = { tag: "Stream.setCanvasWatermarkConfigs:imageWatermarks.wmHeight", value: e3.wmHeight, min: 0 };
              o.isExistOptions(i2).result && o.checkValidInteger(i2);
              const r2 = { tag: "Stream.setCanvasWatermarkConfigs:imageWatermarks.offsetX", value: e3.offsetX };
              o.isExistOptions(r2).result && o.checkValidInteger(r2);
              const s2 = { tag: "Stream.setCanvasWatermarkConfigs:imageWatermarks.offsetY", value: e3.offsetY };
              o.isExistOptions(s2).result && o.checkValidInteger(s2);
              const a2 = { tag: "Stream.setCanvasWatermarkConfigs:imageWatermarks.imageUrls", value: e3.imageUrls };
              o.checkExists(a2);
              const n2 = { tag: "Stream.setCanvasWatermarkConfigs:imageWatermarks.imageUrls.length", value: e3.imageUrls.length, min: 1 };
              o.checkValidInteger(n2);
              const d2 = { tag: "Stream.setCanvasWatermarkConfigs:imageWatermarks.fps", value: e3.fps, min: 0 };
              o.isExistOptions(d2).result && o.checkValidFloat(d2);
            });
          }
          updateWatermarks(e2) {
            this.clear(), this.watermarks = [];
            const t2 = { text: 0, timestamp: 0, image: 0 };
            e2.imageWatermarks && e2.imageWatermarks.forEach((e3) => {
              const t3 = Object.assign({}, this.settings.defaultStyle, { background: "none" });
              let i2;
              "number" == typeof e3.offsetX ? t3.left = e3.offsetX + "px" : e3.offsetX && "string" == typeof e3.offsetX && (t3.left = e3.offsetX), "number" == typeof e3.offsetY ? t3.top = e3.offsetY + "px" : e3.offsetY && "string" == typeof e3.offsetY && (t3.top = e3.offsetY), 0 !== e3.wmWidth && 0 !== e3.wmHeight || (delete e3.wmWidth, delete e3.wmHeight), e3.wmWidth && ("number" == typeof e3.wmWidth ? t3.width = e3.wmWidth + "px" : "string" == typeof e3.wmWidth && (t3.width = e3.wmWidth)), e3.wmHeight && ("number" == typeof e3.wmHeight ? t3.height = e3.wmHeight + "px" : "string" == typeof e3.wmHeight && (t3.height = e3.wmHeight)), "number" == typeof e3.wmHeight ? t3.height = e3.wmHeight + "px" : e3.wmHeight && "string" == typeof e3.wmHeight && (t3.height = e3.wmHeight), i2 = e3.fps ? { type: "image", content: "", imageUrls: e3.imageUrls, loop: !(false === e3.loop), loopIndex: 0, interval: 1e3 / (e3.fps || 1), elem: null, style: t3 } : { type: "image", content: "", imageUrls: [e3.imageUrls[e3.imageUrls.length - 1]], loop: false, loopIndex: 0, interval: 0, elem: null, style: t3 }, this.watermarks.push(i2);
            }), e2.textWatermarks && e2.textWatermarks.forEach((e3) => {
              let i2 = e3.content || "";
              t2.text++;
              const r2 = Object.assign({}, this.settings.defaultStyle);
              "number" == typeof e3.fontColor ? r2.color = n.numberToRGBA(e3.fontColor) : e3.fontColor && "string" == typeof e3.fontColor && (r2.color = e3.fontColor), "number" == typeof e3.fontSize ? r2.fontSize = e3.fontSize + "pt" : e3.fontSize && "string" == typeof e3.fontSize && (r2.fontSize = e3.fontSize), "number" == typeof e3.offsetX ? r2.left = e3.offsetX + "px" : e3.offsetX && "string" == typeof e3.offsetX && (r2.left = e3.offsetX), "number" == typeof e3.offsetY ? r2.top = e3.offsetY + "px" : e3.offsetY && "string" == typeof e3.offsetY && (r2.top = e3.offsetY), !e3.wmWidth && !e3.wmHeight || 0 === e3.wmWidth || 0 === e3.wmHeight ? r2.background = "" : "number" == typeof e3.wmColor ? r2.background = n.numberToRGBA(e3.wmColor) : e3.wmColor && "string" == typeof e3.wmColor && (r2.background = e3.wmColor), e3.wmWidth, "number" == typeof e3.wmWidth ? e3.wmWidth > 0 && (r2.width = e3.wmWidth + "px") : "string" == typeof e3.wmWidth && (r2.width = e3.wmWidth), e3.wmHeight && ("number" == typeof e3.wmHeight ? (e3.wmHeight > 0 && (r2.wmHeight = e3.wmWidth + "px"), r2.height = e3.wmHeight + "px") : "string" == typeof e3.wmHeight && (r2.height = e3.wmHeight));
              const s2 = { type: "text", content: i2, loop: false, elem: null, loopIndex: 0, style: r2 };
              this.watermarks.push(s2);
            }), e2.timestampWatermarks && [e2.timestampWatermarks].forEach((e3) => {
              t2.timestamp++;
              const i2 = Object.assign({}, this.settings.defaultStyle);
              "number" == typeof e3.fontColor ? i2.color = n.numberToRGBA(e3.fontColor) : e3.fontColor && "string" == typeof e3.fontColor && (i2.color = e3.fontColor), "number" == typeof e3.fontSize ? i2.fontSize = e3.fontSize + "pt" : e3.fontSize && "string" == typeof e3.fontSize && (i2.fontSize = e3.fontSize), "number" == typeof e3.offsetX ? i2.left = e3.offsetX + "px" : e3.offsetX && "string" == typeof e3.offsetX && (i2.left = e3.offsetX), "number" == typeof e3.offsetY ? i2.top = e3.offsetY + "px" : e3.offsetY && "string" == typeof e3.offsetY && (i2.top = e3.offsetY), !e3.wmWidth && !e3.wmHeight || 0 === e3.wmWidth || 0 === e3.wmHeight ? i2.background = "" : "number" == typeof e3.wmColor ? i2.background = n.numberToRGBA(e3.wmColor) : e3.wmColor && "string" == typeof e3.wmColor && (i2.background = e3.wmColor), e3.wmWidth && ("number" == typeof e3.wmWidth ? i2.width = e3.wmWidth + "px" : "string" == typeof e3.wmWidth && (i2.width = e3.wmWidth)), e3.wmHeight && ("number" == typeof e3.wmHeight ? i2.height = e3.wmHeight + "px" : "string" == typeof e3.wmHeight && (i2.height = e3.wmHeight));
              const r2 = { type: "timestamp", content: "yyyy-mm-dd HH:MM:ss", loop: false, loopIndex: 0, elem: null, style: i2 };
              this.watermarks.push(r2);
            }), this.div && this.start(this.div);
          }
          start(e2) {
            this.clear(), this.div = e2, this.watermarks.forEach((t2) => {
              let i2;
              switch (t2.type) {
                case "text":
                  i2 = document.createElement("pre"), i2.className = "nim-watermark nim-watermark-text", i2.innerText = t2.content || "", Object.assign(i2.style, t2.style);
                  break;
                case "timestamp":
                  i2 = document.createElement("pre"), i2.className = "nim-watermark nim-watermark-timestamp", i2.innerText = "", Object.assign(i2.style, t2.style);
                  break;
                case "image":
                  !t2.imageUrls && t2.content && (t2.imageUrls = [t2.content]), i2 = document.createElement("div"), i2.className = "nim-watermark nim-watermark-image-container", t2.imgElems = [], t2.imageUrls && t2.imageUrls.length && t2.imageUrls.forEach((e4, r2) => {
                    const s2 = document.createElement("img");
                    s2.className = "nim-watermark nim-watermark-image nim-watermark-image-" + r2, s2.src = e4, s2.style.width = "100%", t2.style.height && (s2.style.height = "100%"), s2.style.overflow = "hidden", t2.imgElems && t2.imgElems.push(s2), i2.appendChild(s2), r2 > 0 && (s2.style.display = "none");
                  }), t2.loopIndex = -1;
                  const e3 = () => {
                    if (!t2.interval && t2.imgElems && t2.loopIndex >= 0) t2.imgElems[t2.loopIndex].style.display = "";
                    else {
                      if (t2.imgElems && t2.imgElems[t2.loopIndex] && (t2.imgElems[t2.loopIndex].style.display = "none"), t2.loopIndex++, t2.imgElems && t2.loopIndex >= t2.imgElems.length) {
                        if (!t2.loop) return void (t2.loopTimer && clearInterval(t2.loopTimer));
                        t2.loopIndex = 0;
                      }
                      t2.imgElems && (t2.imgElems[t2.loopIndex].style.display = "");
                    }
                  };
                  e3(), t2.interval && (t2.loopTimer = setInterval(e3, t2.interval)), Object.assign(i2.style, t2.style);
              }
              t2.elem = i2, e2.appendChild(t2.elem);
            });
          }
          clear() {
            this.div && this.watermarks.forEach((e2) => {
              e2.elem && (e2.elem.remove(), e2.elem = null), e2.loopTimer && clearTimeout(e2.loopTimer);
            });
          }
        }
        t.CanvasWatermarkControl = d;
        const c = new class {
          constructor() {
            this.controls = [], this.timer = setInterval(() => {
              this.updateTimestamps();
            }, 1e3);
          }
          updateTimestamps() {
            this.controls.forEach((e2) => {
              e2.watermarks.filter((e3) => "timestamp" === e3.type).forEach((e3) => {
                e3.elem && (e3.elem.innerText = s.default(/* @__PURE__ */ new Date(), e3.content || "yyyy-mm-dd HH:MM:ss"));
              });
            });
          }
        }();
        t.createCanvasWatermarkControl = function(e2) {
          const t2 = new d(e2);
          return c.controls.push(t2), t2;
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.createEncoderWatermarkControl = t.EncoderWatermarkControl = void 0;
        const s = r(i(196)), a = i(3), o = i(49), n = i(1), d = i(197);
        class c extends a.EventEmitter {
          constructor(e2) {
            super(), this.logger = e2, this.settings = { defaultStyle: { left: 0, top: 0, textWidth: 0, textHeight: 0, fontSize: "15pt", fontFamily: n.getParameters().encoderWatermarkFontFamily, fillStyle: "white", textBaseline: "hanging", bgWidth: -1, bgHeight: -1, bgFillStyle: "rgba(136, 136, 136, 0.5)" } }, this.watermarks = [], this.handler = { name: "watermark", enabled: false, func: this.handleFrame.bind(this) };
          }
          handleFrame(e2, t2, i2) {
            this.watermarks.forEach((e3) => {
              if ("text" === e3.type || "timestamp" === e3.type) {
                let t3 = "";
                t3 = "timestamp" === e3.type ? s.default(/* @__PURE__ */ new Date(), e3.content || "yyyy-mm-dd HH:MM:ss") : e3.content || "", i2.canvasCtx.font = `${e3.style.fontSize} ${e3.style.fontFamily}`, i2.canvasCtx.textBaseline = e3.style.textBaseline;
                e3.content;
                -1 === e3.style.bgWidth && -1 === e3.style.bgHeight && (e3.style.bgWidth = e3.style.textWidth, e3.style.bgHeight = e3.style.textHeight), e3.style.bgWidth && e3.style.bgHeight && (i2.canvasCtx.fillStyle = e3.style.bgFillStyle, i2.canvasCtx.fillRect(e3.style.left, e3.style.top, e3.style.bgWidth, e3.style.bgHeight)), i2.canvasCtx.fillStyle = e3.style.fillStyle, i2.canvasCtx.fillText(t3, e3.style.left, e3.style.top);
              }
              if ("image" === e3.type && e3.imgElems) {
                let t3 = void 0;
                if (e3.interval) {
                  if (e3.startMs && e3.interval) {
                    const i3 = Date.now() - e3.startMs, r2 = Math.floor(i3 / e3.interval);
                    for (let i4 = r2; i4 < r2 + e3.imgElems.length; i4++) {
                      const r3 = e3.imgElems[e3.loop ? i4 % e3.imgElems.length : i4];
                      if (r3 && r3.complete && r3.naturalWidth && r3.naturalHeight) {
                        t3 = r3;
                        break;
                      }
                    }
                  }
                } else e3.imgElems[0].complete && e3.imgElems[0].naturalWidth && e3.imgElems[0].naturalHeight && (t3 = e3.imgElems[0]);
                if (t3) {
                  let r2, s2;
                  e3.style.bgWidth > 0 && e3.style.bgHeight > 0 ? (r2 = e3.style.bgWidth, s2 = e3.style.bgHeight) : (r2 = t3.naturalWidth, s2 = t3.naturalHeight), i2.canvasCtx.drawImage(t3, e3.style.left, e3.style.top, r2, s2);
                }
              }
            });
          }
          checkWatermarkParams(e2) {
            var t2, i2;
            const r2 = { tag: "Stream.setEncoderWatermarkConfigs:watermarks.count", value: ((null === (t2 = e2.textWatermarks) || void 0 === t2 ? void 0 : t2.length) || 0) + (e2.timestampWatermarks ? 1 : 0) + ((null === (i2 = e2.imageWatermarks) || void 0 === i2 ? void 0 : i2.length) || 0), max: n.getParameters().encoderWatermarkLimit };
            o.checkValidInteger(r2), e2.textWatermarks && e2.textWatermarks.forEach((e3) => {
              const t3 = { tag: "Stream.setEncoderWatermarkConfigs:textWatermarks.fontSize", value: e3.fontSize, min: 1, max: 128 };
              o.isExistOptions(t3).result && o.checkValidInteger(t3);
              const i3 = { tag: "Stream.setEncoderWatermarkConfigs:textWatermarks.fontColor", value: e3.fontColor, min: 0, max: 4294967295 };
              o.isExistOptions(i3).result && o.checkValidInteger(i3);
              const r3 = { tag: "Stream.setEncoderWatermarkConfigs:textWatermarks.wmWidth", value: e3.wmWidth, min: 0 };
              o.isExistOptions(r3).result && o.checkValidInteger(r3);
              const s2 = { tag: "Stream.setEncoderWatermarkConfigs:textWatermarks.wmHeight", value: e3.wmHeight, min: 0 };
              o.isExistOptions(s2).result && o.checkValidInteger(s2);
              const a2 = { tag: "Stream.setEncoderWatermarkConfigs:textWatermarks.offsetX", value: e3.offsetX };
              o.isExistOptions(a2).result && o.checkValidInteger(a2);
              const n2 = { tag: "Stream.setEncoderWatermarkConfigs:textWatermarks.offsetY", value: e3.offsetY };
              o.isExistOptions(n2).result && o.checkValidInteger(n2);
            }), e2.timestampWatermarks && [e2.timestampWatermarks].forEach((e3) => {
              const t3 = { tag: "Stream.setEncoderWatermarkConfigs:timestampWatermarks.fontSize", value: e3.fontSize, min: 1, max: 128 };
              o.isExistOptions(t3).result && o.checkValidInteger(t3);
              const i3 = { tag: "Stream.setEncoderWatermarkConfigs:timestampWatermarks.fontColor", value: e3.fontColor, min: 0, max: 4294967295 };
              o.isExistOptions(i3).result && o.checkValidInteger(i3);
              const r3 = { tag: "Stream.setEncoderWatermarkConfigs:timestampWatermarks.wmWidth", value: e3.wmWidth, min: 0 };
              o.isExistOptions(r3).result && o.checkValidInteger(r3);
              const s2 = { tag: "Stream.setEncoderWatermarkConfigs:timestampWatermarks.wmHeight", value: e3.wmHeight, min: 0 };
              o.isExistOptions(s2).result && o.checkValidInteger(s2);
              const a2 = { tag: "Stream.setEncoderWatermarkConfigs:timestampWatermarks.offsetX", value: e3.offsetX };
              o.isExistOptions(a2).result && o.checkValidInteger(a2);
              const n2 = { tag: "Stream.setEncoderWatermarkConfigs:timestampWatermarks.offsetY", value: e3.offsetY };
              o.isExistOptions(n2).result && o.checkValidInteger(n2);
            }), e2.imageWatermarks && e2.imageWatermarks.forEach((e3) => {
              const t3 = { tag: "Stream.setEncoderWatermarkConfigs.imageWatermarks.wmWidth", value: e3.wmWidth, min: 0 };
              o.isExistOptions(t3).result && o.checkValidInteger(t3);
              const i3 = { tag: "Stream.setEncoderWatermarkConfigs:imageWatermarks.wmHeight", value: e3.wmHeight, min: 0 };
              o.isExistOptions(i3).result && o.checkValidInteger(i3);
              const r3 = { tag: "Stream.setEncoderWatermarkConfigs:imageWatermarks.offsetX", value: e3.offsetX };
              o.isExistOptions(r3).result && o.checkValidInteger(r3);
              const s2 = { tag: "Stream.setEncoderWatermarkConfigs:imageWatermarks.offsetY", value: e3.offsetY };
              o.isExistOptions(s2).result && o.checkValidInteger(s2);
              const a2 = { tag: "Stream.setEncoderWatermarkConfigs:imageWatermarks.imageUrls", value: e3.imageUrls };
              o.checkExists(a2);
              const n2 = { tag: "Stream.setEncoderWatermarkConfigs:imageWatermarks.imageUrls.length", value: e3.imageUrls.length, min: 1, max: 10 };
              o.checkValidInteger(n2);
              const d2 = { tag: "Stream.setEncoderWatermarkConfigs:imageWatermarks.fps", value: e3.fps, min: 0, max: 30 };
              o.isExistOptions(d2).result && o.checkValidFloat(d2);
            });
          }
          updateWatermarks(e2) {
            this.watermarks = [];
            const t2 = { text: 0, timestamp: 0, image: 0 };
            e2.imageWatermarks && e2.imageWatermarks.forEach((e3) => {
              const t3 = Object.assign({}, this.settings.defaultStyle, { background: "none" });
              let i2;
              if ("number" == typeof e3.offsetX ? t3.left = e3.offsetX : e3.offsetX, "number" == typeof e3.offsetY ? t3.top = e3.offsetY : e3.offsetY, 0 !== e3.wmWidth && 0 !== e3.wmHeight || (delete e3.wmWidth, delete e3.wmHeight), e3.wmWidth && "number" == typeof e3.wmWidth && (t3.bgWidth = e3.wmWidth), e3.wmHeight && "number" == typeof e3.wmHeight && (t3.bgHeight = e3.wmHeight), false !== e3.loop && (e3.loop = true), i2 = e3.fps ? { type: "image", content: "", imageUrls: e3.imageUrls, loop: !(false === e3.loop), loopIndex: 0, interval: 1e3 / (e3.fps || 1), style: t3 } : { type: "image", content: "", imageUrls: [e3.imageUrls[e3.imageUrls.length - 1]], loop: false, loopIndex: 0, interval: 0, style: t3 }, i2.startMs = Date.now(), i2.imgElems = [], i2.imageUrls) for (let e4 = 0; e4 < i2.imageUrls.length; e4++) {
                const t4 = new Image();
                t4.src = i2.imageUrls[e4], i2.imgElems.push(t4);
              }
              this.watermarks.push(i2);
            }), e2.textWatermarks && e2.textWatermarks.forEach((e3) => {
              let i2 = e3.content || "";
              t2.text++;
              const r2 = Object.assign({}, this.settings.defaultStyle);
              "number" == typeof e3.fontColor ? r2.fillStyle = d.numberToRGBA(e3.fontColor) : e3.fontColor && "string" == typeof e3.fontColor && (r2.fillStyle = e3.fontColor), "number" == typeof e3.fontSize ? r2.fontSize = e3.fontSize + "pt" : e3.fontSize && "string" == typeof e3.fontSize && (r2.fontSize = e3.fontSize);
              const s2 = d.measureText(e3.content, r2.fontSize, r2.fontFamily);
              r2.textWidth = s2.width, r2.textHeight = s2.height, e3.offsetX && (r2.left = e3.offsetX), e3.offsetY && (r2.top = e3.offsetY), e3.wmColor, e3.wmWidth >= 0 && (r2.bgWidth = e3.wmWidth), e3.wmHeight >= 0 && (r2.bgHeight = e3.wmHeight), "number" == typeof e3.wmColor ? r2.bgFillStyle = d.numberToRGBA(e3.wmColor) : e3.wmColor && "string" == typeof e3.wmColor && (r2.bgFillStyle = e3.wmColor);
              const a2 = { type: "text", content: i2, loop: false, loopIndex: 0, style: r2 };
              this.watermarks.push(a2);
            }), e2.timestampWatermarks && [e2.timestampWatermarks].forEach((e3) => {
              t2.timestamp++;
              const i2 = Object.assign({}, this.settings.defaultStyle);
              "number" == typeof e3.fontColor ? i2.fillStyle = d.numberToRGBA(e3.fontColor) : e3.fontColor && "string" == typeof e3.fontColor && (i2.fillStyle = e3.fontColor), "number" == typeof e3.fontSize ? i2.fontSize = e3.fontSize + "pt" : e3.fontSize && "string" == typeof e3.fontSize && (i2.fontSize = e3.fontSize);
              const r2 = d.measureText("yyyy-mm-dd HH:MM:ss", i2.fontSize, i2.fontFamily);
              i2.textWidth = r2.width, i2.textHeight = r2.height, e3.offsetX && (i2.left = e3.offsetX), e3.offsetY && (i2.top = e3.offsetY), e3.wmWidth >= 0 && (i2.bgWidth = e3.wmWidth), e3.wmHeight >= 0 && (i2.bgHeight = e3.wmHeight), "number" == typeof e3.wmColor ? i2.bgFillStyle = d.numberToRGBA(e3.wmColor) : e3.wmColor && "string" === e3.wmColor && (i2.bgFillStyle = e3.wmColor);
              const s2 = { type: "timestamp", content: "yyyy-mm-dd HH:MM:ss", loop: false, loopIndex: 0, style: i2 };
              this.watermarks.push(s2);
            });
          }
        }
        t.EncoderWatermarkControl = c, t.createEncoderWatermarkControl = function(e2) {
          return new c(e2);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = i(3), s = i(199);
        function a(e2) {
          let t2 = 0;
          const i2 = e2.toString().split(".")[1];
          return i2 && (t2 = i2.length), t2;
        }
        function o(e2, t2, i2, r2) {
          let s2 = false;
          return (isNaN(e2) || e2 < t2 || e2 > i2 || a(e2) > a(r2)) && (s2 = true), s2;
        }
        const n = { Pitch: { min: 0.5, max: 2, step: 0.1 }, EQ: { min: -15, max: 15, step: 1 }, Reverb: { wetGain: { min: 0, max: 1, step: 0.1 }, dryGain: { min: 0, max: 1, step: 0.1 }, damping: { min: 0, max: 1, step: 0.1 }, roomSize: { min: 0.1, max: 2, step: 0.1 }, decayTime: { min: 0, max: 20, step: 0.1 }, preDelay: { min: 0, max: 1, step: 0.1 } } };
        class d extends r.EventEmitter {
          constructor(e2, t2) {
            super(), this.audioWorkletAgent = null, this.node = null, this.key = "AIAudioEffects", this.enableAIDenoise = false, this.enableAudioEffect = false, this.stageAIProcessing = e2, this.logger = e2.logger.getChild(() => "AIAudioEffectsProcess"), this.context = t2;
          }
          async init() {
            if (!this.audioWorkletAgent) {
              this.audioWorkletAgent = new s.AudioWorkletAgent({ logger: this.logger, context: this.context, pluginType: this.key }), this.node = this.audioWorkletAgent.node;
              const e2 = this.stageAIProcessing.getPluginConfig(this.key);
              e2 ? await this.audioWorkletAgent.init(e2) : this.logger.error("pluginConfig is not found"), this.bindEvents();
            }
          }
          getAudioNode() {
            return this.node;
          }
          bindEvents() {
            var e2, t2, i2;
            null === (e2 = this.audioWorkletAgent) || void 0 === e2 || e2.on("effects-load", () => {
              this.emit("effects-load");
            }), null === (t2 = this.audioWorkletAgent) || void 0 === t2 || t2.on("error", (e3) => {
              this.emit("error", e3);
            }), null === (i2 = this.audioWorkletAgent) || void 0 === i2 || i2.on("plugin-process-unstable", (e3) => {
              this.emit("plugin-process-unstable", e3);
            });
          }
          setAudioEffect(e2, t2) {
            var i2;
            let r2 = false;
            switch (e2) {
              case 0:
                ("number" != typeof t2 || t2 < 0 || t2 > 8) && (r2 = true);
                break;
              case 1:
                ("number" != typeof t2 || t2 < 0 || t2 > 11) && (r2 = true);
                break;
              case "Pitch":
                r2 = o(t2, n.Pitch.min, n.Pitch.max, n.Pitch.step);
                break;
              case "EQ":
                if (Array.isArray(t2)) {
                  10 !== t2.length && (r2 = true);
                  for (let e3 = 0; e3 < t2.length; e3++) if (o(t2[e3], n.EQ.min, n.EQ.max, n.EQ.step)) {
                    r2 = true;
                    break;
                  }
                } else r2 = true;
                break;
              case "Reverb":
                if ("object" != typeof t2 || Array.isArray(t2)) r2 = true;
                else for (const e3 in t2) if (t2.hasOwnProperty(e3)) {
                  if (o(t2[e3], n.Reverb[e3].min, n.Reverb[e3].max, n.Reverb[e3].step)) {
                    r2 = true;
                    break;
                  }
                } else r2 = true;
                break;
              default:
                r2 = true;
            }
            r2 ? this.logger.error("setAudioEffect fail! outlimit:", e2, t2) : null === (i2 = this.audioWorkletAgent) || void 0 === i2 || i2.postMessage({ type: "effect", effect: { type: e2, value: t2 } });
          }
          setState(e2, t2) {
            this.logger.log(`setAIAudioEffects enable: ${e2}, ${t2}`), this.audioWorkletAgent ? (this.audioWorkletAgent.postMessage({ type: "setState", option: { type: e2, enable: t2 } }), "AIDenoise" === e2 ? this.enableAIDenoise = t2 : "AudioEffect" === e2 && (this.enableAudioEffect = t2)) : this.logger.error("audioWorkletAgent is not init");
          }
          getState(e2) {
            return "AIDenoise" === e2 ? this.enableAIDenoise : "AudioEffect" === e2 ? this.enableAudioEffect : void 0;
          }
          setAIVadEnable(e2 = { vad_enable: false, vad_noise_enable: false, noise_gate_enable: false }) {
            var t2;
            null === (t2 = this.audioWorkletAgent) || void 0 === t2 || t2.postMessage({ type: "AIVadEnable", option: Object.assign({}, e2) });
          }
          destroy() {
            var e2, t2;
            this.logger.log("destroy AIAudioEffectsProcess"), null === (e2 = this.audioWorkletAgent) || void 0 === e2 || e2.removeAllListeners(), null === (t2 = this.audioWorkletAgent) || void 0 === t2 || t2.destroy(), this.audioWorkletAgent = null, this.node = null;
          }
        }
        t.default = d;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = i(3), s = i(199);
        class a extends r.EventEmitter {
          constructor(e2, t2) {
            super(), this.audioWorkletAgent = null, this.node = null, this.key = "AIhowling", this.enableAIDenoise = false, this.enableAudioEffect = false, this.stageAIProcessing = e2, this.logger = e2.logger.getChild(() => "AIhowlingProcess"), this.context = t2;
          }
          async init() {
            if (!this.audioWorkletAgent) {
              this.audioWorkletAgent = new s.AudioWorkletAgent({ logger: this.logger, context: this.context, pluginType: this.key }), this.node = this.audioWorkletAgent.node;
              const e2 = this.stageAIProcessing.getPluginConfig(this.key);
              e2 ? await this.audioWorkletAgent.init(e2) : this.logger.error("pluginConfig is not found"), this.bindEvents();
            }
          }
          getAudioNode() {
            return this.node;
          }
          bindEvents() {
            var e2, t2;
            null === (e2 = this.audioWorkletAgent) || void 0 === e2 || e2.on("aihowling-load", () => {
              this.emit("aihowling-load");
            }), null === (t2 = this.audioWorkletAgent) || void 0 === t2 || t2.on("error", (e3) => {
              this.emit("error", e3);
            });
          }
          setHowlingCallback(e2) {
            var t2;
            null === (t2 = this.audioWorkletAgent) || void 0 === t2 || t2.setHowlingCallback(e2);
          }
          destroy() {
            var e2;
            this.logger.log("destroy AIhowlingProcess"), null === (e2 = this.audioWorkletAgent) || void 0 === e2 || e2.destroy(), this.audioWorkletAgent = null, this.node = null;
          }
        }
        t.default = a;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.parseBase64 = void 0;
        const r = i(296);
        let s;
        t.parseBase64 = function(e2) {
          var t2 = e2.length, i2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          if (!s) {
            s = [];
            for (var a = 0; a < i2.length; a++) s[i2.charCodeAt(a)] = a;
          }
          var o = i2.charAt(64);
          if (o) {
            var n = e2.indexOf(o);
            -1 !== n && (t2 = n);
          }
          return function(e3, t3, i3) {
            for (var s2 = [], a2 = 0, o2 = 0; o2 < t3; o2++) if (o2 % 4) {
              var n2 = i3[e3.charCodeAt(o2 - 1)] << o2 % 4 * 2, d = i3[e3.charCodeAt(o2)] >>> 6 - o2 % 4 * 2, c = n2 | d;
              s2[a2 >>> 2] |= c << 24 - a2 % 4 * 8, a2++;
            }
            return new r.WordArray(s2, a2);
          }(e2, t2, s);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.WordArray = t.Hex = void 0, t.Hex = { stringify(e2) {
          for (var t2 = e2.words, i2 = e2.sigBytes, r = [], s = 0; s < i2; s++) {
            var a = t2[s >>> 2] >>> 24 - s % 4 * 8 & 255;
            r.push((a >>> 4).toString(16)), r.push((15 & a).toString(16));
          }
          return r.join("");
        } };
        t.WordArray = class {
          constructor(e2, t2) {
            e2 = this.words = e2 || [], this.sigBytes = null != t2 ? t2 : 4 * e2.length;
          }
          toString(e2) {
            return (e2 || t.Hex).stringify(this);
          }
          concat(e2) {
            var t2 = this.words, i2 = e2.words, r = this.sigBytes, s = e2.sigBytes;
            if (this.clamp(), r % 4) for (var a = 0; a < s; a++) {
              var o = i2[a >>> 2] >>> 24 - a % 4 * 8 & 255;
              t2[r + a >>> 2] |= o << 24 - (r + a) % 4 * 8;
            }
            else for (var n = 0; n < s; n += 4) t2[r + n >>> 2] = i2[n >>> 2];
            return this.sigBytes += s, this;
          }
          clamp() {
            var e2 = this.words, t2 = this.sigBytes;
            e2[t2 >>> 2] &= 4294967295 << 32 - t2 % 4 * 8, e2.length = Math.ceil(t2 / 4);
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = i(298), s = i(300);
        t.Peer = r, t.WebSocketTransport = s;
      }, function(e, t, i) {
        "use strict";
        var r = o(i(73)), s = o(i(74)), a = i(28);
        function o(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var n = i(201), d = i(202), c = i(1).getParameters, l = new a.Logger({ tagGen: function() {
          return "Peer";
        } }), u = 0;
        e.exports = class extends n {
          constructor(e2) {
            super(l), l.debug("constructor()"), this._closed = false, this.id = u++, this._transport = e2, this._connected = false, this._data = { createTs: Date.now() }, this._sents = /* @__PURE__ */ new Map(), this._notificationId = 0, this._handleTransport();
          }
          get closed() {
            return this._closed;
          }
          get connected() {
            return this._connected;
          }
          get data() {
            return this._data;
          }
          set data(e2) {
            throw new Error("cannot override data object");
          }
          close() {
            if (!this._closed) {
              l.debug("close()"), this._closed = true, this._connected = false, this._notificationId = 0, this._transport.close(), this._transport = null;
              var e2 = true, t2 = false, i2 = void 0;
              try {
                for (var r2, s2 = this._sents.values()[Symbol.iterator](); !(e2 = (r2 = s2.next()).done); e2 = true) {
                  r2.value.close();
                }
              } catch (e3) {
                t2 = true, i2 = e3;
              } finally {
                try {
                  !e2 && s2.return && s2.return();
                } finally {
                  if (t2) throw i2;
                }
              }
              this._sents.clear();
            }
          }
          clear() {
            var e2 = true, t2 = false, i2 = void 0;
            try {
              for (var r2, s2 = this._sents.values()[Symbol.iterator](); !(e2 = (r2 = s2.next()).done); e2 = true) {
                r2.value.close();
              }
            } catch (e3) {
              t2 = true, i2 = e3;
            } finally {
              try {
                !e2 && s2.return && s2.return();
              } finally {
                if (t2) throw i2;
              }
            }
            this._sents.clear();
          }
          request(e2) {
            var t2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
            return (0, s.default)(r.default.mark(function s2() {
              var a2;
              return r.default.wrap(function(r2) {
                for (; ; ) switch (r2.prev = r2.next) {
                  case 0:
                    return a2 = d.createRequest(e2, i2), "Heartbeat" != e2 && t2._logger.debug("request() [method: " + e2 + ", id: " + a2.id + "]"), r2.next = 4, t2._transport.send(a2);
                  case 4:
                    return r2.abrupt("return", new Promise(function(e3, i3) {
                      var r3 = c().protooMessageTimeout, s3 = { id: a2.id, method: a2.method, startTs: Date.now(), resolve: function(i4) {
                        t2._sents.delete(a2.id) && (t2._closed || (clearTimeout(s3.timer), e3(i4)));
                      }, reject: function(e4) {
                        t2._sents.delete(a2.id) && (clearTimeout(s3.timer), i3(e4));
                      }, timer: setTimeout(function() {
                        t2._sents.delete(a2.id) && i3(new Error("request timeout"));
                      }, r3), close: function() {
                        var e4 = new Error();
                        e4.name = "peer closed", s3.method && (e4.message = "向edge的 " + s3.method + " 请求被取消：连接 #" + t2.id + " 已被关闭。连接建立时间：" + (t2._data.openTs - t2._data.createTs) + "ms, 请求时间：" + (Date.now() - s3.startTs) + "ms"), i3(e4);
                      } };
                      t2._sents.set(a2.id, s3);
                    }));
                  case 5:
                  case "end":
                    return r2.stop();
                }
              }, s2, t2);
            }))();
          }
          notify(e2) {
            var t2 = this, i2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0;
            return (0, s.default)(r.default.mark(function s2() {
              var a2;
              return r.default.wrap(function(r2) {
                for (; ; ) switch (r2.prev = r2.next) {
                  case 0:
                    return a2 = d.createNotification(e2, i2), t2._logger.debug("notify() [method:%s]", e2), r2.next = 4, t2._transport.send(a2);
                  case 4:
                  case "end":
                    return r2.stop();
                }
              }, s2, t2);
            }))();
          }
          _handleTransport() {
            var e2 = this;
            if (this._transport.closed) return this._closed = true, void setTimeout(function() {
              e2._closed || (e2._connected = false, e2.safeEmit("close"));
            });
            this._transport.on("open", function() {
              e2._closed || (l.debug('emit "open"'), e2._connected = true, e2._data.openTs = Date.now(), e2.safeEmit("open"));
            }), this._transport.on("disconnected", function() {
              e2._closed || (l.debug('emit "disconnected"'), e2._connected = false, e2.safeEmit("disconnected"));
            }), this._transport.on("failed", function(t2) {
              e2._closed || (l.debug('emit "failed" [currentAttempt:%s]', t2), e2._connected = false, e2.safeEmit("failed", t2));
            }), this._transport.on("close", function() {
              e2._closed || (e2._closed = true, l.debug('emit "close"'), e2._connected = false, e2.safeEmit("close"));
            }), this._transport.on("message", function(t2) {
              t2.request ? e2._handleRequest(t2) : t2.response ? e2._handleResponse(t2) : t2.notification && e2._handleNotification(t2);
            });
          }
          _handleRequest(e2) {
            var t2 = this;
            try {
              this.emit("request", e2, function(i3) {
                var r2 = d.createSuccessResponse(e2, i3);
                t2._transport.send(r2).catch(function() {
                });
              }, function(i3, r2) {
                i3 instanceof Error ? (i3 = 500, r2 = String(i3)) : "number" == typeof i3 && r2 instanceof Error && (r2 = String(r2));
                var s2 = d.createErrorResponse(e2, i3, r2);
                t2._transport.send(s2).catch(function() {
                });
              });
            } catch (t3) {
              var i2 = d.createErrorResponse(e2, 500, String(t3));
              this._transport.send(i2).catch(function() {
              });
            }
          }
          _handleResponse(e2) {
            var t2 = this._sents.get(e2.id);
            if (t2) if (e2.ok) t2.resolve(e2.data);
            else {
              var i2 = new Error(e2.errorReason);
              i2.code = e2.errorCode, t2.reject(i2);
            }
            else l.error("received response does not match any sent request", e2.id, JSON.stringify(e2));
          }
          _handleNotification(e2) {
            if (this._handleNotification > e2.id) l.warn("忽略重复的通知消息: ", JSON.stringify(e2, null, " "));
            else {
              this._notificationId = e2.id;
              var t2 = d.createSuccessResponse(e2, {});
              this._transport.send(t2).catch(function() {
              }), this.safeEmit("notification", e2);
            }
          }
        };
      }, function(e, t, i) {
        "use strict";
        t.generateRandomNumber = function() {
          return Math.round(1e7 * Math.random());
        };
      }, function(e, t, i) {
        "use strict";
        var r = o(i(73)), s = o(i(74)), a = i(28);
        function o(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        }
        var n = i(301), d = i(201), c = i(202), l = i(81).JSONBigStringify, u = i(1).getParameters, h = { retries: 10, factor: 2, minTimeout: 1e3, maxTimeout: 8e3 }, p = new a.Logger({ tagGen: function() {
          return "WebSocketTransport";
        } }), m = 0;
        e.exports = class extends d {
          constructor(e2, t2) {
            super(p), p.debug("constructor() [url:%s, options:%o]", e2, t2), this._closed = false, this._url = e2, this._options = t2 || {}, this._ws = null, this.wsid = 0, this.skipReconnection = false, this._runWebSocket();
          }
          get closed() {
            return this._closed;
          }
          close() {
            if (!this._closed) {
              p.debug("close()"), this._closed = true, this.safeEmit("close");
              try {
                this._ws.onopen = null, this._ws.onclose = null, this._ws.onerror = null, this._ws.onmessage = null, this._ws.close();
              } catch (e2) {
                p.error("close() | error closing the WebSocket: %o", e2);
              }
            }
          }
          send(e2) {
            var t2 = this;
            return (0, s.default)(r.default.mark(function i2() {
              return r.default.wrap(function(i3) {
                for (; ; ) switch (i3.prev = i3.next) {
                  case 0:
                    if (!t2._closed) {
                      i3.next = 2;
                      break;
                    }
                    throw new Error("transport closed");
                  case 2:
                    i3.prev = 2, t2._ws.send(l(e2)), i3.next = 10;
                    break;
                  case 6:
                    throw i3.prev = 6, i3.t0 = i3.catch(2), p.warn("send() failed:", i3.t0.name, i3.t0.message), i3.t0;
                  case 10:
                  case "end":
                    return i3.stop();
                }
              }, i2, t2, [[2, 6]]);
            }))();
          }
          _runWebSocket() {
            var e2 = this, t2 = n.operation(this._options.retry || h), i2 = false;
            t2.attempt(function(r2) {
              e2._closed ? t2.stop() : (p.debug("_runWebSocket() [currentAttempt:%s]", r2), e2._ws = new WebSocket(e2._url, ["protoo"]), m++, e2.wsid = m, e2._ws.onopen = function() {
                e2._closed || (i2 = true, e2.safeEmit("open"));
              }, e2._ws.onclose = function(s2) {
                if (!e2._closed) if (p.warn('WebSocket "close" event [wasClean:%s, code:%s, reason:"%s"]', s2.wasClean, s2.code, s2.reason), i2) {
                  if (t2.stop(), e2.safeEmit("disconnected"), e2._closed || e2.skipReconnection) return;
                  e2._runWebSocket();
                } else e2.safeEmit("failed", r2), e2._closed || t2.retry(true) || (e2._closed = true, e2.safeEmit("close"));
              }, e2._ws.onerror = function() {
                e2._closed || p.error('WebSocket "error" event');
              }, e2._ws.onmessage = function(t3) {
                if (!e2._closed) {
                  var i3 = c.parse(t3.data);
                  i3 && (0 !== e2.listenerCount("message") ? u().signalingMessageDelay ? setTimeout(function() {
                    e2._closed || e2.safeEmit("message", i3);
                  }, u().signalingMessageDelay) : e2.safeEmit("message", i3) : p.error('no listeners for WebSocket "message" event, ignoring received message'));
                }
              });
            });
          }
        };
      }, function(e, t, i) {
        e.exports = i(302);
      }, function(e, t, i) {
        var r = i(303);
        t.operation = function(e2) {
          var i2 = t.timeouts(e2);
          return new r(i2, { forever: e2 && e2.forever, unref: e2 && e2.unref, maxRetryTime: e2 && e2.maxRetryTime });
        }, t.timeouts = function(e2) {
          if (e2 instanceof Array) return [].concat(e2);
          var t2 = { retries: 10, factor: 2, minTimeout: 1e3, maxTimeout: 1 / 0, randomize: false };
          for (var i2 in e2) t2[i2] = e2[i2];
          if (t2.minTimeout > t2.maxTimeout) throw new Error("minTimeout is greater than maxTimeout");
          for (var r2 = [], s = 0; s < t2.retries; s++) r2.push(this.createTimeout(s, t2));
          return e2 && e2.forever && !r2.length && r2.push(this.createTimeout(s, t2)), r2.sort(function(e3, t3) {
            return e3 - t3;
          }), r2;
        }, t.createTimeout = function(e2, t2) {
          var i2 = t2.randomize ? Math.random() + 1 : 1, r2 = Math.round(i2 * t2.minTimeout * Math.pow(t2.factor, e2));
          return r2 = Math.min(r2, t2.maxTimeout);
        }, t.wrap = function(e2, i2, r2) {
          if (i2 instanceof Array && (r2 = i2, i2 = null), !r2) for (var s in r2 = [], e2) "function" == typeof e2[s] && r2.push(s);
          for (var a = 0; a < r2.length; a++) {
            var o = r2[a], n = e2[o];
            e2[o] = (function(r3) {
              var s2 = t.operation(i2), a2 = Array.prototype.slice.call(arguments, 1), o2 = a2.pop();
              a2.push(function(e3) {
                s2.retry(e3) || (e3 && (arguments[0] = s2.mainError()), o2.apply(this, arguments));
              }), s2.attempt(function() {
                r3.apply(e2, a2);
              });
            }).bind(e2, n), e2[o].options = i2;
          }
        };
      }, function(e, t) {
        function i(e2, t2) {
          "boolean" == typeof t2 && (t2 = { forever: t2 }), this._originalTimeouts = JSON.parse(JSON.stringify(e2)), this._timeouts = e2, this._options = t2 || {}, this._maxRetryTime = t2 && t2.maxRetryTime || 1 / 0, this._fn = null, this._errors = [], this._attempts = 1, this._operationTimeout = null, this._operationTimeoutCb = null, this._timeout = null, this._operationStart = null, this._options.forever && (this._cachedTimeouts = this._timeouts.slice(0));
        }
        e.exports = i, i.prototype.reset = function() {
          this._attempts = 1, this._timeouts = this._originalTimeouts;
        }, i.prototype.stop = function() {
          this._timeout && clearTimeout(this._timeout), this._timeouts = [], this._cachedTimeouts = null;
        }, i.prototype.retry = function(e2) {
          if (this._timeout && clearTimeout(this._timeout), !e2) return false;
          var t2 = (/* @__PURE__ */ new Date()).getTime();
          if (e2 && t2 - this._operationStart >= this._maxRetryTime) return this._errors.unshift(new Error("RetryOperation timeout occurred")), false;
          this._errors.push(e2);
          var i2 = this._timeouts.shift();
          if (void 0 === i2) {
            if (!this._cachedTimeouts) return false;
            this._errors.splice(this._errors.length - 1, this._errors.length), this._timeouts = this._cachedTimeouts.slice(0), i2 = this._timeouts.shift();
          }
          var r = this, s = setTimeout(function() {
            r._attempts++, r._operationTimeoutCb && (r._timeout = setTimeout(function() {
              r._operationTimeoutCb(r._attempts);
            }, r._operationTimeout), r._options.unref && r._timeout.unref()), r._fn(r._attempts);
          }, i2);
          return this._options.unref && s.unref(), true;
        }, i.prototype.attempt = function(e2, t2) {
          this._fn = e2, t2 && (t2.timeout && (this._operationTimeout = t2.timeout), t2.cb && (this._operationTimeoutCb = t2.cb));
          var i2 = this;
          this._operationTimeoutCb && (this._timeout = setTimeout(function() {
            i2._operationTimeoutCb();
          }, i2._operationTimeout)), this._operationStart = (/* @__PURE__ */ new Date()).getTime(), this._fn(this._attempts);
        }, i.prototype.try = function(e2) {
          console.log("Using RetryOperation.try() is deprecated"), this.attempt(e2);
        }, i.prototype.start = function(e2) {
          console.log("Using RetryOperation.start() is deprecated"), this.attempt(e2);
        }, i.prototype.start = i.prototype.try, i.prototype.errors = function() {
          return this._errors;
        }, i.prototype.attempts = function() {
          return this._attempts;
        }, i.prototype.mainError = function() {
          if (0 === this._errors.length) return null;
          for (var e2 = {}, t2 = null, i2 = 0, r = 0; r < this._errors.length; r++) {
            var s = this._errors[r], a = s.message, o = (e2[a] || 0) + 1;
            e2[a] = o, o >= i2 && (t2 = s, i2 = o);
          }
          return t2;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.peerLeaveReasonCode = void 0;
        t.peerLeaveReasonCode = { LEAVE_NORMAL: 0, LEAVE_FOR_FAIL_OVER: 1, LEAVE_FOR_KICK: 2, LEAVE_TIMEOUT: 3, LEAVE_FOR_RECONNECT: 4 };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.LBSManager = void 0;
        const s = i(26), a = i(154), o = r(i(6)), n = r(i(8)), d = i(42), c = i(1), l = i(81), u = i(204), h = i(26);
        var p;
        !function(e2) {
          e2[e2.UNKNOWN_ERROR = 99999] = "UNKNOWN_ERROR", e2[e2.TIMEOUT = 70100] = "TIMEOUT", e2[e2.JSON_ERROR = 70101] = "JSON_ERROR", e2[e2.FORMAT_ERROR = 70102] = "FORMAT_ERROR";
        }(p || (p = {}));
        let m = 0;
        t.LBSManager = class {
          constructor(e2) {
            this.lbsManagerId = m++, this.urlBackupMap = {}, this.requestCnt = 0, this.localStorageKey = "LBS_CONFIG", this.builtinConfig = u.geofenceArea.getBuiltinConfig(), this.updateTimer = null, this.lastUpdateStartAt = 0, this.lastUpdate = null, this.tagToMainDomain = {}, this.lbsState = "uninit", this.lbsStateWillChangeTimer = null, this.client = e2, this.logger = e2.logger.getChild(() => {
              let e3 = "LBSManager " + this.lbsState;
              return this.client.adapterRef.lbsManager.lbsManagerId !== this.lbsManagerId && (e3 += "DETACHED"), e3;
            }), window.addEventListener("online", () => {
              "DISCONNECTED" !== this.client.adapterRef.connectState.curState && this.client.adapterRef.lbsManager.lbsManagerId === this.lbsManagerId && Date.now() - this.lastUpdateStartAt > 3e3 && (this.logger.log("侦测到网络连接恢复，尝试更新LBS配置"), this.startUpdate("online"));
            });
          }
          async startUpdate(e2) {
            var t2, i2, r2, a2, o2, n2;
            if (c.getParameters().disableLBSService || c.getParameters().lbsUseBuiltinOnly) return;
            if (!this.client._params.appkey) return void this.logger.error("startUpdate() 无法更新域名配置: 缺少appkey");
            let d2 = s.lbsUrl;
            if (null === (r2 = null === (i2 = null === (t2 = this.client) || void 0 === t2 ? void 0 : t2._params) || void 0 === i2 ? void 0 : i2.neRtcServerAddresses) || void 0 === r2 ? void 0 : r2.channelServer) {
              if (!(null === (n2 = null === (o2 = null === (a2 = this.client) || void 0 === a2 ? void 0 : a2._params) || void 0 === o2 ? void 0 : o2.neRtcServerAddresses) || void 0 === n2 ? void 0 : n2.lbsServer)) return void this.logger.log("startUpdate() 忽略更新LBS配置请求, 当前为私有化配置");
              d2 = this.client._params.neRtcServerAddresses.lbsServer, this.logger.log("startUpdate() 私有化配置的 lbsServer: ", d2);
            }
            const l2 = Date.now(), u2 = l2 - this.lastUpdateStartAt;
            if (u2 < 3e3) return void this.logger.log(`startUpdate() 忽略更新请求 ${e2}: 上次更新于 ${u2} 毫秒前`);
            this.lastUpdateStartAt = l2, this.logger.log("startUpdate(): 开始更新LBS配置。原因：" + e2);
            let h2 = null;
            try {
              h2 = await this.ajax({ url: `${d2}?reason=${e2}&sdkVersion=${encodeURIComponent(s.SDK_VERSION)}&appKey=${encodeURIComponent(this.client._params.appkey)}&business=rtc&clientType=16`, type: "GET", header: {} });
            } catch (e3) {
              this.logger.error("startUpdate() LBS更新失败！", e3);
            }
            if (this.getReportField("lbs").forEach((e3) => {
              this.client.apiEventReport("setRequestLbs", e3);
            }), h2 && h2.nrtc && h2.call && h2.tracking) return h2.ttl && (this.updateTimer && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => {
              this.logger.log("startUpdate() LBS已到过期时间，正在回滚至内建设置"), this.loadBuiltinConfig("expire");
            }, 1e3 * h2.ttl)), this.lastUpdate = { activeFrom: Date.now(), res: h2 }, this.handleLbsStateWillChange(e2), this.addUrlBackup(this.tagToMainDomain.nrtc, h2.nrtc, "nrtc", "lbs"), this.addUrlBackup(this.tagToMainDomain.call, h2.call, "call", "lbs"), this.addUrlBackup(this.tagToMainDomain.tracking, h2.tracking, "tracking", "lbs"), this.lbsState = "remote", this.logger.log(`startUpdate() 成功加载远端配置。过期时间：${h2.ttl}秒后。preloadTimeSec:${h2.preloadTimeSec}：`), this.client.safeEmit("@lbs-config-update", { reason: e2 }), this.saveConfig(h2), h2;
            this.logger.error("startUpdate() startUpdate更新失败: 无效的 LBS 返回 ", h2);
          }
          async loadBuiltinConfig(e2) {
            if (!c.getParameters().disableLBSService) {
              this.builtinConfig = u.geofenceArea.getBuiltinConfig(), "uninit" !== this.lbsState && this.handleLbsStateWillChange(e2);
              for (let e3 in this.builtinConfig) if (this.builtinConfig[e3].length) {
                const t2 = h.TAGS_TO_MAIN_DOMAIN[e3] || this.builtinConfig[e3][0];
                this.addUrlBackup(t2, this.builtinConfig[e3], e3, "builtin"), this.tagToMainDomain[e3] = t2;
              }
              this.lbsState = "builtin", this.client.safeEmit("@lbs-config-update", { reason: e2 }), "oninit" !== e2 && this.logger.log(`成功加载内建配置 ${e2}。`);
            }
          }
          handleLbsStateWillChange(e2) {
            this.lbsStateWillChangeTimer && clearTimeout(this.lbsStateWillChangeTimer);
            const t2 = { lbsState: this.lbsState, settings: this.getSettings() };
            this.lbsStateWillChangeTimer = setTimeout(() => {
              const i2 = { lbsState: this.lbsState, settings: this.getSettings() };
              "DISCONNECTED" !== this.client.adapterRef.connectState.curState && this.client.apiFrequencyControl({ name: "_lbsStateChange", code: 0, param: { reason: e2, before: t2, after: i2 } });
            }, 0);
          }
          getSettings() {
            const e2 = Object.keys(this.urlBackupMap), t2 = {};
            return e2.forEach((e3) => {
              t2[e3] = this.urlBackupMap[e3].map((e4) => {
                const t3 = e4.lastRequest ? { status: e4.lastRequest.status, rtt: e4.lastRequest.rtt } : void 0;
                return { domain: e4.domain, successCount: e4.successCount, failCount: e4.failCount, lastResult: t3 };
              });
            }), t2;
          }
          getReportField(e2) {
            const t2 = [];
            for (let i3 in this.urlBackupMap) for (let r3 = 0; r3 < this.urlBackupMap[i3].length; r3++) {
              const s2 = this.urlBackupMap[i3][r3];
              s2.tag === e2 && t2.push(s2);
            }
            let i2 = [], r2 = 0;
            return t2.forEach((t3) => {
              if (t3.lastRequest && "inprogress" !== t3.lastRequest.status) {
                if (t3.lastRequest.requestId > r2 && (r2 = t3.lastRequest.requestId, i2 = []), t3.lastRequest.requestId !== r2) return;
                "lbs" === e2 ? i2.push({ app_key: this.client._params.appkey, request_id: t3.lastRequest.uuid, err_code: t3.lastRequest.errCode, err_msg: t3.lastRequest.errMsg, rtt: t3.lastRequest.rtt, time: t3.lastRequest.finishiedAt }) : "nrtc" === e2 ? i2.push({ domain: t3.domain, type: 1, code: "success" === t3.lastRequest.status ? 0 : 1 }) : "call" === e2 ? i2.push({ domain: t3.domain, type: 1, code: "success" === t3.lastRequest.status ? 0 : 1, status: t3.lastRequest.status, lbsFrom: this.lbsState, rtt: t3.lastRequest.rtt }) : i2.push({ domain: t3.domain, requestId: t3.lastRequest.uuid, addr: "", type: 1, code: "success" === t3.lastRequest.status ? 0 : 1, status: t3.lastRequest.status, lbsFrom: this.lbsState, rtt: t3.lastRequest.rtt });
              }
            }), i2;
          }
          saveConfig(e2) {
            if (!this.client._params.appkey) return void this.logger.error("saveConfig: 缺少appkey");
            const t2 = { ts: Date.now(), appKey: this.client._params.appkey, sdkVersion: s.SDK_VERSION, sdkBuild: s.BUILD, areaCode: u.geofenceArea.areaCode, config: e2 };
            try {
              localStorage.setItem(this.localStorageKey, l.JSONBigStringify(t2));
            } catch (e3) {
              this.logger.error("saveConfig：无法存储LBS设置", e3.name, e3.message);
            }
          }
          loadLocalConfig(e2) {
            var t2, i2;
            if (!this.client._params.appkey) return this.logger.error("loadLocalConfig: 缺少appkey"), { reason: "appkeyNotFound", config: null };
            if (null === (i2 = null === (t2 = this.client._params) || void 0 === t2 ? void 0 : t2.neRtcServerAddresses) || void 0 === i2 ? void 0 : i2.channelServer) return this.logger.log("忽略 loadLocalConfig 请求：当前为私有化配置"), { reason: "privilization", config: null };
            let r2 = null;
            try {
              const e3 = window.localStorage.getItem(this.localStorageKey);
              if (!e3) return this.logger.log("本地未发现LBS配置"), { reason: "configNotFound", config: null };
              r2 = l.JSONBigParse(e3);
            } catch (e3) {
              this.logger.error("无法读取本地配置：", e3.name, e3.message);
            }
            if (!r2) return { reason: "configError", config: null };
            const a2 = Date.now(), o2 = r2.ts + 1e3 * r2.config.ttl - a2;
            return o2 < 0 ? (this.logger.log(`LBS不使用本地配置：ttl已过期${Math.floor(-o2 / 1e3)} 秒。`), { reason: "expire", config: null }) : r2.sdkVersion !== s.SDK_VERSION || r2.sdkBuild !== s.BUILD ? (this.logger.warn(`LBS不使用本地配置：版本不匹配。${r2.sdkVersion}/${r2.sdkBuild} ${s.SDK_VERSION}/${s.BUILD}。`), { reason: "version", config: null }) : r2.appKey !== this.client._params.appkey ? (this.logger.warn(`LBS不使用本地配置：appKey不匹配。${r2.appKey} ${this.client._params.appkey}。`), { reason: "appkey", config: null }) : r2.areaCode !== u.geofenceArea.areaCode ? (this.logger.warn(`LBS不使用本地配置：areaCode不匹配。${r2.areaCode} ${u.geofenceArea.areaCode}。`), { reason: "areaCode", config: null }) : (this.lastUpdate = { activeFrom: r2.ts, res: r2.config }, this.handleLbsStateWillChange(e2), this.addUrlBackup(this.tagToMainDomain.call, r2.config.call, "call", "localstorage"), this.addUrlBackup(this.tagToMainDomain.nrtc, r2.config.nrtc, "nrtc", "localstorage"), this.addUrlBackup(this.tagToMainDomain.tracking, r2.config.tracking, "tracking", "localstorage"), this.lbsState = "local", this.logger.log(`成功加载本地配置。过期时间：${Math.floor(o2 / 1e3)} 秒后。`), this.client.safeEmit("@lbs-config-update", { reason: e2 }), { reason: "success", config: r2 });
          }
          addUrlBackup(e2, t2, i2, r2) {
            const s2 = this.urlBackupMap[e2] || [];
            this.urlBackupMap[e2] = [];
            const a2 = this.urlBackupMap[e2], o2 = Date.now();
            t2.forEach((t3) => {
              let n2 = s2.find((i3) => i3.domain === t3 && i3.mainDomain === e2);
              n2 ? (n2.updatedAt = o2, n2.tag = i2, n2.source = r2) : n2 = { id: a2.length, domain: t3, mainDomain: e2, successCount: 0, failCount: 0, updatedAt: o2, tag: i2, source: r2 }, a2.push(n2);
            });
          }
          getURLSettings(e2) {
            const t2 = /(\/\/)([^\/]+)(\/)/, i2 = e2.match(t2);
            let r2 = "";
            r2 = i2 ? i2[2] : e2, this.urlBackupMap[r2] || this.addUrlBackup(r2, [r2], "extra", "extra");
            const s2 = this.requestCnt++;
            return this.urlBackupMap[r2].map((i3, r3) => {
              const a2 = e2.replace(t2, `$1${i3.domain}$3`);
              return { seqId: `${s2}_${r3}`, state: "uninit", requestId: s2, url: a2, item: i3 };
            });
          }
          markSuccess(e2, t2) {
            var i2;
            "inprogress" === (null == t2 ? void 0 : t2.status) && (t2.finishiedAt = Date.now(), t2.rtt = t2.finishiedAt - t2.startAt, t2.status = "success", this.logger.debug(`markFinish success seqId:${e2.seqId} source:${e2.item.source} rtt:${t2.rtt}ms url:${e2.url}`)), e2.item.successCount++, e2.state = "success";
            const r2 = this.urlBackupMap[e2.item.mainDomain];
            if (r2 && "fail" === (null === (i2 = r2[0].lastRequest) || void 0 === i2 ? void 0 : i2.status)) {
              const t3 = r2.findIndex((t4) => t4 === e2.item);
              t3 > -1 && (this.logger.warn(`主备域名互换。${r2[0].domain} => ${e2.item.domain}`), this.handleLbsStateWillChange("domainDown:" + r2[0].domain), r2.splice(t3, 1), r2.unshift(e2.item));
            }
          }
          markFail(e2, t2, i2, r2) {
            "inprogress" === (null == t2 ? void 0 : t2.status) && (t2.finishiedAt = Date.now(), t2.rtt = t2.finishiedAt - t2.startAt, t2.status = "fail", t2.errCode = i2, t2.errMsg = r2, this.logger.debug(`markFinish fail seqId:${e2.seqId} source:${e2.item.source} rtt:${t2.rtt}ms url:${e2.url}`, i2, r2)), e2.item.failCount++, e2.state = "fail", this.logger.error("markFail：", e2.item.domain, i2, r2);
          }
          isAllRequestsFinished(e2) {
            for (let t2 in e2) {
              const i2 = e2[t2];
              if ("uninit" === i2.state || "sent" === i2.state) return false;
            }
            return true;
          }
          ajax(e2) {
            if (c.getParameters().disableLBSService) return a.ajax(e2);
            const t2 = this.getURLSettings(e2.url);
            let i2 = false;
            return new Promise((r2, s2) => {
              let u2 = 0, h2 = 0;
              const m2 = (a2, d2, c2) => {
                var m3, f2, v2, S, y, _, R;
                if (h2 = Date.now() - u2, e2.url.indexOf("getChannelInfos.action") > -1 && (this.client.adapterRef.state.getChannelInfoRtt = h2), a2.status >= 400) {
                  if (this.markFail(c2, d2, a2.status, "string" == typeof a2.response ? a2.response : l.JSONBigStringify(a2.response)), t2[1] && t2[1].fire && t2[1].timer) this.logger.warn(`主线路请求发生错误，启用备用线路 【主  ${c2.url} 】【备 ${t2[1].url} 】`, a2.status), t2[1].fire();
                  else if (this.isAllRequestsFinished(t2)) return s2(new n.default({ code: o.default.LBS_REQUEST_ERROR, message: "LBS: 网络请求错误" }));
                } else if ("json" !== a2.responseType || a2.response) if (500 === (null === (m3 = a2.response) || void 0 === m3 ? void 0 : m3.code)) {
                  if (this.markFail(c2, d2, p.UNKNOWN_ERROR, l.JSONBigStringify(a2.response)), t2[1] && t2[1].fire && t2[1].timer) this.logger.warn(`主线路请求发生错误，启用备用线路 【主  ${c2.url} 】【备 ${t2[1].url} 】`, a2.response), t2[1].fire();
                  else if (this.isAllRequestsFinished(t2)) {
                    var b = a2.response;
                    r2(b);
                  }
                } else if ("lbs" !== c2.item.tag || (null === (v2 = null === (f2 = a2.response) || void 0 === f2 ? void 0 : f2.call) || void 0 === v2 ? void 0 : v2.length) && (null === (y = null === (S = a2.response) || void 0 === S ? void 0 : S.nrtc) || void 0 === y ? void 0 : y.length) && (null === (R = null === (_ = a2.response) || void 0 === _ ? void 0 : _.tracking) || void 0 === R ? void 0 : R.length)) {
                  if (this.markSuccess(c2, d2), t2.forEach((e3) => {
                    e3.timer && (clearTimeout(e3.timer), e3.timer = void 0), e3.fire = void 0;
                  }), i2) return void this.logger.log(`${c2.url} 已忽略返回值：${a2.status}`);
                  g(a2);
                  b = a2.response;
                  r2(b);
                } else {
                  if (this.markFail(c2, d2, p.FORMAT_ERROR, l.JSONBigStringify(a2.response)), !(t2[1] && t2[1].fire && t2[1].timer)) return r2(a2.response);
                  this.logger.warn(`主线路请求发生错误，启用备用线路 【主  ${c2.url} 】【备 ${t2[1].url} 】`, "FORMAT_ERROR"), t2[1].fire();
                }
                else if (this.markFail(c2, d2, p.JSON_ERROR, "JSON_ERROR"), t2[1] && t2[1].fire && t2[1].timer) this.logger.warn(`主线路请求发生错误，启用备用线路 【主  ${c2.url} 】【备 ${t2[1].url} 】`, a2), t2[1].fire();
                else if (this.isAllRequestsFinished(t2)) return s2(new n.default({ code: o.default.LBS_JSON_ERROR, message: "LBS: 结果json解析错误" }));
              }, g = (e3) => {
                i2 = true, e3.onload = null, e3.onerror = null, e3.ontimeout = null;
              }, f = (e3, i3, r3, a2) => {
                if (this.markFail(r3, i3, p.UNKNOWN_ERROR, `${a2.type || l.JSONBigStringify(a2)}:${r3.url}`), t2[1] && t2[1].fire && t2[1].timer) this.logger.warn(`主线路请求发生错误，启用备用线路 【主  ${r3.url} 】【备 ${t2[1].url} 】`, a2), t2[1].fire();
                else if (this.isAllRequestsFinished(t2)) return g(e3), s2(new n.default({ code: o.default.LBS_REQUEST_ERROR, message: "LBS: 主线路请求发生错误(onerror)" }));
              }, v = (e3, i3, r3, a2) => {
                if (this.markFail(r3, i3, p.TIMEOUT, "TIMEOUT"), t2[1] && t2[1].fire && t2[1].timer) this.logger.warn(`主线路请求超时，启用备用线路 【主 ${r3.url}】【备 ${t2[1].url}】`, a2), t2[1].fire();
                else if (this.isAllRequestsFinished(t2)) return g(e3), s2(new n.default({ code: o.default.LBS_REQUEST_ERROR, message: "LBS: 主线路请求发生错误(ontimeout)" }));
              };
              t2.forEach((i3, r3) => {
                i3.fire = () => {
                  i3.fire = void 0, i3.timer && (clearTimeout(i3.timer), i3.timer = void 0), i3.state = "sent";
                  const t3 = { status: "inprogress", startAt: Date.now(), requestId: i3.requestId, seqId: i3.seqId, uuid: "", finishiedAt: 0, errCode: 0, errMsg: "", rtt: -1 };
                  i3.item.lastRequest = t3, ((t4, i4) => {
                    const r4 = new XMLHttpRequest();
                    t4.xhr = r4, r4.open(e2.type || "GET", i4.url, true), r4.responseType = e2.dataType || "json";
                    const s3 = e2.contentType || "application/json;charset=UTF-8";
                    if (r4.setRequestHeader("Content-Type", s3), e2.header && Object.keys(e2.header).map((t5) => {
                      e2.header && e2.header[t5] && r4.setRequestHeader(t5, e2.header[t5]);
                    }), "lbs" === i4.item.tag) {
                      const e3 = d.generateUUID();
                      i4.item.lastRequest && (i4.item.lastRequest.uuid = e3), r4.setRequestHeader("X-Request-Id", e3);
                    }
                    r4.onload = m2.bind(r4, r4, t4, i4), r4.onerror = f.bind(r4, r4, t4, i4), r4.ontimeout = v.bind(r4, r4, t4, i4), u2 = Date.now(), s3.indexOf("x-www-form-urlencoded") >= 0 ? e2.data ? r4.send(a.getFormData(e2.data)) : r4.send() : e2.data ? r4.send(l.JSONBigStringify(e2.data)) : r4.send();
                  })(t3, i3), r3 && (i3.timer = setTimeout(() => (i3.timer && (clearTimeout(i3.timer), i3.timer = void 0), s2(new n.default({ code: o.default.LBS_REQUEST_ERROR, message: "LBS: 网络请求错误(无响应)" }))), c.getParameters().fireBackupDelay * r3));
                }, r3 && (i3.timer = setTimeout(() => {
                  i3.fire && (t2[0].state = "fail", this.logger.warn("主线路请求超时，发起备用线路请求：" + i3.url), i3.fire());
                }, c.getParameters().fireBackupDelay * r3));
              }), t2[0].fire && t2[0].fire();
            });
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.SignalProbeManager = void 0;
        const r = i(90), s = i(1);
        t.SignalProbeManager = class {
          constructor(e2) {
            this.worker = null, this.signalStates = {}, this.online = "unknown", this.serverActiveWaiters = [], this.adapterRef = e2, this.logger = this.adapterRef.instance.logger.getChild(() => "SignalProbe online:" + this.online);
          }
          start(e2) {
            this.signalStates = {}, this.online = "unknown", e2.forEach((e3, t2) => {
              this.signalStates[e3] = { index: t2, wsUrl: e3, active: false, connect: { startCnt: 0, successCnt: 0, failCnt: 0, failCntFromLastSuccess: 0, initAt: -1, connectAt: -1 }, ping: { sendIndex: 0, recvIndex: 0, lastSentAt: -1, lastSentMsg: "", rtt: -1 } };
            }), this.logger.log("start", this.signalStates), this.worker && this.worker.terminate();
            try {
              const e3 = r.getBlobUrl("signalProbeWorker"), t2 = new Worker(e3);
              this.worker = t2, t2.onmessage = (e4) => {
                this.processWorkerMessage(e4);
              };
            } catch (e3) {
              this.logger.warn("Failed to start SignalProbeManager:", e3.name, e3.message);
            }
          }
          stop() {
            var e2;
            null === (e2 = this.worker) || void 0 === e2 || e2.terminate(), this.worker = null, this.signalStates = {}, this.online = "unknown";
          }
          getServerState(e2) {
            return this.signalStates[e2] || null;
          }
          getActiveServerCount() {
            let e2 = 0, t2 = 0, i2 = 0;
            for (let r2 in this.signalStates) t2++, this.signalStates[r2].ping.rtt > 0 ? e2++ : i2++;
            return 0 === e2 && (i2 = -1), { cnt: e2, total: t2, code: i2 };
          }
          waitForServerActive(e2 = 1e4) {
            return new Promise((t2) => {
              const i2 = { res: t2, resolved: false, timer: setTimeout(() => {
                i2.resolved || (i2.resolved = true, this.clearWaiters(), t2("timeout"));
              }, e2) };
              this.serverActiveWaiters.push(i2);
            });
          }
          processWorkerMessage(e2) {
            if (!this.worker || !e2.data) return;
            const t2 = e2.data;
            switch (t2.cmd) {
              case "ohayo":
                try {
                  const e3 = JSON.parse(JSON.stringify(this.signalStates)), t3 = { cmd: "init", data: { signalStates: e3, pingInterval: 2e3, reconnectionInterval: 1e4, maxRtt: s.getParameters().joinFirstTimeout + 4e3, wsTimeout: s.getParameters().joinFirstTimeout + 8e3 } };
                  this.worker.postMessage(t3);
                } catch (e3) {
                  this.logger.warn("无法启动通道探测：", e3);
                }
                break;
              case "sync":
                this.processCmdSync(t2.data);
                break;
              case "log":
                this.logger.log(t2.data);
                break;
              case "error":
                this.logger.error(t2.data);
                break;
              default:
                this.logger.error("msg", t2);
            }
          }
          clearWaiters() {
            this.serverActiveWaiters = this.serverActiveWaiters.filter((e2) => !e2.resolved);
          }
          processCmdSync(e2) {
            const t2 = this.signalStates;
            this.signalStates = e2;
            let i2 = false;
            for (let r2 in t2) {
              const s2 = t2[r2], a = e2[r2];
              s2 && a ? s2.active && !a.active ? (i2 = true, "no" !== this.online && 0 === this.getActiveServerCount().cnt && (this.online = "no", this.logger.error("所有服务端的ping均在下线状态，请检查网络")), this.logger.warn("[sync]Turns into inactive: " + a.wsUrl, a)) : !s2.active && a.active && (i2 = true, 1 === this.getActiveServerCount().cnt && "unknown" !== this.online && this.logger.warn("已有服务端上线，网络恢复"), this.online = "yes", this.logger.log(`[sync]Turns into active. RTT: ${a.ping.rtt}ms. ${a.wsUrl}`)) : this.logger.warn("[sync]Unrecognized signal", r2, s2, a);
            }
            if (i2) {
              const e3 = { name: "onPingStateChange", code: this.getActiveServerCount().code, param: { online: this.online } };
              for (let t3 in this.signalStates) {
                const i3 = this.signalStates[t3];
                i3 && (e3.param[t3] = { active: i3.active, rtt: i3.ping.rtt, successCnt: i3.connect.successCnt, failCnt: i3.connect.failCnt });
              }
              this.adapterRef.instance.apiFrequencyControl(e3);
            }
            this.serverActiveWaiters.length && this.getActiveServerCount().cnt > 0 && this.serverActiveWaiters.forEach((e3) => {
              e3.resolved || (e3.resolved = true, this.clearWaiters(), clearTimeout(e3.timer), e3.res("active"));
            });
          }
        };
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.AudioMixer = void 0;
        const s = i(143), a = i(1), o = i(46), n = r(i(8)), d = r(i(6));
        class c extends o.RTCEventEmitter {
          constructor(e2) {
            super(), this.context = null, this.sources = [], this.audioDom = null, this.decodeAudioDom = null, this.streamDestination = null, this.supports = { WebAudio: false, MediaStream: false }, this.sinkId = null, this.adapterRef = e2, this.logger = e2.logger.getChild(() => "AudioMixer"), this.supports = s.RtcSupport.checkWebAudio();
          }
          initWebAudio() {
            try {
              this.context = new window.AudioContext(), this.streamDestination = this.context.createMediaStreamDestination(), this._bindAudioContextEvent(), this.logger.log("WebAudio: initWebAudio success");
            } catch (e2) {
              this.context = null, this.logger.error("WebAudio: initWebAudio failed", e2);
            }
          }
          addStream(e2) {
            return new Promise(async (t2, i2) => {
              if (!this.context || !this.streamDestination) return void t2(void 0);
              if (-1 !== this.sources.findIndex((t3) => t3.sourceNode.mediaStream === e2)) return this.logger.log(`WebAudio: addMs: ${e2.id} 已存在, 不重复添加`), void t2(void 0);
              const r2 = this.context.createMediaStreamSource(e2), s2 = this.context.createGain();
              if (r2.connect(s2), s2.connect(this.streamDestination), this.sources.push({ sourceNode: r2, gainNode: s2 }), this.logger.log(`WebAudio: addMs: 添加 ${e2.id} 成功`), !this.decodeAudioDom) try {
                await this._keepDecodeTrack(e2), await this._initAudioDom();
              } catch (e3) {
                return void i2(new n.default({ code: d.default.AUTO_PLAY_NOT_ALLOWED, url: "https://doc.yunxin.163.com/docs/jcyOTA0ODM/jM3NDE0NTI?platformId=50082", message: "WebAudio: 浏览器自动播放受限" }));
              }
              "running" !== this.context.state ? this.context.resume().then(() => {
                this.logger.log("addStream: 播放成功"), t2(void 0);
              }).catch((e3) => {
                this.logger.error("addStream: 播放失败", e3), i2(new n.default({ code: d.default.AUTO_PLAY_NOT_ALLOWED, url: "https://doc.yunxin.163.com/docs/jcyOTA0ODM/jM3NDE0NTI?platformId=50082", message: "WebAudio: 浏览器自动播放受限" }));
              }) : t2(void 0);
            });
          }
          removeStream(e2) {
            if (!this.context || !this.streamDestination) return void this.logger.log("WebAudio: removeMs: AudioContext 不存在");
            const t2 = this.sources.findIndex((t3) => t3.sourceNode.mediaStream === e2);
            -1 !== t2 ? (this.sources[t2].sourceNode.disconnect(), this.sources[t2].gainNode.disconnect(), this.sources.splice(t2, 1), this.logger.log(`WebAudio: removeMs: 删除${e2.id}成功`), 0 !== this.sources.length ? this._updateDecodeAudioDom(this.sources[0].sourceNode.mediaStream) : (this._destroyDecodeAudioDom(), this._destroyAudioDom())) : this.logger.log(`WebAudio: removeMs: ${e2.id} 不存在，无需删除`);
          }
          connectStream(e2) {
            if (!this.context || !this.streamDestination) return void this.logger.log("WebAudio: connectStream: AudioContext 不存在");
            const t2 = this.sources.findIndex((t3) => t3.sourceNode.mediaStream === e2);
            -1 !== t2 ? (this.sources[t2].gainNode.connect(this.streamDestination), this.logger.log(`WebAudio: connectStream: connect ${e2.id} 成功`)) : this.logger.log(`WebAudio: connectStream: ${e2.id} 不存在，无需链接`);
          }
          disconnectStream(e2) {
            if (!this.context || !this.streamDestination) return void this.logger.log("WebAudio: disconnectStream: AudioContext 不存在");
            const t2 = this.sources.findIndex((t3) => t3.sourceNode.mediaStream === e2);
            -1 !== t2 ? (this.sources[t2].gainNode.disconnect(), this.logger.log(`WebAudio: disconnectStream: disconnect ${e2.id} 成功`)) : this.logger.log(`WebAudio: disconnectStream: ${e2.id} 不存在，无需断开链接`);
          }
          async resume() {
            if (this.context ? this.context.resume().then(() => {
              this.logger.log("[Resume]: resume: resume audio context success");
            }).catch((e2) => {
              this.logger.error("[Resume]: resume audio context failed", e2);
            }) : this.logger.error("[Resume]: resume: audio context is not exist"), this.audioDom) try {
              await this.audioDom.play(), this.logger.log("[Resume]: resume: resume audio dom success");
            } catch (e2) {
              this.logger.error("[Resume]: resume audio dom failed", e2);
            }
            if (this.decodeAudioDom) try {
              await this.decodeAudioDom.play(), this.logger.log("[Resume]: resume: resume decode audio dom success");
            } catch (e2) {
              this.logger.error("[Resume]: resume decode audio dom failed", e2);
            }
          }
          setVolume(e2, t2) {
            if (!this.context || !this.streamDestination) return void this.logger.log("WebAudio: setVolume: AudioContext 不存在");
            const i2 = this.sources.findIndex((e3) => e3.sourceNode.mediaStream === t2);
            -1 !== i2 ? (this.sources[i2].gainNode.gain.value = e2, this.logger.log(`WebAudio: setVolume: ${t2.id} 设置音量为 ${e2}`)) : this.logger.log(`WebAudio: setVolume: ${t2.id} 不存在`);
          }
          async setAudioOutput(e2) {
            if (this.logger.log("setAudioOutput() audioSinkId: ", e2), this.sinkId = e2, this.adapterRef.instance.outputDeviceId = e2, this.audioDom && this.audioDom.srcObject && void 0 !== this.audioDom.sinkId) {
              this.audioDom.srcObject.getAudioTracks().length && (await this.audioDom.setSinkId(e2), this.logger.log("setAudioOutput() 设置通话音频输出设备成功"));
            } else this.logger.warn("setAudioOutput() Browser does not support output device selection.");
          }
          destroy() {
            this._destroyDecodeAudioDom(), this._destroyAudioDom(), this.context && (this.context.close(), this.context = null), this.sources = [];
          }
          async _initAudioDom() {
            if (!this.audioDom) {
              if (this.logger.log("WebAudio: initAudioDom", this.streamDestination.stream.id), this.audioDom = document.createElement("audio"), this.audioDom.srcObject = this.streamDestination.stream, this._bindAudioEvent(this.audioDom), this.sinkId && void 0 !== this.audioDom.sinkId) {
                this.logger.log("音频尝试使用输出设备", this.sinkId);
                try {
                  await this.audioDom.setSinkId(this.sinkId), this.logger.log("音频使用输出设备成功", this.sinkId);
                } catch (e2) {
                  this.logger.error("音频输出设备切换失败", e2.name, e2.message, e2);
                }
              }
              await this.audioDom.play();
            }
          }
          async _keepDecodeTrack(e2) {
            this.decodeAudioDom || (this.logger.log("WebAudio: initDecodeAudioDom", this.streamDestination.stream.id), this.decodeAudioDom = document.createElement("audio"), this.decodeAudioDom.srcObject = e2, this.decodeAudioDom.volume = 1e-4, this.decodeAudioDom.volume = 0, this.decodeAudioDom.muted = true, this._bindAudioEvent(this.decodeAudioDom), await this.decodeAudioDom.play());
          }
          _updateDecodeAudioDom(e2) {
            this.decodeAudioDom && (this.decodeAudioDom.srcObject = e2);
          }
          _destroyDecodeAudioDom() {
            this.decodeAudioDom && (this.logger.log("WebAudio: destroyDecodeAudioDom"), this.decodeAudioDom.pause(), this.decodeAudioDom.srcObject = null, this.decodeAudioDom = null);
          }
          _destroyAudioDom() {
            this.audioDom && (this.logger.log("WebAudio: destroyAudioDom"), this.audioDom.pause(), this.audioDom.srcObject = null, this.audioDom = null);
          }
          _bindAudioEvent(e2) {
            e2.addEventListener("pause", (t2) => {
              this.logger.log(`[Play] 音频侦测到pause，当前播放状态 played: ${e2.played.length}, readyState: ${e2.readyState}, currentTime: ${e2.currentTime}`), this.logger.log("[Play] 可能遇到了播放问题, 尝试主动恢复播放 audio"), e2.play().then(() => {
                this.logger.log("[Play] 主动恢复播放: audio 成功");
              }).catch((e3) => {
                this.logger.error("[Play] 主动恢复播放 audio 出现问题:", e3.name, e3.message);
              });
            }), e2.addEventListener("canplay", (t2) => {
              this.logger.log(`[Play] 音频侦测到canplay，当前播放状态 played: ${e2.played.length}, readyState: ${e2.readyState}, currentTime: ${e2.currentTime}`);
            });
          }
          _bindAudioContextEvent() {
            this.context && (this.context.onstatechange = (e2) => {
              var t2;
              "suspended" === (null === (t2 = this.context) || void 0 === t2 ? void 0 : t2.state) && (this.logger.log(`[AudioContext] 状态改变: ${this.context.state}，尝试恢复`), this.context.resume().then(() => {
                this.logger.log("[AudioContext] 恢复成功");
              }).catch((e3) => {
                this.logger.error("[AudioContext] 恢复失败", e3);
              }));
            });
          }
          getAudioContext() {
            return this.context ? this.context : a.getParameters().disableWebAudio ? (this.logger.warn("WebAudio: getParameters().disableWebAudio is true"), null) : this.supports.WebAudio && this.supports.MediaStream ? (this.initWebAudio(), this.context) : (this.logger.warn("WebAudio or MediaStream is not supported"), null);
          }
        }
        t.AudioMixer = c;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.SpatialManager = void 0;
        const r = i(76), s = i(1);
        t.SpatialManager = class {
          constructor(e2) {
            this.elem = document.createElement("audio"), this.fakeElem = document.createElement("audio"), this.data = {}, this.__v_skip = s.getParameters().enableVSkip, this.context = e2.context, this.client = e2.client, this.options = e2.options, this.logger = e2.client.adapterRef.logger.getChild(() => "spatial");
            try {
              this.destination = new MediaStreamAudioDestinationNode(this.context);
            } catch (e3) {
              if ("TypeError" !== e3.name) throw e3;
              this.destination = this.context.createMediaStreamDestination();
            }
            this.elem.setAttribute("playsinline", "playsinline"), this.elem.setAttribute("autoplay", "autoplay"), this.elem.className = "nertc-panner-manager", this.elem.srcObject = this.destination.stream, this.fakeElem.muted = true, this.fakeElem.volume = 0, this.fakeElem.autoplay = true, this.fakeElem.controls = true;
          }
          getUserData(e2) {
            const t2 = "" + e2;
            "" + parseInt(t2) !== t2 && this.logger.warn("getUserData:异常的uid：", e2);
            let i2 = this.data[t2];
            return i2 || (i2 = { position: { x: 0, y: 0 } }, this.data[t2] = i2), i2;
          }
          shouldSubscribe(e2) {
            const t2 = this.getUserData(e2);
            return Math.abs(t2.position.x) <= 64 && Math.abs(t2.position.y) <= 64;
          }
          async updatePosition(e2, t2) {
            const i2 = this.getUserData(e2), r2 = this.client.adapterRef.remoteStreamMap[e2];
            if (r2) {
              const s2 = this.client.getSubStatus(r2, "all");
              if (this.shouldSubscribe(e2)) if (s2.subscribable) this.logger.log(`[remote#${e2} status:${s2.status}]界内，【即将订阅】: (${i2.position.x}, ${i2.position.y}) => (${t2.x}, ${t2.y})`), i2.position.x = t2.x, i2.position.y = t2.y, await this.client.doSubscribe(r2), this.updatePosition(e2, i2.position);
              else {
                if (i2.position.x === t2.x && i2.position.y === t2.y) return;
                this.logger.log(`[remote#${e2} status:${s2.status}]界内，即将更新remoteStream位置: (${i2.position.x}, ${i2.position.y}) => (${t2.x}, ${t2.y})`), i2.position.x = t2.x, i2.position.y = t2.y, i2.audioNodes && (i2.audioNodes.pannerNode.positionX.value = t2.x, i2.audioNodes.pannerNode.positionY.value = t2.y);
              }
              else if ("subscribed" === s2.status) this.logger.log(`[remote#${e2} status:${s2.status}]界外，【即将取消订阅】:  (${i2.position.x}, ${i2.position.y}) => (${t2.x}, ${t2.y})`), i2.position.x = t2.x, i2.position.y = t2.y, await this.client.doUnsubscribe(r2), this.updatePosition(e2, i2.position);
              else {
                if (i2.position.x === t2.x && i2.position.y === t2.y) return;
                this.logger.log(`[remote#${e2} status:${s2.status}]界外，即将更新remoteStream位置:  (${i2.position.x}, ${i2.position.y}) => (${t2.x}, ${t2.y})`), i2.position.x = t2.x, i2.position.y = t2.y, i2.audioNodes && (i2.audioNodes.pannerNode.positionX.value = t2.x, i2.audioNodes.pannerNode.positionY.value = t2.y);
              }
            } else this.logger.log(`updatePosition: 更新位置的stream: ${e2} ( ${t2.x}, ${t2.y})`), i2.position.x = t2.x, i2.position.y = t2.y;
          }
          init() {
            this.client.addListener("@stream-added", (e2) => {
              const t2 = this.getUserData(e2.stream.getId());
              e2.stream.setSubscribeConfig(this.options.subConfig), this.updatePosition(e2.stream.getId(), t2.position);
            }), this.client.addListener("@stream-unsubscribed", (e2) => {
              const t2 = this.getUserData(e2.stream.getId());
              this.updatePosition(e2.stream.getId(), t2.position);
            }), this.client.addListener("@stream-subscribed", async (e2) => {
              this.logger.log("Subscribed to", e2.stream.streamID, e2.mediaType);
              const t2 = this.getUserData(e2.stream.getId());
              "audio" === e2.mediaType && (t2.audioNodes && (t2.audioNodes.pannerNode.disconnect(), t2.audioNodes.source.disconnect(), t2.audioNodes.gainNode.disconnect()), t2.audioNodes = { source: this.context.createMediaStreamSource(e2.stream.mediaHelper.audio.audioStream), gainNode: this.context.createGain(), pannerNode: new PannerNode(this.context, { panningModel: "HRTF", distanceModel: "linear", rolloffFactor: 1, coneInnerAngle: 360, positionX: t2.position.x, positionY: t2.position.y, positionZ: 0, maxDistance: 100 }) }, t2.audioNodes.source.connect(t2.audioNodes.gainNode), t2.audioNodes.gainNode.connect(t2.audioNodes.pannerNode), t2.audioNodes.pannerNode.connect(this.destination), this.fakeElem.srcObject = e2.stream.mediaHelper.audio.audioStream, this.fakeElem.play().catch((e3) => {
                r.Device.onUserGestureNeeded && (r.Device.onUserGestureNeeded(e3), r.Device.once("user-gesture-fired", () => {
                  this.fakeElem.play();
                }));
              }), this.logger.log("Connected", e2.stream.getId, e2.stream.mediaHelper.audio.audioStream.getAudioTracks()[0])), this.updatePosition(e2.stream.getId(), t2.position);
            });
          }
          play() {
            this.elem.controls = true, "suspended" === this.context.state && r.Device.onUserGestureNeeded && (r.Device.onUserGestureNeeded(new Error("恢复AudioContext")), r.Device.once("user-gesture-fired", () => {
              this.context.resume();
            })), this.elem.play().catch((e2) => {
              r.Device.onUserGestureNeeded && (r.Device.onUserGestureNeeded(e2), r.Device.once("user-gesture-fired", () => {
                this.elem.play();
              }));
            });
          }
        };
      }, function(module, exports, __webpack_require__) {
        "use strict";
        var __createBinding = this && this.__createBinding || (Object.create ? function(e, t, i, r) {
          void 0 === r && (r = i), Object.defineProperty(e, r, { enumerable: true, get: function() {
            return t[i];
          } });
        } : function(e, t, i, r) {
          void 0 === r && (r = i), e[r] = t[i];
        }), __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(e, t) {
          Object.defineProperty(e, "default", { enumerable: true, value: t });
        } : function(e, t) {
          e.default = t;
        }), __importStar = this && this.__importStar || function(e) {
          if (e && e.__esModule) return e;
          var t = {};
          if (null != e) for (var i in e) "default" !== i && Object.prototype.hasOwnProperty.call(e, i) && __createBinding(t, e, i);
          return __setModuleDefault(t, e), t;
        }, __importDefault = this && this.__importDefault || function(e) {
          return e && e.__esModule ? e : { default: e };
        };
        Object.defineProperty(exports, "__esModule", { value: true }), exports.LocalStream = void 0;
        const videoQuality_1 = __webpack_require__(69), alerter_1 = __webpack_require__(142), audioLevel_1 = __webpack_require__(175), media_1 = __webpack_require__(193), parameters_1 = __webpack_require__(1), play_1 = __webpack_require__(195), record_1 = __webpack_require__(147), video_post_processing_1 = __importDefault(__webpack_require__(310)), advanced_beauty_1 = __importDefault(__webpack_require__(333)), basic_beauty_1 = __importDefault(__webpack_require__(334)), virtual_background_1 = __importDefault(__webpack_require__(335)), plugin_1 = __webpack_require__(200), plugin_list_1 = __webpack_require__(155), param_1 = __webpack_require__(49), types_1 = __webpack_require__(48), errorCode_1 = __importDefault(__webpack_require__(6)), rtcError_1 = __importDefault(__webpack_require__(8)), gum_1 = __webpack_require__(71), param_2 = __webpack_require__(49), applyResolution_1 = __webpack_require__(336), env = __importStar(__webpack_require__(7)), RTCEventEmitter_1 = __webpack_require__(46), utils_1 = __webpack_require__(42), webAudio_1 = __webpack_require__(47), StageAIProcessing_1 = __webpack_require__(198), wasmDetect_1 = __webpack_require__(337), audioProfile_1 = __webpack_require__(338), Config_1 = __webpack_require__(26);
        let localStreamCnt = 0;
        class LocalStream extends RTCEventEmitter_1.RTCEventEmitter {
          constructor(e) {
            if (super(), this.safariVideoSizeChange = false, this._advancedBeautyProcessor = null, this.pluginConfigList = { howlingCallback: null }, this.videoPostProcessTags = { isBeautyTrack: false, isBodySegmentTrack: false, isAdvBeautyTrack: false }, this.replaceTags = { videoPost: false, waterMark: false, isMuted: false }, this.audioLevelHelper = null, this.audioLevelHelperSlave = null, this.__v_skip = parameters_1.getParameters().enableVSkip, this.videoProfile = { frameRate: videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_NORMAL, resolution: videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_480p }, this.screenProfile = { frameRate: videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_5, resolution: videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_1080p }, this.state = "UNINIT", this.videoView = null, this.screenView = null, this.renderMode = { local: { video: {}, screen: {} } }, this.inSwitchDevice = { audio: false, video: false }, this.pubStatus = { audio: { audio: false }, audioSlave: { audio: false }, video: { video: false }, screen: { screen: false } }, this.muteStatus = { audio: { send: false }, audioSlave: { send: false }, video: { send: false }, screen: { send: false }, videoThird: { send: false }, videoFourth: { send: false } }, this.isRemote = false, this.active = true, this.destroyed = false, this.canvasWatermarkOptions = null, this.encoderWatermarkOptions = null, this.supportWasm = true, this.supportAIAudioEffects = true, this.supportHowling = true, this.canEnableAIAudioEffects = true, this.constraintSettings = { audio: {}, audioSlave: {}, video: {}, screen: {}, videoThird: {}, videoFourth: {} }, this.basicBeautyStaticRes = (e2) => {
              this.logger.log("config basic beauty static resources."), this.WebGLSupportError(), basic_beauty_1.default.configStaticRes(e2);
            }, this.advBeautyStaticRes = (e2) => {
              this.logger.log("config advanced beauty static resources."), this.WebGLSupportError(), advanced_beauty_1.default.configStaticRes(e2);
            }, this.setAdvBeautyEffect = (...e2) => {
              this.logger.log("set advanced beauty parameters:" + JSON.stringify(e2)), this.videoPostProcess.availableCode < 1 || (this.advancedBeauty.isEnable || this.logger.warn("advanced beauty is not opened."), this.advancedBeauty.setAdvEffect(...e2));
            }, this.presetAdvBeautyEffect = (...e2) => {
              this.logger.log("preset advanced beauty parameters:" + JSON.stringify(e2)), this.videoPostProcess.availableCode < 1 || (this.advancedBeauty.isEnable || this.logger.warn("advanced beauty is not opened."), this.advancedBeauty.presetAdvEffect(...e2));
            }, this.localStreamId = localStreamCnt++, this.logger = e.client.adapterRef.logger.getChild(() => {
              var e2;
              let t = this.localStreamId ? "local" + this.localStreamId : "localStream";
              if (this.mediaHelper) {
                let e3 = "";
                this.mediaHelper.audio.micTrack && (e3 += "m"), this.mediaHelper.video.cameraTrack && (e3 += "c"), this.mediaHelper.screen.screenVideoTrack && (e3 += "s"), this.mediaHelper.screenAudio.screenAudioTrack && (e3 += "t"), e3 && (t += " " + e3);
              }
              return "INITED" !== this.state && (t += " " + this.state), "INITED" === this.state && this.client && (null === (e2 = this.client.adapterRef.localStream) || void 0 === e2 ? void 0 : e2.localStreamId) !== this.localStreamId && (t += " DETACHED"), this.destroyed && (t += " DESTROYED"), t;
            }), e.uid) if ("string" == typeof e.uid) {
              if (this.logger.log("createStream: uid是string类型"), e.client.adapterRef.channelInfo.uidType = "string", !/^[1-9]\d*$/.test(e.uid)) throw this.logger.log("join(): uid不是数字字符串格式"), new rtcError_1.default({ code: errorCode_1.default.JOIN_UID_TYPE_ERROR, message: "createStream: uid不是数字字符串格式" });
            } else {
              if ("number" != typeof e.uid) throw this.logger.error("createStream: uid参数格式非法"), new rtcError_1.default({ code: errorCode_1.default.STREAM_UID_ERROR, message: "createStream: uid参数格式非法" });
              if (this.logger.log("createStream: uid是number类型"), e.client.adapterRef.channelInfo.uidType = "number", e.uid > Number.MAX_SAFE_INTEGER) throw new rtcError_1.default({ code: errorCode_1.default.STREAM_UID_ERROR, message: "Number 类型的 uid 最大值是 2^53 - 1, 请输入正确的参数" });
            }
            else e.uid = "local_" + this.localStreamId;
            this._reset(), this.streamID = e.uid, this.stringStreamID = this.streamID.toString(), this.audio = e.audio, e.audioProcessing && (this.constraintSettings.audio = Object.assign({}, e.audioProcessing)), this.microphoneId = e.microphoneId || "", this.cameraId = e.cameraId || "", this.video = e.video || false, this.screen = e.screen || false, this.screenAudio = e.screenAudio || false, this.sourceId = e.sourceId || "", this.facingMode = e.facingMode || "", this.client = e.client, this.audioSource = e.audioSource || null, this.videoSource = e.videoSource || null, this.screenAudioSource = e.screenAudioSource || null, this.screenVideoSource = e.screenVideoSource || null, this._segmentProcessor = null, this._cameraTrack = null, this._transformedTrack = null, this.mediaHelper = new media_1.MediaHelper({ stream: this }), this._play = new play_1.Play({ stream: this }), this._record = new record_1.Record({ logger: this.logger, client: this.client }), this.client._params && "live" === this.client._params.mode ? this.audioProfile = "music_standard" : this.audioProfile = "speech_low_quality", "never" !== parameters_1.getParameters().enableAlerter && alerter_1.alerter.watchLocalStream(this), this.logger.log("创建本地Stream: ", JSON.stringify({ streamID: this.stringStreamID, audio: e.audio, video: e.video })), this.client.apiFrequencyControl({ name: "createLocalStream", code: 0, param: { streamID: this.stringStreamID, videoProfile: this.videoProfile, audio: this.audio, audioProfile: this.audioProfile, video: this.video, screen: this.screen, screenProfile: this.screenProfile } }), this.supportWasm = wasmDetect_1.webassemblySupported(), this.videoPostProcess = new video_post_processing_1.default(this.logger), this.basicBeauty = new basic_beauty_1.default(this.videoPostProcess), this.virtualBackground = new virtual_background_1.default(this.videoPostProcess), this.advancedBeauty = new advanced_beauty_1.default(this.videoPostProcess), env.IS_ANY_SAFARI && this.videoPostProcess.on("safariVideoSizeChange", () => {
              this.safariVideoSizeChange = true, this.loseContext();
            }), this.videoPostProcess.on("contextLost", () => {
              this.suspendVideoPostProcess(), this.safariVideoSizeChange ? setTimeout(() => {
                this.restoreContext();
              }, 0) : this.emit("video-post-context-lost");
            }), this.videoPostProcess.on("contextRestored", (e2) => {
              this.resumeVideoPostProcess(), this.safariVideoSizeChange ? this.safariVideoSizeChange = false : (this.emit("video-post-context-restored", e2), this.logger.log("webgl context restored, try to reinitialize webgl pipeline."));
            }), this.videoPostProcess.on("beautyResComplete", (e2) => {
              this.emit("basic-beauty-res-complete", e2);
            }), this.videoPostProcess.on("advBeautyResComplete", (e2) => {
              this.emit("adv-beauty-res-complete", e2);
            }), this.videoPostProcess.on("taskSwitch", (e2) => {
              if (this.replaceTags.videoPost = e2, this.replaceCanvas(), e2 && env.IS_ANY_SAFARI) {
                const e3 = parseFloat(env.SAFARI_VERSION || "0");
                e3 < 15.4 && this.logger.warn("It is detected that you are using safari and the version is lower than 15.4. For a better experience, it is recommended to use version 15.4 and above."), 15.3 === e3 && this.logger.warn("In the current version of Safari, enabling video post-processing related functions will cause memory leaks (Safari kernel bug: capturing video streams from WebGL will cause memory leaks)."), 15 === e3 && this.logger.warn("In the current version of Safari, enabling video post-processing related functions will cause the page to crash (Safari kernel bug: WebGL rendering WebCam will cause the page to crash).");
              }
            }), env.IS_ANY_SAFARI && env.SAFARI_MAJOR_VERSION < 15 && document.addEventListener("visibilitychange", () => {
              "visible" === document.visibilityState && this.replaceTags.videoPost && this.logger.warn("In the current version of Safari, the page with the video post-processing function is restored from the background, the sending frame rate will slowly return to the normal frame rate from a lower value.");
            }), this.mediaHelper.on("preProcessChange", (e2) => {
              "video" === e2.mediaType && (this.replaceTags.waterMark = e2.isOn, this.replaceCanvas());
            });
          }
          getAdapterRef() {
            var e;
            return (null === (e = this.client.adapterRef.localStream) || void 0 === e ? void 0 : e.localStreamId) === this.localStreamId ? this.client.adapterRef : null;
          }
          _reset() {
            this.streamID = "", this.stringStreamID = "", this.state = "UNINIT", this.videoProfile = { frameRate: videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_NORMAL, resolution: videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_480p }, this.audioProfile = "speech_low_quality", this.screenProfile = { frameRate: videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_5, resolution: videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_1080p }, this.audio = false, this.microphoneId = "", this.video = false, this.cameraId = "", this.screen = false, this.screenAudio = false, this.sourceId = "", this.facingMode = "", this.videoView = null, this.screenView = null, this.renderMode = { local: { video: {}, screen: {} } }, this.inSwitchDevice = { audio: false, video: false }, this.pubStatus = { audio: { audio: false }, audioSlave: { audio: false }, video: { video: false }, screen: { screen: false } }, this.muteStatus = { audio: { send: false }, audioSlave: { send: false }, video: { send: false }, screen: { send: false }, videoThird: { send: false }, videoFourth: { send: false } }, this.renderMode = { local: { video: {}, screen: {} } }, this.mediaHelper && this.mediaHelper.destroy(), this._play && this._play.destroy(), this._record && this._record.destroy(), this._record = null, this.audioLevelHelper && this.audioLevelHelper.destroy(), this.audioLevelHelper = null, this.audioLevelHelperSlave && this.audioLevelHelperSlave.destroy(), this.audioLevelHelperSlave = null;
          }
          get segmentProcessor() {
            return this._segmentProcessor;
          }
          get Play() {
            return this._play;
          }
          get Record() {
            return this._record;
          }
          getId() {
            return "string" === this.client.adapterRef.channelInfo.uidType ? this.stringStreamID : this.streamID;
          }
          getAudioStream() {
            return this.mediaHelper ? (this.client.apiFrequencyControl({ name: "getAudioStream", code: 0, param: JSON.stringify({ streamID: this.getId() }, null, " ") }), this.mediaHelper.audio.audioStream) : null;
          }
          async init() {
            const e = await this.client.operationQueue.enqueue({ caller: this, method: "init", options: null }), t = () => {
              e();
              const t2 = { audio: this.audio, video: this.video, screen: this.screen, screenAudio: this.screenAudio };
              (this.audio || this.screenAudio) && (t2.audioProfile = this.audioProfile, t2.audioProcessing = this.constraintSettings.audio, t2.audioSlaveProcessing = this.constraintSettings.audioSlave), this.video && (t2.videoProfile = this.mediaHelper.video.captureConfig.high, t2.videoEncoder = this.mediaHelper.video.encoderConfig.high), this.screen && (t2.screenProfile = this.mediaHelper.screen.captureConfig.high, t2.screenEncoder = this.mediaHelper.screen.encoderConfig.high), this.initVideoPostProcess(), this.client.apiFrequencyControl({ name: "init", code: 0, param: Object.assign({ streamID: this.stringStreamID }, t2) }), this.client.apiFrequencyControl({ name: "_trackSettings", code: 0, param: JSON.stringify(this.mediaHelper.getTrackSettings()) });
            };
            let i = null;
            this.state = "INITING", this.logger.log("init() 初始化音视频流对象"), this.client.adapterRef.channelInfo.sessionConfig.maxVideoQuality = videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_1080p, this.videoProfile && (this.client.adapterRef.channelInfo.sessionConfig.videoQuality = this.videoProfile.resolution, this.client.adapterRef.channelInfo.sessionConfig.videoFrameRate = this.videoProfile.frameRate);
            try {
              this.audio && await this.mediaHelper.getStream({ audio: this.audio, audioDeviceId: this.microphoneId, audioSource: this.audioSource });
            } catch (e2) {
              this.logger.log("init() 打开mic失败: " + e2.message), i = e2, this.audio = false;
            }
            try {
              this.video && (await this.mediaHelper.getStream({ video: this.video, videoSource: this.videoSource, videoDeviceId: this.cameraId, facingMode: this.facingMode }), this.mediaHelper.video.preProcessingEnabled && this.mediaHelper.enablePreProcessing("video"));
            } catch (e2) {
              this.logger.log("init() 打开camera失败: " + e2.message), i = e2, this.video = false;
            }
            try {
              if (this.screen) {
                const e2 = { sourceId: this.sourceId, screen: this.screen, screenVideoSource: this.screenVideoSource, screenAudio: this.screenAudio, screenAudioSource: this.screenAudioSource };
                await this.mediaHelper.getStream(e2), this.mediaHelper.screen.preProcessingEnabled && this.mediaHelper.enablePreProcessing("screen");
              }
            } catch (e2) {
              this.logger.log("init() 打开screen失败: " + e2.message), i = e2, this.screen = this.mediaHelper.screen.screenVideoStream.getVideoTracks().length > 0, this.screenAudio = this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks().length > 0;
            }
            try {
              !this.screen && this.screenAudio && this.screenAudioSource && await this.mediaHelper.getStream({ screenAudioSource: this.screenAudioSource });
            } catch (e2) {
              this.logger.log("init() 打开自定义音频辅流失败: " + e2.message), i = e2, this.screenAudio = false;
            }
            if (this.audio || this.video || this.screen || this.screenAudio) this.state = "INITED";
            else {
              if (i) throw this.state = "UNINIT", this.logger.error("localStream.init失败:", i.name, i.message, i), t(), i;
              if (!parameters_1.getParameters().allowEmptyMedia) throw this.state = "UNINIT", this.logger.warn("init() localStream不允许初始化时无任何音视频"), t(), new rtcError_1.default({ code: errorCode_1.default.STREAM_PROFILE_ERROR, message: "init() localStream不允许初始化时无任何音视频" });
              this.logger.log("init() 当前模式下localStream允许初始化时无任何音视频"), this.state = "INITED";
            }
            t();
          }
          initVideoPostProcess() {
            var e;
            null === (e = this.videoPostProcess) || void 0 === e || e.init();
          }
          getAudioTrack(e = "audio") {
            if (this.mediaHelper) return "audio" === e ? this.mediaHelper.getAudioInputTracks()[0] : "audioSlave" === e ? this.mediaHelper.getAudioSlaveInputTracks()[0] : null;
          }
          getVideoTrack(e = "video") {
            if (this.mediaHelper) return "video" === e ? this.mediaHelper.video.cameraTrack || this.mediaHelper.video.videoSource : "screen" === e ? this.mediaHelper.screen.screenVideoTrack || this.mediaHelper.screen.screenVideoSource : null;
          }
          getScreenTrack() {
            return this.mediaHelper.screen.screenVideoStream.getVideoTracks()[0] || null;
          }
          getAudioSlaveTrack() {
            return this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks()[0] || null;
          }
          async play(e, t = {}) {
            if ((t.video || t.screen) && !e) throw this.logger.warn(`play() localStream ${this.getId()} 播放视频没有指定div标签`), new rtcError_1.default({ code: errorCode_1.default.STREAM_PLAY_ARGUMENT_ERROR, message: "play() 播放视频没有指定div标签" });
            param_2.isExistOptions({ tag: "Stream.playOptions.audio", value: t.audio }).result || (t.audio = false), t.audio && !t.audioType && (t.audioType = "mixing"), param_2.isExistOptions({ tag: "Stream.playOptions.video", value: t.video }).result || (t.video = true), param_2.isExistOptions({ tag: "Stream.playOptions.screen", value: t.screen }).result || (t.screen = true), this.logger.log(`play() uid: ${this.stringStreamID}, playOptions: ${JSON.stringify(t)}`), t.audio && this._play && this.mediaHelper.getAudioInputTracks().length > 0 && (this.logger.log(`play() uid ${this.stringStreamID} 开始播放本地音频: `, t.audioType), "voice" === t.audioType ? this._play.playAudioStream("audio", this.mediaHelper.audio.micStream, t.muted) : "music" === t.audioType ? this._play.playAudioStream("audio", this.mediaHelper.audio.musicStream, t.muted) : "mixing" === t.audioType && this._play.playAudioStream("audio", this.mediaHelper.audio.audioStream, t.muted));
            let i = null;
            if ("string" == typeof e ? i = document.getElementById(e) : e && (i = e), i) {
              if (t.video && (this.videoView = i, this._play && this.mediaHelper.video.videoStream.getVideoTracks().length)) {
                this.logger.log(`play() uid ${this.stringStreamID} 开始启动视频播放 主流 本地`);
                try {
                  await this._play.playVideoStream("video", this.mediaHelper.video.renderStream, i), "width" in this.renderMode.local.video && this._play.setRender("video", this.renderMode.local.video);
                } catch (e2) {
                  throw this.logger.log("play() 视频播放异常: ", e2), e2;
                }
                await this.resumeVideoPostProcess();
              }
              if (t.screen && (this.screenView = i, this._play && this.mediaHelper.screen.screenVideoStream.getVideoTracks().length)) {
                this.logger.log(`play() uid ${this.stringStreamID} 开始启动视频播放 辅流 本地`);
                try {
                  await this._play.playVideoStream("screen", this.mediaHelper.screen.renderStream, i), "width" in this.renderMode.local.screen && this._play.setRender("screen", this.renderMode.local.screen);
                } catch (e2) {
                  throw this.logger.log("play() 屏幕共享播放异常: ", e2), e2;
                }
              }
            }
            if (t.audio) {
              const e2 = { enable: true };
              this.client.apiFrequencyControl({ name: "enableEarback", code: 0, param: JSON.stringify(e2, null, " ") });
            }
            this.client.apiFrequencyControl({ name: "play", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, playOptions: t, isRemote: false }, null, " ") });
          }
          async resume() {
            this._play && (this.logger.log("resume() uid: ", this.stringStreamID), await this._play.resume()), this.client.apiFrequencyControl({ name: "resume", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }, null, " ") });
          }
          setLocalRenderMode(e, t) {
            if (!e || !param_1.isNumber(e.width) || !param_1.isNumber(e.height) || e.width < 0 || e.height < 0) throw this.logger.warn("setLocalRenderMode() 参数宽高错误"), this.client.apiFrequencyControl({ name: "setLocalRenderMode", code: -1, param: Object.assign({ streamID: this.stringStreamID, mediaType: t }, e) }), new rtcError_1.default({ code: errorCode_1.default.STREAM_RENDER_ARGUMENT_ERROR, message: "setLocalRenderMode() 参数宽高错误" });
            this.logger.log(`setLocalRenderMode() uid ${this.stringStreamID} 设置本地视频播放窗口大小: `, t || "video+screen", JSON.stringify(e)), t && "video" !== t || (this._play && this._play.setRender("video", e), this.renderMode.local.video = e, this.replaceCanvas()), t && "screen" !== t || (this.renderMode.local.screen = e, this._play && this._play.setRender("screen", e)), this.client.apiFrequencyControl({ name: "setLocalRenderMode", code: 0, param: Object.assign({ streamID: this.stringStreamID, mediaType: t }, e) });
          }
          stop(e) {
            this.logger.log(`stop() uid ${this.stringStreamID} 停止播放 ${e || "音视频流"}`), this._play && (types_1.MediaTypeList.forEach((t) => {
              e && t !== e || this._play.stopPlayStream(t);
            }), this.client.apiFrequencyControl({ name: "stop", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, audio: this.audio, video: this.video, screen: this.screen, type: e }, null, " ") }));
          }
          isPlaying(e) {
            if (this._play) {
              if (types_1.MediaTypeList.indexOf(e) > -1) return this._play.isPlaying(e);
              throw this.logger.warn("isPlaying() unknown type"), new rtcError_1.default({ code: errorCode_1.default.STREAM_ISPLAYING_ARGUMENT_ERROR, message: "isPlaying() type 参数类型非法" });
            }
            return this.client.apiFrequencyControl({ name: "isPlaying", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, type: e }, null, " ") }), this.logger.log(`检查${this.stringStreamID}的${e}播放状态: false`), false;
          }
          canPlay(e) {
            return -1 === types_1.MediaTypeList.indexOf(e) ? null : this._play.canPlay(e);
          }
          async open(e) {
            var t, i, r, s, a, o, n;
            let { type: d, deviceId: c, sourceId: l, facingMode: u, screenAudio: h, audioSource: p, videoSource: m, screenAudioSource: g, screenVideoSource: f, enableMediaPub: v } = e, S = "boolean" != typeof v || false !== v;
            const y = await this.client.operationQueue.enqueue({ caller: this, method: "open", options: e }), _ = (t2) => {
              y();
              const i2 = utils_1.makePrintable(Object.assign({}, e, t2.param), 1);
              this.client.apiFrequencyControl({ name: "open", code: t2.code, param: Object.assign({ streamID: this.stringStreamID }, i2) }), this.client.apiFrequencyControl({ name: "_trackSettings", code: t2.code, param: JSON.stringify(this.mediaHelper.getTrackSettings()) });
            };
            try {
              switch (this.getAdapterRef() || (this.logger.log("open(): 绑定 localStream ", d), this.client.bindLocalStream(this)), d) {
                case "audio":
                  if (this.logger.log("open(): 开启 " + (p ? p.label : "mic设备")), this.mediaHelper.audio.micTrack || this.mediaHelper.audio.audioSource) return this.logger.warn("open(): 请先关闭麦克风"), _({ code: -1, param: { reason: "重复打开麦克风", type: d } }), Promise.reject(new rtcError_1.default({ code: errorCode_1.default.REPEAT_OPEN_MIC_ERROR, message: "open() 重复打开麦克风" }));
                  if (this.audio = true, this.mediaHelper) {
                    const e2 = { audio: true, audioDeviceId: c, audioSource: p };
                    await this.mediaHelper.getStream(e2), this.audioLevelHelper && this.mediaHelper.audio.audioStream && this.audioLevelHelper.updateStream(this.mediaHelper.audio.audioStream), c && (this.microphoneId = c), this.audioSource = p || null, "CONNECTED" !== this.client.adapterRef.connectState.curState ? this.logger.log("Stream.open:client不在频道中，无需发布。", e2) : S && (this.logger.log("Stream.open:开始发布", e2), await (null === (t = this.client.adapterRef._mediasoup) || void 0 === t ? void 0 : t.createProduce(this, "audio"))), (null === (i = this.mediaHelper.audio.stageAIProcessing) || void 0 === i ? void 0 : i.enabled) && (this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.updateWebAudio()), (null === (s = null === (r = this.mediaHelper.audio.webAudio) || void 0 === r ? void 0 : r.Jungle) || void 0 === s ? void 0 : s.connected) && (this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.updateWebAudio(), this.mediaHelper.audio.webAudio.createPitchShifter());
                  }
                  break;
                case "screenAudio":
                  if (!g) return void this.logger.warn("open(): 不允许单独开启屏幕共享音频功能。");
                  if (this.logger.log("open(): 开启自定义屏幕共享音频 " + g.label), this.mediaHelper.screenAudio.screenAudioTrack || this.mediaHelper.screenAudio.screenAudioSource) return this.logger.warn("请先关闭屏幕共享音频"), _({ code: -1, param: { reason: "请先关闭屏幕共享音频", type: d } }), Promise.reject(new rtcError_1.default({ code: errorCode_1.default.REPEAT_OPEN_AUDIO_SLAVE_ERROR, message: "open() 重复打开屏幕共享音频" }));
                  if (this.screenAudio = true, this.mediaHelper) {
                    const e2 = { screenAudio: true, screenAudioSource: g };
                    await this.mediaHelper.getStream(e2), this.audioLevelHelperSlave && this.mediaHelper.screenAudio.screenAudioStream && this.audioLevelHelperSlave.updateStream(this.mediaHelper.screenAudio.screenAudioStream), "CONNECTED" !== this.client.adapterRef.connectState.curState ? this.logger.log("Stream.open:client不在频道中，无需发布。", e2) : S && (this.logger.log("Stream.open:开始发布", e2), await (null === (a = this.client.adapterRef._mediasoup) || void 0 === a ? void 0 : a.createProduce(this, "audioSlave")));
                  }
                  break;
                case "video":
                case "screen":
                  if (this.logger.log(`开启${"video" === d ? "camera" : "screen"}设备`), this[d]) {
                    const e2 = "video" === d;
                    return this.logger.warn("open() 请先关闭" + (e2 ? "摄像头" : "屏幕共享")), this.client.apiFrequencyControl({ name: "open", code: -1, param: JSON.stringify({ reason: "open() 重复打开" + (e2 ? "摄像头" : "屏幕共享"), type: d }, null, " ") }), _({ code: -1, param: { reason: "open() 重复打开" + (e2 ? "摄像头" : "屏幕共享"), type: d } }), Promise.reject(new rtcError_1.default({ code: e2 ? errorCode_1.default.REPEAT_OPEN_CAMERA_ERROR : errorCode_1.default.REPEAT_OPEN_SCREEN_ERROR, message: "open() 重复打开" + (e2 ? "摄像头" : "屏幕共享") }));
                  }
                  if (e.screenAudio && (this.mediaHelper.screenAudio.screenAudioTrack || this.mediaHelper.screenAudio.screenAudioSource)) return this.logger.warn("open() 重复开启屏幕共享音频"), _({ code: -1, param: { reason: "open() 重复开启屏幕共享音频", type: d } }), Promise.reject(new rtcError_1.default({ code: errorCode_1.default.REPEAT_OPEN_AUDIO_SLAVE_ERROR, message: "open() 重复开启屏幕共享音频" }));
                  this[d] = true;
                  const h2 = { videoDeviceId: c, sourceId: l, videoSource: m, screenAudioSource: g, screenVideoSource: f, facingMode: u };
                  h2[d] = true, "screen" === d && e.screenAudio && (h2.screenAudio = true, this.screenAudio = true), await this.mediaHelper.getStream(h2), this.videoSource = m || null, this.screenAudio && this.audioLevelHelperSlave && this.mediaHelper.screenAudio.screenAudioStream && this.audioLevelHelperSlave.updateStream(this.mediaHelper.screenAudio.screenAudioStream), "video" === d && this.mediaHelper.video.preProcessingEnabled && this.mediaHelper.enablePreProcessing("video"), "screen" === d && this.mediaHelper.screen.preProcessingEnabled && this.mediaHelper.enablePreProcessing("screen"), c && "video" === d && (this.cameraId = c), "CONNECTED" !== this.client.adapterRef.connectState.curState ? this.logger.log("Stream.open:client不在频道中, 无需发布。", h2) : S && (this.logger.log("Stream.open:开始发布", h2), await (null === (o = this.client.adapterRef._mediasoup) || void 0 === o ? void 0 : o.createProduce(this, d)), e.screenAudio && await (null === (n = this.client.adapterRef._mediasoup) || void 0 === n ? void 0 : n.createProduce(this, "audioSlave")));
                  break;
                default:
                  throw this.logger.warn("open() 非法参数"), new rtcError_1.default({ code: errorCode_1.default.STREAM_OPTN_NO_TYPE_ERROR, message: "open() type 参数类型非法" });
              }
              _({ code: 0, param: { type: d } });
            } catch (t2) {
              throw ["audio", "video", "screen"].indexOf(d) > -1 && (this[d] = false, "screen" === d && e.screenAudio && (this.screenAudio = false)), this.logger.log(d + " 开启失败: ", t2.name, t2.message), _({ code: -1, param: { type: d, reason: t2.message } }), new rtcError_1.default({ code: t2.code || errorCode_1.default.MEDIA_DEVICE_ERROR, message: `${t2.name} ${t2.message}` });
            }
          }
          async switchScreenStream(e) {
            var t;
            let i = null, r = false, s = null, a = "";
            if ("video" === (null === (t = e.screenVideoSource) || void 0 === t ? void 0 : t.kind)) i = e.screenVideoSource, r = true;
            else {
              i = (await this.mediaHelper.getScreenSource({ screen: this.screen })).getVideoTracks()[0];
            }
            i ? (s = await this.replaceTrack({ mediaType: "screen", track: i, external: r }), s ? (this.client.adapterRef.logger.log(`switchScreenStream: 已从 ${s.external ? "自定义辅流" : "屏幕共享"} 切换到 ${r ? "自定义辅流" : "屏幕共享"}`), s.external || s.oldTrack.stop()) : (a = "当前没有screen流", this.client.adapterRef.logger.error(`switchScreenStream: 无法切换到${r ? "自定义辅流" : "屏幕共享"}: ${a}`))) : (a = "无法获得新的screenVideoTrack", this.client.adapterRef.logger.error("switchScreenStream: ", a)), this.client.adapterRef.instance.apiEventReport("setFunction", { name: "switch_to_custom_screen", oper: "1", param: a || "success" }), this.client.apiFrequencyControl({ name: "switchScreenStream", code: a ? -1 : 0, param: JSON.stringify({ external: r, reason: a }, null, " ") });
          }
          async close(e) {
            var t, i, r, s, a, o;
            e || (e = { type: "all" });
            const n = await this.client.operationQueue.enqueue({ caller: this, method: "close", options: e });
            let d, c, l = e.type;
            switch (l) {
              case "audio":
                if (this.logger.log("close() 关闭mic设备"), !this.audio) {
                  d = errorCode_1.default.STREAM_CLOSE_AUDIO_ERROR, c = "close() 没有开启过麦克风";
                  break;
                }
                this.audio = false, this.mediaHelper.stopStream("audio"), this.getAdapterRef() ? this.mediaHelper.getAudioInputTracks().length > 0 ? this.logger.log("close() 关闭音频，保留发布：", l) : (this.logger.log("close() 停止发布音频"), await (null === (t = this.client.adapterRef._mediasoup) || void 0 === t ? void 0 : t.destroyProduce("audio"))) : this.logger.log("close() 未发布音频，无需停止发布"), this.audioSource = null, (null === (r = null === (i = this.mediaHelper.audio.webAudio) || void 0 === i ? void 0 : i.Jungle) || void 0 === r ? void 0 : r.connected) && (this.mediaHelper.audio.webAudio.disconnectJungle(), this.mediaHelper.disableAudioRouting());
                break;
              case "screenAudio":
                if (this.logger.log("close() 关闭屏幕共享音频"), !this.screenAudio) {
                  d = errorCode_1.default.STREAM_CLOSE_AUDIO_SLAVE_ERROR, c = "close() 没有开启过屏幕共享音频";
                  break;
                }
                this.screenAudio = false, this.mediaHelper.stopStream("screenAudio"), this.getAdapterRef() ? (this.logger.log("close() 停止发布音频辅流"), await (null === (s = this.client.adapterRef._mediasoup) || void 0 === s ? void 0 : s.destroyProduce("audioSlave"))) : this.logger.log("close() 未发布音频，无需停止发布");
                break;
              case "video":
                if (this.logger.log("close() 关闭camera设备"), !this.video) {
                  d = errorCode_1.default.STREAM_CLOSE_CAMERA_ERROR, c = "close() 没有开启过摄像头";
                  break;
                }
                await this.suspendVideoPostProcess(), this._transformedTrack && this._cameraTrack && (this._cameraTrack.stop(), this._cameraTrack = null), this._transformedTrack && (this._transformedTrack.stop(), this._transformedTrack = null), this.video = false, this.mediaHelper.stopStream("video"), this.mediaHelper.video.preProcessingEnabled && this.mediaHelper.disablePreProcessing("video", true), null == this || this._play.stopPlayStream("video"), this.getAdapterRef() ? (this.logger.log("close() 停止发布视频"), await (null === (a = this.client.adapterRef._mediasoup) || void 0 === a ? void 0 : a.destroyProduce("video"))) : this.logger.log("close() 未发布视频，无需停止发布"), this.replaceTags.isMuted && (this.replaceTags.isMuted = false, this.virtualBackground.emptyFrame = false), this.videoSource = null;
                break;
              case "screen":
                if (this.logger.log("close() 关闭屏幕共享"), !this.screen) {
                  d = errorCode_1.default.STREAM_CLOSE_SCREEN_ERROR, c = "close() 没有开启过屏幕共享";
                  break;
                }
                this.screen = false, this.mediaHelper.screen.preProcessingEnabled && this.mediaHelper.disablePreProcessing("screen", true), this.mediaHelper.stopStream("screen"), null == this || this._play.stopPlayStream("screen"), this.getAdapterRef() ? (this.logger.log("Stream.close: 停止发布辅流"), await (null === (o = this.client.adapterRef._mediasoup) || void 0 === o ? void 0 : o.destroyProduce("screen"))) : this.logger.log("Stream.close: 未发布辅流，无需停止发布");
                break;
              case "all":
                this.logger.log(`Stream.close:关闭所有设备: audio ${this.audio}, video ${this.video}, screen ${this.screen}, screenAudio ${this.screenAudio}`), this.audio && await this.close({ type: "audio" }), this.video && await this.close({ type: "video" }), this.screen && await this.close({ type: "screen" }), this.screenAudio && await this.close({ type: "screenAudio" }), this.logger.log(`Stream.close:关闭所有设备成功: audio ${this.audio}, video ${this.video}, screen ${this.screen}, screenAudio ${this.screenAudio}`);
                break;
              default:
                d = errorCode_1.default.STREAM_CLOSE_ARGUMENT_ERROR, c = "close() Unknown Type";
            }
            if (d) throw this.logger.error(c), this.client.apiFrequencyControl({ name: "close", code: -1, param: JSON.stringify({ reason: c, streamID: this.stringStreamID, audio: this.audio, video: this.video, screen: this.screen, type: e.type }, null, " ") }), n(), new rtcError_1.default({ code: d, message: c });
            return n(), void this.client.apiFrequencyControl({ name: "close", code: 0, param: JSON.stringify({ reason: d, streamID: this.stringStreamID, audio: this.audio, video: this.video, screen: this.screen, screenAudio: this.screenAudio, type: e.type }, null, " ") });
          }
          async unmuteAudio() {
            var e, t;
            this.logger.log("unmuteAudio() 启用音频轨道: ", this.stringStreamID);
            try {
              this.getAdapterRef() && await (null === (e = this.client.adapterRef._mediasoup) || void 0 === e ? void 0 : e.unmuteAudio());
              const i = this.mediaHelper.audio.audioStream.getAudioTracks();
              i && i.length && i.forEach((e2) => {
                e2.enabled = true;
              }), this.mediaHelper.getAudioInputTracks().forEach((e2) => {
                e2.enabled = true;
              }), (null === (t = this.mediaHelper.audio.webAudio) || void 0 === t ? void 0 : t.gainFilter) && (this.mediaHelper.audio.webAudio.gainFilter.gain.value = 1), this.muteStatus.audio.send = false, this.client.apiFrequencyControl({ name: "unmuteAudio", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }, null, " ") });
            } catch (e2) {
              this.logger.error("unmuteAudio() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteAudio", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, reason: e2.message }, null, " ") });
            }
          }
          async muteAudio() {
            var e, t;
            this.logger.log("muteAudio() 禁用音频轨道: ", this.stringStreamID);
            try {
              this.getAdapterRef() && await (null === (e = this.client.adapterRef._mediasoup) || void 0 === e ? void 0 : e.muteAudio());
              const i = this.mediaHelper.audio.audioStream.getAudioTracks();
              i && i.length && i.forEach((e2) => {
                e2.enabled = false;
              }), this.mediaHelper.getAudioInputTracks().forEach((e2) => {
                e2.enabled = false;
              }), (null === (t = this.mediaHelper.audio.webAudio) || void 0 === t ? void 0 : t.gainFilter) && (this.mediaHelper.audio.webAudio.gainFilter.gain.value = 0), this.muteStatus.audio.send = true, this.client.apiFrequencyControl({ name: "muteAudio", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }, null, " ") });
            } catch (e2) {
              this.logger.error("muteAudio() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "muteAudio", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, reason: e2.message }, null, " ") });
            }
          }
          async unmuteAudioSlave() {
            var e;
            this.logger.log("unmuteAudioSlave() 启用音频辅流轨道: ", this.stringStreamID);
            try {
              this.getAdapterRef() && await (null === (e = this.client.adapterRef._mediasoup) || void 0 === e ? void 0 : e.unmuteAudioSlave());
              const t = this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks();
              t && t.length && t.forEach((e2) => {
                e2.enabled = true;
              }), this.muteStatus.audioSlave.send = false, this.client.apiFrequencyControl({ name: "unmuteAudioSlave", code: 0, param: JSON.stringify({ streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("unmuteAudioSlave() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteAudioSlave", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, reason: e2 }, null, " ") });
            }
          }
          async muteAudioSlave() {
            var e;
            this.logger.log("muteAudioSlave() 禁用音频辅流轨道: ", this.stringStreamID);
            try {
              this.getAdapterRef() && await (null === (e = this.client.adapterRef._mediasoup) || void 0 === e ? void 0 : e.muteAudioSlave());
              const t = this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks();
              t && t.length && t.forEach((e2) => {
                e2.enabled = false;
              }), this.muteStatus.audioSlave.send = true, this.client.apiFrequencyControl({ name: "muteAudioSlave", code: 0, param: JSON.stringify({ streamID: this.stringStreamID }, null, " ") });
            } catch (e2) {
              this.logger.error("muteAudioSlave() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "muteAudioSlave", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, reason: e2 }, null, " ") });
            }
          }
          hasAudio() {
            return this.mediaHelper.getAudioInputTracks().length > 0;
          }
          hasAudioSlave() {
            return this.mediaHelper.getAudioSlaveInputTracks().length > 0;
          }
          getAudioLevel(e = "audio") {
            var t, i;
            let r = 0;
            switch (r = "audio" === e ? (null === (t = this.AudioLevelHelper) || void 0 === t ? void 0 : t.getAudioLevel()) || r : (null === (i = this.AudioLevelHelperSlave) || void 0 === i ? void 0 : i.getAudioLevel()) || r, parameters_1.getParameters().audioLevelFittingAlgorithm) {
              case "classic":
                return r;
              case "linear":
                return Math.max(0, Math.min(100, Math.round(200 * r)));
              case "log2":
                return Math.max(0, Math.min(100, Math.round(8.638 * Math.log2(r) + 97.244)));
            }
          }
          getAudioSlaveLevel() {
            return this.mediaHelper.getGain();
          }
          enableAudioFrame(e = 1e3) {
            if (this.logger.log(`enableAudioFrame() 音频数据时长:  ${e} ms, mediaType: audio`), e < 100 || e > 1e5) return this.logger.error("enableAudioFrame() 音频数据时长应该在 100 - 100000 毫秒之间"), false;
            if (!this.AudioLevelHelper) return this.logger.warn("enableAudioFrame() 音频数据回调开启失败，AudioLevelHelper未初始化"), false;
            if (this.AudioLevelHelper.enableAudioData) return this.logger.warn("enableAudioFrame() 音频数据回调已开启,请勿重复开启"), true;
            this.AudioLevelHelper.enableAudioData = true, this.logger.log("enableAudioFrame() 开启音频数据回调");
            const t = this._setAudioFrameDuration(e);
            return this.client.apiFrequencyControl({ name: "enableAudioFrame", code: t ? 0 : -1, param: { streamID: this.stringStreamID, duration: e, mediaType: "audio" } }), t;
          }
          disableAudioFrame() {
            var e;
            return (null === (e = this.AudioLevelHelper) || void 0 === e ? void 0 : e.enableAudioData) ? (this.AudioLevelHelper.enableAudioData = false, this.logger.log("disableAudioFrame() 关闭音频数据回调, mediaType: audio"), this.client.apiFrequencyControl({ name: "disableAudioFrame", code: 0, param: { streamID: this.stringStreamID, mediaType: "audio" } }), true) : (this.logger.log("disableAudioFrame() 音频数据回调未开启,请勿重复关闭"), false);
          }
          _setAudioFrameDuration(e = 1e3) {
            var t;
            return !!(null === (t = this.AudioLevelHelper) || void 0 === t ? void 0 : t.setBufferTime(e));
          }
          get AudioLevelHelper() {
            if (!this.audioLevelHelper && this.mediaHelper.audio.audioStream.getAudioTracks().length) {
              const e = webAudio_1.getAudioContext();
              e && e.audioWorklet && e.audioWorklet.addModule || (this.logger.error("AudioContext is not supported in this browser"), this.client.safeEmit("error", "AUDIOLEVEL_NOT_SUPPORTED")), this.audioLevelHelper = new audioLevel_1.AudioLevel({ stream: this.mediaHelper.audio.audioStream, logger: this.logger }), this.audioLevelHelper.on("audio-data", (e2) => {
                this.emit("audio-data", e2);
              });
            }
            return this.audioLevelHelper;
          }
          get AudioLevelHelperSlave() {
            return !this.audioLevelHelperSlave && this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks().length && (this.audioLevelHelperSlave = new audioLevel_1.AudioLevel({ stream: this.mediaHelper.screenAudio.screenAudioStream, logger: this.logger })), this.audioLevelHelperSlave;
          }
          setAudioProfile(e) {
            param_1.checkValidEnum({ tag: "LocalStream.setAudioProfile", value: e, enums: audioProfile_1.AudioProfile }), this.logger.log("setAudioProfile() 设置音频属性: ", e), this.audioProfile = e, this.client.apiFrequencyControl({ name: "setAudioProfile", code: 0, param: { streamID: this.stringStreamID, profile: e } });
          }
          setAudioProcessing(e, t) {
            param_1.checkValidEnum({ tag: "LocalStream.setAudioProcessing", value: e, enums: types_1.MediaTypeList });
            const i = this.constraintSettings[e], r = Object.assign({}, i, t);
            return this.constraintSettings[e] = r, this.logger.log(`setAudioProcessing ${e} ${JSON.stringify(i)} => ${JSON.stringify(r)}`), "audio" === e && this.mediaHelper.getAudioInputTracks().length || "audioSlave" === e && this.mediaHelper.screenAudio.screenAudioStream.getAudioTracks().length ? (this.logger.warn("setAudioProcessing：当前已有开启音频。3A开关设置仅在重启音频后生效"), this.client.apiFrequencyControl({ name: "setAudioProcessing", code: -1, param: JSON.stringify(t) })) : this.client.apiFrequencyControl({ name: "setAudioProcessing", code: 0, param: JSON.stringify(t) }), this.mediaHelper.getAudioConstraints(e);
          }
          setAudioVolume(e = 100) {
            var t;
            let i, r;
            (!Number.isInteger(e) || e < 0 || e > 100) && (i = errorCode_1.default.SET_AUDIO_VOLUME_ARGUMENTS_ERROR, r = "setAudioVolume() volume 应该为 0 - 100 的整数");
            const s = e / 100;
            if (this.logger.log(`setAudioVolume() 调节${this.stringStreamID}的音量大小: ${2.55 * e} (normalized: ${s})`), this.audio ? null === (t = this._play) || void 0 === t || t.setPlayVolume("audio", s) : (r = "setAudioVolume() 没有音频流，请检查是否有发布过音频", i = errorCode_1.default.SET_AUDIO_VOLUME_ERROR), this.client.apiFrequencyControl({ name: "setAudioVolume", code: i ? -1 : 0, param: { streamID: this.stringStreamID, isRemote: false, volume: 2.55 * e, normalizedVolume: s, reason: r } }), i) throw this.logger.error(r), new rtcError_1.default({ code: i, message: r });
          }
          setCaptureVolume(e, t) {
            let i, r;
            if (Number.isInteger(e) ? (e < 0 || e > 1e3) && (i = errorCode_1.default.STREAM_SET_CAPTURE_VOLUME_ARGUMENT_ERROR, r = "setCaptureVolume() volume 应该为 0 - 1000 的整数") : (i = errorCode_1.default.SET_CAPTURE_VOLUME_ARGUMENTS_ERROR, r = "setCaptureVolume() volume 应该为 0 - 1000 的整数"), this.client.apiFrequencyControl({ name: "setCaptureVolume", code: i ? -1 : 0, param: JSON.stringify({ streamID: this.stringStreamID, audioType: t, volume: e }, null, " ") }), i) throw this.logger.error(r), new rtcError_1.default({ code: i, message: r });
            this.logger.log(`setCaptureVolume() 调节${this.stringStreamID}的音量大小: ${e}`), this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.setGain(e / 100, t);
          }
          setAudioEffectLite(e, t) {
            this.logger.log(`setAudioEffectLite: ${e}  ${t}`), this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.setAudioEffectLite(e, t), this.client.apiFrequencyControl({ name: "setAudioEffectLite", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, type: e, value: t, isRemote: false }) });
          }
          disableAudioEffectLite() {
            this.logger.log("disableAudioEffectLite() 关闭音效"), this.mediaHelper.setAudioEffectLite("close", 0), this.mediaHelper.audio.audioRoutingEnabled && this.mediaHelper.disableAudioRouting(), this.client.apiFrequencyControl({ name: "disableAudioEffectLite", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }) });
          }
          async setAudioOutput(e, t) {
            if (this._play) {
              try {
                await this._play.setAudioOutput(e);
              } catch (e2) {
                throw t && setTimeout(() => {
                  t(e2);
                }, 0), this.logger.error("设置输出设备失败", e2.name, e2.message), new rtcError_1.default({ code: errorCode_1.default.SET_AUDIO_OUTPUT_ERROR, message: e2.message || "系统内部错误" });
              }
              t && setTimeout(t, 0);
            }
            this.client.apiFrequencyControl({ name: "setAudioOutput", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, deviceId: e, isRemote: false }, null, " ") });
          }
          async switchDevice(e, t) {
            var i, r, s, a;
            this.logger.log(`switchDevice() 切换媒体输入设备: ${e}, deviceId: ${t}`);
            let o, n, d = {};
            if (this.inSwitchDevice[e] ? (n = "switchDevice() 正在切换中, 重复切换 " + e, o = errorCode_1.default.SWITCH_DEVICE_REPEAT_ERROR) : this.inSwitchDevice[e] = true, "audio" === e) {
              const s2 = this.mediaHelper.audio.micTrack;
              let a2;
              if (a2 = "getSettings" in MediaStreamTrack.prototype ? null == s2 ? void 0 : s2.getSettings().deviceId : null === (r = null === (i = null == s2 ? void 0 : s2.getConstraints()) || void 0 === i ? void 0 : i.deviceId) || void 0 === r ? void 0 : r.exact, "live" === (null == s2 ? void 0 : s2.readyState) && a2 === t) return this.logger.warn("switchDevice() 切换相同的麦克风设备，不处理"), void (this.inSwitchDevice[e] = false);
              if (this.hasAudio() ? this.audioSource && (n = "switchDevice() 自定义音频输入不支持，无法切换", o = errorCode_1.default.SWITCH_DEVICE_NO_SUPPORT_AUDIO) : (n = "switchDevice() 当前没有开启音频输入设备，无法切换", o = errorCode_1.default.SWITCH_DEVICE_NO_MIC_ERROR), o) throw this.logger.error(n), this.inSwitchDevice[e] = false, this.client.apiFrequencyControl({ name: "switchDevice", code: -1, param: { reason: n, type: e, deviceId: t, streamID: this.stringStreamID } }), new rtcError_1.default({ code: o, message: n });
              this.mediaHelper.audio.micConstraint && this.mediaHelper.audio.micConstraint.audio ? this.mediaHelper.audio.micConstraint.audio.deviceId = { exact: t } : this.mediaHelper.audio.micConstraint ? (this.mediaHelper.audio.micConstraint.audio = {}, this.mediaHelper.audio.micConstraint.audio.deviceId = { exact: t }) : this.mediaHelper.audio.micConstraint = { audio: { deviceId: { exact: t } } }, d = this.mediaHelper.audio.micConstraint, this.microphoneId = t;
            } else {
              if ("video" !== e) return this.logger.error("switchDevice() type参数错误: " + e), Promise.reject(new rtcError_1.default({ code: errorCode_1.default.SWITCH_DEVICE_REPEAT_ARGUMENTS_ERROR, message: "switchDevice() type参数错误: " + e }));
              {
                const i2 = this.mediaHelper.video.cameraTrack;
                let r2;
                if (await this.suspendVideoPostProcess(), this._transformedTrack && (this._transformedTrack.stop(), this._transformedTrack = null), r2 = "getSettings" in MediaStreamTrack.prototype ? null == i2 ? void 0 : i2.getSettings().deviceId : null === (a = null === (s = null == i2 ? void 0 : i2.getConstraints()) || void 0 === s ? void 0 : s.deviceId) || void 0 === a ? void 0 : a.exact, "live" === (null == i2 ? void 0 : i2.readyState) && r2 === t) return this.logger.log("switchDevice() 切换相同的摄像头设备，不处理"), void (this.inSwitchDevice[e] = false);
                if (this.hasVideo() ? this.videoSource && (n = "switchDevice() 自定义视频输入不支持切换", o = errorCode_1.default.SWITCH_DEVICE_NO_SUPPORT_VIDEO) : (n = "switchDevice() 当前没有开启视频输入设备，无法切换", o = errorCode_1.default.SWITCH_DEVICE_NO_CAMERA_ERROR), o) return this.logger.error(n), this.inSwitchDevice[e] = false, this.client.apiFrequencyControl({ name: "switchDevice", code: -1, param: { reason: n, type: e, deviceId: t, streamID: this.stringStreamID } }), Promise.reject(new rtcError_1.default({ code: o, message: n }));
                this.mediaHelper.video.cameraConstraint && this.mediaHelper.video.cameraConstraint.video && (this.mediaHelper.video.cameraConstraint.video.deviceId = { exact: t }, d = this.mediaHelper.video.cameraConstraint), this.cameraId = t, this.replaceTags.isMuted && (this.replaceTags.isMuted = false, this.virtualBackground.emptyFrame = false);
              }
            }
            try {
              const i2 = this.mediaHelper.video.preProcessingEnabled;
              i2 && this.mediaHelper.disablePreProcessing("video"), await this.mediaHelper.getSecondStream(d), this.inSwitchDevice[e] = false, i2 && this.mediaHelper.enablePreProcessing("video"), "video" === e && await this.resumeVideoPostProcess(), "audio" === e && this.audioLevelHelper && this.audioLevelHelper.updateStream(this.mediaHelper.audio.audioStream), this.client.apiFrequencyControl({ name: "switchDevice", code: 0, param: { type: e, deviceId: t, streamID: this.stringStreamID } }), this.client.apiFrequencyControl({ name: "_trackSettings", code: 0, param: JSON.stringify(this.mediaHelper.getTrackSettings()) }), this._play.resume();
            } catch (i2) {
              throw this.logger.error("switchDevice() 异常：", i2.name, i2.message, i2), this.inSwitchDevice[e] = false, this.client.apiFrequencyControl({ name: "switchDevice", code: -1, param: { reason: i2.message, type: e, deviceId: t, streamID: this.stringStreamID } }), this.client.apiFrequencyControl({ name: "_trackSettings", code: 0, param: JSON.stringify(this.mediaHelper.getTrackSettings()) }), new rtcError_1.default({ code: i2.code || errorCode_1.default.UNKNOWN_TYPE_ERROR, message: i2.message || i2.name });
            }
          }
          async unmuteVideo() {
            var e, t;
            this.logger.log(`unmuteVideo() 启用 ${this.stringStreamID} 的视频轨道`);
            try {
              if (this.virtualBackground && (this.virtualBackground.emptyFrame = false), this.getAdapterRef() && (null === (e = this.client.adapterRef._mediasoup) || void 0 === e || e.unmuteVideo()), this.mediaHelper.video.videoSource && (this.mediaHelper.video.videoSource.enabled = true), this.mediaHelper.video.cameraTrack && (this.mediaHelper.video.cameraTrack.enabled = true), this.videoPostProcess.sourceTrack && (this.videoPostProcess.sourceTrack.enabled = true), env.IS_SAFARI) {
                const e2 = null === (t = this._play) || void 0 === t ? void 0 : t.video.containerDom;
                e2 && (e2.style.backgroundColor = "");
              }
              this.muteStatus.video.send = false, this.client.apiFrequencyControl({ name: "unmuteVideo", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }, null, " ") }), this.replaceTags.isMuted = false;
            } catch (e2) {
              this.logger.error("unmuteVideo() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "unmuteVideo", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, reason: e2.message }, null, " ") });
            }
          }
          async muteVideo() {
            var e, t;
            this.logger.log(`muteVideo() 禁用 ${this.stringStreamID} 的视频轨道`);
            try {
              if (this.virtualBackground && (this.virtualBackground.emptyFrame = true), env.IS_SAFARI) {
                const t2 = null === (e = this._play) || void 0 === e ? void 0 : e.video.dom;
                t2 && (t2.style.backgroundColor = "black");
              }
              this.getAdapterRef() && await (null === (t = this.client.adapterRef._mediasoup) || void 0 === t ? void 0 : t.muteVideo()), this.mediaHelper.video.videoSource && (this.mediaHelper.video.videoSource.enabled = false), this.mediaHelper.video.cameraTrack && (this.mediaHelper.video.cameraTrack.enabled = false), this.videoPostProcess.sourceTrack && (this.videoPostProcess.sourceTrack.enabled = false), this.muteStatus.video.send = true, this.client.apiFrequencyControl({ name: "muteVideo", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }, null, " ") }), this.replaceTags.isMuted = true;
            } catch (e2) {
              this.logger.error("muteVideo() 异常: ", e2.name, e2.message, e2), this.client.apiFrequencyControl({ name: "muteVideo", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, reason: e2.message }, null, " ") }), this.replaceTags.isMuted = false;
            }
          }
          async unmuteScreen() {
            var e;
            this.logger.log(`unmuteScreen() 启用 ${this.stringStreamID} 的视频轨道`);
            try {
              this.getAdapterRef() && (null === (e = this.client.adapterRef._mediasoup) || void 0 === e || e.unmuteScreen()), this.mediaHelper.screen.screenVideoTrack && (this.mediaHelper.screen.screenVideoTrack.enabled = true), this.mediaHelper.screen.screenVideoSource && (this.mediaHelper.screen.screenVideoSource.enabled = true), this.muteStatus.screen.send = false, this.client.apiFrequencyControl({ name: "unmuteScreen", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }, null, " ") });
            } catch (e2) {
              this.logger.error("unmuteScreen() 异常: ", e2.name, e2.message), this.client.apiFrequencyControl({ name: "unmuteScreen", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, reason: e2.message }, null, " ") });
            }
          }
          async muteScreen() {
            var e;
            this.logger.log(`muteScreen() 禁用 ${this.stringStreamID} 的辅流轨道`);
            try {
              this.getAdapterRef() && await (null === (e = this.client.adapterRef._mediasoup) || void 0 === e ? void 0 : e.muteScreen()), this.mediaHelper.screen.screenVideoSource && (this.mediaHelper.screen.screenVideoSource.enabled = false), this.mediaHelper.screen.screenVideoTrack && (this.mediaHelper.screen.screenVideoTrack.enabled = false), this.muteStatus.screen.send = true, this.client.apiFrequencyControl({ name: "muteScreen", code: 0, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false }, null, " ") });
            } catch (e2) {
              this.logger.error("muteScreen() ", e2.message), this.client.apiFrequencyControl({ name: "muteScreen", code: -1, param: JSON.stringify({ streamID: this.stringStreamID, isRemote: false, reason: e2.message }, null, " ") });
            }
          }
          hasVideo() {
            return this.logger.log("hasVideo()"), this.mediaHelper.video.videoStream.getVideoTracks().length > 0;
          }
          async setVideoProfile(e) {
            e.resolution > -1 && (this.videoProfile.resolution = e.resolution), e.frameRate > -1 && (this.videoProfile.frameRate = e.frameRate), this.mediaHelper.video.captureConfig.high = this.mediaHelper.convert(this.videoProfile), this.mediaHelper.video.encoderConfig.high.maxBitrate = this.getVideoBW(this.videoProfile) || this.mediaHelper.video.encoderConfig.high.maxBitrate, this.logger.log(`setVideoProfile() options: ${JSON.stringify(e)}, 视频采集参数: ${JSON.stringify(this.mediaHelper.video.captureConfig.high)}, 编码参数: ${JSON.stringify(this.mediaHelper.video.encoderConfig.high)}`), this.client.adapterRef.channelInfo.sessionConfig.maxVideoQuality = videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_1080p, this.client.adapterRef.channelInfo.sessionConfig.videoQuality = this.videoProfile.resolution, this.client.adapterRef.channelInfo.sessionConfig.videoFrameRate = this.videoProfile.frameRate;
            let t = this.mediaHelper.video.cameraTrack;
            if (this.videoPostProcess.hasAnyTask && (this.logger.log("setVideoProfile() 侦测到美颜在开启状态"), t = this.videoPostProcess.sourceTrack), t) try {
              let e2;
              this.logger.log(`setVideoProfile() 尝试动态修改分辨率【${t.label}】`), await applyResolution_1.applyResolution({ track: t, targetWidth: this.mediaHelper.video.captureConfig.high.width, targetHeight: this.mediaHelper.video.captureConfig.high.height, keepAspectRatio: parameters_1.getParameters().keepAspectRatio, logger: this.logger }), e2 = t && "getSettings" in MediaStreamTrack.prototype ? t.getSettings() : t.getConstraints(), e2.width && e2.height && (this.mediaHelper.video.cameraConstraint.video.width = e2.width, this.mediaHelper.video.cameraConstraint.video.height = e2.height);
            } catch (e2) {
              this.logger.error("setVideoProfile() 无法设置动态分辨率:", e2.name, e2.message);
            }
            const i = this.getSender("video", "high");
            if (i) {
              const e2 = i.getParameters(), t2 = e2.encodings && e2.encodings[0];
              if ((null == t2 ? void 0 : t2.maxBitrate) !== this.mediaHelper.video.encoderConfig.high.maxBitrate) {
                this.logger.log(`setVideoProfile() 调整上行码率 ${t2.maxBitrate} => ${this.mediaHelper.video.encoderConfig.high.maxBitrate}`), t2.maxBitrate = this.mediaHelper.video.encoderConfig.high.maxBitrate;
                try {
                  i.setParameters(e2);
                } catch (e3) {
                  this.logger.warn("setVideoProfile() 无法调整上行码率: ", e3.name, e3.message);
                }
              }
            }
            this.client.apiFrequencyControl({ name: "setVideoProfile", code: 0, param: Object.assign({ streamID: this.stringStreamID }, e) }), this.replaceCanvas();
          }
          setVideoEncoderConfiguration(e) {
            if (e.mediaType = e.mediaType || "video", e.streamType = e.streamType || "high", this.logger.log("setVideoEncoderConfiguration() 自定义视频编码配置: ", e), this.mediaHelper[e.mediaType].encoderConfig[e.streamType]) {
              if (e.maxBitrate) {
                const t = 1e3 * e.maxBitrate;
                this.logger.log(`setVideoEncoderConfiguration() 设置maxBitrate ${e.mediaType} ${e.streamType} ${this.mediaHelper[e.mediaType].encoderConfig[e.streamType].maxBitrate} => ${t}`), this.mediaHelper[e.mediaType].encoderConfig[e.streamType].maxBitrate = t;
              } else this.logger.log("setVideoEncoderConfiguration:未设定maxBitrate。保留目前的值: ", e.mediaType, e.streamType, this.mediaHelper[e.mediaType].encoderConfig[e.streamType].maxBitrate);
              "string" == typeof e.contentHint ? (this.logger.log(`setVideoEncoderConfiguration: 应用 contentHint ${e.mediaType} ${e.streamType} ${this.mediaHelper[e.mediaType].encoderConfig[e.streamType].contentHint} => ${e.contentHint}`), this.mediaHelper[e.mediaType].encoderConfig[e.streamType].contentHint = e.contentHint) : this.logger.log("setVideoEncoderConfiguration: 未设定 contentHint。保留目前的值：", e.mediaType, e.streamType, this.mediaHelper[e.mediaType].encoderConfig[e.streamType].contentHint);
            } else this.logger.warn("setVideoEncoderConfiguration() 无法识别的媒体类型：", e.mediaType, e.streamType);
            this.getSender(e.mediaType, e.streamType) && this.applyEncoderConfig(e.mediaType, e.streamType), this.client.apiFrequencyControl({ name: "setVideoEncoderConfiguration", code: 0, param: { streamID: this.stringStreamID, options: e } });
          }
          async replaceTrack(e) {
            let t, i = false, r = false, s = "video";
            if ("screen" === e.mediaType) r = this.mediaHelper.screen.preProcessingEnabled, s = e.mediaType, r && this.mediaHelper.disablePreProcessing("screen"), this.mediaHelper.screen.screenVideoTrack ? (t = this.mediaHelper.screen.screenVideoTrack, this.mediaHelper.screen.screenVideoTrack = null) : this.mediaHelper.screen.screenVideoSource && (i = true, t = this.mediaHelper.screen.screenVideoSource, this.mediaHelper.screen.screenVideoSource = null), t && (e.external ? this.mediaHelper.screen.screenVideoSource = e.track : this.mediaHelper.screen.screenVideoTrack = e.track, gum_1.emptyStreamWith(this.mediaHelper.screen.screenVideoStream, e.track), gum_1.emptyStreamWith(this.mediaHelper.screen.renderStream, e.track), this.mediaHelper.screen.screenVideoStream.getVideoTracks().length && "string" == typeof this.mediaHelper.screen.encoderConfig.high.contentHint && this.mediaHelper.screen.screenVideoStream.getVideoTracks()[0].contentHint !== this.mediaHelper.screen.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint screen high", this.mediaHelper.screen.encoderConfig.high.contentHint), this.mediaHelper.screen.screenVideoStream.getVideoTracks()[0].contentHint = this.mediaHelper.screen.encoderConfig.high.contentHint));
            else if ("video" === e.mediaType) {
              const r2 = this.mediaHelper.video.preProcessingEnabled;
              s = e.mediaType, r2 && this.mediaHelper.disablePreProcessing("video"), this.mediaHelper.video.cameraTrack ? (t = this.mediaHelper.video.cameraTrack, this.mediaHelper.video.cameraTrack = null) : this.mediaHelper.video.videoSource && (i = true, t = this.mediaHelper.video.videoSource, this.mediaHelper.video.videoSource = null), t && (e.external ? this.mediaHelper.video.videoSource = e.track : this.mediaHelper.video.cameraTrack = e.track, gum_1.emptyStreamWith(this.mediaHelper.video.videoStream, e.track), gum_1.emptyStreamWith(this.mediaHelper.video.renderStream, e.track), this.mediaHelper.video.videoStream.getVideoTracks().length && "string" == typeof this.mediaHelper.video.encoderConfig.high.contentHint && this.mediaHelper.video.videoStream.getVideoTracks()[0].contentHint !== this.mediaHelper.video.encoderConfig.high.contentHint && (this.logger.log("replaceTrack() 应用 contentHint video high", this.mediaHelper.video.encoderConfig.high.contentHint), this.mediaHelper.video.videoStream.getVideoTracks()[0].contentHint = this.mediaHelper.video.encoderConfig.high.contentHint), this.mediaHelper.video.preProcessingEnabled && this.mediaHelper.enablePreProcessing("video"));
            }
            if (!t) return this.logger.error(`replaceTrack() ${e.mediaType} 当前没有可替换的流`), null;
            if (this.logger.log(`replaceTrack ${e.mediaType}【external: ${i} ${t.label}】=>【external: ${e.external} ${e.track.label}】`), gum_1.watchTrack(e.track), this.mediaHelper.listenToTrackEnded(e.track), r) this.mediaHelper.enablePreProcessing(s);
            else {
              const t2 = this.getSender(e.mediaType, "high");
              t2 && (t2.replaceTrack(e.track), this.logger.log(`replaceTrack() ${e.mediaType} 成功替换上行`));
            }
            return this.replaceTags.isMuted && this.mediaHelper.video.cameraTrack && (this.mediaHelper.video.cameraTrack.enabled = false), { oldTrack: t, external: i };
          }
          hasScreen() {
            return this.mediaHelper.screen.screenVideoStream.getVideoTracks().length > 0;
          }
          setScreenProfile(e) {
            e.frameRate > -1 && (this.screenProfile.frameRate = e.frameRate), e.resolution > -1 && (this.screenProfile.resolution = e.resolution), this.mediaHelper.screen.captureConfig.high = this.mediaHelper.convert(this.screenProfile), this.mediaHelper.screen.encoderConfig.high.maxBitrate = this.getVideoBW(this.screenProfile), this.logger.log(`setScreenProfile() profile: ${JSON.stringify(e)}, 屏幕共享采集参数: ${JSON.stringify(this.mediaHelper.screen.captureConfig.high)}, 编码参数: ${JSON.stringify(this.mediaHelper.screen.encoderConfig.high)}`), this.client.adapterRef.channelInfo.sessionConfig.screenQuality = e, this.mediaHelper.screen.screenVideoTrack && applyResolution_1.applyResolution({ track: this.mediaHelper.screen.screenVideoTrack, targetWidth: this.mediaHelper.screen.captureConfig.high.width, targetHeight: this.mediaHelper.screen.captureConfig.high.height, keepAspectRatio: parameters_1.getParameters().keepAspectRatio, logger: this.logger });
            const t = this.getSender("screen", "high");
            if (t) {
              const e2 = t.getParameters(), i = e2.encodings && e2.encodings[0];
              if ((null == i ? void 0 : i.maxBitrate) !== this.mediaHelper.screen.encoderConfig.high.maxBitrate) {
                this.logger.log(`setScreenProfile() 调整上行码率 ${i.maxBitrate} => ${this.mediaHelper.screen.encoderConfig.high.maxBitrate}`), i.maxBitrate = this.mediaHelper.screen.encoderConfig.high.maxBitrate;
                try {
                  t.setParameters(e2);
                } catch (e3) {
                  this.logger.error("setScreenProfile() 无法调整上行码率", e3.name, e3.message);
                }
              }
            }
            this.client.apiFrequencyControl({ name: "setScreenProfile", code: 0, param: Object.assign({ streamID: this.stringStreamID }, e) });
          }
          getSender(e, t) {
            var i, r, s;
            const a = null === (s = null === (r = null === (i = this.getAdapterRef()) || void 0 === i ? void 0 : i._mediasoup) || void 0 === r ? void 0 : r._sendTransport) || void 0 === s ? void 0 : s.handler._pc;
            let o = null;
            return a && ("audio" === e && (o = "high" === t ? a.audioSender : null), "video" === e ? o = "high" === t ? a.videoSender : a.videoSenderLow : "screen" === e ? o = "high" === t ? a.screenSender : a.screenSenderLow : "audioSlave" === e && (o = a.audioSlaveSender)), o || null;
          }
          applyEncoderConfig(e, t) {
            let i = this.mediaHelper[e].encoderConfig[t].maxBitrate;
            if (!i) return;
            let r = this.getSender(e, t);
            if (!r) return void this.logger.error("localStream.applyEncoderConfig: cannot find sender for ", e, t);
            let s = this.mediaHelper[e].encoderConfig[t].contentHint;
            "string" == typeof s && r.track && r.track.contentHint !== s && (this.logger.log(`applyEncoderConfig 应用 contentHint：${e} ${t} ${r.track.contentHint} => ${s}`), r.track.contentHint = s);
            const a = r.getParameters();
            let o = void 0;
            a.encodings && a.encodings.length ? (o = a.encodings[0].maxBitrate, a.encodings[0].maxBitrate = i) : a.encodings = [{ maxBitrate: i }], r.setParameters(a).then(() => {
              this.logger.log(`最大编码码率：${e} ${t} ${o ? o + "=>" : ""}${i}`);
            }).catch((r2) => {
              this.logger.error(`应用最大编码码率失败：${e} ${t} ${i}`, a, r2.name, r2.message);
            });
          }
          getVideoBW(e) {
            return e.resolution == videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_180p ? e.frameRate <= videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_15 ? 14e4 : 22e4 : e.resolution == videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_480p ? e.frameRate <= videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_15 ? 5e5 : 75e4 : e.resolution == videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_720p ? e.frameRate <= videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_15 ? 113e4 : 171e4 : e.resolution == videoQuality_1.NERTC_VIDEO_QUALITY.VIDEO_QUALITY_1080p ? e.frameRate <= videoQuality_1.VIDEO_FRAME_RATE.CHAT_VIDEO_FRAME_RATE_15 ? 208e4 : 315e4 : (this.logger.warn("发现不支持的 NERTC_VIDEO_QUALITY " + e.resolution), 8e5);
          }
          async takeSnapshot(e) {
            var t, i, r, s;
            let a, o;
            const n = this.video && (null === (i = null === (t = this._play) || void 0 === t ? void 0 : t.video) || void 0 === i ? void 0 : i.dom), d = this.screen && (null === (s = null === (r = this.Play) || void 0 === r ? void 0 : r.screen) || void 0 === s ? void 0 : s.dom);
            if (n || d ? (this.logger.log("takeSnapshot() options: " + JSON.stringify(e)), await this._play.takeSnapshot(e, "download", this.streamID), this.client.apiFrequencyControl({ name: "takeSnapshot", code: 0, param: Object.assign({ streamID: this.stringStreamID, isRemote: false }, e) })) : (o = "takeSnapshot(): 没有视频流, 请检查视频是否正在播放", a = errorCode_1.default.STREAM_TAKE_SNAPSHOT_ERROR), a) throw this.logger.error(o), this.client.apiFrequencyControl({ name: "takeSnapshot", code: -1, param: JSON.stringify(Object.assign(Object.assign({ streamID: this.stringStreamID, isRemote: false }, e), { reason: o }), null, " ") }), new rtcError_1.default({ code: a, message: o });
          }
          takeSnapshotBase64(e) {
            var t, i, r, s;
            let a, o;
            const n = this.video && (null === (i = null === (t = this._play) || void 0 === t ? void 0 : t.video) || void 0 === i ? void 0 : i.dom), d = this.screen && (null === (s = null === (r = this.Play) || void 0 === r ? void 0 : r.screen) || void 0 === s ? void 0 : s.dom);
            if (n || d) {
              let t2 = this._play.takeSnapshot(e, "base64");
              return this.client.apiFrequencyControl({ name: "takeSnapshotBase64", code: 0, param: Object.assign({ streamID: this.stringStreamID, isRemote: false }, e) }), t2;
            }
            if (o = "takeSnapshotBase64(): 没有视频流, 请检查视频是否正在播放", a = errorCode_1.default.STREAM_TAKE_SNAPSHOT_ERROR, a) throw this.logger.error(o), this.client.apiFrequencyControl({ name: "takeSnapshotBase64", code: -1, param: JSON.stringify(Object.assign(Object.assign({ streamID: this.stringStreamID, isRemote: false }, e), { reason: o }), null, " ") }), new rtcError_1.default({ code: a, message: o });
          }
          getCurrentFrameData(e = { mediaType: "video" }) {
            return this._play.getCurrentFrameData(e);
          }
          async startMediaRecording(e) {
            const t = [];
            switch (e.type) {
              case "screen":
                t.push(this.mediaHelper.screen.screenVideoStream), t.push(this.mediaHelper.audio.audioStream);
                break;
              case "camera":
              case "video":
                t.push(this.mediaHelper.video.videoStream), t.push(this.mediaHelper.audio.audioStream);
                break;
              case "audio":
                if (t.push(this.mediaHelper.audio.audioStream), this.client.adapterRef.remoteStreamMap) for (var i in this.client.adapterRef.remoteStreamMap) {
                  const e2 = this.client.adapterRef.remoteStreamMap[i];
                  t.push(e2.mediaHelper.audio.audioStream);
                }
            }
            if (0 !== t.length) {
              if (!this._record || !this.streamID || !t) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_ERROR, message: "localStream_startMediaRecording: 开始录制时参数异常" });
              return this._record && this._record.start({ uid: "string" === this.client.adapterRef.channelInfo.uidType ? this.stringStreamID : this.streamID, type: e.type, reset: e.reset, stream: t });
            }
            this.logger.log("未发现要录制的媒体流");
          }
          stopMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "localStream.stopMediaRecording: 录制未开始" });
            return this._record.stop({});
          }
          playMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "localStream.playMediaRecording: 录制未开始" });
            return this._record.play(e.view);
          }
          listMediaRecording() {
            let e = [];
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "localStream.listMediaRecording: 录制未开始" });
            const t = this._record.getRecordStatus();
            return "init" !== t.status && e.push(t), e;
          }
          cleanMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "localStream.cleanMediaRecording: 录制未开始" });
            return this._record.clean();
          }
          downloadMediaRecording(e) {
            if (!this._record || !this._record.recoder) throw new rtcError_1.default({ code: errorCode_1.default.RECORDING_NOT_START_ERROR, message: "localStream.downloadMediaRecording: 录制未开始" });
            return this._record.download();
          }
          startAudioMixing(e) {
            if (this.logger.log("startAudioMixing() 开始伴音"), e.replace && (this.canEnableAIAudioEffects = false), e.auidoMixingEnd) {
              const t = this, i = e.auidoMixingEnd;
              e.auidoMixingEnd = function() {
                t.canEnableAIAudioEffects = true, i.apply(this, arguments);
              };
            }
            return this.mediaHelper.startAudioMixing(e);
          }
          stopAudioMixing() {
            return this.logger.log("stopAudioMixing() 停止伴音"), this.canEnableAIAudioEffects = true, this.mediaHelper.stopAudioMixing();
          }
          pauseAudioMixing() {
            return this.logger.log("pauseAudioMixing() 暂停伴音"), this.mediaHelper.pauseAudioMixing();
          }
          resumeAudioMixing() {
            return this.logger.log("resumeAudioMixing() 恢复伴音"), this.mediaHelper.resumeAudioMixing();
          }
          adjustAudioMixingVolume(e) {
            return this.logger.log("adjustAudioMixingVolume() 调节伴音音量: ", e), this.mediaHelper.setAudioMixingVolume(e);
          }
          getAudioMixingDuration() {
            return this.logger.log("getAudioMixingDuration() 获取伴音总时长"), this.mediaHelper.getAudioMixingTotalTime();
          }
          getAudioMixingCurrentPosition() {
            return this.mediaHelper.getAudioMixingPlayedTime();
          }
          setAudioMixingPosition(e) {
            return this.logger.log("setAudioMixingPosition() 设置伴音音频文件的播放位置: ", e), this.mediaHelper.setAudioMixingPlayTime(e);
          }
          async playEffect(e) {
            return this.logger.log("playEffect() 开始播放音效: ", JSON.stringify(e, null, " ")), this.mediaHelper.playEffect(e);
          }
          async stopEffect(e) {
            return this.logger.log("stopEffect() 停止播放音效: ", e), this.mediaHelper.stopEffect(e);
          }
          async pauseEffect(e) {
            return this.logger.log("pauseEffect() 暂停播放音效：", e), this.mediaHelper.pauseEffect(e);
          }
          async resumeEffect(e) {
            return this.logger.log("resumeEffect() 恢复播放音效文件: ", e), this.mediaHelper.resumeEffect(e);
          }
          async setVolumeOfEffect(e, t) {
            return this.logger.log(`setVolumeOfEffect() 调节 ${e} 音效文件音量为: ${t}`), this.mediaHelper.setVolumeOfEffect(e, t);
          }
          async preloadEffect(e, t) {
            return this.logger.log(`preloadEffect() 预加载 ${e} 音效文件地址: ${t}`), this.mediaHelper.preloadEffect(e, t);
          }
          async unloadEffect(e) {
            return this.logger.log("unloadEffect() 释放指定音效文件 " + e), this.mediaHelper.unloadEffect(e);
          }
          getEffectsVolume() {
            return this.logger.log("getEffectsVolume() 获取所有音效文件播放音量"), this.mediaHelper.getEffectsVolume();
          }
          setEffectsVolume(e) {
            return this.logger.log("setEffectsVolume() 设置所有音效文件播放音量:", e), this.mediaHelper.setEffectsVolume(e);
          }
          async stopAllEffects() {
            return this.logger.log("stopAllEffects() 停止播放所有音效文件"), this.mediaHelper.stopAllEffects();
          }
          async pauseAllEffects() {
            return this.logger.log("pauseAllEffects() 暂停播放所有音效文件"), this.mediaHelper.pauseAllEffects();
          }
          async resumeAllEffects() {
            return this.logger.log("resumeAllEffects() 恢复播放所有音效文件"), this.mediaHelper.resumeAllEffects();
          }
          getAudioEffectsDuration(e) {
            return this.logger.log("getAudioEffectsDuration() 获取音效总时长"), this.mediaHelper.getAudioEffectsTotalTime(e);
          }
          getAudioEffectsCurrentPosition(e) {
            return this.mediaHelper.getAudioEffectsPlayedTime(e);
          }
          setCanvasWatermarkConfigs(e) {
            if (this._play) {
              let t = "screen" === e.mediaType ? this._play.screen.canvasWatermark : this._play.video.canvasWatermark;
              if (!t) return void this.logger.error("setCanvasWatermarkConfigs：播放器未初始化", e.mediaType);
              const i = { TEXT: 10, TIMESTAMP: 1, IMAGE: 4 };
              if (e.textWatermarks && e.textWatermarks.length > i.TEXT) throw this.logger.error(`目前的文字水印数量：${e.textWatermarks.length}。允许的数量：${i.TEXT}`), new rtcError_1.default({ code: errorCode_1.default.WATERMARKS_EXCEEDED_ERROR, message: "最多可以设置 10 个文字水印" });
              if (e.imageWatermarks && e.imageWatermarks.length > i.IMAGE) throw this.logger.error(`目前的图片水印数量：${e.imageWatermarks.length}。允许的数量：${i.IMAGE}`), new rtcError_1.default({ code: errorCode_1.default.WATERMARKS_EXCEEDED_ERROR, message: "最多可以设置 4 个图片水印" });
              t.checkWatermarkParams(e), t.updateWatermarks(e), this.canvasWatermarkOptions = e, this.client.apiFrequencyControl({ name: "setLocalCanvasWatermarkConfigs", code: 0, param: { streamID: this.stringStreamID, isRemote: false, mediaType: e.mediaType } });
            } else this.logger.error("setCanvasWatermarkConfigs: 播放器未初始化");
          }
          setEncoderWatermarkConfigs(e) {
            var t, i;
            if (this._play && this._play) {
              const r = e.mediaType || "video", s = this._play[r].encoderWatermark;
              if (!s) return void this.logger.error("setEncoderWatermarkConfigs: 播放器未初始化", e.mediaType);
              (null === (t = e.textWatermarks) || void 0 === t ? void 0 : t.length) || e.timestampWatermarks || (null === (i = e.imageWatermarks) || void 0 === i ? void 0 : i.length) ? (s.handler.enabled = true, this.mediaHelper[r].preProcessingEnabled || this.mediaHelper.enablePreProcessing(r)) : (s.handler.enabled = false, this.mediaHelper.canDisablePreProcessing(r) && this.mediaHelper.disablePreProcessing(r));
              const a = { TEXT: 10, TIMESTAMP: 1, IMAGE: 4 };
              if (e.textWatermarks && e.textWatermarks.length > a.TEXT) throw this.logger.error(`目前的文字水印数量：${e.textWatermarks.length}。允许的数量：${a.TEXT}`), new rtcError_1.default({ code: errorCode_1.default.WATERMARKS_EXCEEDED_ERROR, message: "最多可以设置 10 个文字水印" });
              if (e.imageWatermarks && e.imageWatermarks.length > a.IMAGE) throw this.logger.error(`目前的图片水印数量：${e.imageWatermarks.length}。允许的数量：${a.IMAGE}`), new rtcError_1.default({ code: errorCode_1.default.WATERMARKS_EXCEEDED_ERROR, message: "最多可以设置 4 个图片水印" });
              s.checkWatermarkParams(e), s.updateWatermarks(e), this.encoderWatermarkOptions = e, this.client.apiFrequencyControl({ name: "setEncoderWatermarkConfigs", code: 0, param: JSON.stringify(e, null, 2) });
            } else this.logger.error("setEncoderWatermarkConfigs: 播放器未初始化");
          }
          getMuteStatus(e) {
            if (types_1.MediaTypeList.indexOf(e) > -1) return { muted: this.muteStatus[e].send };
            throw new Error("getMuteStatus Invalid Media " + e);
          }
          WebGLSupportError() {
            if (0 === this.videoPostProcess.availableCode) throw new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_SUPPORT_ERROR, message: "当前环境不支持 WebGL" });
            if (-2 === this.videoPostProcess.availableCode) throw new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_INIT, message: "WebGL 未初始化" });
          }
          setBeautyEffectOptions(e) {
            if (this.logger.log("set basic beauty parameters:", e), !(this.videoPostProcess.availableCode < 1)) {
              this.basicBeauty.isEnable || this.logger.warn("basic beauty is not opened.");
              for (const t in e) try {
                e[t] = Math.min(Math.max(parseFloat(e[t] + ""), 0), 1);
              } catch (i) {
                e[t] = 0, this.logger.error("setBeautyEffectOptions:" + i.message);
              }
              this.lastEffects = Object.assign(Object.assign({}, this.lastEffects), e), this.basicBeauty.setBeautyOptions(e);
            }
          }
          async setBeautyEffect(e, t = false) {
            if (this.logger.log((e ? "start" : "close") + " basic beauty."), this.WebGLSupportError(), e && this.videoPostProcess.availableCode < 2) return this.logger.error(this.videoPostProcess.glErrorTip);
            const i = this.basicBeauty;
            if (!t) {
              if (e && i.isEnable) return this.logger.warn("basic beauty is already opened");
              if (!e && !i.isEnable) return this.logger.warn("basic beauty is already closed");
            }
            if (this.videoPostProcessTags.isBeautyTrack = e, this.mediaHelper && this.mediaHelper.video.cameraTrack) {
              this.replaceTags.waterMark && this.mediaHelper.disablePreProcessing("video", true), this._cameraTrack = this.mediaHelper.video.cameraTrack;
              let r = 0;
              try {
                this._transformedTrack = await i.setBeauty(e, this._cameraTrack), await this.replacePluginTrack({ mediaType: "video", track: this._transformedTrack, external: false });
              } catch (e2) {
                r = -1, this.logger.error("setBeautyEffect:" + e2.message);
              }
              if (this.mediaHelper.video.preProcessingEnabled && this.mediaHelper.enablePreProcessing("video"), e && 0 === r) {
                let e2;
                e2 = this.lastEffects ? this.lastEffects : { brightnessLevel: 0, rednessLevel: 0, smoothnessLevel: 0 }, i.setBeautyOptions(e2);
              }
              t || this.client.apiFrequencyControl({ name: "setBeautyEffect", code: r, param: { streamID: this.stringStreamID, isRemote: false, isEnable: e } });
            } else this.logger.log("setBeautyEffect:video track not ready.");
          }
          setFilter(e, t) {
            if (this.logger.log("set beauty filter parameters:" + JSON.stringify([e, t])), !(this.videoPostProcess.availableCode < 1)) {
              this.basicBeauty.isEnable || this.logger.warn("basic beauty is not opened.");
              try {
                void 0 !== t && (t = Math.min(Math.max(parseFloat(t + ""), 0), 1));
              } catch (e2) {
                t = void 0, this.logger.error("setFilter:" + e2.message);
              }
              this.lastFilter = e, this.basicBeauty.setFilter(e, t);
            }
          }
          enableBodySegment() {
            return new Promise((e, t) => {
              if (this.logger.log("start virtual background."), this.WebGLSupportError(), this.videoPostProcess.availableCode < 2) throw this.logger.error(this.videoPostProcess.glErrorTip), new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_INIT, message: this.videoPostProcess.glErrorTip });
              if (!this.videoPostProcess.getPlugin("VirtualBackground")) throw this.logger.error("virtual background plugin is not register."), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_REGISTER, message: "virtual background plugin is not register" });
              if (this._segmentProcessor) return this.logger.warn("virtual background is already opened."), e(0);
              env.IS_ANY_SAFARI && parseFloat(env.SAFARI_VERSION || "0") < 15 && this.logger.warn("In the current version of Safari, wasm has low execution efficiency, which will result in low frame rate when background-segmentation is enabled."), this._initSegmentProcessor(e, t);
            });
          }
          _initSegmentProcessor(e, t) {
            this._segmentProcessor = this.virtualBackground, this._segmentProcessor.init(), this._segmentProcessor.once("segment-load", async () => {
              var i;
              let r = 0;
              try {
                await this._startBodySegment(), this.client.apiFrequencyControl({ name: "enableBodySegment", code: r, param: { streamID: this.stringStreamID } }), e();
              } catch (e2) {
                null === (i = this._segmentProcessor) || void 0 === i || i.destroy(), this._segmentProcessor = null, r = -1, this.logger.error("enableBodySegment:" + e2.message), this.client.apiFrequencyControl({ name: "enableBodySegment", code: r, param: { streamID: this.stringStreamID } }), t(e2);
              }
            });
          }
          async disableBodySegment() {
            if (this.logger.log("close virtual background."), this.WebGLSupportError(), this._segmentProcessor) {
              let e = 0;
              try {
                await this._cancelBodySegment(), this._segmentProcessor.destroy(), this._segmentProcessor = null;
              } catch (t) {
                e = -1, this.logger.error("disableBodySegment:" + t.message);
              }
              this.client.apiFrequencyControl({ name: "disableBodySegment", code: e, param: { streamID: this.stringStreamID } });
            } else this.logger.warn("virtual background is already closed.");
          }
          async _startBodySegment() {
            this.videoPostProcess.availableCode < 2 || this._segmentProcessor && (await this.transformTrack(true, this._segmentProcessor), this.videoPostProcessTags.isBodySegmentTrack = true);
          }
          async _cancelBodySegment() {
            this.videoPostProcess.availableCode < 1 || this._segmentProcessor && (await this.transformTrack(false, this._segmentProcessor), this.videoPostProcessTags.isBodySegmentTrack = false);
          }
          setBackground(e) {
            this.logger.log("set virtual background parameters:" + JSON.stringify(e)), this.videoPostProcess.availableCode < 1 || (this.virtualBackground.isEnable || this.logger.warn("virtual background is not opened."), this.virtualBackground.setVirtualBackGround(e));
          }
          setBackGround(e) {
            this.setBackground(e);
          }
          enableAdvancedBeauty(e) {
            return new Promise((t, i) => {
              if (this.logger.log("start advanced beauty."), this.WebGLSupportError(), this.videoPostProcess.availableCode < 2) throw this.logger.error(this.videoPostProcess.glErrorTip), new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_INIT, message: this.videoPostProcess.glErrorTip });
              if (!this.videoPostProcess.getPlugin("AdvancedBeauty")) throw this.logger.error("advanced beauty plugin is not register."), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_REGISTER, message: "advanced beauty plugin is not register" });
              if (this._advancedBeautyProcessor) return this.logger.warn("advanced beauty is already opened."), t(0);
              env.IS_ANY_SAFARI && parseFloat(env.SAFARI_VERSION || "0") < 15 && this.logger.warn("In the current version of Safari, wasm has low execution efficiency, which will result in low frame rate when advanced-beauty is enabled."), this._initAdvancedBeautyProcessor(t, i, e);
            });
          }
          _initAdvancedBeautyProcessor(e, t, i) {
            this._advancedBeautyProcessor = this.advancedBeauty, this._advancedBeautyProcessor.init(i), this._advancedBeautyProcessor.once("facePoints-load", async () => {
              var i2;
              let r = 0;
              try {
                await this._startAdvancedBeauty(), this.client.apiFrequencyControl({ name: "enableAdvancedBeauty", code: r, param: { streamID: this.stringStreamID } }), e();
              } catch (e2) {
                null === (i2 = this._advancedBeautyProcessor) || void 0 === i2 || i2.destroy(), this._advancedBeautyProcessor = null, r = -1, this.logger.error("enableAdvancedBeauty:" + e2.message), this.client.apiFrequencyControl({ name: "enableAdvancedBeauty", code: r, param: { streamID: this.stringStreamID } }), t(e2);
              }
            });
          }
          async disableAdvancedBeauty() {
            if (this.logger.log("close advanced beauty."), this.WebGLSupportError(), this._advancedBeautyProcessor) {
              let e = 0;
              try {
                await this._cancelAdvancedBeauty(), this._advancedBeautyProcessor.destroy(), this._advancedBeautyProcessor = null;
              } catch (t) {
                e = -1, this.logger.error("disableAdvancedBeauty:" + t.message);
              }
              this.client.apiFrequencyControl({ name: "disableAdvancedBeauty", code: e, param: { streamID: this.stringStreamID } });
            } else this.logger.warn("advanced beauty is already closed.");
          }
          async _startAdvancedBeauty() {
            this.videoPostProcess.availableCode < 2 || this._advancedBeautyProcessor && (await this.transformTrack(true, this._advancedBeautyProcessor), this.videoPostProcessTags.isAdvBeautyTrack = true);
          }
          async _cancelAdvancedBeauty() {
            this.videoPostProcess.availableCode < 1 || this._advancedBeautyProcessor && (await this.transformTrack(false, this._advancedBeautyProcessor), this.videoPostProcessTags.isAdvBeautyTrack = false);
          }
          async enableAIDenoise() {
            if (!this.canEnableAIAudioEffects) return this.logger.error("请先关闭伴音功能"), false;
            if (!this.supportAIAudioEffects) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_SUPPORT, message: "Unsupport Plugin, Please check your plugin version" });
            let e;
            if (this.logger.log("start denoise."), this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
            else {
              const t2 = webAudio_1.getAudioContext();
              if (!t2) return this.logger.error("当前环境不支持AudioContext"), false;
              e = new StageAIProcessing_1.StageAIProcessing(t2, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
            }
            if (!e.getPluginConfig("AIAudioEffects")) throw this.logger.error("AIAudioEffects plugin is not register."), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_REGISTER, message: "AIAudioEffects plugin is not register" });
            e.enabled = true;
            const t = e.getProcessor("AIAudioEffects");
            return t ? (t.getState("AIDenoise") ? this.logger.warn("ai denoise is already opened.") : (t.setState("AIDenoise", true), this.emit("ai-denoise-enabled"), this.client.apiFrequencyControl({ name: "enableAIDenoise", code: 0, param: { streamID: this.stringStreamID } })), true) : (e.once("effects-load", async () => {
              this.logger.log("ai audio effects loaded");
              const t2 = e.getProcessor("AIAudioEffects");
              null == t2 || t2.setState("AIDenoise", true), this.emit("ai-denoise-enabled"), this.client.apiFrequencyControl({ name: "enableAIDenoise", code: 0, param: { streamID: this.stringStreamID } }), this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.updateWebAudio();
            }), await e.initProcessor("AIAudioEffects"), true);
          }
          async disableAIDenoise() {
            this.logger.log("close ai denoise.");
            const e = this.mediaHelper.audio.stageAIProcessing, t = null == e ? void 0 : e.getProcessor("AIAudioEffects");
            return e ? t ? (t.setState("AIDenoise", false), t.getState("AIDenoise") || t.getState("AudioEffect") || (this.logger.log("AIDenoise and AudioEffect are both closed. destroy AIAudioEffects Processor"), e.destroyProcessor("AIAudioEffects")), e.hasWorkingPlugin() || (e.enabled = false, this.mediaHelper.updateWebAudio(), this.mediaHelper.canDisableAudioRouting() && this.mediaHelper.disableAudioRouting()), this.client.apiFrequencyControl({ name: "disableAIDenoise", code: 0, param: { streamID: this.stringStreamID } }), false) : (this.logger.warn("ai denoise is already closed."), true) : (this.logger.warn("disableAIDenoise: audio process is not created"), true);
          }
          setAIVadEnable(e) {
            var t;
            this.logger.log("setAIVadEnable:" + JSON.stringify(e));
            const i = null === (t = this.mediaHelper.audio.stageAIProcessing) || void 0 === t ? void 0 : t.getProcessor("AIAudioEffects");
            i ? i.getState("AIDenoise") ? (i.setAIVadEnable(e), this.client.apiFrequencyControl({ name: "setAIVadEnable", code: 0, param: { streamID: this.stringStreamID, options: JSON.stringify(e) } })) : this.logger.warn("ai denoise is not opened.") : this.logger.warn("audioEffectsProcessor is not created.");
          }
          async enableAudioEffect() {
            if (!this.canEnableAIAudioEffects) return this.logger.error("请先关闭伴音功能"), false;
            if (!this.supportAIAudioEffects) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_SUPPORT, message: "Unsupport Plugin, Please check your plugin version" });
            let e;
            if (this.logger.log("start audio effect."), this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
            else {
              const t2 = webAudio_1.getAudioContext();
              if (!t2) return this.logger.error("当前环境不支持AudioContext"), false;
              e = new StageAIProcessing_1.StageAIProcessing(t2, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
            }
            if (!e.getPluginConfig("AIAudioEffects")) throw this.logger.error("AudioEffects plugin is not register."), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_REGISTER, message: "ai audio effect plugin is not register" });
            e.enabled = true;
            const t = e.getProcessor("AIAudioEffects");
            return t ? (t.getState("AudioEffect") ? this.logger.warn("audio effect is already opened.") : (t.setState("AudioEffect", true), this.emit("audio-effect-enabled"), this.client.apiFrequencyControl({ name: "enableAudioEffect", code: 0, param: { streamID: this.stringStreamID } })), true) : (e.once("effects-load", async () => {
              this.logger.log("ai audio effects loaded");
              const t2 = e.getProcessor("AIAudioEffects");
              null == t2 || t2.setState("AudioEffect", true), this.emit("audio-effect-enabled"), this.client.apiFrequencyControl({ name: "enableAudioEffect", code: 0, param: { streamID: this.stringStreamID } }), this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.updateWebAudio();
            }), await e.initProcessor("AIAudioEffects"), true);
          }
          async disableAudioEffect() {
            this.logger.log("close audio effect.");
            const e = this.mediaHelper.audio.stageAIProcessing, t = null == e ? void 0 : e.getProcessor("AIAudioEffects");
            return e ? t ? (null == t || t.setState("AudioEffect", false), (null == t ? void 0 : t.getState("AIDenoise")) || (null == t ? void 0 : t.getState("AudioEffect")) || (this.logger.log("AIDenoise and AudioEffect are both closed. destroy AIAudioEffects Processor"), e.destroyProcessor("AIAudioEffects")), e.hasWorkingPlugin() || (e.enabled = false, this.mediaHelper.updateWebAudio(), this.mediaHelper.canDisableAudioRouting() && this.mediaHelper.disableAudioRouting()), this.client.apiFrequencyControl({ name: "disableAudioEffect", code: 0, param: { streamID: this.stringStreamID } }), true) : (this.logger.warn("ai audio effect is already closed."), true) : (this.logger.warn("disableAudioEffect: audio process is not created"), true);
          }
          setAudioEffect(e, t) {
            this.logger.log(`setAudioEffect:${e} `, JSON.stringify(t));
            const i = this.mediaHelper.audio.stageAIProcessing, r = null == i ? void 0 : i.getProcessor("AIAudioEffects");
            (null == r ? void 0 : r.getState("AudioEffect")) ? (r.setAudioEffect(e, t), this.client.apiFrequencyControl({ name: "setAudioEffect", code: 0, param: { streamID: this.stringStreamID, type: e, value: JSON.stringify(t) } })) : this.logger.warn("audio effect is not opened.");
          }
          async enableAIhowling() {
            if (!this.canEnableAIAudioEffects) return this.logger.error("请先关闭伴音功能"), false;
            if (!this.supportHowling) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_SUPPORT, message: "Unsupport Plugin, Please check your plugin version" });
            let e;
            if (this.logger.log("start ai howling."), this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
            else {
              const t = webAudio_1.getAudioContext();
              if (!t) return this.logger.error("当前环境不支持AudioContext"), false;
              e = new StageAIProcessing_1.StageAIProcessing(t, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
            }
            if (!e.getPluginConfig("AIhowling")) throw this.logger.error("AIhowling plugin is not register."), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_REGISTER, message: "aihowling plugin is not register" });
            e.enabled = true;
            return e.getProcessor("AIhowling") ? (this.logger.warn("ai howling is already opened."), true) : (e.once("aihowling-load", async () => {
              this.logger.log("ai howling loaded"), this.pluginConfigList.howlingCallback && (this.onAudioHasHowling(this.pluginConfigList.howlingCallback), this.pluginConfigList.howlingCallback = null), this.emit("ai-howling-enabled"), this.mediaHelper.audio.audioRoutingEnabled || this.mediaHelper.enableAudioRouting(), this.mediaHelper.updateWebAudio();
            }), await e.initProcessor("AIhowling"), this.client.apiFrequencyControl({ name: "enableAIhowling", code: 0, param: { streamID: this.stringStreamID } }), true);
          }
          async disableAIhowling() {
            this.logger.log("close ai howling.");
            const e = this.mediaHelper.audio.stageAIProcessing, t = null == e ? void 0 : e.getProcessor("AIhowling");
            return e ? t ? (e.destroyProcessor("AIhowling"), e.hasWorkingPlugin() || (e.enabled = false, this.mediaHelper.updateWebAudio(), this.mediaHelper.canDisableAudioRouting() && this.mediaHelper.disableAudioRouting()), this.client.apiFrequencyControl({ name: "disableAIhowling", code: 0, param: { streamID: this.stringStreamID } }), true) : (this.logger.warn("aihowling is already closed."), true) : (this.logger.warn("disableAIhowling: audio process is not created"), true);
          }
          onAudioHasHowling(e) {
            this.logger.log("set onAudioHasHowling callback");
            const t = this.mediaHelper.audio.stageAIProcessing, i = null == t ? void 0 : t.getProcessor("AIhowling");
            i ? (i.setHowlingCallback(e), this.client.apiFrequencyControl({ name: "onAudioHasHowling", code: 0, param: { streamID: this.stringStreamID } })) : (this.pluginConfigList.howlingCallback = e, this.logger.warn("onAudioHasHowling: audio process is not created"));
          }
          async replacePluginTrack(e) {
            if (this.videoPostProcess.availableCode < 1) return;
            let t, i = false;
            if ("screen" === e.mediaType ? (this.mediaHelper.screen.screenVideoTrack ? (t = this.mediaHelper.screen.screenVideoTrack, this.mediaHelper.screen.screenVideoTrack = null) : this.mediaHelper.screen.screenVideoSource && (i = true, t = this.mediaHelper.screen.screenVideoSource, this.mediaHelper.screen.screenVideoSource = null), t && (e.external ? this.mediaHelper.screen.screenVideoSource = e.track : this.mediaHelper.screen.screenVideoTrack = e.track, gum_1.emptyStreamWith(this.mediaHelper.screen.screenVideoStream, e.track), gum_1.emptyStreamWith(this.mediaHelper.screen.renderStream, e.track), this.mediaHelper.screen.screenVideoStream.getVideoTracks().length && "string" == typeof this.mediaHelper.screen.encoderConfig.high.contentHint && this.mediaHelper.screen.screenVideoStream.getVideoTracks()[0].contentHint !== this.mediaHelper.screen.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint screen high", this.mediaHelper.screen.encoderConfig.high.contentHint), this.mediaHelper.screen.screenVideoStream.getVideoTracks()[0].contentHint = this.mediaHelper.screen.encoderConfig.high.contentHint))) : "video" === e.mediaType && (this.mediaHelper.video.cameraTrack ? (t = this.mediaHelper.video.cameraTrack, this.mediaHelper.video.cameraTrack = null) : this.mediaHelper.video.videoSource && (i = true, t = this.mediaHelper.video.videoSource, this.mediaHelper.video.videoSource = null), t && (e.external ? this.mediaHelper.video.videoSource = e.track : this.mediaHelper.video.cameraTrack = e.track, gum_1.emptyStreamWith(this.mediaHelper.video.videoStream, e.track), gum_1.emptyStreamWith(this.mediaHelper.video.renderStream, e.track), this.mediaHelper.video.videoStream.getVideoTracks().length && "string" == typeof this.mediaHelper.video.encoderConfig.high.contentHint && this.mediaHelper.video.videoStream.getVideoTracks()[0].contentHint !== this.mediaHelper.video.encoderConfig.high.contentHint && (this.logger.log("应用 contentHint video high", this.mediaHelper.video.encoderConfig.high.contentHint), this.mediaHelper.video.videoStream.getVideoTracks()[0].contentHint = this.mediaHelper.video.encoderConfig.high.contentHint))), !t) return this.logger.error(`replaceTrack ${e.mediaType} 当前没有可替换的流`), null;
            this.logger.log(`replaceTrack ${e.mediaType}【external: ${i} ${t.label}】=>【external: ${e.external} ${e.track.label}】`), gum_1.watchTrack(e.track), this.mediaHelper.listenToTrackEnded(e.track);
            const r = this.getSender(e.mediaType, "high");
            return r && (r.replaceTrack(e.track), this.logger.log(`replaceTrack ${e.mediaType} 成功替换上行`)), this.replaceTags.isMuted && this.mediaHelper.video.cameraTrack && (this.mediaHelper.video.cameraTrack.enabled = false), { oldTrack: t, external: i };
          }
          async transformTrack(e, t) {
            if (!(this.videoPostProcess.availableCode < 1) && t) if (this.mediaHelper && this.mediaHelper.video.cameraTrack) {
              this.replaceTags.waterMark && this.mediaHelper.disablePreProcessing("video", true), this._cameraTrack = this.mediaHelper.video.cameraTrack;
              let i = null;
              try {
                this._transformedTrack = await t.setTrack(e, this._cameraTrack), this._transformedTrack && await this.replacePluginTrack({ mediaType: "video", track: this._transformedTrack, external: false });
              } catch (e2) {
                i = e2;
              }
              if (this.mediaHelper.video.preProcessingEnabled && this.mediaHelper.enablePreProcessing("video"), i) throw i;
            } else this.logger.log("transformTrack:video track not ready.");
          }
          async registerPlugin(options) {
            if (this.logger.log("register plugin: " + options.key), options.async) return this.registerPluginAsync(options);
            if (!this.supportWasm) throw this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: "unsupportWasm" } }), new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_SUPPORT_ERROR, message: `该浏览器不支持WebAssembly，注册 ${options.key} 失败。` });
            if ("AIhowling" === options.key && env.CHROME_MAJOR_VERSION && env.CHROME_MAJOR_VERSION < 77) throw this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: "unsupportChromeVersion: " + env.CHROME_MAJOR_VERSION } }), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_SUPPORT_BROWSER, message: `该浏览器版本不支持插件 ${options.key}，请升级浏览器。` });
            if (this.videoPostProcess.getPlugin(options.key)) return this.logger.warn(`plugin ${options.key} already exists.`);
            const stageAIProcessing = this.mediaHelper.audio.stageAIProcessing;
            if (null == stageAIProcessing ? void 0 : stageAIProcessing.getPluginConfig(options.key)) return this.logger.warn(`plugin ${options.key} already exists.`), false;
            let plugin = null;
            options.adapterRef = this.client.adapterRef;
            try {
              if (options.pluginUrl ? (await plugin_1.loadPlugin(options.key, options.pluginUrl), plugin = eval(`new window.${options.key}(options)`)) : options.pluginObj && (plugin = new options.pluginObj(options)), !plugin) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: "unsupport plugin " + options.key });
              plugin.once("plugin-load", () => {
                if (plugin.version !== Config_1.SDK_VERSION) throw this.logger.error(`插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。`), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_VERSION_ERROR, message: `插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。` });
                if (this.logger.log(`plugin ${options.key} loaded`), -1 !== plugin_list_1.videoPlugins.indexOf(options.key)) this.WebGLSupportError(), this.videoPostProcess.registerPlugin(options.key, plugin);
                else {
                  if (-1 === plugin_list_1.audioPlugins.indexOf(options.key)) throw new Error("unsupport plugin " + options.key + JSON.stringify(options));
                  {
                    let e;
                    if (this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
                    else {
                      const t2 = webAudio_1.getAudioContext();
                      if (!t2) return this.logger.error("当前环境不支持AudioContext"), false;
                      e = new StageAIProcessing_1.StageAIProcessing(t2, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
                    }
                    "AIAudioEffects" == options.key && (this.supportAIAudioEffects = true), "AIhowling" == options.key && (this.supportHowling = true);
                    const t = Object.assign(Object.assign({}, options), { blobUrl: plugin.url, wasmBinary: plugin.wasmBinary });
                    e.registerPlugin(t), e.once("error", (e2) => {
                      const { msg: t2, key: i } = e2;
                      this.logger.error(`plugin ${options.key} error: ${i} ${t2}`), "AIAudioEffects" == i && (this.supportAIAudioEffects = false), "AIhowling" == i && (this.supportHowling = false), this.unregisterPlugin(i), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${t2}。` } });
                    }), e.on("plugin-process-unstable", (e2) => {
                      this.emit("plugin-process-unstable", Object.assign({ streamID: this.stringStreamID }, e2));
                    });
                  }
                }
                this.emit("plugin-load", options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: 0, param: { streamID: this.stringStreamID, plugin: options.key } });
              }), plugin.once("plugin-load-error", (e) => {
                this.emit("plugin-load-error", { key: options.key, msg: `load ${options.wasmUrl} error.` }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `load ${options.wasmUrl} error.` } });
              }), plugin.once("error", (e) => {
                "AIAudioEffects" == options.key && (this.supportAIAudioEffects = false), "AIhowling" == options.key && (this.supportHowling = false), this.unregisterPlugin(options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${e}。` } });
              });
            } catch (e) {
              throw this.emit("plugin-load-error", { key: options.key, msg: e }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: e } }), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: e.message });
            }
          }
          async registerPluginAsync(options) {
            return new Promise(async (resolve, reject) => {
              if (this.logger.log("register plugin:" + options.key), !this.supportWasm) throw this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: "unsupportWasm" } }), new rtcError_1.default({ code: errorCode_1.default.WEBGL_NOT_SUPPORT_ERROR, message: `该浏览器不支持WebAssembly，注册 ${options.key} 失败。` });
              if ("AIhowling" === options.key && env.CHROME_MAJOR_VERSION && env.CHROME_MAJOR_VERSION < 77) throw this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: "unsupportChromeVersion: " + env.CHROME_MAJOR_VERSION } }), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_NOT_SUPPORT_BROWSER, message: `该浏览器版本不支持插件 ${options.key}，请升级浏览器。` });
              if (this.videoPostProcess.getPlugin(options.key)) return this.logger.warn(`plugin ${options.key} already exists.`), void resolve(`plugin ${options.key} already exists.`);
              const stageAIProcessing = this.mediaHelper.audio.stageAIProcessing;
              if (null == stageAIProcessing ? void 0 : stageAIProcessing.getPluginConfig(options.key)) return this.logger.warn(`plugin ${options.key} already exists.`), void resolve(`plugin ${options.key} already exists.`);
              let plugin = null;
              options.adapterRef = this.client.adapterRef;
              try {
                if (options.pluginUrl ? (await plugin_1.loadPlugin(options.key, options.pluginUrl), plugin = eval(`new window.${options.key}(options)`)) : options.pluginObj && (plugin = new options.pluginObj(options)), !plugin) throw new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: "unsupport plugin " + options.key });
                plugin.once("plugin-load", () => {
                  if (plugin.version !== Config_1.SDK_VERSION) throw this.logger.error(`插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。`), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_VERSION_ERROR, message: `插件 ${options.key} 版本不匹配，当前SDK版本为 ${Config_1.SDK_VERSION}，插件版本为 ${plugin.version}。` });
                  if (this.logger.log(`plugin ${options.key} loaded`), -1 !== plugin_list_1.videoPlugins.indexOf(options.key)) this.WebGLSupportError(), this.videoPostProcess.registerPlugin(options.key, plugin);
                  else {
                    if (-1 === plugin_list_1.audioPlugins.indexOf(options.key)) throw new Error(`unsupport plugin ${options.key} ${options.wasmUrl}`);
                    {
                      let e;
                      if (this.mediaHelper.audio.stageAIProcessing) e = this.mediaHelper.audio.stageAIProcessing;
                      else {
                        const t2 = webAudio_1.getAudioContext();
                        if (!t2) return this.logger.error("当前环境不支持AudioContext"), false;
                        e = new StageAIProcessing_1.StageAIProcessing(t2, this.logger), this.mediaHelper.audio.stageAIProcessing = e;
                      }
                      "AIAudioEffects" == options.key && (this.supportAIAudioEffects = true), "AIhowling" == options.key && (this.supportHowling = true);
                      const t = Object.assign(Object.assign({}, options), { blobUrl: plugin.url, wasmBinary: plugin.wasmBinary });
                      e.registerPlugin(t), e.once("error", (e2) => {
                        const { msg: t2, key: i } = e2;
                        this.logger.error(`plugin ${options.key} error: ${i} ${t2}`), "AIAudioEffects" == i && (this.supportAIAudioEffects = false), "AIhowling" == i && (this.supportHowling = false), this.unregisterPlugin(i), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${t2}。` } });
                      }), e.on("plugin-process-unstable", (e2) => {
                        this.emit("plugin-process-unstable", Object.assign({ streamID: this.stringStreamID }, e2));
                      });
                    }
                  }
                  this.emit("plugin-load", options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: 0, param: { streamID: this.stringStreamID, plugin: options.key } }), resolve(void 0);
                }), plugin.once("plugin-load-error", (e) => {
                  this.emit("plugin-load-error", { key: options.key, msg: `load ${options.wasmUrl} error.` }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `load ${options.wasmUrl} error.` } }), reject(new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: e }));
                }), plugin.once("error", (e) => {
                  "AIAudioEffects" == options.key && (this.supportAIAudioEffects = false), "AIhowling" == options.key && (this.supportHowling = false), this.unregisterPlugin(options.key), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: `插件 ${options.key} 内部错误：${e}。` } }), reject(new rtcError_1.default({ code: errorCode_1.default.PLUGIN_ERROR, message: e }));
                });
              } catch (e) {
                throw this.emit("plugin-load-error", { key: options.key, msg: e }), this.client.apiFrequencyControl({ name: "registerPlugin", code: -1, param: { streamID: this.stringStreamID, plugin: options.key, msg: e } }), new rtcError_1.default({ code: errorCode_1.default.PLUGIN_LOADED_ERROR, message: e.message || e.msg || "unsupport plugin " + options.key });
              }
            });
          }
          async unregisterPlugin(e) {
            var t;
            if (this.logger.log("unRegister plugin: " + e), -1 !== plugin_list_1.audioPlugins.indexOf(e)) {
              const i = this.mediaHelper.audio.stageAIProcessing;
              if ("AIAudioEffects" === e) {
                const e2 = null == i ? void 0 : i.getProcessor("AIAudioEffects");
                (null == e2 ? void 0 : e2.getState("AIDenoise")) && this.disableAIDenoise(), (null == e2 ? void 0 : e2.getState("AudioEffect")) && this.disableAudioEffect();
              }
              "AIhowling" === e && this.disableAIhowling(), null == i || i.unregisterPlugin(e), (null == i ? void 0 : i.hasWorkingPlugin()) || (null === (t = this.mediaHelper.audio.stageAIProcessing) || void 0 === t || t.destroy(), this.mediaHelper.audio.stageAIProcessing = null);
            } else this.WebGLSupportError(), this.videoPostProcess && ("VirtualBackground" === e && this._segmentProcessor ? await this.disableBodySegment() : "AdvancedBeauty" === e && this._advancedBeautyProcessor && await this.disableAdvancedBeauty(), this.videoPostProcess.unregisterPlugin(e));
            this.client.apiFrequencyControl({ name: "unregisterPlugin", code: 0, param: { streamID: this.stringStreamID, plugin: e } });
          }
          async suspendVideoPostProcess() {
            if (this.videoPostProcess.availableCode < 1) return;
            const { isBeautyTrack: e, isBodySegmentTrack: t, isAdvBeautyTrack: i } = this.videoPostProcessTags;
            e && (await this.setBeautyEffect(false, true), this.videoPostProcessTags.isBeautyTrack = true), t && (await this._cancelBodySegment(), this.videoPostProcessTags.isBodySegmentTrack = true), i && (await this._cancelAdvancedBeauty(), this.videoPostProcessTags.isAdvBeautyTrack = true);
          }
          async resumeVideoPostProcess() {
            if (!(this.videoPostProcess.availableCode < 1)) try {
              const { isBeautyTrack: e, isBodySegmentTrack: t, isAdvBeautyTrack: i } = this.videoPostProcessTags;
              e && (await this.setBeautyEffect(true, true), this.lastEffects && this.setBeautyEffectOptions(this.lastEffects), this.lastFilter && this.setFilter(this.lastFilter)), t && await this._startBodySegment(), i && await this._startAdvancedBeauty();
            } catch (e) {
              this.logger.log("开启失败: " + e);
            }
          }
          async replaceCanvas() {
            var e;
            if (this.videoPostProcess.availableCode < 1) return;
            if (!this._play) return;
            if (!env.IS_ANY_SAFARI) return;
            if (env.SAFARI_VERSION && parseFloat(env.SAFARI_VERSION) > 15.2) return;
            const t = this._play.video.dom, i = this._play.video.containerDom;
            if (t && i) {
              const r = this.videoPostProcess.filters, s = this.videoPostProcess.video, a = this.replaceTags.videoPost, o = this.replaceTags.waterMark;
              if (a) {
                const e2 = r.canvas;
                if (e2.style.height = "0px", e2.style.width = "0px", document.body.appendChild(e2), env.SAFARI_MAJOR_VERSION < 14 && s && (s.style.height = "0px", s.style.width = "0px", document.body.appendChild(s)), o || r.canvas.parentElement === i) o && (t.style.display = "");
                else {
                  const e3 = r.canvas;
                  t.style.display = "none", e3.style.position = "absolute";
                  const s2 = i.getBoundingClientRect(), a2 = s2.width / s2.height, o2 = e3.width / e3.height, { width: n, height: d, cut: c } = this.renderMode.local.video, l = n / d;
                  if (c) if (l > o2) {
                    e3.style.width = "100%", e3.style.left = "0px";
                    const t2 = s2.width / o2 / s2.height;
                    e3.style.height = 100 * t2 + "%", e3.style.top = 50 * -(t2 - 1) + "%";
                  } else {
                    e3.style.height = "100%", e3.style.top = "0px";
                    const t2 = s2.height * o2 / s2.width;
                    e3.style.width = 100 * t2 + "%", e3.style.left = 50 * -(t2 - 1) + "%";
                  }
                  else if (a2 > o2) {
                    e3.style.height = "100%", e3.style.top = "0px";
                    const t2 = s2.height * o2 / s2.width;
                    e3.style.width = 100 * t2 + "%", e3.style.left = 50 * (1 - t2) + "%";
                  } else {
                    e3.style.width = "100%", e3.style.left = "0px";
                    const t2 = s2.width / o2 / s2.height;
                    e3.style.height = 100 * t2 + "%", e3.style.top = 50 * (1 - t2) + "%";
                  }
                  i.appendChild(r.canvas);
                }
              } else t.style.display = "", null === (e = r.canvas.parentNode) || void 0 === e || e.removeChild(r.canvas);
            }
          }
          loseContext() {
            var e, t;
            try {
              null === (t = null === (e = this.videoPostProcess.filters) || void 0 === e ? void 0 : e.webglLostContext) || void 0 === t || t.loseContext();
            } catch (e2) {
            }
          }
          restoreContext() {
            var e, t;
            try {
              null === (t = null === (e = this.videoPostProcess.filters) || void 0 === e ? void 0 : e.webglLostContext) || void 0 === t || t.restoreContext();
            } catch (e2) {
            }
          }
          getNativeDom(e) {
            const t = this[e], i = this._play[e].dom;
            return t && i || this.logger.warn("No local " + e), i;
          }
          delay(e) {
            return new Promise((t) => setTimeout(t, e));
          }
          async destroy() {
            this.client && (this.client.apiFrequencyControl({ name: "destroy", code: 0, param: { streamID: this.stringStreamID, isRemote: false } }), this.logger.log(`uid ${this.stringStreamID} 销毁 Stream 实例`), this.stop(), env.ANY_CHROME_MAJOR_VERSION && env.ANY_CHROME_MAJOR_VERSION < 62 && await this.delay(100), this._reset(), this.destroyed = true, this.lastEffects = null, this.lastFilter = null, this._segmentProcessor && (this._segmentProcessor.destroy(), this._segmentProcessor = null), this._advancedBeautyProcessor && (this._advancedBeautyProcessor.destroy(), this._advancedBeautyProcessor = null), this._cameraTrack && (this._cameraTrack.stop(), this._cameraTrack = null), this._transformedTrack && (this._transformedTrack.stop(), this._transformedTrack = null), this.videoPostProcess.destroy());
          }
        }
        exports.LocalStream = LocalStream;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__createBinding || (Object.create ? function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), Object.defineProperty(e2, r2, { enumerable: true, get: function() {
            return t2[i2];
          } });
        } : function(e2, t2, i2, r2) {
          void 0 === r2 && (r2 = i2), e2[r2] = t2[i2];
        }), s = this && this.__setModuleDefault || (Object.create ? function(e2, t2) {
          Object.defineProperty(e2, "default", { enumerable: true, value: t2 });
        } : function(e2, t2) {
          e2.default = t2;
        }), a = this && this.__importStar || function(e2) {
          if (e2 && e2.__esModule) return e2;
          var t2 = {};
          if (null != e2) for (var i2 in e2) "default" !== i2 && Object.prototype.hasOwnProperty.call(e2, i2) && r(t2, e2, i2);
          return s(t2, e2), t2;
        }, o = this && this.__importDefault || function(e2) {
          return e2 && e2.__esModule ? e2 : { default: e2 };
        };
        Object.defineProperty(t, "__esModule", { value: true });
        const n = i(3), d = a(i(7)), c = o(i(311)), l = i(312);
        class u extends n.EventEmitter {
          constructor(e2) {
            super(), this.pluginModules = { VirtualBackground: null, AdvancedBeauty: null }, this.isAlive = true, this.filters = null, this.video = null, this.frameRate = 15, this.timerId = -1, this.taskSet = /* @__PURE__ */ new Set(), this.taskSnapshot = /* @__PURE__ */ new Set(), this.readyTaskSet = /* @__PURE__ */ new Set(["BasicBeauty"]), this.sourceMap = null, this.maskData = null, this.advBeautyData = [], this.sourceTrack = null, this.trackInstance = null, this.videoSizeTag = "", this.frameCount = [0, 0], this.update = (e3 = true) => {
              if (this.availableCode < 2) return;
              if (d.IS_ANY_SAFARI && "hidden" === document.visibilityState) return;
              const t2 = this.filters;
              if (!this.taskSet.size) return t2 ? t2.update(false) : c.default.clearTimeout(this.timerId);
              if (e3 && (this.frameCount[0] += 1), this.taskReady) {
                let e4 = false, i2 = false;
                if (this.taskSet.has("VirtualBackground") && (t2.virtualBackground.setMaskMap(this.maskData), this.maskData = null, e4 = true, i2 = true), this.taskSet.has("AdvancedBeauty") ? (t2.advBeauty.setAdvData(this.advBeautyData), this.advBeautyData = [], e4 = true) : i2 = false, this.taskSnapshot = new Set(this.taskSet), this.readyTaskSet.clear(), this.readyTaskSet.add("BasicBeauty"), this.frameCount[1] = this.frameCount[0], e4 ? (t2.update(false), this.sourceMap = t2.normal.getImageData(t2.srcMap)) : t2.update(true), this.taskSet.has("VirtualBackground")) {
                  const e5 = this.pluginModules.VirtualBackground;
                  if (e5) {
                    const { width: r2, height: s2 } = t2.canvas;
                    r2 > 16 && s2 > 16 ? e5.process(i2 ? this.sourceMap.slice() : this.sourceMap, r2, s2, (e6) => {
                      const t3 = (e6.data || e6).length;
                      this.maskData = this.taskSet.has("VirtualBackground") && t3 > 0 ? e6 : null, this.readyTaskSet.add("VirtualBackground"), this.frameCount[1] < this.frameCount[0] && (this.updateTimer(), this.update(false));
                    }, d.IS_CHROME && (d.CHROME_MAJOR_VERSION || 0) >= 104) : this.readyTaskSet.add("VirtualBackground");
                  }
                }
                if (this.taskSet.has("AdvancedBeauty")) {
                  const e5 = this.pluginModules.AdvancedBeauty;
                  if (e5) {
                    const { width: i3, height: r2 } = t2.canvas;
                    e5.process(this.sourceMap, i3, r2, (e6) => {
                      this.advBeautyData = this.taskSet.has("AdvancedBeauty") ? e6 : [], this.readyTaskSet.add("AdvancedBeauty"), this.frameCount[1] < this.frameCount[0] && (this.updateTimer(), this.update(false));
                    }, d.IS_CHROME && (d.CHROME_MAJOR_VERSION || 0) >= 104);
                  }
                }
              }
            }, this.setTaskAndTrack = (e3, t2, i2) => new Promise((r2, s2) => {
              if (this.availableCode < 1) return s2(this.glErrorTip);
              if (t2) {
                if (this.hasTask(e3)) return r2(this.track);
                this.createTrack(i2).then((t3) => {
                  this.addTask(e3), setTimeout(() => {
                    r2(this.track);
                  }, t3);
                }).catch((e4) => {
                  s2(e4);
                });
              } else {
                if (!this.hasTask(e3)) return r2(this.track);
                this.removeTask(e3), r2(this.track);
              }
            }), this.logger = e2;
          }
          registerPlugin(e2, t2) {
            this.pluginModules[e2] = t2;
          }
          getPlugin(e2) {
            return this.pluginModules[e2];
          }
          unregisterPlugin(e2) {
            this.pluginModules[e2] = null;
          }
          init() {
            try {
              this.filters = new l.Filters();
              const e2 = this.filters.canvas;
              e2.addEventListener("webglcontextlost", (e3) => {
                e3.preventDefault(), this.emit("contextLost");
              }, false), e2.addEventListener("webglcontextrestored", (e3) => {
                var t2;
                e3.preventDefault();
                let i2 = true;
                this.filters = (null === (t2 = this.filters) || void 0 === t2 ? void 0 : t2.clone()) || null, this.filters || (i2 = false), this.emit("contextRestored", i2);
              }, false);
            } catch (e2) {
            }
          }
          get availableCode() {
            return this.isAlive ? this.filters ? this.filters.gl ? this.filters.gl.isContextLost() ? 1 : 2 : 0 : -2 : -1;
          }
          get glErrorTip() {
            switch (this.availableCode) {
              case -1:
                return "localStream is already destroyed.";
              case 0:
                return "the current environment does not support webgl.";
              case -2:
                return "filters is not initialized.";
              case 1:
                return "webgl context has been lost.";
            }
            return "";
          }
          get taskReady() {
            for (const e2 of this.taskSnapshot) if (!this.readyTaskSet.has(e2)) return false;
            return true;
          }
          addTask(e2) {
            this.taskSet.has(e2) || (this.taskSet.add(e2), this.logger.log(`task ${e2} is added.`), this.update(), 1 === this.taskSet.size && (this.updateTimer(), this.emit("taskSwitch", true)));
          }
          removeTask(e2) {
            var t2;
            this.taskSet.delete(e2), this.logger.log(`task ${e2} is removed.`), 0 === this.taskSet.size && (c.default.clearTimeout(this.timerId), this.timerId = -1, this.sourceMap = null, null === (t2 = this.trackInstance) || void 0 === t2 || t2.stop(), this.trackInstance = null, this.emit("taskSwitch", false)), this.update(), this.taskSnapshot.delete(e2);
          }
          hasTask(e2) {
            return this.taskSet.has(e2);
          }
          get hasAnyTask() {
            return this.taskSet.size > 0;
          }
          videoSizeChange(e2, t2) {
            if (d.IS_ANY_SAFARI && this.filters) {
              const i2 = `${e2}-${t2}`;
              this.videoSizeTag !== i2 && (this.videoSizeTag = i2, this.emit("safariVideoSizeChange"));
            }
          }
          createTrack(e2) {
            return new Promise((t2, i2) => {
              var r2, s2;
              if (this.trackInstance && this.trackInstance === e2) return this.logger.log("VideoPostProcess track transform unnecessary"), t2(0);
              this.logger.log("VideoPostProcess track transform");
              const a2 = e2.getSettings();
              this.frameRate = a2.frameRate || 15, this.frameRate > 30 && (this.logger.warn("In chrome, webgl drawing video which framerate greater than 30fps may cause memory leak."), this.frameRate = 30), this.sourceTrack = e2, this.trackInstance && (this.trackInstance.stop(), this.trackInstance = null), a2.width && a2.height && (null === (r2 = this.filters) || void 0 === r2 || r2.setSize(a2.width, a2.height), this.videoSizeTag || (this.videoSizeTag = `${a2.width}-${a2.height}`));
              const o2 = (null === (s2 = this.filters) || void 0 === s2 ? void 0 : s2.canvas).captureStream(this.frameRate);
              this.trackInstance = o2.getVideoTracks()[0], this.video = this.video || document.createElement("video");
              const n2 = new MediaStream([this.sourceTrack]);
              this.video.srcObject = n2;
              const d2 = (e3) => {
                var t3;
                const { videoWidth: i3, videoHeight: r3 } = e3;
                null === (t3 = this.filters) || void 0 === t3 || t3.setSize(i3, r3), this.videoSizeChange(i3, r3);
              };
              this.video.onloadedmetadata = () => {
                this.video.play().then(() => {
                  this.filters.mapSource = this.video, d2(this.video), t2(0);
                }).catch((e3) => {
                  i2(e3);
                });
              }, this.video.onresize = () => {
                d2(this.video);
              };
            });
          }
          get track() {
            return this.taskSet.size ? (this.logger.log("return video post procss track."), this.trackInstance) : (this.logger.log("return origin track."), this.sourceTrack);
          }
          updateTimer() {
            c.default.clearTimeout(this.timerId), this.timerId = c.default.setTimeout(() => {
              this.updateTimer(), this.update();
            }, 1e3 / (1.1 * this.frameRate), null);
          }
          destroy() {
            var e2, t2, i2;
            this.isAlive = false, c.default.clearTimeout(this.timerId), this.removeAllListeners(), this.taskSet.clear(), this.readyTaskSet.clear(), this.taskSnapshot.clear(), null === (e2 = this.sourceTrack) || void 0 === e2 || e2.stop(), this.sourceTrack = null, null === (t2 = this.trackInstance) || void 0 === t2 || t2.stop(), this.trackInstance = null, this.video = null, null === (i2 = this.filters) || void 0 === i2 || i2.destroy(), this.filters = null, this.sourceMap = null, this.maskData = null, this.advBeautyData = null, this.pluginModules = null, this.frameCount = [0, 0];
          }
        }
        t.default = u;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = i(90);
        const s = new class {
          constructor() {
            this.id = 0, this.callbacks = {}, this.worker = null;
          }
          getWorker() {
            return this.worker || (this.worker = new Worker(r.getBlobUrl("webWorkerTimer")), this.worker.onmessage = (e2) => {
              switch (e2.data.message) {
                case "interval:tick":
                case "timeout:tick": {
                  const t2 = this.callbacks[e2.data.id];
                  t2 && t2.fn && t2.fn.apply(t2.context);
                  break;
                }
                case "interval:cleared":
                case "timeout:cleared":
                  delete this.callbacks[e2.data.id];
              }
            }), this.worker;
          }
          setInterval(e2, t2, i2) {
            this.id++;
            const r2 = this.id;
            return this.callbacks[r2] = { fn: e2, context: i2 }, this.getWorker().postMessage({ command: "interval:start", interval: t2, id: r2 }), r2;
          }
          setTimeout(e2, t2, i2) {
            this.id++;
            const r2 = this.id;
            return this.callbacks[r2] = { fn: e2, context: i2 }, this.getWorker().postMessage({ command: "timeout:start", timeout: t2, id: r2 }), r2;
          }
          clearInterval(e2) {
            this.getWorker().postMessage({ command: "interval:clear", id: e2 });
          }
          clearTimeout(e2) {
            this.getWorker().postMessage({ command: "timeout:clear", id: e2 });
          }
        }();
        t.default = s;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.Filters = void 0;
        const r = i(156), s = i(313), a = i(75), o = i(205), n = i(322), d = i(326), c = i(327), l = i(328), u = i(329);
        class h {
          constructor(e2) {
            this._alive = true, this.time = -1, this.lastTimer = performance.now(), this.webglLostContext = null, this._renderer = new s.Renderer({ canvas: e2, antialias: true }), this.map = a.createTexture(this._renderer.gl, null);
            const t2 = this._renderer.gl;
            this.webglLostContext = t2.getExtension("WEBGL_lose_context");
            const { posArray: i2, uvArray: h2, advBeautyIndicesArray: p, advBeautyPosArray: m, advBeautyZindexArray: g, advFaceMaskUVArray: f, advEyeTeethPosArray: v, advEyeTeethIndicesArray: S, advEyeTeethZindexArray: y, advEyeTeethUVArray: _ } = l.typedArray, R = r.createAttributeBuffer(t2, "position", i2, 2), b = r.createAttributeBuffer(t2, "uv", h2, 2), T = r.createAttributeBuffer(t2, "position", m, 2), E = r.createAttributeBuffer(t2, "zIndex", g, 1), A = r.createAttributeBuffer(t2, "indices", p, 1, "ELEMENT_ARRAY_BUFFER"), I = r.createAttributeBuffer(t2, "uv", f, 2), w = r.createAttributeBuffer(t2, "tPosition", v, 2), C = r.createAttributeBuffer(t2, "indices", S, 1, "ELEMENT_ARRAY_BUFFER"), O = r.createAttributeBuffer(t2, "zIndex", y, 1), k = r.createAttributeBuffer(t2, "uv", _, 2);
            this.advBeauty = new o.AdvBeautyFilter(this._renderer, this.map, T, E, A, I, R, b, w, C, O, k), this.beauty = new n.BeautyFilter(this._renderer, this.map, R, b), this.lut = new d.LutFilter(this._renderer, this.map, R, b), this.normal = new c.NormalFilter(this._renderer, this.map, R, b), this.virtualBackground = new u.VirtualBackFilter(this._renderer, this.map, R, b);
          }
          clone() {
            var e2;
            try {
              const t2 = new h(this._renderer.canvas);
              t2.mapSource = (null === (e2 = this.srcMap) || void 0 === e2 ? void 0 : e2.source) || null, this.advBeauty.remove(), t2.advBeauty.presetAdvEffect(Object.assign({}, this.advBeauty.params));
              const i2 = this.virtualBackground.lastSetInfo;
              return "bk" === i2.type ? t2.virtualBackground.setBackground(i2.value) : "blur" === i2.type && t2.virtualBackground.setBlurIntensity(i2.value), t2;
            } catch (e3) {
              return null;
            }
          }
          get filters() {
            return [this.advBeauty, this.beauty, this.lut, this.virtualBackground, this.normal];
          }
          get canvas() {
            return this._renderer.canvas;
          }
          get gl() {
            return this._renderer.gl;
          }
          get srcMap() {
            return this.map;
          }
          set mapSource(e2) {
            const t2 = this.map;
            t2 && (t2.source = e2, t2.refresh());
          }
          get isAlive() {
            return this._alive;
          }
          setSize(e2, t2) {
            this._renderer.setSize(e2, t2), this.filters.forEach((e3) => {
              e3.updateSize();
            });
          }
          render() {
            const e2 = this.filters;
            e2[0].map = this.map, e2[0].render(), e2[1].faceMask = e2[0].faceMask, e2[1].featureParas = e2[0].featureParas;
            for (let t2 = 1; t2 < e2.length; t2++) e2[t2].map = e2[t2 - 1].output, e2[t2].render();
          }
          update(e2 = true) {
            var t2;
            if (this._alive) {
              if (this.time < 0) this.time = 0, this.lastTimer = performance.now();
              else {
                const e3 = performance.now(), t3 = Math.min(e3 - this.lastTimer, 100);
                this.lastTimer = e3, this.time += t3 / 1e3;
              }
              e2 && (null === (t2 = this.map) || void 0 === t2 || t2.refresh()), this.render();
            }
          }
          destroy() {
            this._alive = false, this.time = -1;
            const e2 = this._renderer.gl;
            this.filters.forEach((e3) => {
              e3.destroy();
            }), null == e2 || e2.deleteTexture(this.map.glTexture);
          }
        }
        t.Filters = h;
      }, function(e, t, i) {
        "use strict";
        var r = this && this.__rest || function(e2, t2) {
          var i2 = {};
          for (var r2 in e2) Object.prototype.hasOwnProperty.call(e2, r2) && t2.indexOf(r2) < 0 && (i2[r2] = e2[r2]);
          if (null != e2 && "function" == typeof Object.getOwnPropertySymbols) {
            var s2 = 0;
            for (r2 = Object.getOwnPropertySymbols(e2); s2 < r2.length; s2++) t2.indexOf(r2[s2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, r2[s2]) && (i2[r2[s2]] = e2[r2[s2]]);
          }
          return i2;
        };
        Object.defineProperty(t, "__esModule", { value: true }), t.Renderer = void 0;
        const s = i(85);
        t.Renderer = class {
          constructor(e2) {
            this._gl = null, this._pixelRatio = 1, this._viewport = { x: 0, y: 0, width: 640, height: 480 };
            const t2 = Object.assign({ preserveDrawingBuffer: true, powerPreference: "high-performance" }, e2), { canvas: i2 = document.createElement("canvas"), width: a = 640, height: o = 480 } = t2, n = r(t2, ["canvas", "width", "height"]);
            this._canvas = i2, this._gl = s.getWebGLContext(i2, n);
            const d = this.setSize(a, o);
            this.setViewport(0, 0, d.width, d.height);
          }
          get canvas() {
            return this._canvas;
          }
          get gl() {
            return this._gl;
          }
          getPixelRatio() {
            var e2;
            return null !== (e2 = this._pixelRatio) && void 0 !== e2 ? e2 : 1;
          }
          setPixelRatio(e2) {
            const t2 = this.getPixelRatio();
            if (t2 === e2) return;
            const i2 = this.getSize();
            i2.width /= t2, i2.height /= t2, this._pixelRatio = e2, this.setSize(i2.width, i2.height);
          }
          getSize() {
            return { width: this.canvas.width, height: this.canvas.height };
          }
          setSize(e2, t2, i2 = false) {
            const r2 = this.canvas, s2 = this.getPixelRatio();
            return r2.width = e2 * s2, i2 && (r2.style.width = e2 + "px"), r2.height = t2 * s2, i2 && (r2.style.height = t2 + "px"), this.getSize();
          }
          getViewport() {
            return this._viewport;
          }
          setViewport(e2, t2, i2, r2) {
            var s2;
            this._viewport = { x: e2, y: t2, width: i2, height: r2 }, null === (s2 = this.gl) || void 0 === s2 || s2.viewport(e2, t2, i2, r2);
          }
          resize(e2, t2, i2, r2) {
            const s2 = this.setSize(e2, t2);
            i2 && this.setPixelRatio(i2), r2 ? this.setViewport(r2.x, r2.y, r2.width, r2.height) : this.setViewport(0, 0, s2.width, s2.height);
          }
          render(e2) {
            if (!this.gl) return;
            const t2 = this.gl;
            t2.enable(t2.CULL_FACE), e2.render();
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.defaultShader = void 0, t.defaultShader = { vShader: "\n    attribute vec4 position;\n    void main() {\n        gl_Position = position;\n    }\n", fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    void main() {\n        gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0);\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.createShader = void 0, t.createShader = function(e2, t2, i2) {
          const r = e2.createShader({ VERTEX: e2.VERTEX_SHADER, FRAGMENT: e2.FRAGMENT_SHADER }[i2]);
          if (!r) return console.error(i2 + "Shader was not created successfully."), null;
          if (e2.shaderSource(r, t2), e2.compileShader(r), e2.getShaderParameter(r, e2.COMPILE_STATUS)) return r;
          const s = t2.split("\n").map((e3, t3) => `${t3 + 1}${e3}`).join("\n");
          return console.error(`${e2.getShaderInfoLog(r)}
%cshader source code
${s}
`, "color: #008040"), e2.deleteShader(r), null;
        };
      }, function(e, t, i) {
        "use strict";
        function r(e2, t2, i2, r2, s, a) {
          var o;
          if (i2 === e2.FLOAT) return r2 ? (i3) => e2.uniform1fv(t2, i3) : (i3) => e2.uniform1f(t2, i3);
          const n = { [e2.FLOAT_VEC2]: (i3) => e2.uniform2fv(t2, i3), [e2.FLOAT_VEC3]: (i3) => e2.uniform3fv(t2, i3), [e2.FLOAT_VEC4]: (i3) => e2.uniform4fv(t2, i3) }[i2];
          if (n) return n;
          if (i2 === e2.INT || i2 === e2.BOOL) return r2 ? (i3) => e2.uniform1iv(t2, i3) : (i3) => e2.uniform1i(t2, i3);
          const d = { [e2.BOOL_VEC2]: e2.INT_VEC2, [e2.BOOL_VEC3]: e2.INT_VEC3, [e2.BOOL_VEC4]: e2.INT_VEC4 }, c = { [e2.INT_VEC2]: (i3) => e2.uniform2iv(t2, i3), [e2.INT_VEC3]: (i3) => e2.uniform3iv(t2, i3), [e2.INT_VEC4]: (i3) => e2.uniform4iv(t2, i3) }[null !== (o = d[i2]) && void 0 !== o ? o : i2];
          if (c) return c;
          const l = { [e2.FLOAT_MAT2]: (i3) => e2.uniformMatrix2fv(t2, false, i3), [e2.FLOAT_MAT3]: (i3) => e2.uniformMatrix3fv(t2, false, i3), [e2.FLOAT_MAT4]: (i3) => e2.uniformMatrix4fv(t2, false, i3) }[i2];
          if (l) return l;
          if (i2 === e2.SAMPLER_2D || i2 === e2.SAMPLER_CUBE) {
            const o2 = i2 === e2.SAMPLER_2D ? e2.TEXTURE_2D : e2.TEXTURE_CUBE_MAP;
            if (r2) {
              const i3 = [];
              for (let e3 = 0; e3 < s; e3++) i3.push(a.value++);
              return (r3) => {
                e2.uniform1iv(t2, i3), r3.forEach((t3, r4) => {
                  var s2;
                  e2.activeTexture(e2.TEXTURE0 + i3[r4]), e2.bindTexture(o2, null !== (s2 = null == t3 ? void 0 : t3.glTexture) && void 0 !== s2 ? s2 : null);
                });
              };
            }
            {
              const i3 = a.value++;
              return (r3) => {
                var s2;
                e2.uniform1i(t2, i3), e2.activeTexture(e2.TEXTURE0 + i3), e2.bindTexture(o2, null !== (s2 = null == r3 ? void 0 : r3.glTexture) && void 0 !== s2 ? s2 : null);
              };
            }
          }
          return () => {
            console.warn("no matching uniform setter.");
          };
        }
        Object.defineProperty(t, "__esModule", { value: true }), t.parseUniforms = void 0, t.parseUniforms = function(e2, t2) {
          const i2 = { value: 0 }, s = e2.getProgramParameter(t2, e2.ACTIVE_UNIFORMS), a = {};
          for (let o = 0; o < s; o++) {
            const s2 = e2.getActiveUniform(t2, o);
            if (s2) {
              const o2 = s2.size > 1, n = o2 ? s2.name.replace("[0]", "") : s2.name, d = s2.type, c = e2.getUniformLocation(t2, n);
              if (null !== c) {
                const t3 = r(e2, c, d, o2, s2.size, i2);
                a[n] = { type: d, size: s2.size, value: null, setter: (e3) => {
                  void 0 !== e3 ? a[n].value = e3 : t3(a[n].value);
                } };
              } else console.warn(`uniform:[${n}] is null.`);
            }
          }
          return a;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.advBeautyEyeShader = void 0, t.advBeautyEyeShader = { fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    uniform vec2 eyeCenter;\n    uniform vec2 rdDir;\n    uniform float rdIntensity;\n    uniform float lgIntensity;\n    uniform float intensRatio;\n    uniform float range;\n\n    varying vec2 vuv;\n\n    mat3 scaleByNormal(vec2 normal, float k, float refx, float refy){\n        float a = 1.0 + (k - 1.0) * normal.x * normal.x;\n        float b = (k - 1.0) * normal.x * normal.y;\n        float c = 1.0 + (k - 1.0) * normal.y * normal.y;\n        return mat3(\n            a, b, 0.0,\n            b, c, 0.0,\n            (1.0 - a) * refx - b * refy, (1.0 - c) * refy - b * refx, 1.0\n        );\n    }\n\n    vec2 lgEye(vec2 uv, vec2 center, float range, float strength, float powRatio) {\n        float dist = distance(uv, center);\n        if(dist > range){\n            return uv;\n        }\n        vec2 dir = normalize(uv - center);\n        float scale = 1. - strength + strength * pow(smoothstep(0., 1., dist / range), powRatio);\n        float newDist = dist * scale;\n        return center + newDist * dir;\n    }\n\n    vec2 rdEye(vec2 uv, vec2 center, float range, float strength, float powRatio){\n        float dist = distance(uv, center);\n        if(dist > range){\n            return uv;\n        }\n        float scale = 1. - strength + strength * pow(smoothstep(0., 1., dist / range), powRatio);\n        return (scaleByNormal(rdDir, scale, center.x, center.y) * vec3(uv, 1.0)).xy;\n    }\n\n    void main() {\n        vec2 uv = vuv;\n        if(intensRatio > 0.0){\n            if(rdIntensity > 0.0){\n                float maxRdIntens = mix(1.0, 0.5, lgIntensity);\n                float rdIntens = mix(0.0, maxRdIntens, rdIntensity * intensRatio);\n                uv = lgEye(uv, eyeCenter, range * 2.0, rdIntens, 0.075);\n                uv = rdEye(uv, eyeCenter, range * 2.0, rdIntens, 0.1);\n            }\n            if(lgIntensity > 0.0){\n                float lgIntens = lgIntensity * intensRatio;\n                uv = lgEye(uv, eyeCenter, range * 2.5, lgIntens, 0.1);\n                uv = rdEye(uv, eyeCenter, range * 2.5, lgIntens, 0.05);\n            }\n        }\n        gl_FragColor = texture2D(map, uv);\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.advBeautyShader = void 0, t.advBeautyShader = { vShader: "\n    uniform vec2 size;\n\n    attribute vec2 position;\n    attribute vec2 tPosition;\n    attribute float zIndex;\n\n    varying vec2 vuv;\n\n    vec2 npos(vec2 pos){\n        return pos / size;\n    }\n\n    float ndcx(float x){\n        return (x - 1.0) * 2.0 + 1.0;\n    }\n\n    float ndcy(float y){\n        return (1.0 - y) * 2.0 - 1.0;\n    }\n\n    vec2 ndcpos(vec2 pos){\n        return vec2(ndcx(pos.x), ndcy(pos.y));\n    }\n\n    void main() {\n        vec2 nPos = position;\n        vec2 ntPos = tPosition;\n        if(zIndex > -0.000001){\n            nPos = npos(nPos);\n            ntPos = npos(ntPos);\n        }\n        vec2 ndcPos = ndcpos(ntPos);\n        gl_Position = vec4(ndcPos, zIndex, 1.0);\n\n        vuv = nPos;\n        vuv.y = 1.0 - vuv.y;\n    }\n", fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform float showWire;\n    uniform vec2 size;\n    uniform sampler2D map;\n    uniform sampler2D wireMap;\n    uniform sampler2D eyeTeethMaskMap;\n    uniform sampler2D teethLut;\n    uniform float eyeIntensity;\n    uniform float teethIntensity;\n    varying vec2 vuv;\n\n    vec3 lut64(vec3 color, sampler2D lut){\n        float blue = color.b * 63.0;\n\n        vec2 q1;\n        float fb = floor(blue);\n        q1.y = floor(fb * 0.125);\n        q1.x = fb - (q1.y * 8.0);\n\n        vec2 q2;\n        float cb = ceil(blue);\n        q2.y = floor(cb * 0.125);\n        q2.x = cb - (q2.y * 8.0);\n\n        vec2 t = 0.123 * color.rg + vec2(0.000976563);\n        vec2 t1 = q1 * 0.125 + t;\n        vec3 p1 = texture2D(lut, t1).rgb;\n\n        vec2 t2 = q2 * 0.125 + t;\n        vec3 p2 = texture2D(lut, t2).rgb;\n\n        return mix(p1, p2, fract(blue));\n    }\n\n    void main() {\n        vec4 color = texture2D(map, vuv);\n        if(eyeIntensity > 0.0 || teethIntensity > 0.0){\n            vec4 eyeTeethMask = texture2D(eyeTeethMaskMap, vuv);\n            float teethInten = eyeTeethMask.r > 0.0 ? teethIntensity * eyeTeethMask.a : 0.0;\n            float eyeInten = eyeTeethMask.g > 0.0 ? eyeIntensity * eyeTeethMask.a : 0.0;\n            if(teethInten>0.0){\n                color.rgb = mix(color.rgb, lut64(color.rgb, teethLut), teethInten);\n            }\n            if(eyeInten>0.0){\n                vec2 step1 = vec2(size.x / 640.0 / size.x, 0.0);\n                vec2 step2 = vec2(0.0, size.y / 480.0 /size.y);\n                vec3 sumColor = vec3(0.0, 0.0, 0.0);\n                sumColor += texture2D(map, vuv - 2.0 * step1 - 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 2.0 * step1 - 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 2.0 * step1).rgb;\n                sumColor += texture2D(map, vuv - 2.0 * step1 + 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 2.0 * step1 + 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 1.0 * step1 - 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 1.0 * step1 - 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 1.0 * step1).rgb;\n                sumColor += texture2D(map, vuv - 1.0 * step1 + 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 1.0 * step1 + 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv - 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv).rgb;\n                sumColor += texture2D(map, vuv + 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 1.0 * step1 - 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 1.0 * step1 - 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 1.0 * step1).rgb;\n                sumColor += texture2D(map, vuv + 1.0 * step1 + 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 1.0 * step1 + 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 2.0 * step1 - 2.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 2.0 * step1 - 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 2.0 * step1).rgb;\n                sumColor += texture2D(map, vuv + 2.0 * step1 + 1.0 * step2).rgb;\n                sumColor += texture2D(map, vuv + 2.0 * step1 + 2.0 * step2).rgb;\n\n                sumColor = sumColor * 0.04;\n                sumColor = clamp(sumColor + (color.rgb - sumColor) * 2.0, 0.0, 1.0);\n                sumColor = max(color.rgb, sumColor);\n                color.rgb = mix(color.rgb, sumColor, eyeInten);\n                eyeInten = 1.0 + eyeInten * 0.25;\n                color.rgb = (color.rgb - vec3(0.5)) * eyeInten + vec3(0.5);\n            }\n        }\n        if(showWire > 0.5){\n            vec4 wire = texture2D(wireMap, vuv);\n            gl_FragColor = mix(color, wire, wire.a);\n        }else{\n            gl_FragColor = color;\n        }\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.advBeautyWireShader = void 0, t.advBeautyWireShader = { vShader: "\n    uniform vec2 size;\n\n    attribute vec2 position;\n\n    vec2 npos(vec2 pos){\n        return pos / size;\n    }\n\n    float ndcx(float x){\n        return (x - 1.0) * 2.0 + 1.0;\n    }\n\n    float ndcy(float y){\n        return (1.0 - y) * 2.0 - 1.0;\n    }\n\n    vec2 ndcpos(vec2 pos){\n        return vec2(ndcx(pos.x), ndcy(pos.y));\n    }\n\n    void main() {\n        vec2 nPos = npos(position);\n        vec2 ndcPos = ndcpos(nPos);\n        gl_Position = vec4(ndcPos, 0.0, 1.0);\n    }\n", fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n    void main() {\n        gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0);\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.advFaceMaskShader = void 0, t.advFaceMaskShader = { vShader: "\n    uniform vec2 size;\n\n    attribute vec2 tPosition;\n    attribute vec2 uv;\n    attribute float zIndex;\n\n    varying vec2 vuv;\n\n    vec2 npos(vec2 pos){\n        return pos / size;\n    }\n\n    float ndcx(float x){\n        return (x - 1.0) * 2.0 + 1.0;\n    }\n\n    float ndcy(float y){\n        return (1.0 - y) * 2.0 - 1.0;\n    }\n\n    vec2 ndcpos(vec2 pos){\n        return vec2(ndcx(pos.x), ndcy(pos.y));\n    }\n\n    void main() {\n        vec2 nPos = tPosition;\n        if(zIndex > -0.000001){\n            nPos = npos(nPos);\n        }\n        vec2 ndcPos = ndcpos(nPos);\n        gl_Position = vec4(ndcPos, zIndex, 1.0);\n        vuv = uv;\n    }\n", fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    uniform sampler2D maskMap;\n    uniform int index;\n    varying vec2 vuv;\n\n    void main() {\n      vec4 color = index == 0 ? vec4(0.0) : texture2D(map, vuv);\n      vec4 mask = texture2D(maskMap, vuv);\n      float a = 1.0 - (1.0 - color.a) * (1.0 - mask.a);\n      vec3 rgb = max(color.rgb, mask.rgb);\n      gl_FragColor = vec4(rgb, a);\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.handlers = t.preHandle = t.Matrix3x3 = t.Vector2 = void 0;
        class r {
          constructor(e2, t2) {
            this.value = [0, 0], this.value = [e2, t2];
          }
          get x() {
            return this.value[0];
          }
          set x(e2) {
            this.value[0] = e2;
          }
          get y() {
            return this.value[1];
          }
          set y(e2) {
            this.value[1] = e2;
          }
          get lengthPow2() {
            return Math.pow(this.x, 2) + Math.pow(this.y, 2);
          }
          get length() {
            return Math.sqrt(this.lengthPow2);
          }
          static getVec(e2, t2) {
            const i2 = 2 * t2;
            if (i2 < 0) throw new Error("index out range");
            const s2 = i2 + 1;
            if (s2 >= e2.length) throw new Error("index out range");
            return new r(e2[i2], e2[s2]);
          }
          static setPoint(e2, t2, i2) {
            const r2 = 2 * t2;
            if (r2 < 0) throw new Error("index out range");
            const s2 = r2 + 1;
            if (s2 >= e2.length) throw new Error("index out range");
            e2[r2] = i2.value[0], e2[s2] = i2.value[1];
          }
          static normalize(e2) {
            const t2 = Math.sqrt(e2.value[0] * e2.value[0] + e2.value[1] * e2.value[1]);
            return new r(e2.value[0] / t2, e2.value[1] / t2);
          }
          static add(e2, t2) {
            return new r(e2.value[0] + t2.value[0], e2.value[1] + t2.value[1]);
          }
          static sub(e2, t2) {
            return new r(e2.value[0] - t2.value[0], e2.value[1] - t2.value[1]);
          }
          static scale(e2, t2) {
            return new r(e2.value[0] * t2, e2.value[1] * t2);
          }
          static scaleByAxis(e2, t2, i2) {
            return new r(e2.x * t2, e2.y * i2);
          }
          static disPow2(e2, t2) {
            const i2 = e2.value, r2 = t2.value, s2 = i2[0] - r2[0], a2 = i2[1] - r2[1];
            return s2 * s2 + a2 * a2;
          }
          static dis(e2, t2) {
            return Math.sqrt(r.disPow2(e2, t2));
          }
          static lerp(e2, t2, i2) {
            if (!e2 || !t2) return e2 || t2;
            const s2 = e2.value, a2 = t2.value;
            return new r(s2[0] + (a2[0] - s2[0]) * i2, s2[1] + (a2[1] - s2[1]) * i2);
          }
          static intersectPoint(e2, t2, i2, s2) {
            const a2 = e2.value, o2 = t2.value, n2 = i2.value, d = s2.value, c = n2[0] - d[0], l = a2[0] - o2[0], u = n2[1] - d[1], h = a2[1] - o2[1], p = l * u - h * c;
            if (0 == p) return null;
            const m = a2[0] * o2[1] - a2[1] * o2[0], g = n2[0] * d[1] - n2[1] * d[0];
            return new r((m * c - l * g) / p, (m * u - h * g) / p);
          }
          static center(...e2) {
            const t2 = e2.length;
            if (!t2) return new r(0, 0);
            if (1 === t2) return new r(...e2[0].value);
            if (2 === t2) return new r((e2[0].value[0] + e2[1].value[0]) / 2, (e2[0].value[1] + e2[1].value[1]) / 2);
            let i2 = 0, s2 = 0, a2 = 0;
            for (let r2 = t2 - 1, o3 = 0; o3 < t2; r2 = o3, o3++) {
              const t3 = e2[r2].value, n3 = e2[o3].value, d = t3[0] * n3[1] - n3[0] * t3[1];
              i2 += d, s2 += (n3[0] + t3[0]) * d, a2 += (n3[1] + t3[1]) * d;
            }
            let o2 = 0, n2 = 0;
            return 0 != i2 && (o2 = s2 / (3 * i2), n2 = a2 / (3 * i2)), new r(o2, n2);
          }
          static dot(e2, t2) {
            return e2.x * t2.x + e2.y * t2.y;
          }
          static cross(e2, t2) {
            return e2.x * t2.y - t2.x * e2.y;
          }
          static angle(e2, t2) {
            const i2 = r.normalize(e2), s2 = r.normalize(t2);
            return Math.acos(Math.min(1, Math.max(-1, r.dot(i2, s2))));
          }
          static fromToAngle(e2, t2) {
            return r.cross(e2, t2) < 0 ? -r.angle(e2, t2) : r.angle(e2, t2);
          }
        }
        t.Vector2 = r;
        class s {
          constructor(e2, t2, i2, r2, s2, a2, o2, n2, d) {
            this.matrix = [[e2, t2, i2], [r2, s2, a2], [o2, n2, d]];
          }
          get a() {
            return this.matrix[0][0];
          }
          set a(e2) {
            this.matrix[0][0] = e2;
          }
          get b() {
            return this.matrix[1][0];
          }
          set b(e2) {
            this.matrix[1][0] = e2;
          }
          get c() {
            return this.matrix[0][1];
          }
          set c(e2) {
            this.matrix[0][1] = e2;
          }
          get d() {
            return this.matrix[1][1];
          }
          set d(e2) {
            this.matrix[1][1] = e2;
          }
          get e() {
            return this.matrix[0][2];
          }
          set e(e2) {
            this.matrix[0][2] = e2;
          }
          get f() {
            return this.matrix[1][2];
          }
          set f(e2) {
            this.matrix[1][2] = e2;
          }
          get transpose() {
            let e2 = this.matrix;
            return new s(e2[0][0], e2[1][0], e2[2][0], e2[0][1], e2[1][1], e2[2][1], e2[0][2], e2[1][2], e2[2][2]);
          }
          multiplyPoint(e2) {
            let t2 = e2.x, i2 = e2.y, s2 = t2 * this.matrix[0][0] + i2 * this.matrix[0][1] + this.matrix[0][2], a2 = t2 * this.matrix[1][0] + i2 * this.matrix[1][1] + this.matrix[1][2], o2 = t2 * this.matrix[2][0] + i2 * this.matrix[2][1] + this.matrix[2][2];
            return new r(s2 / o2, a2 / o2);
          }
          multiplyVector(e2) {
            let t2 = e2.x, i2 = e2.y, s2 = t2 * this.matrix[0][0] + i2 * this.matrix[0][1], a2 = t2 * this.matrix[1][0] + i2 * this.matrix[1][1];
            return new r(s2, a2);
          }
          static identity() {
            return new s(1, 0, 0, 0, 1, 0, 0, 0, 1);
          }
          static rotate(e2, t2, i2) {
            let r2 = Math.cos(e2), a2 = Math.sin(e2), o2 = s.identity();
            return o2.matrix[0][0] = r2, o2.matrix[0][1] = -a2, o2.matrix[1][0] = a2, o2.matrix[1][1] = r2, o2.matrix[0][2] = t2 * (1 - r2) + i2 * a2, o2.matrix[1][2] = i2 * (1 - r2) - t2 * a2, o2;
          }
          static scaleByNormal(e2, t2, i2, a2) {
            e2 = r.normalize(e2);
            let o2 = 1 + (t2 - 1) * Math.pow(e2.x, 2), n2 = (t2 - 1) * e2.x * e2.y, d = 1 + (t2 - 1) * Math.pow(e2.y, 2);
            return new s(o2, n2, (1 - o2) * i2 - n2 * a2, n2, d, (1 - d) * a2 - n2 * i2, 0, 0, 1);
          }
        }
        t.Matrix3x3 = s;
        let a, o, n = true;
        t.preHandle = (e2) => {
          a = r.getVec(e2, 74), o = r.getVec(e2, 77);
        }, t.handlers = { eyeAngle: (e2, t2) => {
          const i2 = 0.06 * (t2 - 0.5) * Math.PI, n2 = s.rotate(i2, a.x, a.y);
          [52, 53, 54, 55, 56, 57, 72, 73].forEach((t3) => {
            const i3 = n2.multiplyPoint(r.getVec(e2, t3));
            r.setPoint(e2, t3, i3);
          });
          const d = s.rotate(-i2, o.x, o.y);
          [58, 59, 60, 61, 62, 63, 75, 76].forEach((t3) => {
            const i3 = d.multiplyPoint(r.getVec(e2, t3));
            r.setPoint(e2, t3, i3);
          });
        }, openCanthus: (e2, t2) => {
          t2 *= 0.05;
          const i2 = r.getVec(e2, 43), s2 = r.getVec(e2, 46);
          let a2 = r.getVec(e2, 55), o2 = r.getVec(e2, 58);
          const n2 = r.intersectPoint(i2, s2, a2, o2) || i2;
          a2 = r.lerp(a2, n2, t2), o2 = r.lerp(o2, n2, t2), r.setPoint(e2, 55, a2), r.setPoint(e2, 58, o2), [54, 56, 59, 63].forEach((i3) => {
            let s3 = r.getVec(e2, i3);
            s3 = r.lerp(s3, i3 < 57 ? a2 : o2, 0.05 * t2), r.setPoint(e2, i3, s3);
          });
        }, eyeDistance: (e2, t2) => {
          t2 = 0.1 * (t2 - 0.5);
          const i2 = r.getVec(e2, 43), s2 = r.scale(r.sub(a, i2), t2), n2 = r.scale(r.sub(o, i2), t2);
          [52, 53, 54, 55, 56, 57, 72, 73, 74].forEach((t3) => {
            const i3 = r.add(r.getVec(e2, t3), s2);
            r.setPoint(e2, t3, i3);
          }), [58, 59, 60, 61, 62, 63, 75, 76, 77].forEach((t3) => {
            const i3 = r.add(r.getVec(e2, t3), n2);
            r.setPoint(e2, t3, i3);
          }), a = r.getVec(e2, 74), o = r.getVec(e2, 77);
        }, roundedEye: (e2, t2) => (n = false, a = r.center(...[52, 53, 54, 55, 56, 57, 72, 73].map((t3) => r.getVec(e2, t3))), o = r.center(...[58, 59, 60, 61, 62, 63, 75, 76].map((t3) => r.getVec(e2, t3))), { lEyeCenter: a, rEyeCenter: o }), enlargeEye: (e2, t2) => (n ? (a = r.center(...[52, 53, 54, 55, 56, 57, 72, 73].map((t3) => r.getVec(e2, t3))), o = r.center(...[58, 59, 60, 61, 62, 63, 75, 76].map((t3) => r.getVec(e2, t3)))) : n = true, { lEyeCenter: a, rEyeCenter: o }), shrinkNose: (e2, t2) => {
          t2 *= 0.15;
          const i2 = r.getVec(e2, 46);
          [80, 81, 82, 83].forEach((s3) => {
            r.setPoint(e2, s3, r.lerp(r.getVec(e2, s3), i2, t2));
          });
          const s2 = r.getVec(e2, 49);
          [47, 51].forEach((i3) => {
            r.setPoint(e2, i3, r.lerp(r.getVec(e2, i3), s2, t2));
          });
        }, lengthenNose: (e2, t2) => {
          t2 = 0.25 * (t2 - 0.5);
          const i2 = [80, 81, 82, 83, 47, 51], s2 = r.getVec(e2, 46), a2 = [];
          i2.forEach((t3) => {
            a2.push(r.sub(r.getVec(e2, t3), s2));
          });
          const o2 = r.getVec(e2, 49), n2 = r.lerp(o2, r.getVec(e2, 87), t2);
          r.setPoint(e2, 49, n2);
          const d = r.sub(n2, o2), c = r.add(s2, d);
          r.setPoint(e2, 46, c), a2.forEach((t3, s3) => {
            const a3 = r.add(c, t3);
            r.setPoint(e2, i2[s3], a3);
          });
        }, shrinkMouth: (e2, t2) => {
          const i2 = 1 + 0.25 * (t2 -= 0.65), s2 = 1 + 0.2 * t2, a2 = [1, 0.7, 0.2, 0, 0.2, 0.7, 1, 0.66, 0.33, 0, 0.33, 0.66], o2 = [1, 0.66, 0, 0.66, 1, 0.66, 0, 0.66], n2 = [84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95], d = [96, 97, 98, 99, 100, 101, 102, 103], c = [], l = [];
          n2.forEach((t3) => {
            c.push(r.getVec(e2, t3));
          }), d.forEach((t3) => {
            l.push(r.getVec(e2, t3));
          });
          const u = r.center(...c);
          c.forEach((t3, o3) => {
            const d2 = a2[o3], c2 = i2 * d2 + s2 * (1 - d2);
            r.setPoint(e2, n2[o3], r.add(u, r.scale(r.sub(t3, u), c2)));
          }), l.forEach((t3, a3) => {
            const n3 = o2[a3], c2 = i2 * n3 + s2 * (1 - n3);
            r.setPoint(e2, d[a3], r.add(u, r.scale(r.sub(t3, u), c2)));
          });
        }, widenMouth: (e2, t2) => {
          t2 -= 0.5, t2 *= t2 < 0 ? 0.3 : 0.2;
          const i2 = r.getVec(e2, 90), a2 = r.getVec(e2, 84), o2 = r.getVec(e2, 87), n2 = r.getVec(e2, 93), d = r.intersectPoint(i2, a2, o2, n2) || r.center(o2, n2), c = s.scaleByNormal(r.sub(d, a2), t2 + 1, d.x, d.y), l = s.scaleByNormal(r.sub(d, i2), t2 + 1, d.x, d.y);
          [84, 96, 85, 95, 97, 103, 86, 94].forEach((t3) => {
            r.setPoint(e2, t3, c.multiplyPoint(r.getVec(e2, t3)));
          }), [90, 100, 89, 91, 99, 101, 88, 92].forEach((t3) => {
            r.setPoint(e2, t3, l.multiplyPoint(r.getVec(e2, t3)));
          });
        }, mouthCorners: (e2, t2) => {
          const i2 = 0.06 * (t2 - 0.5) * Math.PI, a2 = r.center(...[84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95].map((t3) => r.getVec(e2, t3)));
          let o2 = s.rotate(i2, a2.value[0], a2.value[1]), n2 = s.rotate(0.66 * i2, a2.value[0], a2.value[1]), d = s.rotate(0.33 * i2, a2.value[0], a2.value[1]), c = s.rotate(0.1 * i2, a2.value[0], a2.value[1]), l = [o2, n2, c, d, n2, o2, n2, n2];
          [84, 85, 86, 94, 95, 96, 97, 103].forEach((t3, i3) => {
            const s2 = l[i3].multiplyPoint(r.getVec(e2, t3));
            r.setPoint(e2, t3, s2);
          }), o2 = s.rotate(-i2, a2.value[0], a2.value[1]), n2 = s.rotate(0.66 * -i2, a2.value[0], a2.value[1]), d = s.rotate(0.33 * -i2, a2.value[0], a2.value[1]), c = s.rotate(0.1 * -i2, a2.value[0], a2.value[1]), l = [o2, n2, c, d, n2, o2, n2, n2], [90, 89, 88, 92, 91, 100, 99, 101].forEach((t3, i3) => {
            const s2 = l[i3].multiplyPoint(r.getVec(e2, t3));
            r.setPoint(e2, t3, s2);
          });
        }, adjustPhiltrum: (e2, t2) => {
          t2 = 0.25 * (t2 - 0.5);
          const i2 = r.getVec(e2, 87), s2 = r.scale(r.sub(r.getVec(e2, 49), i2), t2);
          for (let t3 = 84; t3 < 104; t3++) r.setPoint(e2, t3, r.add(r.getVec(e2, t3), s2));
        }, shrinkUnderjaw: (e2, t2) => {
          const i2 = t2 *= 0.1, s2 = t2, a2 = r.getVec(e2, 16), o2 = r.getVec(e2, 49), n2 = r.getVec(e2, 0), d = r.getVec(e2, 32), c = [[6, 26], [8, 24], [10, 22], [12, 20], [14, 18]], l = [], u = [], h = [];
          c.forEach((t3) => {
            const i3 = r.getVec(e2, t3[0]), s3 = r.getVec(e2, t3[1]);
            l.push([i3, s3]), u.push(r.intersectPoint(i3, o2, n2, a2)), h.push(r.intersectPoint(s3, o2, d, a2));
          });
          const p = [0.33, 0.66, 1, 0.66, 0.33];
          l.forEach((t3, a3) => {
            const o3 = r.lerp(t3[0], u[a3], i2 * p[a3]), n3 = r.lerp(t3[1], h[a3], s2 * p[a3]);
            r.setPoint(e2, c[a3][0], o3), r.setPoint(e2, c[a3][1], n3);
          });
        }, shrinkCheekbone: (e2, t2) => {
          const i2 = t2 *= 0.08, s2 = t2, a2 = r.getVec(e2, 43), o2 = r.getVec(e2, 49), n2 = [[0, 32], [2, 30], [4, 28], [6, 26], [8, 24]], d = [], c = [];
          n2.forEach((t3) => {
            const i3 = r.getVec(e2, t3[0]), s3 = r.getVec(e2, t3[1]);
            d.push([i3, s3]), c.push(r.intersectPoint(i3, s3, a2, o2));
          });
          const l = [0.33, 0.66, 0.33, 0.22, 0.11];
          d.forEach((t3, a3) => {
            const o3 = r.lerp(t3[0], c[a3], i2 * l[a3]), d2 = r.lerp(t3[1], c[a3], s2 * l[a3]);
            r.setPoint(e2, n2[a3][0], o3), r.setPoint(e2, n2[a3][1], d2);
          });
        }, lengthenJaw: (e2, t2) => {
          t2 = 0.1 * (0.5 - t2);
          const i2 = r.getVec(e2, 16), s2 = r.sub(r.getVec(e2, 49), i2), a2 = [0.5, 0.5];
          [12, 20, 14, 16, 18].forEach((i3, o2) => {
            r.setPoint(e2, i3, r.add(r.getVec(e2, i3), r.scale(s2, t2 * (a2[o2] || 1))));
          });
        }, narrowedFace: (e2, t2) => {
          const i2 = t2 *= 0.05, s2 = t2, a2 = r.getVec(e2, 43), o2 = r.getVec(e2, 16), n2 = [0.33, 0.66, 1];
          [[106, 111], [0, 32], [2, 30], [4, 28], [6, 26], [8, 24], [10, 22], [12, 20], [14, 18]].forEach((t3, d) => {
            let c = r.getVec(e2, t3[0]), l = r.getVec(e2, t3[1]), u = r.intersectPoint(c, l, a2, o2);
            const h = n2[d] || 1;
            c = r.lerp(c, u, i2 * h), l = r.lerp(l, u, s2 * h), r.setPoint(e2, t3[0], c), r.setPoint(e2, t3[1], l);
          });
        }, shrinkFace: (e2, t2) => {
          const i2 = t2 *= 0.1, s2 = t2, a2 = r.getVec(e2, 43), o2 = r.getVec(e2, 16);
          let n2 = [[2, 30], [4, 28], [6, 26], [8, 24], [10, 22], [12, 20], [14, 18]], d = [0.1, 0.325, 0.55, 0.775, 1, 0.9, 0.8, 0.7];
          n2.forEach((t3, n3) => {
            let c2 = r.getVec(e2, t3[0]), l = r.getVec(e2, t3[1]), u = r.intersectPoint(c2, l, a2, o2);
            c2 = r.lerp(c2, u, i2 * d[n3]), l = r.lerp(l, u, s2 * d[n3]), r.setPoint(e2, t3[0], c2), r.setPoint(e2, t3[1], l);
          });
          const c = r.getVec(e2, 93);
          n2 = [[14, 18], [12, 20]], d = [0.4, 0.2], n2.forEach((t3, a3) => {
            let o3 = r.getVec(e2, t3[0]), n3 = r.getVec(e2, t3[1]);
            o3 = r.lerp(o3, c, i2 * d[a3]), n3 = r.lerp(n3, c, s2 * d[a3]), r.setPoint(e2, t3[0], o3), r.setPoint(e2, t3[1], n3);
          }), r.setPoint(e2, 16, r.lerp(r.getVec(e2, 16), c, 0.6 * Math.max(i2, s2)));
        }, vShapedFace: (e2, t2) => {
          const i2 = t2 *= 0.2, s2 = t2, a2 = r.getVec(e2, 16), o2 = r.getVec(e2, 2), n2 = r.getVec(e2, 30), d = [[4, 28], [6, 26], [8, 24], [10, 22], [12, 20], [14, 18]], c = [], l = [], u = [];
          d.forEach((t3) => {
            const i3 = r.getVec(e2, t3[0]), s3 = r.getVec(e2, t3[1]);
            c.push([i3, s3]), l.push(r.intersectPoint(i3, s3, o2, a2)), u.push(r.intersectPoint(s3, i3, n2, a2));
          });
          const h = [0.33, 0.66];
          c.forEach((t3, a3) => {
            const o3 = r.lerp(t3[0], l[a3], i2 * (h[a3] || 1)), n3 = r.lerp(t3[1], u[a3], s2 * (h[a3] || 1));
            r.setPoint(e2, d[a3][0], o3), r.setPoint(e2, d[a3][1], n3);
          });
        }, minifyFace: (e2, t2) => {
          t2 *= 0.1;
          const i2 = r.getVec(e2, 43), s2 = r.getVec(e2, 49), a2 = r.getVec(e2, 2), o2 = r.getVec(e2, 30), n2 = r.lerp(r.intersectPoint(i2, s2, a2, o2), i2, t2);
          let d = [0.1, 0.25, 0.4, 0.55, 0.7, 0.85];
          [4, 6, 8, 10, 12, 14, 84, 85, 86, 94, 95, 96, 97, 103, 47, 80, 82].forEach((i3, s3) => {
            const a3 = r.lerp(r.getVec(e2, i3), n2, t2 * (d[s3] || 0.65));
            r.setPoint(e2, i3, a3);
          }), [28, 26, 24, 22, 20, 18, 88, 89, 90, 91, 92, 99, 100, 101, 51, 81, 83].forEach((i3, s3) => {
            const a3 = r.lerp(r.getVec(e2, i3), n2, t2 * (d[s3] || 0.65));
            r.setPoint(e2, i3, a3);
          }), d = [1], [16, 93, 102, 98, 87, 49, 46].forEach((i3, s3) => {
            const a3 = r.lerp(r.getVec(e2, i3), n2, t2 * (d[s3] || 0.65));
            r.setPoint(e2, i3, a3);
          });
        }, shortenFace: (e2, t2) => {
          t2 *= 0.1;
          const i2 = r.getVec(e2, 43), a2 = r.getVec(e2, 49), o2 = r.center(i2, a2) || r.getVec(e2, 45), n2 = s.scaleByNormal(r.sub(i2, a2), 1 - t2, o2.x, o2.y);
          for (let t3 = 4; t3 < 30; t3 += 2) r.setPoint(e2, t3, n2.multiplyPoint(r.getVec(e2, t3)));
          for (let t3 = 80; t3 < 84; t3++) r.setPoint(e2, t3, n2.multiplyPoint(r.getVec(e2, t3)));
          for (let t3 = 46; t3 < 52; t3++) r.setPoint(e2, t3, n2.multiplyPoint(r.getVec(e2, t3)));
          for (let t3 = 84; t3 < 104; t3++) r.setPoint(e2, t3, n2.multiplyPoint(r.getVec(e2, t3)));
        }, whitenTeeth: (e2, t2) => {
          let i2 = r.dis(r.getVec(e2, 98), r.getVec(e2, 102)) / (r.dis(r.getVec(e2, 96), r.getVec(e2, 100)) || 1);
          return t2 * Math.max(0, Math.min(1, Math.pow(5 * i2, 2)));
        } };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.BeautyFilter = void 0;
        const r = i(134), s = i(135), a = i(75), o = i(136), n = i(323), d = i(324), c = i(325), l = i(206), u = i(137), h = {};
        class p extends u.Filter {
          constructor(e2, t2, i2, r2) {
            super(e2, t2, i2, r2), this._smooth = 0, this._whiten = 0, this._redden = 0, this._faceMask = null, this._featureParas = { forehead: 0, eyeRim: 0, noseLine: 0 }, this.featureEnable = false, this.whitenMap = a.createTexture(e2.gl, null, { flipY: false }), this.reddenMap = a.createTexture(e2.gl, null, { flipY: false });
            const { programs: s2, framebuffers: o2 } = this.initProgramsBuffers();
            this.programs = s2, this.framebuffers = o2, this.initUniforms();
          }
          initProgramsBuffers() {
            const e2 = this.renderer.gl, t2 = this.renderer.getSize(), i2 = {}, a2 = {}, u2 = { blurX: { vShader: d.beautyBlurShader.vShader, fShader: d.beautyBlurShader.fShader, size: { width: t2.width >> 1, height: t2.height >> 1 } }, blurY: { vShader: d.beautyBlurShader.vShader, fShader: d.beautyBlurShader.fShader, size: { width: t2.width >> 1, height: t2.height >> 1 } }, highPass: { vShader: o.baseTextureShader.vShader, fShader: c.beautyHighPassShader.fShader, size: t2 }, hBlurX: { vShader: d.beautyBlurShader.vShader, fShader: d.beautyBlurShader.fShader, size: t2 }, hBlurY: { vShader: d.beautyBlurShader.vShader, fShader: d.beautyBlurShader.fShader, size: t2 }, beauty: { vShader: o.baseTextureShader.vShader, fShader: n.beautyShader.fShader, size: t2 }, whiten: { vShader: o.baseTextureShader.vShader, fShader: l.lutShader.fShader, size: t2 }, redden: { vShader: o.baseTextureShader.vShader, fShader: l.lutShader.fShader, size: t2 } };
            for (const t3 in u2) {
              const { vShader: o2, fShader: n2, size: d2 } = u2[t3], c2 = new s.Program(e2);
              c2.setShader(o2, "VERTEX"), c2.setShader(n2, "FRAGMENT"), c2.setAttributeBuffer(this.posBuffer), c2.setAttributeBuffer(this.uvBuffer), i2[t3] = c2;
              const l2 = r.createFrameBuffer(e2, d2.width, d2.height);
              a2[t3] = l2;
            }
            return { programs: i2, framebuffers: a2 };
          }
          initUniforms() {
            const e2 = this.programs, t2 = this.framebuffers, i2 = this.map, { width: r2, height: s2 } = this.renderer.getSize(), a2 = [r2, s2], o2 = [r2 >> 1, s2 >> 1];
            e2.blurX.setUniform("map", i2), e2.blurX.setUniform("size", o2), e2.blurY.setUniform("map", t2.blurX.targetTexture), e2.blurY.setUniform("size", o2), e2.blurY.setUniform("isVertical", 1), e2.highPass.setUniform("map", i2), e2.highPass.setUniform("blurMap", t2.blurY.targetTexture), e2.hBlurX.setUniform("map", t2.highPass.targetTexture), e2.hBlurX.setUniform("size", a2), e2.hBlurY.setUniform("map", t2.hBlurX.targetTexture), e2.hBlurY.setUniform("size", a2), e2.hBlurY.setUniform("isVertical", 1), e2.beauty.setUniform("size", a2), e2.beauty.setUniform("map", i2), e2.beauty.setUniform("blurMap", t2.blurY.targetTexture), e2.beauty.setUniform("highPassMap", t2.hBlurY.targetTexture), e2.beauty.setUniform("intensity", 0);
            const n2 = this.featureParas;
            for (const t3 in n2) e2.beauty.setUniform(t3 + "Inten", this._featureParas[t3]);
            e2.whiten.setUniform("map", i2), e2.whiten.setUniform("lut", this.whitenMap), e2.whiten.setUniform("intensity", 0), e2.redden.setUniform("map", i2), e2.redden.setUniform("lut", this.reddenMap), e2.redden.setUniform("intensity", 0);
          }
          get map() {
            return super.map;
          }
          set map(e2) {
            e2 !== this._map && (this._map = e2, ["blurX", "highPass", "beauty"].forEach((e3) => {
              this.programs[e3].setUniform("map", this._map);
            }), this.mapChange());
          }
          setLutsSrc(e2, t2) {
            const { whiten: i2, redden: r2 } = e2;
            let s2 = 2;
            const o2 = [], n2 = () => {
              s2 -= 1, s2 <= 0 && (null == t2 || t2(o2));
            };
            if (h.whiten) {
              this.whitenMap.source = h.whiten, this.whitenMap.refresh();
              const e3 = this._whiten;
              this._whiten = 0, this.whiten = e3, n2();
            } else a.retryLoadImage(i2, 3, (e3) => {
              h.whiten = e3, this.whitenMap.source = e3, this.whitenMap.refresh();
              const t3 = this._whiten;
              this._whiten = 0, this.whiten = t3, n2();
            }, () => {
              o2.push(i2), n2();
            });
            if (h.redden) {
              this.reddenMap.source = h.redden, this.reddenMap.refresh();
              const e3 = this._redden;
              this._redden = 0, this.redden = e3, n2();
            } else a.retryLoadImage(r2, 3, (e3) => {
              h.redden = e3, this.reddenMap.source = e3, this.reddenMap.refresh();
              const t3 = this._redden;
              this._redden = 0, this.redden = t3, n2();
            }, () => {
              o2.push(r2), n2();
            });
          }
          get smoothOut() {
            return this.smooth || this.featureEnable ? this.framebuffers.beauty.targetTexture : this.map;
          }
          get whitenOut() {
            return this.whiten ? this.framebuffers.whiten.targetTexture : this.smoothOut;
          }
          mapChange() {
            this.programs.whiten.setUniform("map", this.smoothOut), this.programs.redden.setUniform("map", this.whitenOut);
          }
          get smooth() {
            return this._smooth;
          }
          set smooth(e2) {
            this._smooth !== e2 && (this._smooth = e2, this.programs.beauty.setUniform("intensity", this._smooth), this.mapChange());
          }
          get whiten() {
            return this._whiten;
          }
          set whiten(e2) {
            this._whiten !== e2 && (this._whiten = e2, this.programs.whiten.setUniform("intensity", this.whitenMap && this.whitenMap.source ? this._whiten : 0), this.mapChange());
          }
          get redden() {
            return this._redden;
          }
          set redden(e2) {
            this._redden !== e2 && (this._redden = e2, this.programs.redden.setUniform("intensity", this.reddenMap && this.reddenMap.source ? this._redden : 0));
          }
          set faceMask(e2) {
            this._faceMask !== e2 && (this.programs.beauty.setUniform("maskMap", e2), this.programs.beauty.setUniform("hasMask", e2 ? 1 : 0), this._faceMask = e2);
          }
          set featureParas(e2) {
            let t2 = 0;
            for (const i2 in e2) {
              const r2 = e2[i2];
              t2 += r2, this._featureParas[i2] !== r2 && (this.programs.beauty.setUniform(i2 + "Inten", r2), this._featureParas[i2] = r2);
            }
            this.featureEnable = t2 > 0, this.mapChange();
          }
          get output() {
            return this.redden ? this.framebuffers.redden.targetTexture : this.whiten ? this.framebuffers.whiten.targetTexture : this.smooth || this.featureEnable ? this.framebuffers.beauty.targetTexture : super.output;
          }
          updateSize() {
            const e2 = this.renderer.getSize(), t2 = [e2.width, e2.height], i2 = [e2.width >> 1, e2.height >> 1];
            ["blurX", "blurY"].forEach((e3) => {
              const t3 = this.framebuffers[e3];
              t3.targetTexture.opts.width = i2[0], t3.targetTexture.opts.height = i2[1], t3.targetTexture.refresh();
              this.programs[e3].setUniform("size", i2);
            }), ["highPass", "hBlurX", "hBlurY", "beauty", "whiten", "redden"].forEach((e3) => {
              const i3 = this.framebuffers[e3];
              if (i3.targetTexture.opts.width = t2[0], i3.targetTexture.opts.height = t2[1], i3.targetTexture.refresh(), ["highPass", "whiten", "redden"].indexOf(e3) < 0) {
                this.programs[e3].setUniform("size", t2);
              }
            });
          }
          render() {
            const e2 = this.renderer, { width: t2, height: i2 } = e2.getSize(), r2 = this.programs, s2 = this.framebuffers;
            (this.smooth || this.featureEnable) && (e2.setViewport(0, 0, t2 >> 1, i2 >> 1), s2.blurX.bind(), e2.render(r2.blurX), s2.blurY.bind(), e2.render(r2.blurY), e2.setViewport(0, 0, t2, i2), s2.highPass.bind(), e2.render(r2.highPass), s2.hBlurX.bind(), e2.render(r2.hBlurX), s2.hBlurY.bind(), e2.render(r2.hBlurY), s2.beauty.bind(), e2.render(r2.beauty)), this.whiten && (s2.whiten.bind(), e2.render(r2.whiten)), this.redden && (s2.redden.bind(), e2.render(r2.redden));
          }
          destroy() {
            super.destroy();
            const e2 = this.renderer.gl;
            null == e2 || e2.deleteTexture(this.whitenMap.glTexture), null == e2 || e2.deleteTexture(this.reddenMap.glTexture);
          }
        }
        t.BeautyFilter = p;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.beautyShader = void 0, t.beautyShader = { fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform vec2 size;\n\n    uniform sampler2D map;\n    uniform sampler2D blurMap;\n    uniform sampler2D highPassMap;\n    uniform sampler2D maskMap;\n    uniform int hasMask;\n\n    // 磨皮度\n    uniform float intensity;\n    uniform float foreheadInten;\n    uniform float eyeRimInten;\n    uniform float noseLineInten;\n\n    varying vec2 vuv;\n\n    void main() {\n        vec4 originColor = texture2D(map, vuv);\n        float _intensity = intensity;\n        if(hasMask > 0){\n            vec4 mask = texture2D(maskMap, vuv);\n            float intens = max(max(mask.r * noseLineInten, mask.g * foreheadInten), mask.b * eyeRimInten);\n            if(intens > 0.0){\n              _intensity = mix(_intensity, 1.5, intens);\n            }else{\n              _intensity *= mask.a;\n            }\n        }\n        if(_intensity > 0.0){\n            vec2 stepOffset = 0.5 / size;\n            float uOffsetX = stepOffset.x;\n            float uOffsetY = stepOffset.y;\n            float strength = _intensity * 1.0;\n\n            vec4 meanColor = texture2D(blurMap, vuv);\n            vec4 varColor = texture2D(highPassMap, vuv);\n\n            float value = clamp((min(originColor.r, meanColor.r - 0.1) - 0.2) * 4.0, 0.0, 1.0);\n            float meanValue = (varColor.r + varColor.g + varColor.b) / 3.0;\n            float currentIntensity = (1.0 - meanValue / (meanValue + 0.1)) * value * strength;\n            vec3 resultColor = mix(originColor.rgb, meanColor.rgb, currentIntensity);\n            float sum = 0.25*originColor.g;\n            sum += 0.125 *texture2D(map,vec2(vuv.x-uOffsetX, vuv.y)).g;\n            sum += 0.125 *texture2D(map,vec2(vuv.x+uOffsetX, vuv.y)).g;\n            sum += 0.125 *texture2D(map,vec2(vuv.x, vuv.y-uOffsetY)).g;\n            sum += 0.125 *texture2D(map,vec2(vuv.x, vuv.y+uOffsetY)).g;\n            sum += 0.0625*texture2D(map,vec2(vuv.x+uOffsetX, vuv.y+uOffsetY)).g;\n            sum += 0.0625*texture2D(map,vec2(vuv.x+uOffsetX, vuv.y-uOffsetY)).g;\n            sum += 0.0625*texture2D(map,vec2(vuv.x-uOffsetX, vuv.y+uOffsetY)).g;\n            sum += 0.0625*texture2D(map,vec2(vuv.x-uOffsetX, vuv.y-uOffsetY)).g;\n\n            float hPass = originColor.g - sum + 0.5;\n            float flag = step(0.5, hPass);\n            vec3 color = mix(max(vec3(0.0), (2.0*hPass + resultColor - 1.0)), min(vec3(1.0), (resultColor + 2.0*hPass - 1.0)), flag);\n\n            gl_FragColor = vec4(mix(resultColor.rgb, color.rgb, _intensity), 1.0);\n        }else{\n            gl_FragColor = originColor;\n        }\n    }" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.beautyBlurShader = void 0, t.beautyBlurShader = { vShader: "\n    uniform vec2 size;\n    uniform float isVertical;\n\n    attribute vec4 position;\n    attribute vec2 uv;\n\n    varying vec2 vuv;\n    varying vec4 vTextureShift1;\n	varying vec4 vTextureShift2;\n	varying vec4 vTextureShift3;\n	varying vec4 vTextureShift4;\n\n    void main() {\n        gl_Position = position;\n        vuv = uv;\n        // 偏移步距\n        vec2 stepOffset = 1.0 / size;\n        if(isVertical> 0.5){\n            stepOffset.x = 0.0;\n        }else{\n            stepOffset.y = 0.0;\n        }\n\n        vTextureShift1 = vec4(uv - stepOffset, uv + stepOffset);\n		vTextureShift2 = vec4(uv- 2.0 * stepOffset, uv + 2.0 * stepOffset);\n		vTextureShift3 = vec4(uv - 3.0 * stepOffset, uv + 3.0 * stepOffset);\n		vTextureShift4 = vec4(uv - 4.0 * stepOffset, uv + 4.0 * stepOffset);\n    }\n", fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n\n    varying vec2 vuv;\n    varying vec4 vTextureShift1;\n	varying vec4 vTextureShift2;\n	varying vec4 vTextureShift3;\n	varying vec4 vTextureShift4;\n\n    void main() {\n        vec4 color = texture2D(map, vuv);\n\n        vec3 sum = color.rgb;\n        sum += texture2D(map, vTextureShift1.xy).rgb;\n		sum += texture2D(map, vTextureShift1.zw).rgb;\n		sum += texture2D(map, vTextureShift2.xy).rgb;\n		sum += texture2D(map, vTextureShift2.zw).rgb;\n		sum += texture2D(map, vTextureShift3.xy).rgb;\n		sum += texture2D(map, vTextureShift3.zw).rgb;\n		sum += texture2D(map, vTextureShift4.xy).rgb;\n		sum += texture2D(map, vTextureShift4.zw).rgb;\n\n        gl_FragColor = vec4(sum * 0.1111, 1.0);\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.beautyHighPassShader = void 0, t.beautyHighPassShader = { fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    uniform sampler2D blurMap;\n\n    varying vec2 vuv;\n\n    void main() {\n        vec4 color = texture2D(map, vuv);\n        vec4 blurColor = texture2D(blurMap, vuv);\n        vec3 diffColor = (color.rgb - blurColor.rgb) * 6.0;\n        diffColor = diffColor * diffColor;\n        diffColor = min(diffColor, 1.0);\n        gl_FragColor = vec4(diffColor, 1.0);\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.LutFilter = void 0;
        const r = i(134), s = i(135), a = i(75), o = i(136), n = i(206), d = i(137), c = {};
        class l extends d.Filter {
          constructor(e2, t2, i2, r2) {
            super(e2, t2, i2, r2), this.lutImgs = {}, this.curLutName = null, this.lutMap = a.createTexture(e2.gl, null, { flipY: false });
            const { program: s2, framebuffer: o2 } = this.initProgramBuffer();
            this.programs.main = s2, this.framebuffers.main = o2;
          }
          initProgramBuffer() {
            const e2 = this.renderer.gl, t2 = this.renderer.getSize(), i2 = new s.Program(e2);
            i2.setShader(o.baseTextureShader.vShader, "VERTEX"), i2.setShader(n.lutShader.fShader, "FRAGMENT"), i2.setAttributeBuffer(this.posBuffer), i2.setAttributeBuffer(this.uvBuffer);
            const a2 = r.createFrameBuffer(e2, t2.width, t2.height);
            return i2.setUniform("map", this.map), i2.setUniform("lut", this.lutMap), i2.setUniform("intensity", 0), { program: i2, framebuffer: a2 };
          }
          getLutImg(e2) {
            var t2;
            return e2 && null !== (t2 = this.lutImgs[e2]) && void 0 !== t2 ? t2 : null;
          }
          get map() {
            return this._map;
          }
          set map(e2) {
            this._map !== e2 && (this._map = e2, this.programs.main.setUniform("map", this._map));
          }
          setLutsSrc(e2, t2) {
            let i2 = Object.keys(e2).length;
            const r2 = [], s2 = () => {
              i2 -= 1, i2 <= 0 && (null == t2 || t2(r2));
            };
            for (const t3 in e2) {
              const { src: i3, intensity: o2 = 0.5 } = e2[t3];
              this.lutImgs[t3] = { img: null, intensity: o2 }, c[t3] ? (this.lutImgs[t3].img = c[t3], t3 === this.curLutName && (this.curLutName = null, this.setlut(t3)), s2()) : a.retryLoadImage(i3, 3, (e3) => {
                c[t3] = e3, this.lutImgs[t3].img = e3, t3 === this.curLutName && (this.curLutName = null, this.setlut(t3)), s2();
              }, () => {
                r2.push(i3), s2();
              });
            }
          }
          get output() {
            return this.intensity ? this.framebuffers.main.targetTexture : super.output;
          }
          updateSize() {
            const e2 = this.renderer.getSize(), t2 = this.framebuffers.main;
            t2.targetTexture.opts.width = e2.width, t2.targetTexture.opts.height = e2.height, t2.targetTexture.refresh();
          }
          setlut(e2, t2) {
            if (e2 !== this.curLutName) {
              this.curLutName = e2;
              const t3 = this.getLutImg(this.curLutName);
              t3 && (this.lutMap.source = t3.img, this.lutMap.refresh());
            }
            t2 = null != t2 ? t2 : this.intensity, this.intensity = t2;
          }
          get intensity() {
            const e2 = this.getLutImg(this.curLutName);
            return e2 ? e2.intensity : 0;
          }
          set intensity(e2) {
            const t2 = this.getLutImg(this.curLutName);
            t2 ? (t2.intensity = e2, t2.img ? this.programs.main.setUniform("intensity", this.intensity) : this.programs.main.setUniform("intensity", 0)) : this.programs.main.setUniform("intensity", 0);
          }
          render() {
            this.intensity && (this.framebuffers.main.bind(), this.renderer.render(this.programs.main));
          }
          destroy() {
            var e2;
            super.destroy(), null === (e2 = this.renderer.gl) || void 0 === e2 || e2.deleteTexture(this.lutMap.glTexture);
          }
        }
        t.LutFilter = l;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.NormalFilter = void 0;
        const r = i(134), s = i(135), a = i(136), o = i(137);
        class n extends o.Filter {
          constructor(e2, t2, i2, r2) {
            super(e2, t2, i2, r2), this._srcMap = null, this.pixels = null, this.initProgram();
          }
          initProgram() {
            const e2 = this.renderer.gl;
            let t2 = this.renderer.getSize();
            const i2 = new s.Program(e2);
            i2.setShader(a.baseTextureShader.vShader, "VERTEX"), i2.setShader(a.baseTextureShader.yFlipFShader, "FRAGMENT"), i2.setAttributeBuffer(this.posBuffer), i2.setAttributeBuffer(this.uvBuffer);
            const o2 = r.createFrameBuffer(e2, t2.width, t2.height);
            i2.setUniform("map", this._srcMap), this.programs.imgData = i2, this.framebuffers.imgData = o2;
            const n2 = new s.Program(e2);
            n2.setShader(a.baseTextureShader.vShader, "VERTEX"), n2.setShader(a.baseTextureShader.fShader, "FRAGMENT"), n2.setAttributeBuffer(this.posBuffer), n2.setAttributeBuffer(this.uvBuffer), n2.setUniform("map", this._map), this.programs.main = n2;
          }
          getImageData(e2) {
            e2 !== this._srcMap && (this._srcMap = e2, this.programs.imgData.setUniform("map", this._srcMap)), this._srcMap && this._srcMap.refresh();
            const t2 = this.renderer, { width: i2, height: r2 } = t2.getSize(), s2 = t2.gl;
            return this.framebuffers.imgData.bind(), t2.render(this.programs.imgData), this.pixels && this.pixels.length === i2 * r2 * 4 || (this.pixels = new Uint8Array(i2 * r2 * 4)), s2.readPixels(0, 0, i2, r2, s2.RGBA, s2.UNSIGNED_BYTE, this.pixels), this.framebuffers.imgData.bind(true), this.pixels;
          }
          get map() {
            return this._map;
          }
          set map(e2) {
            this._map !== e2 && (this._map = e2, this.programs.main.setUniform("map", this._map));
          }
          updateSize() {
            const e2 = this.renderer.getSize(), t2 = this.framebuffers.imgData;
            t2 && (t2.targetTexture.opts.width = e2.width, t2.targetTexture.opts.height = e2.height, t2.targetTexture.refresh());
          }
          render() {
            const e2 = this.renderer, { width: t2, height: i2 } = e2.getSize(), r2 = e2.gl;
            e2.setViewport(0, 0, t2, i2), r2.bindFramebuffer(r2.FRAMEBUFFER, null), e2.render(this.programs.main);
          }
        }
        t.NormalFilter = n;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.typedArray = void 0, t.typedArray = { posArray: new Int8Array([-1, 1, -1, -1, 1, 1, 1, -1]), uvArray: new Uint8Array([0, 1, 0, 0, 1, 1, 1, 0]), advBeautyPosArray: new Int16Array((() => {
          const e2 = [];
          for (let t2 = 0; t2 < 145; t2++) e2.push(0, 0);
          return e2.push(0, 0, 0, 1, 1, 1, 1, 0), e2;
        })()), advBeautyZindexArray: new Int16Array((() => {
          const e2 = [];
          for (let t2 = 0; t2 < 145; t2++) e2.push(0);
          return e2.push(-1, -1, -1, -1), e2;
        })()), advBeautyIndicesArray: new Uint16Array([145, 146, 147, 145, 147, 148, 0, 2, 52, 52, 2, 57, 57, 2, 4, 57, 4, 73, 73, 4, 80, 73, 80, 56, 56, 80, 55, 55, 80, 43, 67, 55, 43, 67, 54, 55, 66, 54, 67, 66, 72, 54, 65, 72, 66, 65, 53, 72, 64, 53, 65, 64, 52, 53, 33, 52, 64, 0, 52, 33, 33, 64, 34, 34, 64, 65, 34, 65, 35, 35, 65, 66, 35, 66, 36, 36, 66, 67, 36, 67, 37, 53, 52, 57, 53, 57, 73, 53, 73, 72, 72, 73, 56, 72, 56, 54, 54, 56, 55, 37, 67, 43, 37, 43, 38, 38, 43, 68, 68, 43, 58, 58, 43, 81, 43, 46, 81, 81, 46, 83, 46, 51, 83, 46, 49, 51, 46, 47, 49, 46, 82, 47, 80, 82, 46, 43, 80, 46, 43, 55, 80, 67, 55, 43, 38, 68, 39, 39, 68, 69, 39, 69, 40, 40, 69, 70, 40, 70, 41, 41, 70, 71, 41, 71, 42, 32, 61, 30, 30, 61, 62, 30, 62, 28, 62, 76, 28, 76, 81, 28, 63, 81, 76, 58, 81, 63, 43, 81, 58, 43, 58, 68, 68, 58, 59, 68, 59, 69, 69, 59, 75, 69, 75, 70, 70, 75, 60, 70, 60, 71, 71, 60, 61, 71, 61, 42, 42, 61, 32, 59, 58, 63, 59, 63, 76, 59, 76, 75, 75, 76, 62, 75, 62, 60, 60, 62, 61, 4, 82, 80, 4, 6, 82, 6, 8, 82, 82, 8, 84, 8, 10, 84, 84, 10, 12, 84, 12, 95, 95, 12, 14, 95, 14, 94, 94, 14, 93, 93, 14, 16, 93, 16, 18, 93, 18, 92, 92, 18, 20, 92, 20, 91, 91, 20, 90, 90, 20, 22, 90, 22, 24, 90, 24, 83, 83, 24, 26, 83, 26, 28, 83, 28, 81, 106, 0, 33, 106, 33, 34, 107, 106, 34, 107, 34, 35, 108, 107, 35, 108, 35, 36, 109, 108, 36, 109, 36, 37, 110, 109, 37, 116, 110, 37, 116, 37, 38, 115, 116, 38, 114, 115, 38, 114, 38, 39, 113, 114, 39, 113, 39, 40, 112, 113, 40, 112, 40, 41, 111, 112, 41, 111, 41, 42, 111, 42, 32, 82, 84, 47, 47, 84, 85, 47, 85, 86, 47, 86, 49, 49, 86, 87, 49, 87, 88, 49, 88, 51, 51, 88, 89, 51, 89, 90, 83, 51, 90, 85, 84, 96, 85, 96, 97, 85, 97, 86, 86, 97, 87, 87, 97, 98, 87, 98, 99, 87, 99, 88, 88, 99, 89, 89, 99, 100, 89, 100, 90, 100, 91, 90, 101, 91, 100, 101, 92, 91, 102, 92, 101, 102, 93, 92, 102, 94, 93, 103, 94, 102, 103, 95, 94, 96, 95, 103, 84, 95, 96, 96, 103, 97, 97, 103, 102, 97, 102, 98, 98, 102, 99, 99, 102, 101, 99, 101, 100, 0, 117, 118, 0, 118, 2, 2, 118, 119, 2, 119, 4, 4, 119, 120, 4, 120, 6, 6, 120, 121, 6, 121, 8, 8, 121, 122, 8, 122, 10, 10, 122, 123, 10, 123, 12, 12, 123, 124, 12, 124, 14, 14, 124, 125, 14, 125, 16, 16, 125, 126, 16, 126, 18, 18, 126, 127, 18, 127, 20, 20, 127, 128, 20, 128, 22, 22, 128, 129, 22, 129, 24, 24, 129, 130, 24, 130, 26, 26, 130, 131, 26, 131, 28, 28, 131, 132, 28, 132, 30, 30, 132, 133, 30, 133, 32, 106, 134, 117, 106, 117, 0, 107, 135, 134, 107, 134, 106, 108, 136, 135, 108, 135, 107, 109, 137, 136, 109, 136, 108, 110, 138, 137, 110, 137, 109, 116, 144, 138, 116, 138, 110, 115, 143, 144, 115, 144, 116, 114, 142, 143, 114, 143, 115, 113, 141, 142, 113, 142, 114, 112, 140, 141, 112, 141, 113, 111, 139, 140, 111, 140, 112, 32, 133, 139, 32, 139, 111]), advFaceMaskUVArray: new Float32Array([0.30859375, 0.58203125, 0.30859375, 0.5546875, 0.310546875, 0.52734375, 0.3125, 0.5, 0.314453125, 0.47265625, 0.318359375, 0.4453125, 0.322265625, 0.41796875, 0.330078125, 0.392578125, 0.337890625, 0.369140625, 0.349609375, 0.34765625, 0.365234375, 0.328125, 0.380859375, 0.310546875, 0.400390625, 0.296875, 0.419921875, 0.28515625, 0.44140625, 0.27734375, 0.46484375, 0.271484375, 0.486328125, 0.26953125, 0.509765625, 0.271484375, 0.533203125, 0.275390625, 0.5546875, 0.283203125, 0.578125, 0.29296875, 0.59765625, 0.306640625, 0.6171875, 0.32421875, 0.634765625, 0.341796875, 0.650390625, 0.36328125, 0.662109375, 0.388671875, 0.669921875, 0.4140625, 0.67578125, 0.44140625, 0.6796875, 0.46875, 0.68359375, 0.49609375, 0.685546875, 0.525390625, 0.6875, 0.552734375, 0.6875, 0.580078125, 0.33984375, 0.634765625, 0.36328125, 0.66796875, 0.392578125, 0.673828125, 0.421875, 0.671875, 0.451171875, 0.6640625, 0.521484375, 0.666015625, 0.55078125, 0.671875, 0.58203125, 0.673828125, 0.611328125, 0.666015625, 0.63671875, 0.634765625, 0.486328125, 0.60546875, 0.484375, 0.568359375, 0.482421875, 0.533203125, 0.482421875, 0.498046875, 0.443359375, 0.47265625, 0.462890625, 0.46875, 0.484375, 0.46484375, 0.505859375, 0.470703125, 0.52734375, 0.474609375, 0.369140625, 0.599609375, 0.384765625, 0.611328125, 0.421875, 0.611328125, 0.4375, 0.59765625, 0.419921875, 0.591796875, 0.384765625, 0.591796875, 0.537109375, 0.59765625, 0.552734375, 0.611328125, 0.591796875, 0.611328125, 0.607421875, 0.59765625, 0.591796875, 0.591796875, 0.5546875, 0.591796875, 0.36328125, 0.646484375, 0.392578125, 0.650390625, 0.421875, 0.6484375, 0.451171875, 0.642578125, 0.521484375, 0.642578125, 0.55078125, 0.6484375, 0.580078125, 0.6484375, 0.611328125, 0.64453125, 0.40234375, 0.615234375, 0.400390625, 0.58984375, 0.40234375, 0.6015625, 0.57421875, 0.615234375, 0.57421875, 0.58984375, 0.572265625, 0.6015625, 0.4609375, 0.6015625, 0.51171875, 0.6015625, 0.443359375, 0.521484375, 0.5234375, 0.5234375, 0.431640625, 0.490234375, 0.537109375, 0.4921875, 0.416015625, 0.392578125, 0.44140625, 0.41796875, 0.470703125, 0.427734375, 0.486328125, 0.427734375, 0.5, 0.4296875, 0.53125, 0.419921875, 0.55859375, 0.39453125, 0.537109375, 0.375, 0.51171875, 0.36328125, 0.484375, 0.361328125, 0.4609375, 0.36328125, 0.4375, 0.375, 0.421875, 0.392578125, 0.453125, 0.408203125, 0.484375, 0.412109375, 0.51953125, 0.41015625, 0.552734375, 0.39453125, 0.51953125, 0.388671875, 0.484375, 0.38671875, 0.453125, 0.38671875, 0.40234375, 0.599609375, 0.57421875, 0.599609375, 0.3046875, 0.634765625, 0.31640625, 0.685546875, 0.341796875, 0.734375, 0.380859375, 0.7734375, 0.431640625, 0.802734375, 0.6875, 0.638671875, 0.671875, 0.693359375, 0.642578125, 0.7421875, 0.599609375, 0.78125, 0.546875, 0.806640625, 0.48828125, 0.81640625, 0.25390625, 0.576171875, 0.2578125, 0.50390625, 0.26171875, 0.43359375, 0.271484375, 0.36328125, 0.29296875, 0.298828125, 0.328125, 0.24609375, 0.373046875, 0.205078125, 0.427734375, 0.1796875, 0.486328125, 0.169921875, 0.546875, 0.177734375, 0.60546875, 0.19921875, 0.65625, 0.240234375, 0.69921875, 0.291015625, 0.724609375, 0.357421875, 0.736328125, 0.427734375, 0.744140625, 0.501953125, 0.74609375, 0.57421875, 0.25, 0.64453125, 0.263671875, 0.7109375, 0.296875, 0.7734375, 0.34765625, 0.82421875, 0.4140625, 0.86328125, 0.74609375, 0.650390625, 0.7265625, 0.720703125, 0.689453125, 0.783203125, 0.6328125, 0.833984375, 0.564453125, 0.8671875, 0.48828125, 0.880859375, 0, 0, 0, 0, 0, 0, 0, 0]), advEyeTeethPosArray: new Int16Array(48), advEyeTeethZindexArray: new Int16Array(24), advEyeTeethUVArray: new Float32Array([0.927, 0.789, 0.772, 0.877, 0.49, 0.91, 0.269, 0.872, 0.078, 0.764, 0.272, 0.61, 0.506, 0.559, 0.738, 0.611, 0.927, 0.789, 0.772, 0.877, 0.49, 0.91, 0.269, 0.872, 0.078, 0.764, 0.272, 0.61, 0.506, 0.559, 0.738, 0.611, 0.067, 0.28, 0.267, 0.389, 0.512, 0.364, 0.754, 0.389, 0.933, 0.29, 0.76, 0.159, 0.497, 0.112, 0.243, 0.156]), advEyeTeethIndicesArray: new Uint16Array([1, 0, 7, 1, 7, 6, 1, 6, 2, 2, 6, 5, 2, 5, 3, 3, 5, 4, 11, 12, 13, 11, 13, 14, 11, 14, 10, 10, 14, 15, 10, 15, 9, 9, 15, 8, 16, 23, 17, 17, 23, 22, 17, 22, 18, 18, 22, 19, 19, 22, 21, 19, 21, 20]), advForeheadPosArray: new Int16Array(98), advForeheadZindexArray: new Int16Array(49), advForeheadUVArray: new Float32Array([0.12, 0.564, 0.181, 0.619, 0.26, 0.628, 0.341, 0.616, 0.41, 0.592, 0.597, 0.592, 0.666, 0.616, 0.747, 0.628, 0.827, 0.619, 0.887, 0.564, 0.051, 0.638, 0.101, 0.753, 0.154, 0.853, 0.236, 0.933, 0.355, 0.955, 0.504, 0.956, 0.652, 0.955, 0.771, 0.933, 0.853, 0.853, 0.907, 0.753, 0.956, 0.638, 0.155, 0.266, 0.281, 0.306, 0.441, 0.371, 0.598, 0.395, 0.694, 0.334, 0.763, 0.247, 0.134, 0.379, 0.242, 0.427, 0.401, 0.49, 0.604, 0.522, 0.749, 0.455, 0.87, 0.3, 0.306, 0.251, 0.397, 0.232, 0.497, 0.217, 0.593, 0.23, 0.673, 0.262, 0.356, 0.104, 0.491, 0.024, 0.652, 0.11, 0.306, 0.251, 0.397, 0.232, 0.497, 0.217, 0.593, 0.23, 0.673, 0.262, 0.356, 0.104, 0.491, 0.024, 0.652, 0.11]), advForeheadIndicesArray: new Uint16Array([18, 0, 1, 11, 18, 1, 11, 1, 2, 12, 11, 2, 12, 2, 3, 13, 12, 3, 13, 3, 4, 14, 13, 4, 14, 4, 15, 15, 4, 5, 16, 15, 5, 17, 16, 5, 17, 5, 6, 17, 6, 18, 18, 6, 7, 19, 18, 7, 19, 7, 8, 20, 19, 8, 20, 8, 9, 27, 21, 28, 28, 21, 22, 29, 28, 22, 29, 22, 23, 30, 29, 23, 30, 23, 24, 31, 30, 24, 31, 24, 25, 32, 31, 25, 32, 25, 26]) };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.VirtualBackFilter = void 0;
        const r = i(134), s = i(330), a = i(135), o = i(75), n = i(136), d = i(331), c = i(332), l = i(137);
        class u extends l.Filter {
          constructor(e2, t2, i2, r2) {
            super(e2, t2, i2, r2), this.intensity = 0.1, this.lastSetInfo = {}, this.sourceMap = t2, this.maskMap = o.createTexture(e2.gl, null), this.bkColor = new s.GlColor("#e7ad3c"), this.bkMap = o.createTexture(e2.gl, null), this.initProgramBuffer();
          }
          initProgramBuffer() {
            const e2 = this.renderer.gl, t2 = this.renderer.getSize(), i2 = [o.toNthPower(t2.width), o.toNthPower(t2.height)], s2 = new a.Program(e2);
            s2.setShader(n.baseTextureShader.vShader, "VERTEX"), s2.setShader(n.baseTextureShader.fShader, "FRAGMENT"), s2.setAttributeBuffer(this.posBuffer), s2.setAttributeBuffer(this.uvBuffer);
            const l2 = r.createFrameBuffer(e2, i2[0], i2[1], true);
            s2.setUniform("map", this.sourceMap), this.programs.mip = s2, this.framebuffers.mip = l2;
            const u2 = new a.Program(e2);
            u2.setShader(n.baseTextureShader.vShader, "VERTEX"), u2.setShader(d.mipMapBlurShader.fShader, "FRAGMENT"), u2.setAttributeBuffer(this.posBuffer), u2.setAttributeBuffer(this.uvBuffer);
            const h = r.createFrameBuffer(e2, t2.width, t2.height);
            u2.setUniform("map", l2.targetTexture), u2.setUniform("radius", 0.25 * Math.max(t2.width, t2.height)), u2.setUniform("intensity", 0.1), this.programs.blur = u2, this.framebuffers.blur = h;
            const p = new a.Program(e2);
            p.setShader(n.baseTextureShader.vShader, "VERTEX"), p.setShader(c.virtualBackShader.fShader, "FRAGMENT"), p.setAttributeBuffer(this.posBuffer), p.setAttributeBuffer(this.uvBuffer);
            const m = r.createFrameBuffer(e2, t2.width, t2.height);
            p.setUniform("map", this.map), p.setUniform("maskMap", this.maskMap), p.setUniform("backColor", this.bkColor.value), p.setUniform("backMap", this.bkMap), p.setUniform("size", [t2.width, t2.height]), p.setUniform("bkSize", [0, 0]), p.setUniform("backType", 0), p.setUniform("emptyFrame", 0), this.programs.main = p, this.framebuffers.main = m;
          }
          get map() {
            return this._map;
          }
          set map(e2) {
            this._map !== e2 && (this._map = e2, this.programs.main.setUniform("map", this._map));
          }
          set emptyFrame(e2) {
            this.programs.main.setUniform("emptyFrame", e2 ? 1 : 0);
          }
          setMaskMap(e2) {
            const t2 = this.maskMap;
            t2 && (t2.source = e2, t2.refresh());
          }
          setBkColor(e2) {
            this.bkColor.setValue(e2 || "#e7ad3c"), this.programs.main.setUniform("backColor", this.bkColor.value);
          }
          getBkInfo() {
            const e2 = this.bkMap, t2 = e2 ? e2.source : null, i2 = { type: "color", size: [0, 0] };
            return t2 && ("videoWidth" in t2 ? (i2.type = "video", i2.size = [t2.videoWidth, t2.videoHeight]) : t2 instanceof Image && (i2.type = "image", i2.size = [t2.naturalWidth, t2.naturalHeight])), i2;
          }
          setBkMap(e2) {
            const t2 = this.bkMap;
            t2 && (e2 instanceof Image || null === e2 ? (t2.source = e2, t2.refresh()) : "readyState" in e2 && (e2.readyState < 2 ? setTimeout(() => {
              this.setBkMap(e2);
            }, 16.7) : (t2.source = e2, t2.refresh())));
          }
          setBackground(e2) {
            const t2 = typeof e2;
            "string" === t2 || null === e2 ? (this.setBkColor(e2), this.setBkMap(null)) : "object" === t2 && (this.setBkColor(null), this.setBkMap(e2));
            const i2 = this.getBkInfo();
            this.programs.main.setUniform("backType", "color" === i2.type ? 0 : 1), "color" !== i2.type && (this.programs.main.setUniform("backMap", this.bkMap), this.programs.main.setUniform("bkSize", i2.size)), this.lastSetInfo = { type: "bk", value: e2 };
          }
          setBlurIntensity(e2) {
            const t2 = this.renderer.getSize();
            e2 = Math.max(0.1, Math.min(1, e2)), this.programs.blur.setUniform("intensity", e2), this.programs.main.setUniform("backMap", this.framebuffers.blur.targetTexture), this.programs.main.setUniform("bkSize", [t2.width, t2.height]), this.programs.main.setUniform("backType", 1), this.lastSetInfo = { type: "blur", value: e2 };
          }
          get output() {
            return this.maskMap && this.maskMap.source ? this.framebuffers.main.targetTexture : super.output;
          }
          updateSize() {
            const e2 = this.renderer.getSize(), t2 = [o.toNthPower(e2.width), o.toNthPower(e2.height)];
            ["blur", "main"].forEach((t3) => {
              const i3 = this.framebuffers[t3];
              i3.targetTexture.opts.width = e2.width, i3.targetTexture.opts.height = e2.height, i3.targetTexture.refresh();
            });
            const i2 = this.framebuffers.mip;
            i2.targetTexture.opts.width = t2[0], i2.targetTexture.opts.height = t2[1], i2.targetTexture.refresh(), this.programs.main.setUniform("size", [e2.width, e2.height]), this.programs.blur.setUniform("radius", 0.25 * Math.max(e2.width, e2.height)), this.programs.main.getUniform("backMap").value === i2.targetTexture && this.programs.main.setUniform("bkSize", t2);
          }
          render() {
            var e2;
            if (this.maskMap && this.maskMap.source) {
              const t2 = this.renderer;
              if (this.programs.main.getUniform("backMap").value === this.framebuffers.blur.targetTexture) {
                const e3 = t2.getSize(), i2 = this.framebuffers.mip.targetTexture;
                t2.setViewport(0, 0, i2.opts.width, i2.opts.height), this.framebuffers.mip.bind(), this.programs.mip.render(), this.framebuffers.mip.targetTexture.updateMipMap(), t2.setViewport(0, 0, e3.width, e3.height), this.framebuffers.blur.bind(), this.programs.blur.render();
              } else {
                "video" === this.getBkInfo().type && (null === (e2 = this.bkMap) || void 0 === e2 || e2.refresh());
              }
              this.framebuffers.main.bind(), this.programs.main.render();
            }
          }
          destroy() {
            var e2, t2;
            super.destroy(), null === (e2 = this.renderer.gl) || void 0 === e2 || e2.deleteTexture(this.maskMap.glTexture), null === (t2 = this.renderer.gl) || void 0 === t2 || t2.deleteTexture(this.bkMap.glTexture);
          }
        }
        t.VirtualBackFilter = u;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.GlColor = void 0;
        t.GlColor = class {
          constructor(e2) {
            this._color = [1, 1, 1, 1], this.convert(e2);
          }
          convert(e2) {
            if ("string" == typeof e2) {
              if (/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/i.test(e2)) {
                if (4 === e2.length) {
                  let t3 = "#";
                  for (let i2 = 1; i2 < 4; i2 += 1) t3 += e2.slice(i2, i2 + 1).concat(e2.slice(i2, i2 + 1));
                  e2 = t3;
                }
                const t2 = [];
                for (let i2 = 1; i2 < 7; i2 += 2) t2.push(parseInt("0x" + e2.slice(i2, i2 + 2)));
                return void this.convert(t2);
              }
              console.error(`color:[${e2}] format is error.`);
            } else this._color = e2.map((e3, t2) => t2 < 3 ? Math.min(Math.max(Number(e3), 0), 255) / 255 : Math.min(Math.max(Number(Number(null != e3 ? e3 : 1)), 0), 1));
          }
          get value() {
            return this._color;
          }
          setValue(e2) {
            this.convert(e2);
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.mipMapBlurShader = void 0, t.mipMapBlurShader = { fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    uniform float intensity;\n    uniform float radius;\n    varying vec2 vuv;\n\n    float weight(float t, float log2radius, float gamma)\n    {\n        return exp(-gamma*pow(log2radius-t,2.));\n    }\n\n    vec3 sample_blured(vec2 uv, float radius, float gamma)\n    {\n        vec3 pix = vec3(0.);\n        float norm = 0.;\n        for(float i = 0.; i < 10.; i += 0.5)\n        {\n            float k = weight(i, log2(radius), gamma);\n            pix += k * texture2D(map, uv, i).rgb;\n            norm += k;\n        }\n        return pix*pow(norm,-0.95);\n    }\n\n    void main() {\n        gl_FragColor = vec4(sample_blured(vuv, mix(8.0, radius, intensity), intensity), 1.0);\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.virtualBackShader = void 0, t.virtualBackShader = { fShader: "\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D map;\n    uniform sampler2D maskMap;\n    uniform sampler2D backMap;\n    uniform vec3 backColor;\n    uniform vec2 size;\n    uniform vec2 bkSize;\n    uniform int backType;\n    uniform int emptyFrame;\n\n    varying vec2 vuv;\n\n    void main() {\n        if(emptyFrame > 0){\n            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        }else{\n            vec3 color = texture2D(map, vuv).rgb;\n            float alpha = texture2D(maskMap, vuv).a;\n\n            vec3 bk = backColor;\n            // 背景图\n            if(backType == 1){\n                float ratio = size.x / size.y;\n                float bkRatio = bkSize.x / bkSize.y;\n                vec2 suv = vuv;\n                if(ratio > bkRatio){\n                    suv.y = (suv.y - 0.5) * bkRatio / ratio + 0.5;\n                }else{\n                    suv.x = (suv.x - 0.5) * ratio / bkRatio + 0.5;\n                }\n                bk = texture2D(backMap, suv).rgb;\n            }\n\n            gl_FragColor = vec4(mix(bk, color, alpha), 1.0);\n        }\n    }\n" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = i(3), s = i(205);
        class a extends r.EventEmitter {
          constructor(e2) {
            var t2;
            super(), this.setAdvEffect = (...e3) => {
              var t3;
              this.videPostProcess.availableCode < 1 || (this.logger.log(`set advbeauty effect：[${e3[0]}, ${e3[1]}]`), null === (t3 = this.videPostProcess.filters) || void 0 === t3 || t3.advBeauty.setAdvEffect(...e3));
            }, this.presetAdvEffect = (...e3) => {
              var t3;
              this.videPostProcess.availableCode < 1 || (this.logger.log("preset advbeauty effect：" + JSON.stringify(e3[0])), null === (t3 = this.videPostProcess.filters) || void 0 === t3 || t3.advBeauty.presetAdvEffect(...e3));
            }, this.videPostProcess = e2, null === (t2 = this.videPostProcess.filters) || void 0 === t2 || t2.advBeauty.on("advBeautyResComplete", (e3) => {
              this.videPostProcess.emit("advBeautyResComplete", e3);
            });
          }
          get advancedBeautyProcess() {
            const e2 = this.videPostProcess.getPlugin("AdvancedBeauty");
            return e2 || this.logger.error("Can not get AdvancedBeauty plugin"), e2;
          }
          init(e2) {
            this.videPostProcess.availableCode < 1 || (this.advancedBeautyProcess.on("facePoints-load", () => {
              this.emit("facePoints-load"), this.advancedBeautyProcess.setFaceSize(Math.min(5, Math.max(1, e2 || 1)));
            }), this.advancedBeautyProcess.init());
          }
          destroy() {
            this.videPostProcess.availableCode < 1 || (this.advancedBeautyProcess.removeAllListeners(), this.advancedBeautyProcess.destroy());
          }
          get logger() {
            return this.videPostProcess.logger;
          }
          setTrack(e2, t2) {
            var i2;
            return e2 && a.configStaticRes(s.resSet, null === (i2 = this.videPostProcess.filters) || void 0 === i2 ? void 0 : i2.advBeauty), new Promise((i3, r2) => {
              this.videPostProcess.setTaskAndTrack("AdvancedBeauty", e2, t2).then((t3) => {
                var r3;
                e2 || null === (r3 = this.videPostProcess.filters) || void 0 === r3 || r3.advBeauty.setAdvData([]), i3(t3);
              }).catch((e3) => {
                r2(e3);
              });
            });
          }
          get isEnable() {
            return this.videPostProcess.hasTask("AdvancedBeauty");
          }
        }
        t.default = a, a.configStaticRes = (e2, t2) => {
          s.AdvBeautyFilter.configStaticRes(e2, t2);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = { beauty: { whiten: "https://yx-web-nosdn.netease.im/common/cab8e4f0696d3d8e29ee10d6dccc1204/meibai.png", redden: "https://yx-web-nosdn.netease.im/common/c614e2af82da88807067926d7ff3be3d/hongrun.png" }, filters: { ziran: { src: "https://yx-web-nosdn.netease.im/common/c89328281947fceabdc71d5fa08b2345/ziran.png", intensity: 1 }, baixi: { src: "https://yx-web-nosdn.netease.im/common/3a22a55384b0bd5b07fca3509bfc981a/baixi.png", intensity: 0.5 }, fennen: { src: "https://yx-web-nosdn.netease.im/common/db5befdae1f46dad2e5a6d702bad19ea/fennen.png", intensity: 0.5 }, weimei: { src: "https://yx-web-nosdn.netease.im/common/cf8bfec70d7998bb0033757276c6559a/weimei.png", intensity: 0.5 }, langman: { src: "https://yx-web-nosdn.netease.im/common/1c50a14532bfa3ad503a82ddd13f0ec8/langman.png", intensity: 0.5 }, rixi: { src: "https://yx-web-nosdn.netease.im/common/c414819383913b5db0d9b686276e3d57/rixi.png", intensity: 0.5 }, landiao: { src: "https://yx-web-nosdn.netease.im/common/4c77522852dc14448603be21abc571c8/landiao.png", intensity: 0.5 }, qingliang: { src: "https://yx-web-nosdn.netease.im/common/1150e94f831d24148239001588a7ca7d/qingliang.png", intensity: 0.5 }, huaijiu: { src: "https://yx-web-nosdn.netease.im/common/6a38caeab164d1b5cc086391d6a11a74/huaijiu.png", intensity: 0.5 }, qingcheng: { src: "https://yx-web-nosdn.netease.im/common/3b3332c5ae4306312b6f3c4c552a464a/qingcheng.png", intensity: 1 }, wuhou: { src: "https://yx-web-nosdn.netease.im/common/200fc7a12177774f4eb23f55d72643ee/wuhou.png", intensity: 1 }, zhigan: { src: "https://yx-web-nosdn.netease.im/common/848bd44506cf8e10ecabf564e3d74809/zhigan.png", intensity: 1 }, mopian: { src: "https://yx-web-nosdn.netease.im/common/c454efa119520f0793ce51327951ed0a/mopian.png", intensity: 1 }, dianying: { src: "https://yx-web-nosdn.netease.im/common/3a6a22adad29c5844fc829f4f889a79f/dianying.png", intensity: 1 }, heibai: { src: "https://yx-web-nosdn.netease.im/common/941270f2948218ea19f2d79db5e7d349/heibai.png", intensity: 1 } } }, s = /* @__PURE__ */ new Set();
        t.default = class {
          constructor(e2) {
            this.lutLoaded = false, this.videPostProcess = e2, this.videPostProcess.on("contextLost", () => {
              this.lutLoaded = false;
            }), s.add(this);
          }
          startLut() {
            if (this.lutLoaded) return;
            const e2 = this.videPostProcess.filters;
            if (!e2) return;
            let t2 = 2;
            const i2 = [], s2 = () => {
              t2 -= 1, t2 <= 0 && this.videPostProcess.emit("beautyResComplete", i2);
            };
            e2.beauty.setLutsSrc(r.beauty, (e3) => {
              i2.push(...e3), s2();
            }), e2.lut.setLutsSrc(r.filters, (e3) => {
              i2.push(...e3), s2();
            }), this.lutLoaded = true;
          }
          setFilter(e2, t2) {
            var i2;
            null === (i2 = this.videPostProcess.filters) || void 0 === i2 || i2.lut.setlut(e2, t2);
          }
          setBeauty(e2, t2) {
            return e2 && this.startLut(), new Promise((i2, r2) => {
              this.videPostProcess.setTaskAndTrack("BasicBeauty", e2, t2).then((t3) => {
                if (!e2) {
                  const e3 = this.videPostProcess.filters;
                  if (!e3) return;
                  e3.beauty.whiten = 0, e3.beauty.redden = 0, e3.beauty.smooth = 0, e3.lut.setlut(null);
                }
                i2(t3);
              }).catch((e3) => {
                r2(e3);
              });
            });
          }
          setBeautyOptions(e2) {
            const t2 = this.videPostProcess.filters;
            t2 && ("smoothnessLevel" in e2 && (t2.beauty.smooth = e2.smoothnessLevel), "brightnessLevel" in e2 && (t2.beauty.whiten = e2.brightnessLevel), "rednessLevel" in e2 && (t2.beauty.redden = e2.rednessLevel));
          }
          get isEnable() {
            return this.videPostProcess.hasTask("BasicBeauty");
          }
          static configStaticRes(e2) {
            let t2 = false;
            e2.beauty && (r.beauty = Object.assign({}, e2.beauty), t2 = true), e2.filters && (r.filters = Object.assign({}, e2.filters), t2 = true), t2 && s.forEach((e3) => {
              try {
                e3.lutLoaded = false, e3.startLut();
              } catch (e4) {
              }
            });
          }
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true });
        const r = i(3), s = i(75);
        class a extends r.EventEmitter {
          constructor(e2) {
            super(), this.bgOption = { type: "color", color: "#e7ad3c" }, this.videPostProcess = e2;
          }
          get segmentProcess() {
            return this.videPostProcess.getPlugin("VirtualBackground");
          }
          init() {
            this.segmentProcess.on("segment-load", () => {
              this.emit("segment-load");
            }), this.segmentProcess.init();
          }
          destroy() {
            this.segmentProcess.removeAllListeners(), this.segmentProcess.destroy();
          }
          setVirtualBackGround(e2) {
            this.bgOption = e2;
            const { type: t2 } = e2;
            switch (t2) {
              case "image":
                const { source: t3 } = e2;
                if ("object" == typeof t3) this.setBackGround(t3);
                else if ("string" == typeof t3) if (t3.includes("data:image")) {
                  const e3 = new Image();
                  e3.onload = () => {
                    this.setBackGround(e3);
                  }, e3.src = t3;
                } else if (t3.includes("http")) s.loadImage(t3, (e3) => {
                  this.setBackGround(e3);
                });
                else {
                  const e3 = new Image();
                  e3.onload = () => {
                    this.setBackGround(e3);
                  }, e3.src = t3;
                }
                break;
              case "color":
                this.setBackGround(e2.color);
                break;
              case "blur":
                this.setBlurIntensity(e2.level / 10);
            }
          }
          setTrack(e2, t2) {
            return new Promise((i2, r2) => {
              this.videPostProcess.setTaskAndTrack("VirtualBackground", e2, t2).then((t3) => {
                var r3;
                e2 || null === (r3 = this.videPostProcess.filters) || void 0 === r3 || r3.virtualBackground.setMaskMap(null), i2(t3);
              }).catch((e3) => {
                r2(e3);
              });
            });
          }
          setBackGround(e2) {
            var t2;
            null === (t2 = this.videPostProcess.filters) || void 0 === t2 || t2.virtualBackground.setBackground(e2);
          }
          setBlurIntensity(e2) {
            var t2;
            null === (t2 = this.videPostProcess.filters) || void 0 === t2 || t2.virtualBackground.setBlurIntensity(e2);
          }
          get isEnable() {
            return this.videPostProcess.hasTask("VirtualBackground");
          }
          set emptyFrame(e2) {
            this.videPostProcess.filters.virtualBackground.emptyFrame = e2;
          }
        }
        t.default = a;
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.applyResolution = void 0, t.applyResolution = async function(e2) {
          const { track: t2, targetWidth: i2, targetHeight: r, keepAspectRatio: s, logger: a } = e2;
          let o;
          if (o = "getSettings" in MediaStreamTrack.prototype ? t2.getSettings() : t2.getConstraints(), o.width && o.height) if (o.width !== i2 || o.height !== r) {
            let e3;
            s ? (e3 = { aspectRatio: o.width / o.height }, o.width / o.height >= i2 / r ? e3.width = i2 : e3.height = r) : e3 = { width: i2, height: r }, await t2.applyConstraints(e3), await new Promise((e4) => {
              setTimeout(e4, 100);
            });
            const n = t2.getSettings();
            o.width !== n.width || o.height !== n.height ? a.log(`applyResolution 成功修改分辨率 保留长宽比：${s} ${o.width}x${o.height} => ${n.width}x${n.height} (constraints: ${JSON.stringify(e3)})【${t2.label}】`) : a.warn(`applyResolution 无法修改分辨率为${i2}x${r}，目前的分辨率：${o.width}x${o.height} (constraints: ${JSON.stringify(e3)})【${t2.label}】`);
          } else a.log(`applyResolution 无需修改分辨率 ${o.width}x${o.height} 【${t2.label}】`);
          else a.log(`applyResolution 摄像头不支持动态修改分辨率 【${t2.label}】`);
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.webassemblySupported = void 0, t.webassemblySupported = function() {
          try {
            if ("object" == typeof WebAssembly && "function" == typeof WebAssembly.instantiate) {
              const e2 = new WebAssembly.Module(Uint8Array.of(0, 97, 115, 109, 1, 0, 0, 0));
              if (e2 instanceof WebAssembly.Module) return new WebAssembly.Instance(e2) instanceof WebAssembly.Instance;
            }
          } catch (e2) {
            return false;
          }
          return false;
        };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.AudioProfile = void 0, t.AudioProfile = ["speech_low_quality", "speech_standard", "music_standard", "standard_stereo", "high_quality", "high_quality_stereo"];
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.serverError = t.clientNotYetPublished = t.STREAM_HAS_NO_MEDIA_ATTRIBUTES = t.clientNotYetUninitialized = t.invalidArguments = t.ok = void 0, t.ok = { name: "OK", code: 200, desc: "success" }, t.invalidArguments = { name: "invalid arguments", code: 1, desc: "请检查参数的有效性" }, t.clientNotYetUninitialized = { name: "client not yet uninitialized", code: 2, desc: "请先调用createClient创建Client" }, t.STREAM_HAS_NO_MEDIA_ATTRIBUTES = { name: "STREAM_HAS_NO_MEDIA_ATTRIBUTES", code: 10, desc: "stream不合法，没有audio、video或者screen属性" }, t.clientNotYetPublished = { name: "client not yet published", code: 11, desc: "请先publish" }, t.serverError = { name: "server error code", code: 414, desc: "" };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.LIVE_STREAM_AUDIO_CODEC_PROFILE = t.LIVE_STREAM_AUDIO_SAMPLE_RATE = void 0, t.LIVE_STREAM_AUDIO_SAMPLE_RATE = { SAMPLE_RATE_32000: 32e3, SAMPLE_RATE_44100: 44100, SAMPLE_RATE_48000: 48e3 }, t.LIVE_STREAM_AUDIO_CODEC_PROFILE = { LC_AAC: 0, HE_AAC: 1 };
      }, function(e, t, i) {
        "use strict";
        Object.defineProperty(t, "__esModule", { value: true }), t.NETWORK_STATUS = void 0, t.NETWORK_STATUS = { 0: "UNKNOWN", 1: "EXCELLENT", 2: "GOOD", 3: "POOR", 4: "BAD", 5: "VERYBAD", 6: "DOWN" };
      }]);
    });
  }
});
export default require_NERTC();
/*! Bundled license information:

nertc-web-sdk/NERTC.js:
  (*! NeRTC 5.6.50|BUILD v5.6.50-0-gaaf117b6 production 20241225 *)
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (*
   * [js-sha1]{@link https://github.com/emn178/js-sha1}
   *
   * @version 0.6.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2017
   * @license MIT
   *)
*/
//# sourceMappingURL=nertc-web-sdk.js.map
